(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("vue"), require("@vxe-ui/core"), require("xe-utils"));
	else if(typeof define === 'function' && define.amd)
		define([, "@vxe-ui/core", "xe-utils"], factory);
	else if(typeof exports === 'object')
		exports["VxeUITable"] = factory(require("vue"), require("@vxe-ui/core"), require("xe-utils"));
	else
		root["VxeUITable"] = factory(root["Vue"], root["VxeUI"], root["XEUtils"]);
})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__9274__, __WEBPACK_EXTERNAL_MODULE__4345__, __WEBPACK_EXTERNAL_MODULE__8871__) {
return /******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 9274:
/***/ (function(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__9274__;

/***/ }),

/***/ 4345:
/***/ (function(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__4345__;

/***/ }),

/***/ 8871:
/***/ (function(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__8871__;

/***/ }),

/***/ 9306:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(4901);
var tryToString = __webpack_require__(6823);

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw new $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 679:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isPrototypeOf = __webpack_require__(1625);

var $TypeError = TypeError;

module.exports = function (it, Prototype) {
  if (isPrototypeOf(Prototype, it)) return it;
  throw new $TypeError('Incorrect invocation');
};


/***/ }),

/***/ 8551:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isObject = __webpack_require__(34);

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw new $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ 9617:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toIndexedObject = __webpack_require__(5397);
var toAbsoluteIndex = __webpack_require__(5610);
var lengthOfArrayLike = __webpack_require__(6198);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    if (length === 0) return !IS_INCLUDES && -1;
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el !== el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value !== value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 4527:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var isArray = __webpack_require__(4376);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Safari < 13 does not throw an error in this case
var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function () {
  // makes no sense without proper strict mode support
  if (this !== undefined) return true;
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).length = 1;
  } catch (error) {
    return error instanceof TypeError;
  }
}();

module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {
  if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {
    throw new $TypeError('Cannot set read only .length');
  } return O.length = length;
} : function (O, length) {
  return O.length = length;
};


/***/ }),

/***/ 6319:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var anObject = __webpack_require__(8551);
var iteratorClose = __webpack_require__(9539);

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  } catch (error) {
    iteratorClose(iterator, 'throw', error);
  }
};


/***/ }),

/***/ 2195:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ 6955:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var TO_STRING_TAG_SUPPORT = __webpack_require__(2140);
var isCallable = __webpack_require__(4901);
var classofRaw = __webpack_require__(2195);
var wellKnownSymbol = __webpack_require__(8227);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 7740:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var hasOwn = __webpack_require__(9297);
var ownKeys = __webpack_require__(5031);
var getOwnPropertyDescriptorModule = __webpack_require__(7347);
var definePropertyModule = __webpack_require__(4913);

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ 2211:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ 2529:
/***/ (function(module) {


// `CreateIterResultObject` abstract operation
// https://tc39.es/ecma262/#sec-createiterresultobject
module.exports = function (value, done) {
  return { value: value, done: done };
};


/***/ }),

/***/ 6699:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var definePropertyModule = __webpack_require__(4913);
var createPropertyDescriptor = __webpack_require__(6980);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 6980:
/***/ (function(module) {


module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 4659:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var definePropertyModule = __webpack_require__(4913);
var createPropertyDescriptor = __webpack_require__(6980);

module.exports = function (object, key, value) {
  if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));
  else object[key] = value;
};


/***/ }),

/***/ 2106:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var makeBuiltIn = __webpack_require__(283);
var defineProperty = __webpack_require__(4913);

module.exports = function (target, name, descriptor) {
  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty.f(target, name, descriptor);
};


/***/ }),

/***/ 6840:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(4901);
var definePropertyModule = __webpack_require__(4913);
var makeBuiltIn = __webpack_require__(283);
var defineGlobalProperty = __webpack_require__(9433);

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),

/***/ 6279:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var defineBuiltIn = __webpack_require__(6840);

module.exports = function (target, src, options) {
  for (var key in src) defineBuiltIn(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ 9433:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(globalThis, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    globalThis[key] = value;
  } return value;
};


/***/ }),

/***/ 3724:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
});


/***/ }),

/***/ 4055:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);
var isObject = __webpack_require__(34);

var document = globalThis.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 6837:
/***/ (function(module) {


var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),

/***/ 8727:
/***/ (function(module) {


// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 2839:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);

var navigator = globalThis.navigator;
var userAgent = navigator && navigator.userAgent;

module.exports = userAgent ? String(userAgent) : '';


/***/ }),

/***/ 9519:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);
var userAgent = __webpack_require__(2839);

var process = globalThis.process;
var Deno = globalThis.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ 6518:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);
var getOwnPropertyDescriptor = (__webpack_require__(7347).f);
var createNonEnumerableProperty = __webpack_require__(6699);
var defineBuiltIn = __webpack_require__(6840);
var defineGlobalProperty = __webpack_require__(9433);
var copyConstructorProperties = __webpack_require__(7740);
var isForced = __webpack_require__(2796);

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = globalThis;
  } else if (STATIC) {
    target = globalThis[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = globalThis[TARGET] && globalThis[TARGET].prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 9039:
/***/ (function(module) {


module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 6080:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(7476);
var aCallable = __webpack_require__(9306);
var NATIVE_BIND = __webpack_require__(616);

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ 616:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ 9565:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_BIND = __webpack_require__(616);

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ 350:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var hasOwn = __webpack_require__(9297);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 7476:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var classofRaw = __webpack_require__(2195);
var uncurryThis = __webpack_require__(9504);

module.exports = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
};


/***/ }),

/***/ 9504:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_BIND = __webpack_require__(616);

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ 7751:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);
var isCallable = __webpack_require__(4901);

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(globalThis[namespace]) : globalThis[namespace] && globalThis[namespace][method];
};


/***/ }),

/***/ 1767:
/***/ (function(module) {


// `GetIteratorDirect(obj)` abstract operation
// https://tc39.es/proposal-iterator-helpers/#sec-getiteratordirect
module.exports = function (obj) {
  return {
    iterator: obj,
    next: obj.next,
    done: false
  };
};


/***/ }),

/***/ 851:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var classof = __webpack_require__(6955);
var getMethod = __webpack_require__(5966);
var isNullOrUndefined = __webpack_require__(4117);
var Iterators = __webpack_require__(6269);
var wellKnownSymbol = __webpack_require__(8227);

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR)
    || getMethod(it, '@@iterator')
    || Iterators[classof(it)];
};


/***/ }),

/***/ 81:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var aCallable = __webpack_require__(9306);
var anObject = __webpack_require__(8551);
var tryToString = __webpack_require__(6823);
var getIteratorMethod = __webpack_require__(851);

var $TypeError = TypeError;

module.exports = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
  throw new $TypeError(tryToString(argument) + ' is not iterable');
};


/***/ }),

/***/ 5966:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var aCallable = __webpack_require__(9306);
var isNullOrUndefined = __webpack_require__(4117);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ 4576:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var check = function (it) {
  return it && it.Math === Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  check(typeof this == 'object' && this) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 9297:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var toObject = __webpack_require__(8981);

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ 421:
/***/ (function(module) {


module.exports = {};


/***/ }),

/***/ 397:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var getBuiltIn = __webpack_require__(7751);

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ 5917:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var fails = __webpack_require__(9039);
var createElement = __webpack_require__(4055);

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a !== 7;
});


/***/ }),

/***/ 7055:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var fails = __webpack_require__(9039);
var classof = __webpack_require__(2195);

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) === 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ 3706:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var isCallable = __webpack_require__(4901);
var store = __webpack_require__(7629);

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 1181:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_WEAK_MAP = __webpack_require__(8622);
var globalThis = __webpack_require__(4576);
var isObject = __webpack_require__(34);
var createNonEnumerableProperty = __webpack_require__(6699);
var hasOwn = __webpack_require__(9297);
var shared = __webpack_require__(7629);
var sharedKey = __webpack_require__(6119);
var hiddenKeys = __webpack_require__(421);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = globalThis.TypeError;
var WeakMap = globalThis.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 4209:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var wellKnownSymbol = __webpack_require__(8227);
var Iterators = __webpack_require__(6269);

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ 4376:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var classof = __webpack_require__(2195);

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) === 'Array';
};


/***/ }),

/***/ 4901:
/***/ (function(module) {


// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
var documentAll = typeof document == 'object' && document.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
module.exports = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ 2796:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);
var isCallable = __webpack_require__(4901);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value === POLYFILL ? true
    : value === NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 4117:
/***/ (function(module) {


// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ 34:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(4901);

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 6395:
/***/ (function(module) {


module.exports = false;


/***/ }),

/***/ 757:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var getBuiltIn = __webpack_require__(7751);
var isCallable = __webpack_require__(4901);
var isPrototypeOf = __webpack_require__(1625);
var USE_SYMBOL_AS_UID = __webpack_require__(7040);

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ 2652:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var bind = __webpack_require__(6080);
var call = __webpack_require__(9565);
var anObject = __webpack_require__(8551);
var tryToString = __webpack_require__(6823);
var isArrayIteratorMethod = __webpack_require__(4209);
var lengthOfArrayLike = __webpack_require__(6198);
var isPrototypeOf = __webpack_require__(1625);
var getIterator = __webpack_require__(81);
var getIteratorMethod = __webpack_require__(851);
var iteratorClose = __webpack_require__(9539);

var $TypeError = TypeError;

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var ResultPrototype = Result.prototype;

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_RECORD = !!(options && options.IS_RECORD);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_RECORD) {
    iterator = iterable.iterator;
  } else if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn) throw new $TypeError(tryToString(iterable) + ' is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf(ResultPrototype, result)) return result;
      } return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }

  next = IS_RECORD ? iterable.next : iterator.next;
  while (!(step = call(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }
    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
  } return new Result(false);
};


/***/ }),

/***/ 9539:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var anObject = __webpack_require__(8551);
var getMethod = __webpack_require__(5966);

module.exports = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject(iterator);
  try {
    innerResult = getMethod(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject(innerResult);
  return value;
};


/***/ }),

/***/ 9462:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var create = __webpack_require__(2360);
var createNonEnumerableProperty = __webpack_require__(6699);
var defineBuiltIns = __webpack_require__(6279);
var wellKnownSymbol = __webpack_require__(8227);
var InternalStateModule = __webpack_require__(1181);
var getMethod = __webpack_require__(5966);
var IteratorPrototype = (__webpack_require__(7657).IteratorPrototype);
var createIterResultObject = __webpack_require__(2529);
var iteratorClose = __webpack_require__(9539);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ITERATOR_HELPER = 'IteratorHelper';
var WRAP_FOR_VALID_ITERATOR = 'WrapForValidIterator';
var setInternalState = InternalStateModule.set;

var createIteratorProxyPrototype = function (IS_ITERATOR) {
  var getInternalState = InternalStateModule.getterFor(IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER);

  return defineBuiltIns(create(IteratorPrototype), {
    next: function next() {
      var state = getInternalState(this);
      // for simplification:
      //   for `%WrapForValidIteratorPrototype%.next` our `nextHandler` returns `IterResultObject`
      //   for `%IteratorHelperPrototype%.next` - just a value
      if (IS_ITERATOR) return state.nextHandler();
      try {
        var result = state.done ? undefined : state.nextHandler();
        return createIterResultObject(result, state.done);
      } catch (error) {
        state.done = true;
        throw error;
      }
    },
    'return': function () {
      var state = getInternalState(this);
      var iterator = state.iterator;
      state.done = true;
      if (IS_ITERATOR) {
        var returnMethod = getMethod(iterator, 'return');
        return returnMethod ? call(returnMethod, iterator) : createIterResultObject(undefined, true);
      }
      if (state.inner) try {
        iteratorClose(state.inner.iterator, 'normal');
      } catch (error) {
        return iteratorClose(iterator, 'throw', error);
      }
      if (iterator) iteratorClose(iterator, 'normal');
      return createIterResultObject(undefined, true);
    }
  });
};

var WrapForValidIteratorPrototype = createIteratorProxyPrototype(true);
var IteratorHelperPrototype = createIteratorProxyPrototype(false);

createNonEnumerableProperty(IteratorHelperPrototype, TO_STRING_TAG, 'Iterator Helper');

module.exports = function (nextHandler, IS_ITERATOR) {
  var IteratorProxy = function Iterator(record, state) {
    if (state) {
      state.iterator = record.iterator;
      state.next = record.next;
    } else state = record;
    state.type = IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER;
    state.nextHandler = nextHandler;
    state.counter = 0;
    state.done = false;
    setInternalState(this, state);
  };

  IteratorProxy.prototype = IS_ITERATOR ? WrapForValidIteratorPrototype : IteratorHelperPrototype;

  return IteratorProxy;
};


/***/ }),

/***/ 713:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var aCallable = __webpack_require__(9306);
var anObject = __webpack_require__(8551);
var getIteratorDirect = __webpack_require__(1767);
var createIteratorProxy = __webpack_require__(9462);
var callWithSafeIterationClosing = __webpack_require__(6319);

var IteratorProxy = createIteratorProxy(function () {
  var iterator = this.iterator;
  var result = anObject(call(this.next, iterator));
  var done = this.done = !!result.done;
  if (!done) return callWithSafeIterationClosing(iterator, this.mapper, [result.value, this.counter++], true);
});

// `Iterator.prototype.map` method
// https://github.com/tc39/proposal-iterator-helpers
module.exports = function map(mapper) {
  anObject(this);
  aCallable(mapper);
  return new IteratorProxy(getIteratorDirect(this), {
    mapper: mapper
  });
};


/***/ }),

/***/ 7657:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);
var isCallable = __webpack_require__(4901);
var isObject = __webpack_require__(34);
var create = __webpack_require__(2360);
var getPrototypeOf = __webpack_require__(2787);
var defineBuiltIn = __webpack_require__(6840);
var wellKnownSymbol = __webpack_require__(8227);
var IS_PURE = __webpack_require__(6395);

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) {
  defineBuiltIn(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ 6269:
/***/ (function(module) {


module.exports = {};


/***/ }),

/***/ 6198:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toLength = __webpack_require__(8014);

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ 283:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var fails = __webpack_require__(9039);
var isCallable = __webpack_require__(4901);
var hasOwn = __webpack_require__(9297);
var DESCRIPTORS = __webpack_require__(3724);
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(350).CONFIGURABLE);
var inspectSource = __webpack_require__(3706);
var InternalStateModule = __webpack_require__(1181);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
var stringSlice = uncurryThis(''.slice);
var replace = uncurryThis(''.replace);
var join = uncurryThis([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
    name = '[' + replace($String(name), /^Symbol\(([^)]*)\).*$/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ 741:
/***/ (function(module) {


var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ 2360:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__(8551);
var definePropertiesModule = __webpack_require__(6801);
var enumBugKeys = __webpack_require__(8727);
var hiddenKeys = __webpack_require__(421);
var html = __webpack_require__(397);
var documentCreateElement = __webpack_require__(4055);
var sharedKey = __webpack_require__(6119);

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  // eslint-disable-next-line no-useless-assignment -- avoid memory leak
  activeXDocument = null;
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es/no-object-create -- safe
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};


/***/ }),

/***/ 6801:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(8686);
var definePropertyModule = __webpack_require__(4913);
var anObject = __webpack_require__(8551);
var toIndexedObject = __webpack_require__(5397);
var objectKeys = __webpack_require__(1072);

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};


/***/ }),

/***/ 4913:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var IE8_DOM_DEFINE = __webpack_require__(5917);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(8686);
var anObject = __webpack_require__(8551);
var toPropertyKey = __webpack_require__(6969);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 7347:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var call = __webpack_require__(9565);
var propertyIsEnumerableModule = __webpack_require__(8773);
var createPropertyDescriptor = __webpack_require__(6980);
var toIndexedObject = __webpack_require__(5397);
var toPropertyKey = __webpack_require__(6969);
var hasOwn = __webpack_require__(9297);
var IE8_DOM_DEFINE = __webpack_require__(5917);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ 8480:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var internalObjectKeys = __webpack_require__(1828);
var enumBugKeys = __webpack_require__(8727);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 3717:
/***/ (function(__unused_webpack_module, exports) {


// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 2787:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var hasOwn = __webpack_require__(9297);
var isCallable = __webpack_require__(4901);
var toObject = __webpack_require__(8981);
var sharedKey = __webpack_require__(6119);
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(2211);

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object ? ObjectPrototype : null;
};


/***/ }),

/***/ 1625:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ 1828:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var hasOwn = __webpack_require__(9297);
var toIndexedObject = __webpack_require__(5397);
var indexOf = (__webpack_require__(9617).indexOf);
var hiddenKeys = __webpack_require__(421);

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ 1072:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var internalObjectKeys = __webpack_require__(1828);
var enumBugKeys = __webpack_require__(8727);

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ 8773:
/***/ (function(__unused_webpack_module, exports) {


var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 4270:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var isCallable = __webpack_require__(4901);
var isObject = __webpack_require__(34);

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw new $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 5031:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var getBuiltIn = __webpack_require__(7751);
var uncurryThis = __webpack_require__(9504);
var getOwnPropertyNamesModule = __webpack_require__(8480);
var getOwnPropertySymbolsModule = __webpack_require__(3717);
var anObject = __webpack_require__(8551);

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 7750:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isNullOrUndefined = __webpack_require__(4117);

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 6119:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var shared = __webpack_require__(5745);
var uid = __webpack_require__(3392);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 7629:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var IS_PURE = __webpack_require__(6395);
var globalThis = __webpack_require__(4576);
var defineGlobalProperty = __webpack_require__(9433);

var SHARED = '__core-js_shared__';
var store = module.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});

(store.versions || (store.versions = [])).push({
  version: '3.39.0',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2014-2024 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.39.0/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ 5745:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var store = __webpack_require__(7629);

module.exports = function (key, value) {
  return store[key] || (store[key] = value || {});
};


/***/ }),

/***/ 4495:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(9519);
var fails = __webpack_require__(9039);
var globalThis = __webpack_require__(4576);

var $String = globalThis.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol('symbol detection');
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 5610:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toIntegerOrInfinity = __webpack_require__(1291);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 5397:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(7055);
var requireObjectCoercible = __webpack_require__(7750);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 1291:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var trunc = __webpack_require__(741);

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ 8014:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toIntegerOrInfinity = __webpack_require__(1291);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  var len = toIntegerOrInfinity(argument);
  return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 8981:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var requireObjectCoercible = __webpack_require__(7750);

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 2777:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var isObject = __webpack_require__(34);
var isSymbol = __webpack_require__(757);
var getMethod = __webpack_require__(5966);
var ordinaryToPrimitive = __webpack_require__(4270);
var wellKnownSymbol = __webpack_require__(8227);

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw new $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 6969:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toPrimitive = __webpack_require__(2777);
var isSymbol = __webpack_require__(757);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ 2140:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var wellKnownSymbol = __webpack_require__(8227);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 6823:
/***/ (function(module) {


var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 3392:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ 7040:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(4495);

module.exports = NATIVE_SYMBOL &&
  !Symbol.sham &&
  typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 8686:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var fails = __webpack_require__(9039);

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype !== 42;
});


/***/ }),

/***/ 8622:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);
var isCallable = __webpack_require__(4901);

var WeakMap = globalThis.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ 8227:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);
var shared = __webpack_require__(5745);
var hasOwn = __webpack_require__(9297);
var uid = __webpack_require__(3392);
var NATIVE_SYMBOL = __webpack_require__(4495);
var USE_SYMBOL_AS_UID = __webpack_require__(7040);

var Symbol = globalThis.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 4114:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var toObject = __webpack_require__(8981);
var lengthOfArrayLike = __webpack_require__(6198);
var setArrayLength = __webpack_require__(4527);
var doesNotExceedSafeInteger = __webpack_require__(6837);
var fails = __webpack_require__(9039);

var INCORRECT_TO_LENGTH = fails(function () {
  return [].push.call({ length: 0x100000000 }, 1) !== 4294967297;
});

// V8 <= 121 and Safari <= 15.4; FF < 23 throws InternalError
// https://bugs.chromium.org/p/v8/issues/detail?id=12681
var properErrorOnNonWritableLength = function () {
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).push();
  } catch (error) {
    return error instanceof TypeError;
  }
};

var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();

// `Array.prototype.push` method
// https://tc39.es/ecma262/#sec-array.prototype.push
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  push: function push(item) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var argCount = arguments.length;
    doesNotExceedSafeInteger(len + argCount);
    for (var i = 0; i < argCount; i++) {
      O[len] = arguments[i];
      len++;
    }
    setArrayLength(O, len);
    return len;
  }
});


/***/ }),

/***/ 8111:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var globalThis = __webpack_require__(4576);
var anInstance = __webpack_require__(679);
var anObject = __webpack_require__(8551);
var isCallable = __webpack_require__(4901);
var getPrototypeOf = __webpack_require__(2787);
var defineBuiltInAccessor = __webpack_require__(2106);
var createProperty = __webpack_require__(4659);
var fails = __webpack_require__(9039);
var hasOwn = __webpack_require__(9297);
var wellKnownSymbol = __webpack_require__(8227);
var IteratorPrototype = (__webpack_require__(7657).IteratorPrototype);
var DESCRIPTORS = __webpack_require__(3724);
var IS_PURE = __webpack_require__(6395);

var CONSTRUCTOR = 'constructor';
var ITERATOR = 'Iterator';
var TO_STRING_TAG = wellKnownSymbol('toStringTag');

var $TypeError = TypeError;
var NativeIterator = globalThis[ITERATOR];

// FF56- have non-standard global helper `Iterator`
var FORCED = IS_PURE
  || !isCallable(NativeIterator)
  || NativeIterator.prototype !== IteratorPrototype
  // FF44- non-standard `Iterator` passes previous tests
  || !fails(function () { NativeIterator({}); });

var IteratorConstructor = function Iterator() {
  anInstance(this, IteratorPrototype);
  if (getPrototypeOf(this) === IteratorPrototype) throw new $TypeError('Abstract class Iterator not directly constructable');
};

var defineIteratorPrototypeAccessor = function (key, value) {
  if (DESCRIPTORS) {
    defineBuiltInAccessor(IteratorPrototype, key, {
      configurable: true,
      get: function () {
        return value;
      },
      set: function (replacement) {
        anObject(this);
        if (this === IteratorPrototype) throw new $TypeError("You can't redefine this property");
        if (hasOwn(this, key)) this[key] = replacement;
        else createProperty(this, key, replacement);
      }
    });
  } else IteratorPrototype[key] = value;
};

if (!hasOwn(IteratorPrototype, TO_STRING_TAG)) defineIteratorPrototypeAccessor(TO_STRING_TAG, ITERATOR);

if (FORCED || !hasOwn(IteratorPrototype, CONSTRUCTOR) || IteratorPrototype[CONSTRUCTOR] === Object) {
  defineIteratorPrototypeAccessor(CONSTRUCTOR, IteratorConstructor);
}

IteratorConstructor.prototype = IteratorPrototype;

// `Iterator` constructor
// https://tc39.es/ecma262/#sec-iterator
$({ global: true, constructor: true, forced: FORCED }, {
  Iterator: IteratorConstructor
});


/***/ }),

/***/ 1148:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var iterate = __webpack_require__(2652);
var aCallable = __webpack_require__(9306);
var anObject = __webpack_require__(8551);
var getIteratorDirect = __webpack_require__(1767);

// `Iterator.prototype.every` method
// https://tc39.es/ecma262/#sec-iterator.prototype.every
$({ target: 'Iterator', proto: true, real: true }, {
  every: function every(predicate) {
    anObject(this);
    aCallable(predicate);
    var record = getIteratorDirect(this);
    var counter = 0;
    return !iterate(record, function (value, stop) {
      if (!predicate(value, counter++)) return stop();
    }, { IS_RECORD: true, INTERRUPTED: true }).stopped;
  }
});


/***/ }),

/***/ 2489:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var call = __webpack_require__(9565);
var aCallable = __webpack_require__(9306);
var anObject = __webpack_require__(8551);
var getIteratorDirect = __webpack_require__(1767);
var createIteratorProxy = __webpack_require__(9462);
var callWithSafeIterationClosing = __webpack_require__(6319);
var IS_PURE = __webpack_require__(6395);

var IteratorProxy = createIteratorProxy(function () {
  var iterator = this.iterator;
  var predicate = this.predicate;
  var next = this.next;
  var result, done, value;
  while (true) {
    result = anObject(call(next, iterator));
    done = this.done = !!result.done;
    if (done) return;
    value = result.value;
    if (callWithSafeIterationClosing(iterator, predicate, [value, this.counter++], true)) return value;
  }
});

// `Iterator.prototype.filter` method
// https://tc39.es/ecma262/#sec-iterator.prototype.filter
$({ target: 'Iterator', proto: true, real: true, forced: IS_PURE }, {
  filter: function filter(predicate) {
    anObject(this);
    aCallable(predicate);
    return new IteratorProxy(getIteratorDirect(this), {
      predicate: predicate
    });
  }
});


/***/ }),

/***/ 116:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var iterate = __webpack_require__(2652);
var aCallable = __webpack_require__(9306);
var anObject = __webpack_require__(8551);
var getIteratorDirect = __webpack_require__(1767);

// `Iterator.prototype.find` method
// https://tc39.es/ecma262/#sec-iterator.prototype.find
$({ target: 'Iterator', proto: true, real: true }, {
  find: function find(predicate) {
    anObject(this);
    aCallable(predicate);
    var record = getIteratorDirect(this);
    var counter = 0;
    return iterate(record, function (value, stop) {
      if (predicate(value, counter++)) return stop(value);
    }, { IS_RECORD: true, INTERRUPTED: true }).result;
  }
});


/***/ }),

/***/ 7588:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var iterate = __webpack_require__(2652);
var aCallable = __webpack_require__(9306);
var anObject = __webpack_require__(8551);
var getIteratorDirect = __webpack_require__(1767);

// `Iterator.prototype.forEach` method
// https://tc39.es/ecma262/#sec-iterator.prototype.foreach
$({ target: 'Iterator', proto: true, real: true }, {
  forEach: function forEach(fn) {
    anObject(this);
    aCallable(fn);
    var record = getIteratorDirect(this);
    var counter = 0;
    iterate(record, function (value) {
      fn(value, counter++);
    }, { IS_RECORD: true });
  }
});


/***/ }),

/***/ 1701:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var map = __webpack_require__(713);
var IS_PURE = __webpack_require__(6395);

// `Iterator.prototype.map` method
// https://tc39.es/ecma262/#sec-iterator.prototype.map
$({ target: 'Iterator', proto: true, real: true, forced: IS_PURE }, {
  map: map
});


/***/ }),

/***/ 8237:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var iterate = __webpack_require__(2652);
var aCallable = __webpack_require__(9306);
var anObject = __webpack_require__(8551);
var getIteratorDirect = __webpack_require__(1767);

var $TypeError = TypeError;

// `Iterator.prototype.reduce` method
// https://tc39.es/ecma262/#sec-iterator.prototype.reduce
$({ target: 'Iterator', proto: true, real: true }, {
  reduce: function reduce(reducer /* , initialValue */) {
    anObject(this);
    aCallable(reducer);
    var record = getIteratorDirect(this);
    var noInitial = arguments.length < 2;
    var accumulator = noInitial ? undefined : arguments[1];
    var counter = 0;
    iterate(record, function (value) {
      if (noInitial) {
        noInitial = false;
        accumulator = value;
      } else {
        accumulator = reducer(accumulator, value, counter);
      }
      counter++;
    }, { IS_RECORD: true });
    if (noInitial) throw new $TypeError('Reduce of empty iterator with no initial value');
    return accumulator;
  }
});


/***/ }),

/***/ 3579:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var iterate = __webpack_require__(2652);
var aCallable = __webpack_require__(9306);
var anObject = __webpack_require__(8551);
var getIteratorDirect = __webpack_require__(1767);

// `Iterator.prototype.some` method
// https://tc39.es/ecma262/#sec-iterator.prototype.some
$({ target: 'Iterator', proto: true, real: true }, {
  some: function some(predicate) {
    anObject(this);
    aCallable(predicate);
    var record = getIteratorDirect(this);
    var counter = 0;
    return iterate(record, function (value, stop) {
      if (predicate(value, counter++)) return stop();
    }, { IS_RECORD: true, INTERRUPTED: true }).stopped;
  }
});


/***/ }),

/***/ 1806:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var anObject = __webpack_require__(8551);
var iterate = __webpack_require__(2652);
var getIteratorDirect = __webpack_require__(1767);

var push = [].push;

// `Iterator.prototype.toArray` method
// https://tc39.es/ecma262/#sec-iterator.prototype.toarray
$({ target: 'Iterator', proto: true, real: true }, {
  toArray: function toArray() {
    var result = [];
    iterate(getIteratorDirect(anObject(this)), push, { that: result, IS_RECORD: true });
    return result;
  }
});


/***/ }),

/***/ 8992:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4`
__webpack_require__(8111);


/***/ }),

/***/ 3215:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4`
__webpack_require__(1148);


/***/ }),

/***/ 4520:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4`
__webpack_require__(2489);


/***/ }),

/***/ 2577:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4`
__webpack_require__(116);


/***/ }),

/***/ 3949:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4`
__webpack_require__(7588);


/***/ }),

/***/ 1454:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4`
__webpack_require__(1701);


/***/ }),

/***/ 8872:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4`
__webpack_require__(8237);


/***/ }),

/***/ 7550:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4`
__webpack_require__(3579);


/***/ }),

/***/ 1795:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4`
__webpack_require__(1806);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "";
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Colgroup: function() { return /* reexport */ Colgroup; },
  Column: function() { return /* reexport */ Column; },
  Grid: function() { return /* reexport */ Grid; },
  Table: function() { return /* reexport */ Table; },
  Toolbar: function() { return /* reexport */ Toolbar; },
  VXETable: function() { return /* reexport */ VXETable; },
  VxeColgroup: function() { return /* reexport */ VxeColgroup; },
  VxeColumn: function() { return /* reexport */ VxeColumn; },
  VxeGrid: function() { return /* reexport */ VxeGrid; },
  VxeTable: function() { return /* reexport */ VxeTable; },
  VxeToolbar: function() { return /* reexport */ VxeToolbar; },
  VxeUI: function() { return /* reexport */ core_.VxeUI; },
  _t: function() { return /* reexport */ _t; },
  clipboard: function() { return /* reexport */ clipboard; },
  commands: function() { return /* reexport */ commands; },
  config: function() { return /* reexport */ config; },
  "default": function() { return /* binding */ entry_lib; },
  formats: function() { return /* reexport */ formats; },
  getConfig: function() { return /* reexport */ getConfig; },
  getI18n: function() { return /* reexport */ getI18n; },
  getIcon: function() { return /* reexport */ getIcon; },
  getTheme: function() { return /* reexport */ getTheme; },
  globalEvents: function() { return /* reexport */ globalEvents; },
  globalResize: function() { return /* reexport */ globalResize; },
  hooks: function() { return /* reexport */ hooks; },
  install: function() { return /* reexport */ install; },
  interceptor: function() { return /* reexport */ interceptor; },
  log: function() { return /* reexport */ log; },
  menus: function() { return /* reexport */ menus; },
  modal: function() { return /* reexport */ modal; },
  print: function() { return /* reexport */ print; },
  readFile: function() { return /* reexport */ readFile; },
  renderer: function() { return /* reexport */ renderer; },
  saveFile: function() { return /* reexport */ saveFile; },
  setConfig: function() { return /* reexport */ setConfig; },
  setI18n: function() { return /* reexport */ setI18n; },
  setIcon: function() { return /* reexport */ setIcon; },
  setLanguage: function() { return /* reexport */ setLanguage; },
  setTheme: function() { return /* reexport */ setTheme; },
  setup: function() { return /* reexport */ setup; },
  t: function() { return /* reexport */ t; },
  use: function() { return /* reexport */ use; },
  validators: function() { return /* reexport */ validators; },
  version: function() { return /* reexport */ version; }
});

// NAMESPACE OBJECT: ./packages/components.ts
var components_namespaceObject = {};
__webpack_require__.r(components_namespaceObject);
__webpack_require__.d(components_namespaceObject, {
  Colgroup: function() { return Colgroup; },
  Column: function() { return Column; },
  Grid: function() { return Grid; },
  Table: function() { return Table; },
  Toolbar: function() { return Toolbar; },
  VXETable: function() { return VXETable; },
  VxeColgroup: function() { return VxeColgroup; },
  VxeColumn: function() { return VxeColumn; },
  VxeGrid: function() { return VxeGrid; },
  VxeTable: function() { return VxeTable; },
  VxeToolbar: function() { return VxeToolbar; },
  VxeUI: function() { return core_.VxeUI; },
  _t: function() { return _t; },
  clipboard: function() { return clipboard; },
  commands: function() { return commands; },
  config: function() { return config; },
  formats: function() { return formats; },
  getConfig: function() { return getConfig; },
  getI18n: function() { return getI18n; },
  getIcon: function() { return getIcon; },
  getTheme: function() { return getTheme; },
  globalEvents: function() { return globalEvents; },
  globalResize: function() { return globalResize; },
  hooks: function() { return hooks; },
  install: function() { return install; },
  interceptor: function() { return interceptor; },
  log: function() { return log; },
  menus: function() { return menus; },
  modal: function() { return modal; },
  print: function() { return print; },
  readFile: function() { return readFile; },
  renderer: function() { return renderer; },
  saveFile: function() { return saveFile; },
  setConfig: function() { return setConfig; },
  setI18n: function() { return setI18n; },
  setIcon: function() { return setIcon; },
  setLanguage: function() { return setLanguage; },
  setTheme: function() { return setTheme; },
  setup: function() { return setup; },
  t: function() { return t; },
  use: function() { return use; },
  validators: function() { return validators; },
  version: function() { return version; }
});

;// ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
/* eslint-disable no-var */
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (false) { var getCurrentScript; }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __webpack_require__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.iterator.constructor.js
var esnext_iterator_constructor = __webpack_require__(8992);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.iterator.for-each.js
var esnext_iterator_for_each = __webpack_require__(3949);
// EXTERNAL MODULE: external {"root":"VxeUI","commonjs":"@vxe-ui/core","commonjs2":"@vxe-ui/core","amd":"@vxe-ui/core"}
var core_ = __webpack_require__(4345);
// EXTERNAL MODULE: external {"root":"XEUtils","commonjs":"xe-utils","commonjs2":"xe-utils","amd":"xe-utils"}
var external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_ = __webpack_require__(8871);
var external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default = /*#__PURE__*/__webpack_require__.n(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_);
;// ./node_modules/dom-zindex/es/index.esm.js
var winDom = null;
var bodyEl = null;
var storeEl = null;
var storeId = 'z-index-manage';
var styleEl = null;
var styleId = 'z-index-style';
var storeMainKey = 'm';
var storeSubKey = 's';
var storeData = {
  m: 1000,
  s: 1000
};
function getDocument() {
  if (!winDom) {
    if (typeof document !== 'undefined') {
      winDom = document;
    }
  }
  return winDom;
}
function getBody() {
  if (winDom && !bodyEl) {
    bodyEl = winDom.body || winDom.getElementsByTagName('body')[0];
  }
  return bodyEl;
}
function getDomMaxZIndex() {
  var max = 0;
  var dom = getDocument();
  if (dom) {
    var body = getBody();
    if (body) {
      var allElem = body.getElementsByTagName('*');
      for (var i = 0; i < allElem.length; i++) {
        var elem = allElem[i];
        if (elem && elem.style && elem.nodeType === 1) {
          var zIndex = elem.style.zIndex;
          if (zIndex && /^\d+$/.test(zIndex)) {
            max = Math.max(max, Number(zIndex));
          }
        }
      }
    }
  }
  return max;
}
function getStyle() {
  if (!styleEl) {
    var dom = getDocument();
    if (dom) {
      styleEl = dom.getElementById(styleId);
      if (!styleEl) {
        styleEl = dom.createElement('style');
        styleEl.id = styleId;
        dom.getElementsByTagName('head')[0].appendChild(styleEl);
      }
    }
  }
  return styleEl;
}
function updateVar() {
  var styEl = getStyle();
  if (styEl) {
    var prefixes = '--dom-';
    var propKey = '-z-index';
    styEl.innerHTML = ':root{' + prefixes + 'main' + propKey + ':' + getCurrent() + ';' + prefixes + 'sub' + propKey + ':' + getSubCurrent() + '}';
  }
}
function getStoreDom() {
  if (!storeEl) {
    var dom = getDocument();
    if (dom) {
      storeEl = dom.getElementById(storeId);
      if (!storeEl) {
        var body = getBody();
        if (body) {
          storeEl = dom.createElement('div');
          storeEl.id = storeId;
          storeEl.style.display = 'none';
          body.appendChild(storeEl);
          setCurrent(storeData.m);
          setSubCurrent(storeData.s);
        }
      }
    }
  }
  return storeEl;
}
function createSetHandle(key) {
  return function (value) {
    if (value) {
      value = Number(value);
      storeData[key] = value;
      var el = getStoreDom();
      if (el) {
        if (el.dataset) {
          el.dataset[key] = value + '';
        } else {
          el.setAttribute('data-' + key, value + '');
        }
      }
    }
    updateVar();
    return storeData[key];
  };
}
var setCurrent = createSetHandle(storeMainKey);
function createGetHandle(key, nextMethod) {
  return function getCurrent(currZindex) {
    var zIndex;
    var el = getStoreDom();
    if (el) {
      var domVal = el.dataset ? el.dataset[key] : el.getAttribute('data-' + key);
      if (domVal) {
        zIndex = Number(domVal);
      }
    }
    if (!zIndex) {
      zIndex = storeData[key];
    }
    if (currZindex) {
      if (Number(currZindex) < zIndex) {
        return nextMethod();
      }
      return currZindex;
    }
    return zIndex;
  };
}
var getCurrent = createGetHandle(storeMainKey, getNext);
function getNext() {
  return setCurrent(getCurrent() + 1);
}
var setSubCurrent = createSetHandle(storeSubKey);
var _getSubCurrent = createGetHandle(storeSubKey, getSubNext);
function getSubCurrent() {
  return getCurrent() + _getSubCurrent();
}
function getSubNext() {
  setSubCurrent(_getSubCurrent() + 1);
  return getSubCurrent();
}
/**
 * Web common z-index style management
 */
var DomZIndex = {
  setCurrent: setCurrent,
  getCurrent: getCurrent,
  getNext: getNext,
  setSubCurrent: setSubCurrent,
  getSubCurrent: getSubCurrent,
  getSubNext: getSubNext,
  getMax: getDomMaxZIndex
};
updateVar();
/* harmony default export */ var index_esm = (DomZIndex);
;// ./packages/ui/src/utils.ts



function isEnableConf(conf) {
  return conf && conf.enabled !== false;
}
function isEmptyValue(cellValue) {
  return cellValue === null || cellValue === undefined || cellValue === '';
}
function parseFile(file) {
  const name = file.name;
  const tIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().lastIndexOf(name, '.');
  const type = name.substring(tIndex + 1, name.length).toLowerCase();
  const filename = name.substring(0, tIndex);
  return {
    filename,
    type
  };
}
function nextZIndex() {
  return index_esm.getNext();
}
function getLastZIndex() {
  return index_esm.getCurrent();
}
function hasChildrenList(item) {
  return item && item.children && item.children.length > 0;
}
function getFuncText(content, args) {
  if (content) {
    const translate = core_.VxeUI.getConfig().translate;
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(translate ? translate('' + content, args) : content);
  }
  return '';
}
function formatText(value, placeholder) {
  return '' + (isEmptyValue(value) ? placeholder ? core_.VxeUI.getConfig().emptyCell : '' : value);
}
/**
 * 判断值为：'' | null | undefined 时都属于空值
 */
function eqEmptyValue(cellValue) {
  return cellValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(cellValue);
}
;// ./packages/ui/index.ts


const version = "4.13.16";
core_.VxeUI.version = version;
core_.VxeUI.tableVersion = version;
core_.VxeUI.setConfig({
  emptyCell: '　',
  table: {
    fit: true,
    showHeader: true,
    animat: true,
    delayHover: 250,
    autoResize: true,
    minHeight: 144,
    // keepSource: false,
    // showOverflow: null,
    // showHeaderOverflow: null,
    // showFooterOverflow: null,
    // resizeInterval: 500,
    // size: null,
    // zIndex: null,
    // stripe: false,
    // border: false,
    // round: false,
    // emptyText: '暂无数据',
    // emptyRender: {
    //   name: ''
    // },
    // rowConfig: {
    //   keyField: '_X_ROW_KEY' // 行数据的唯一主键字段名
    // },
    resizeConfig: {
      // refreshDelay: 20
    },
    resizableConfig: {
      dragMode: 'auto',
      showDragTip: true,
      isSyncAutoHeight: true,
      isSyncAutoWidth: true,
      minHeight: 18
    },
    radioConfig: {
      // trigger: 'default'
      strict: true
    },
    rowDragConfig: {
      showIcon: true,
      animation: true,
      showGuidesStatus: true,
      showDragTip: true
    },
    columnDragConfig: {
      showIcon: true,
      animation: true,
      showGuidesStatus: true,
      showDragTip: true
    },
    checkboxConfig: {
      // trigger: 'default',
      strict: true
    },
    tooltipConfig: {
      enterable: true
    },
    validConfig: {
      showMessage: true,
      autoClear: true,
      autoPos: true,
      message: 'inline',
      msgMode: 'single',
      theme: 'beautify'
    },
    columnConfig: {
      maxFixedSize: 4
    },
    cellConfig: {
      padding: true
    },
    headerCellConfig: {
      height: 'unset'
    },
    footerCellConfig: {
      height: 'unset'
    },
    // menuConfig: {
    //   visibleMethod () {}
    // },
    customConfig: {
      // enabled: false,
      allowVisible: true,
      allowResizable: true,
      allowFixed: true,
      allowSort: true,
      showFooter: true,
      placement: 'top-right',
      //  storage: false,
      //  checkMethod () {},
      modalOptions: {
        showMaximize: true,
        mask: true,
        lockView: true,
        resize: true,
        escClosable: true
      },
      drawerOptions: {
        mask: true,
        lockView: true,
        escClosable: true,
        resize: true
      }
    },
    sortConfig: {
      // remote: false,
      // trigger: 'default',
      // orders: ['asc', 'desc', null],
      // sortMethod: null,
      showIcon: true,
      allowClear: true,
      allowBtn: true,
      iconLayout: 'vertical'
    },
    filterConfig: {
      // remote: false,
      // filterMethod: null,
      // destroyOnClose: false,
      // isEvery: false,
      showIcon: true
    },
    rowGroupConfig: {
      padding: true,
      rowField: 'id',
      parentField: '_X_ROW_PARENT_KEY',
      childrenField: '_X_ROW_CHILDREN',
      mapChildrenField: '_X_ROW_CHILD_LIST',
      indent: 20,
      showIcon: true
    },
    treeConfig: {
      padding: true,
      rowField: 'id',
      parentField: 'parentId',
      childrenField: 'children',
      hasChildField: 'hasChild',
      mapChildrenField: '_X_ROW_CHILD',
      indent: 20,
      showIcon: true
    },
    expandConfig: {
      // trigger: 'default',
      showIcon: true,
      mode: 'fixed'
    },
    editConfig: {
      // mode: 'cell',
      showIcon: true,
      showAsterisk: true,
      autoFocus: true
    },
    importConfig: {
      _typeMaps: {
        csv: 1,
        html: 1,
        xml: 1,
        txt: 1
      }
    },
    exportConfig: {
      _typeMaps: {
        csv: 1,
        html: 1,
        xml: 1,
        txt: 1
      }
    },
    printConfig: {},
    mouseConfig: {
      extension: true
    },
    keyboardConfig: {
      isEsc: true
    },
    areaConfig: {
      autoClear: true,
      selectCellByHeader: true,
      selectCellByBody: true,
      extendDirection: {
        top: true,
        left: true,
        bottom: true,
        right: true
      }
    },
    clipConfig: {
      isCopy: true,
      isCut: true,
      isPaste: true
    },
    fnrConfig: {
      isFind: true,
      isReplace: true
    },
    virtualXConfig: {
      enabled: false,
      gt: 24,
      preSize: 1,
      oSize: 0
    },
    virtualYConfig: {
      enabled: false,
      gt: 100,
      preSize: 1,
      oSize: 0
    },
    scrollbarConfig: {
      // width: 14,
      // height: 14
    }
  },
  // export: {
  //   types: {}
  // },
  grid: {
    // size: null,
    // zoomConfig: {
    //   escRestore: true
    // },
    formConfig: {
      enabled: true
    },
    pagerConfig: {
      enabled: true
      // perfect: false
    },
    toolbarConfig: {
      enabled: true
      // perfect: false
    },
    proxyConfig: {
      enabled: true,
      autoLoad: true,
      showResponseMsg: true,
      showActiveMsg: true,
      props: {
        list: null,
        result: 'result',
        total: 'page.total',
        message: 'message'
      }
      // beforeItem: null,
      // beforeColumn: null,
      // beforeQuery: null,
      // afterQuery: null,
      // beforeDelete: null,
      // afterDelete: null,
      // beforeSave: null,
      // afterSave: null
    }
  },
  toolbar: {
    // size: null,
    // import: {
    //   mode: 'covering'
    // },
    // export: {
    //   types: ['csv', 'html', 'xml', 'txt']
    // },
    // buttons: []
  }
});
const iconPrefix = 'vxe-table-icon-';
core_.VxeUI.setIcon({
  // table
  TABLE_SORT_ASC: iconPrefix + 'caret-up',
  TABLE_SORT_DESC: iconPrefix + 'caret-down',
  TABLE_FILTER_NONE: iconPrefix + 'funnel',
  TABLE_FILTER_MATCH: iconPrefix + 'funnel',
  TABLE_EDIT: iconPrefix + 'edit',
  TABLE_TITLE_PREFIX: iconPrefix + 'question-circle-fill',
  TABLE_TITLE_SUFFIX: iconPrefix + 'question-circle-fill',
  TABLE_TREE_LOADED: iconPrefix + 'spinner roll',
  TABLE_TREE_OPEN: iconPrefix + 'caret-right rotate90',
  TABLE_TREE_CLOSE: iconPrefix + 'caret-right',
  TABLE_EXPAND_LOADED: iconPrefix + 'spinner roll',
  TABLE_EXPAND_OPEN: iconPrefix + 'arrow-right rotate90',
  TABLE_EXPAND_CLOSE: iconPrefix + 'arrow-right',
  TABLE_CHECKBOX_CHECKED: iconPrefix + 'checkbox-checked-fill',
  TABLE_CHECKBOX_UNCHECKED: iconPrefix + 'checkbox-unchecked',
  TABLE_CHECKBOX_INDETERMINATE: iconPrefix + 'checkbox-indeterminate-fill',
  TABLE_RADIO_CHECKED: iconPrefix + 'radio-checked-fill',
  TABLE_RADIO_UNCHECKED: iconPrefix + 'radio-unchecked',
  TABLE_CUSTOM_SORT: iconPrefix + 'drag-handle',
  TABLE_MENU_OPTIONS: iconPrefix + 'arrow-right',
  TABLE_DRAG_ROW: iconPrefix + 'drag-handle',
  TABLE_DRAG_COLUMN: iconPrefix + 'drag-handle',
  TABLE_DRAG_STATUS_ROW: iconPrefix + 'sort',
  TABLE_DRAG_STATUS_SUB_ROW: iconPrefix + 'add-sub',
  TABLE_DRAG_STATUS_COLUMN: iconPrefix + 'swap',
  TABLE_DRAG_DISABLED: iconPrefix + 'no-drop',
  TABLE_ROW_GROUP_OPEN: iconPrefix + 'arrow-right rotate90',
  TABLE_ROW_GROUP_CLOSE: iconPrefix + 'arrow-right',
  // toolbar
  TOOLBAR_TOOLS_REFRESH: iconPrefix + 'repeat',
  TOOLBAR_TOOLS_REFRESH_LOADING: iconPrefix + 'repeat roll',
  TOOLBAR_TOOLS_IMPORT: iconPrefix + 'upload',
  TOOLBAR_TOOLS_EXPORT: iconPrefix + 'download',
  TOOLBAR_TOOLS_PRINT: iconPrefix + 'print',
  TOOLBAR_TOOLS_FULLSCREEN: iconPrefix + 'fullscreen',
  TOOLBAR_TOOLS_MINIMIZE: iconPrefix + 'minimize',
  TOOLBAR_TOOLS_CUSTOM: iconPrefix + 'custom-column',
  TOOLBAR_TOOLS_FIXED_LEFT: iconPrefix + 'fixed-left',
  TOOLBAR_TOOLS_FIXED_LEFT_ACTIVE: iconPrefix + 'fixed-left-fill',
  TOOLBAR_TOOLS_FIXED_RIGHT: iconPrefix + 'fixed-right',
  TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVE: iconPrefix + 'fixed-right-fill'
});
const setTheme = core_.VxeUI.setTheme;
const getTheme = core_.VxeUI.getTheme;
const setConfig = core_.VxeUI.setConfig;
const getConfig = core_.VxeUI.getConfig;
const setIcon = core_.VxeUI.setIcon;
const getIcon = core_.VxeUI.getIcon;
const setLanguage = core_.VxeUI.setLanguage;
const setI18n = core_.VxeUI.setI18n;
const getI18n = core_.VxeUI.getI18n;
const globalEvents = core_.VxeUI.globalEvents;
const globalResize = core_.VxeUI.globalResize;
const renderer = core_.VxeUI.renderer;
const validators = core_.VxeUI.validators;
const menus = core_.VxeUI.menus;
const formats = core_.VxeUI.formats;
const commands = core_.VxeUI.commands;
const interceptor = core_.VxeUI.interceptor;
const clipboard = core_.VxeUI.clipboard;
const log = core_.VxeUI.log;
const hooks = core_.VxeUI.hooks;
const use = core_.VxeUI.use;
/**
 * 已废弃
 * @deprecated
 */
const setup = options => {
  return core_.VxeUI.setConfig(options);
};
core_.VxeUI.setup = setup;
/**
 * 已废弃
 * @deprecated
 */
const config = options => {
  return core_.VxeUI.setConfig(options);
};
core_.VxeUI.config = config;
/**
 * 已废弃
 * @deprecated
 */
const t = (key, args) => {
  return core_.VxeUI.getI18n(key, args);
};
core_.VxeUI.t = t;
/**
 * 已废弃
 * @deprecated
 */
const _t = (content, args) => {
  return getFuncText(content, args);
};
core_.VxeUI._t = _t;
/**
 * 已废弃，兼容老版本
 * @deprecated
 */
const VXETable = core_.VxeUI;
/**
 * 已废弃，兼容老版本
 * @deprecated
 */
const saveFile = options => {
  return core_.VxeUI.saveFile(options);
};
/**
 * 已废弃，兼容老版本
 * @deprecated
 */
const readFile = options => {
  return core_.VxeUI.readFile(options);
};
/**
 * 已废弃，兼容老版本
 * @deprecated
 */
const print = options => {
  return core_.VxeUI.print(options);
};
/**
 * 已废弃，兼容老版本
 * @deprecated
 */
const modal = {
  /**
   * 已废弃，兼容老版本
   * @deprecated
   */
  get(id) {
    return core_.VxeUI.modal.get(id);
  },
  /**
   * 已废弃，兼容老版本
   * @deprecated
   */
  close(id) {
    return core_.VxeUI.modal.close(id);
  },
  /**
   * 已废弃，兼容老版本
   * @deprecated
   */
  open(options) {
    return core_.VxeUI.modal.open(options);
  },
  /**
   * 已废弃，兼容老版本
   * @deprecated
   */
  alert(content, title, options) {
    return core_.VxeUI.modal.alert(content, title, options);
  },
  /**
   * 已废弃，兼容老版本
   * @deprecated
   */
  confirm(content, title, options) {
    return core_.VxeUI.modal.confirm(content, title, options);
  },
  /**
   * 已废弃，兼容老版本
   * @deprecated
   */
  message(content, options) {
    return core_.VxeUI.modal.message(content, options);
  },
  /**
   * 已废弃，兼容老版本
   * @deprecated
   */
  notification(content, title, options) {
    return core_.VxeUI.modal.notification(content, title, options);
  }
};

/* harmony default export */ var ui = ((/* unused pure expression or super */ null && (VxeUI)));
// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__(9274);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__(4114);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.iterator.map.js
var esnext_iterator_map = __webpack_require__(1454);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.iterator.some.js
var esnext_iterator_some = __webpack_require__(7550);
;// ./packages/ui/src/log.ts

const {
  log: log_log
} = core_.VxeUI;
const log_version = `table v${"4.13.16"}`;
const warnLog = log_log.create('warn', log_version);
const errLog = log_log.create('error', log_version);
;// ./packages/table/src/columnInfo.ts





const {
  getI18n: columnInfo_getI18n,
  formats: columnInfo_formats
} = core_.VxeUI;
class ColumnInfo {
  /* eslint-disable @typescript-eslint/no-use-before-define */
  constructor($xeTable, _vm, {
    renderHeader,
    renderCell,
    renderFooter,
    renderData
  } = {}) {
    const tableProps = $xeTable.props;
    const $xeGrid = $xeTable.xeGrid;
    const formatter = _vm.formatter;
    const visible = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(_vm.visible) ? _vm.visible : true;
    const types = ['seq', 'checkbox', 'radio', 'expand', 'html'];
    if (_vm.type && types.indexOf(_vm.type) === -1) {
      warnLog('vxe.error.errProp', [`type=${_vm.type}`, types.join(', ')]);
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(_vm.cellRender) || _vm.cellRender && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(_vm.cellRender)) {
      warnLog('vxe.error.errProp', [`column.cell-render=${_vm.cellRender}`, 'column.cell-render={}']);
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(_vm.editRender) || _vm.editRender && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(_vm.editRender)) {
      warnLog('vxe.error.errProp', [`column.edit-render=${_vm.editRender}`, 'column.edit-render={}']);
    }
    if (_vm.type === 'expand') {
      const {
        treeConfig
      } = tableProps;
      const {
        computeTreeOpts
      } = $xeTable.getComputeMaps();
      const treeOpts = computeTreeOpts.value;
      if (treeConfig && (treeOpts.showLine || treeOpts.line)) {
        errLog('vxe.error.errConflicts', ['tree-config.showLine', 'column.type=expand']);
      }
    }
    if (formatter) {
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(formatter)) {
        const gFormatOpts = columnInfo_formats.get(formatter) || (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default())[formatter];
        if (!gFormatOpts || !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod)) {
          errLog('vxe.error.notFormats', [formatter]);
        }
      } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(formatter)) {
        const gFormatOpts = columnInfo_formats.get(formatter[0]) || (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default())[formatter[0]];
        if (!gFormatOpts || !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod)) {
          errLog('vxe.error.notFormats', [formatter[0]]);
        }
      }
    }
    Object.assign(this, {
      // 基本属性
      type: _vm.type,
      property: _vm.field,
      field: _vm.field,
      title: _vm.title,
      width: _vm.width,
      minWidth: _vm.minWidth,
      maxWidth: _vm.maxWidth,
      resizable: _vm.resizable,
      fixed: _vm.fixed,
      align: _vm.align,
      headerAlign: _vm.headerAlign,
      footerAlign: _vm.footerAlign,
      showOverflow: _vm.showOverflow,
      showHeaderOverflow: _vm.showHeaderOverflow,
      showFooterOverflow: _vm.showFooterOverflow,
      className: _vm.className,
      headerClassName: _vm.headerClassName,
      footerClassName: _vm.footerClassName,
      formatter: formatter,
      footerFormatter: _vm.footerFormatter,
      padding: _vm.padding,
      verticalAlign: _vm.verticalAlign,
      sortable: _vm.sortable,
      sortBy: _vm.sortBy,
      sortType: _vm.sortType,
      filters: toFilters(_vm.filters),
      filterMultiple: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(_vm.filterMultiple) ? _vm.filterMultiple : true,
      filterMethod: _vm.filterMethod,
      filterResetMethod: _vm.filterResetMethod,
      filterRecoverMethod: _vm.filterRecoverMethod,
      filterRender: _vm.filterRender,
      rowGroupNode: _vm.rowGroupNode,
      treeNode: _vm.treeNode,
      dragSort: _vm.dragSort,
      rowResize: _vm.rowResize,
      cellType: _vm.cellType,
      cellRender: _vm.cellRender,
      editRender: _vm.editRender,
      contentRender: _vm.contentRender,
      headerExportMethod: _vm.headerExportMethod,
      exportMethod: _vm.exportMethod,
      footerExportMethod: _vm.footerExportMethod,
      titleHelp: _vm.titleHelp,
      titlePrefix: _vm.titlePrefix,
      titleSuffix: _vm.titleSuffix,
      // 自定义参数
      params: _vm.params,
      // 渲染属性
      id: _vm.colId || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('col_'),
      parentId: null,
      visible,
      // 内部属性（一旦被使用，将导致不可升级版本）
      halfVisible: false,
      defaultVisible: visible,
      defaultFixed: _vm.fixed,
      checked: false,
      halfChecked: false,
      disabled: false,
      // 分组层级
      level: 1,
      // 跨行
      rowSpan: 1,
      // 跨列
      colSpan: 1,
      // 数据排序
      order: null,
      sortTime: 0,
      // 列排序
      sortNumber: 0,
      renderSortNumber: 0,
      renderFixed: '',
      renderVisible: false,
      renderWidth: 0,
      renderHeight: 0,
      renderResizeWidth: 0,
      renderAutoWidth: 0,
      resizeWidth: 0,
      renderLeft: 0,
      renderArgs: [],
      model: {},
      renderHeader: renderHeader || _vm.renderHeader,
      renderCell: renderCell || _vm.renderCell,
      renderFooter: renderFooter || _vm.renderFooter,
      renderData: renderData,
      // 单元格插槽，只对 grid 有效
      slots: _vm.slots
    });
    if ($xeGrid) {
      const {
        computeProxyOpts
      } = $xeGrid.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      if (proxyOpts.beforeColumn) {
        proxyOpts.beforeColumn({
          $grid: $xeGrid,
          column: this
        });
      }
    }
  }
  getTitle() {
    return getFuncText(this.title || (this.type === 'seq' ? columnInfo_getI18n('vxe.table.seqTitle') : ''));
  }
  getKey() {
    const {
      type
    } = this;
    return this.field || (type ? `type=${type}` : null);
  }
  update(name, value) {
    // 不支持直接修改的属性
    if (name !== 'filters') {
      if (name === 'field') {
        // 兼容旧属性
        this.property = value;
      }
      this[name] = value;
    }
  }
}
;// ./packages/ui/src/dom.ts

const reClsMap = {};
let tpImgEl;
function initTpImg() {
  if (!tpImgEl) {
    tpImgEl = new Image();
    tpImgEl.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
  }
  return tpImgEl;
}
function getTpImg() {
  if (!tpImgEl) {
    return initTpImg();
  }
  return tpImgEl;
}
function getPropClass(property, params) {
  return property ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(property) ? property(params) : property : '';
}
function getClsRE(cls) {
  if (!reClsMap[cls]) {
    reClsMap[cls] = new RegExp(`(?:^|\\s)${cls}(?!\\S)`, 'g');
  }
  return reClsMap[cls];
}
function getNodeOffset(elem, container, rest) {
  if (elem) {
    const parentElem = elem.parentNode;
    rest.top += elem.offsetTop;
    rest.left += elem.offsetLeft;
    if (parentElem && parentElem !== document.documentElement && parentElem !== document.body) {
      rest.top -= parentElem.scrollTop;
      rest.left -= parentElem.scrollLeft;
    }
    if (container && (elem === container || elem.offsetParent === container) ? 0 : elem.offsetParent) {
      return getNodeOffset(elem.offsetParent, container, rest);
    }
  }
  return rest;
}
function isPx(val) {
  return val && /^\d+(px)?$/.test(val);
}
function isScale(val) {
  return val && /^\d+%$/.test(val);
}
function hasClass(elem, cls) {
  return !!(elem && elem.className && elem.className.match && elem.className.match(getClsRE(cls)));
}
function removeClass(elem, cls) {
  if (elem && hasClass(elem, cls)) {
    elem.className = elem.className.replace(getClsRE(cls), '');
  }
}
function addClass(elem, cls) {
  if (elem && !hasClass(elem, cls)) {
    removeClass(elem, cls);
    elem.className = `${elem.className} ${cls}`;
  }
}
function hasControlKey(evnt) {
  return evnt.ctrlKey || evnt.metaKey;
}
function toCssUnit(val, unit = 'px') {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(val) || /^\d+$/.test(`${val}`)) {
    return `${val}${unit}`;
  }
  return `${val || ''}`;
}
function getDomNode() {
  const documentElement = document.documentElement;
  const bodyElem = document.body;
  return {
    scrollTop: documentElement.scrollTop || bodyElem.scrollTop,
    scrollLeft: documentElement.scrollLeft || bodyElem.scrollLeft,
    visibleHeight: documentElement.clientHeight || bodyElem.clientHeight,
    visibleWidth: documentElement.clientWidth || bodyElem.clientWidth
  };
}
function getOffsetHeight(elem) {
  return elem ? elem.offsetHeight : 0;
}
function getPaddingTopBottomSize(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const paddingTop = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.paddingTop);
    const paddingBottom = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.paddingBottom);
    return paddingTop + paddingBottom;
  }
  return 0;
}
function setScrollTop(elem, scrollTop) {
  if (elem) {
    elem.scrollTop = scrollTop;
  }
}
function setScrollLeft(elem, scrollLeft) {
  if (elem) {
    elem.scrollLeft = scrollLeft;
  }
}
// export function setScrollLeftAndTop (elem: HTMLElement | null, scrollLeft: number, scrollTop: number) {
//   if (elem) {
//     elem.scrollLeft = scrollLeft
//     elem.scrollTop = scrollTop
//   }
// }
function updateCellTitle(overflowElem, column) {
  const content = column.type === 'html' ? overflowElem.innerText : overflowElem.textContent;
  if (overflowElem.getAttribute('title') !== content) {
    overflowElem.setAttribute('title', content);
  }
}
/**
 * 检查触发源是否属于目标节点
 */
function getEventTargetNode(evnt, container, queryCls, queryMethod) {
  let targetElem;
  let target = evnt.target.shadowRoot && evnt.composed ? evnt.composedPath()[0] || evnt.target : evnt.target;
  while (target && target.nodeType && target !== document) {
    if (queryCls && hasClass(target, queryCls) && (!queryMethod || queryMethod(target))) {
      targetElem = target;
    } else if (target === container) {
      return {
        flag: queryCls ? !!targetElem : true,
        container,
        targetElem: targetElem
      };
    }
    target = target.parentNode;
  }
  return {
    flag: false
  };
}
/**
 * 获取元素相对于 document 的位置
 */
function getOffsetPos(elem, container) {
  return getNodeOffset(elem, container, {
    left: 0,
    top: 0
  });
}
function getAbsolutePos(elem) {
  const bounding = elem.getBoundingClientRect();
  const boundingTop = bounding.top;
  const boundingLeft = bounding.left;
  const {
    scrollTop,
    scrollLeft,
    visibleHeight,
    visibleWidth
  } = getDomNode();
  return {
    boundingTop,
    top: scrollTop + boundingTop,
    boundingLeft,
    left: scrollLeft + boundingLeft,
    visibleHeight,
    visibleWidth
  };
}
const scrollIntoViewIfNeeded = 'scrollIntoViewIfNeeded';
const scrollIntoView = 'scrollIntoView';
function scrollToView(elem) {
  if (elem) {
    if (elem[scrollIntoViewIfNeeded]) {
      elem[scrollIntoViewIfNeeded]();
    } else if (elem[scrollIntoView]) {
      elem[scrollIntoView]();
    }
  }
}
function triggerEvent(targetElem, type) {
  if (targetElem) {
    targetElem.dispatchEvent(new Event(type));
  }
}
function isNodeElement(elem) {
  return elem && elem.nodeType === 1;
}
;// ./packages/table/src/util.ts










const getAllConvertColumns = (columns, parentColumn) => {
  const result = [];
  columns.forEach(column => {
    column.parentId = parentColumn ? parentColumn.id : null;
    if (column.visible) {
      if (column.children && column.children.length && column.children.some(column => column.visible)) {
        result.push(column);
        result.push(...getAllConvertColumns(column.children, column));
      } else {
        result.push(column);
      }
    }
  });
  return result;
};
const convertHeaderColumnToRows = originColumns => {
  let maxLevel = 1;
  const traverse = (column, parent) => {
    if (parent) {
      column.level = parent.level + 1;
      if (maxLevel < column.level) {
        maxLevel = column.level;
      }
    }
    if (column.children && column.children.length && column.children.some(column => column.visible)) {
      let colSpan = 0;
      column.children.forEach(subColumn => {
        if (subColumn.visible) {
          traverse(subColumn, column);
          colSpan += subColumn.colSpan;
        }
      });
      column.colSpan = colSpan;
    } else {
      column.colSpan = 1;
    }
  };
  originColumns.forEach(column => {
    column.level = 1;
    traverse(column);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getAllConvertColumns(originColumns);
  allColumns.forEach(column => {
    if (column.children && column.children.length && column.children.some(column => column.visible)) {
      column.rowSpan = 1;
    } else {
      column.rowSpan = maxLevel - column.level + 1;
    }
    rows[column.level - 1].push(column);
  });
  return rows;
};
function restoreScrollLocation($xeTable, scrollLeft, scrollTop) {
  const internalData = $xeTable.internalData;
  if (scrollLeft || scrollTop) {
    internalData.intoRunScroll = false;
    internalData.inVirtualScroll = false;
    internalData.inWheelScroll = false;
    internalData.inHeaderScroll = false;
    internalData.inBodyScroll = false;
    internalData.inFooterScroll = false;
    internalData.scrollRenderType = '';
    // 还原滚动状态
    return $xeTable.scrollTo(scrollLeft, scrollTop);
  }
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
}
/**
 * 生成行的唯一主键
 */
function getRowUniqueId() {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('row_');
}
// 行主键 key
function getRowkey($xeTable) {
  const {
    props
  } = $xeTable;
  const {
    computeRowOpts
  } = $xeTable.getComputeMaps();
  const rowOpts = computeRowOpts.value;
  return `${props.rowId || rowOpts.keyField || '_X_ROW_KEY'}`;
}
// 行主键 value
function getRowid($xeTable, row) {
  const rowid = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, getRowkey($xeTable));
  return encodeRowid(rowid);
}
function createHandleUpdateRowId($xeTable) {
  const rowKey = getRowkey($xeTable);
  const isDeepKey = rowKey.indexOf('.') > -1;
  const updateRId = isDeepKey ? updateDeepRowKey : updateFastRowKey;
  return {
    rowKey,
    handleUpdateRowId(row) {
      return row ? updateRId(row, rowKey) : null;
    }
  };
}
function createHandleGetRowId($xeTable) {
  const rowKey = getRowkey($xeTable);
  const isDeepKey = rowKey.indexOf('.') > -1;
  const getRId = isDeepKey ? getDeepRowIdByKey : getFastRowIdByKey;
  return {
    rowKey,
    handleGetRowId(row) {
      return row ? getRId(row, rowKey) : null;
    }
  };
}
// 编码行主键
function encodeRowid(rowVal) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(rowVal) ? '' : encodeURIComponent(rowVal);
}
function getDeepRowIdByKey(row, rowKey) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, rowKey);
}
function updateDeepRowKey(row, rowKey) {
  let rowid = getDeepRowIdByKey(row, rowKey);
  if (eqEmptyValue(rowid)) {
    rowid = getRowUniqueId();
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, rowKey, rowid);
  }
  return rowid;
}
function getFastRowIdByKey(row, rowKey) {
  return row[rowKey];
}
function updateFastRowKey(row, rowKey) {
  let rowid = getFastRowIdByKey(row, rowKey);
  if (eqEmptyValue(rowid)) {
    rowid = getRowUniqueId();
    row[rowKey] = rowid;
  }
  return rowid;
}
const handleFieldOrColumn = ($xeTable, fieldOrColumn) => {
  if (fieldOrColumn) {
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrColumn) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(fieldOrColumn) ? $xeTable.getColumnByField(`${fieldOrColumn}`) : fieldOrColumn;
  }
  return null;
};
const handleRowidOrRow = ($xeTable, rowidOrRow) => {
  if (rowidOrRow) {
    const rowid = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(rowidOrRow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(rowidOrRow) ? rowidOrRow : getRowid($xeTable, rowidOrRow);
    return $xeTable.getRowById(rowid);
  }
  return null;
};
function getPaddingLeftRightSize(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const paddingLeft = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.paddingLeft);
    const paddingRight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.paddingRight);
    return paddingLeft + paddingRight;
  }
  return 0;
}
function getElementMarginWidth(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const marginLeft = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.marginLeft);
    const marginRight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.marginRight);
    return elem.offsetWidth + marginLeft + marginRight;
  }
  return 0;
}
function queryCellElement(cell, selector) {
  return cell.querySelector('.vxe-cell' + selector);
}
function toFilters(filters) {
  if (filters && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(filters)) {
    return filters.map(({
      label,
      value,
      data,
      resetValue,
      checked
    }) => {
      return {
        label,
        value,
        data,
        resetValue,
        checked: !!checked,
        _checked: !!checked
      };
    });
  }
  return filters;
}
function toTreePathSeq(path) {
  return path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : '.').join('');
}
function getCellValue(row, column) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
}
function setCellValue(row, column, value) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, column.field, value);
}
function getRefElem(refEl) {
  if (refEl) {
    const rest = refEl.value;
    if (rest) {
      return rest.$el || rest;
    }
  }
  return null;
}
function getCellHeight(height) {
  if (height === 'unset') {
    return 0;
  }
  return height || 0;
}
/**
 * 列宽拖动最大宽度
 * @param params
 * @returns
 */
function getColReMaxWidth(params) {
  const {
    $table
  } = params;
  const {
    computeResizableOpts
  } = $table.getComputeMaps();
  const resizableOpts = computeResizableOpts.value;
  const {
    maxWidth: reMaxWidth
  } = resizableOpts;
  // 如果自定义调整宽度逻辑
  if (reMaxWidth) {
    const customMaxWidth = XEUtils.isFunction(reMaxWidth) ? reMaxWidth(params) : reMaxWidth;
    if (customMaxWidth !== 'auto') {
      return Math.max(1, XEUtils.toNumber(customMaxWidth));
    }
  }
  return -1;
}
/**
 * 列宽拖动最小宽度
 * @param params
 * @returns
 */
function getColReMinWidth(params) {
  const {
    $table,
    column,
    cell
  } = params;
  const tableProps = $table.props;
  const internalData = $table.internalData;
  const {
    computeResizableOpts
  } = $table.getComputeMaps();
  const resizableOpts = computeResizableOpts.value;
  const {
    minWidth: reMinWidth
  } = resizableOpts;
  // 如果自定义调整宽度逻辑
  if (reMinWidth) {
    const customMinWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(reMinWidth) ? reMinWidth(params) : reMinWidth;
    if (customMinWidth !== 'auto') {
      return Math.max(1, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(customMinWidth));
    }
  }
  const {
    elemStore
  } = internalData;
  const {
    showHeaderOverflow: allColumnHeaderOverflow
  } = tableProps;
  const {
    showHeaderOverflow,
    minWidth: colMinWidth
  } = column;
  const headOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(showHeaderOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
  const showEllipsis = headOverflow === 'ellipsis';
  const showTitle = headOverflow === 'title';
  const showTooltip = headOverflow === true || headOverflow === 'tooltip';
  const hasEllipsis = showTitle || showTooltip || showEllipsis;
  const minTitleWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor((external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getComputedStyle(cell).fontSize) || 14) * 1.6);
  const paddingLeftRight = getPaddingLeftRightSize(cell) + getPaddingLeftRightSize(queryCellElement(cell, ''));
  let mWidth = minTitleWidth + paddingLeftRight;
  // 默认最小宽处理
  if (hasEllipsis) {
    const dragIconWidth = getPaddingLeftRightSize(queryCellElement(cell, '>.vxe-cell--drag-handle'));
    const checkboxIconWidth = getPaddingLeftRightSize(queryCellElement(cell, '>.vxe-cell--checkbox'));
    const requiredIconWidth = getElementMarginWidth(queryCellElement(cell, '>.vxe-cell--required-icon'));
    const editIconWidth = getElementMarginWidth(queryCellElement(cell, '>.vxe-cell--edit-icon'));
    const prefixIconWidth = getElementMarginWidth(queryCellElement(cell, '>.vxe-cell-title-prefix-icon'));
    const suffixIconWidth = getElementMarginWidth(queryCellElement(cell, '>.vxe-cell-title-suffix-icon'));
    const sortIconWidth = getElementMarginWidth(queryCellElement(cell, '>.vxe-cell--sort'));
    const filterIconWidth = getElementMarginWidth(queryCellElement(cell, '>.vxe-cell--filter'));
    mWidth += dragIconWidth + checkboxIconWidth + requiredIconWidth + editIconWidth + prefixIconWidth + suffixIconWidth + filterIconWidth + sortIconWidth;
  }
  // 如果设置最小宽
  if (colMinWidth) {
    const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
    if (bodyScrollElem) {
      if (isScale(colMinWidth)) {
        const bodyWidth = bodyScrollElem.clientWidth - 1;
        const meanWidth = bodyWidth / 100;
        return Math.max(mWidth, Math.floor(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(colMinWidth) * meanWidth));
      } else if (isPx(colMinWidth)) {
        return Math.max(mWidth, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(colMinWidth));
      }
    }
  }
  return mWidth;
}
function isColumnInfo(column) {
  return column && (column.constructor === ColumnInfo || column instanceof ColumnInfo);
}
function createColumn($xeTable, options, renderOptions) {
  return isColumnInfo(options) ? options : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(new ColumnInfo($xeTable, options, renderOptions));
}
function watchColumn($xeTable, props, column) {
  Object.keys(props).forEach(name => {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props[name], value => {
      column.update(name, value);
      if ($xeTable) {
        if (name === 'filters') {
          $xeTable.setFilter(column, value);
          $xeTable.handleUpdateDataQueue();
        } else if (['visible', 'fixed', 'width', 'minWidth', 'maxWidth'].includes(name)) {
          $xeTable.handleRefreshColumnQueue();
        }
      }
    });
  });
}
function assembleColumn($xeTable, elem, column, colgroup) {
  const {
    reactData
  } = $xeTable;
  const {
    staticColumns
  } = reactData;
  const parentElem = elem.parentNode;
  const parentColumn = colgroup ? colgroup.columnConfig : null;
  const parentCols = parentColumn ? parentColumn.children : staticColumns;
  if (parentElem && parentCols) {
    parentCols.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, elem), 0, column);
    reactData.staticColumns = staticColumns.slice(0);
  }
}
function destroyColumn($xeTable, column) {
  const {
    reactData
  } = $xeTable;
  const {
    staticColumns
  } = reactData;
  const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(staticColumns, item => item.id === column.id, {
    children: 'children'
  });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  reactData.staticColumns = staticColumns.slice(0);
}
function getRootColumn($xeTable, column) {
  const {
    internalData
  } = $xeTable;
  const {
    fullColumnIdData
  } = internalData;
  if (!column) {
    return null;
  }
  let parentColId = column.parentId;
  while (fullColumnIdData[parentColId]) {
    const column = fullColumnIdData[parentColId].column;
    parentColId = column.parentId;
    if (!parentColId) {
      return column;
    }
  }
  return column;
}
const lineOffsetSizes = {
  mini: 3,
  small: 2,
  medium: 1,
  large: 0
};
const countTreeExpand = (prevRow, params) => {
  let count = 1;
  if (!prevRow) {
    return count;
  }
  const {
    $table
  } = params;
  const {
    computeTreeOpts
  } = $table.getComputeMaps();
  const treeOpts = computeTreeOpts.value;
  const {
    transform,
    mapChildrenField
  } = treeOpts;
  const childrenField = treeOpts.children || treeOpts.childrenField;
  const rowChildren = prevRow[transform ? mapChildrenField : childrenField];
  if (rowChildren && $table.isTreeExpandByRow(prevRow)) {
    for (let index = 0; index < rowChildren.length; index++) {
      count += countTreeExpand(rowChildren[index], params);
    }
  }
  return count;
};
const getOffsetSize = $xeTable => {
  const {
    computeSize
  } = $xeTable.getComputeMaps();
  const vSize = computeSize.value;
  if (vSize) {
    return lineOffsetSizes[vSize] || 0;
  }
  return 0;
};
function calcTreeLine(params, prevRow) {
  const {
    $table,
    row
  } = params;
  const tableProps = $table.props;
  const tableReactData = $table.reactData;
  const tableInternalData = $table.internalData;
  const {
    showOverflow
  } = tableProps;
  const {
    scrollYLoad
  } = tableReactData;
  const {
    fullAllDataRowIdData
  } = tableInternalData;
  const {
    computeRowOpts,
    computeCellOpts,
    computeDefaultRowHeight
  } = $table.getComputeMaps();
  const rowOpts = computeRowOpts.value;
  const cellOpts = computeCellOpts.value;
  const defaultRowHeight = computeDefaultRowHeight.value;
  const rowid = getRowid($table, row);
  const rowRest = fullAllDataRowIdData[rowid];
  const currCellHeight = rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
  let expandSize = 1;
  if (prevRow) {
    expandSize = countTreeExpand(prevRow, params);
  }
  let cellHeight = currCellHeight;
  const vnHeight = rowRest.height;
  if (scrollYLoad) {
    if (!showOverflow) {
      cellHeight = vnHeight || currCellHeight;
    }
  }
  return cellHeight * expandSize - (prevRow ? 1 : 12 - getOffsetSize($table));
}
function clearTableDefaultStatus($xeTable) {
  const {
    props,
    internalData
  } = $xeTable;
  internalData.initStatus = false;
  $xeTable.clearSort();
  $xeTable.clearCurrentRow();
  $xeTable.clearCurrentColumn();
  $xeTable.clearRadioRow();
  $xeTable.clearRadioReserve();
  $xeTable.clearCheckboxRow();
  $xeTable.clearCheckboxReserve();
  $xeTable.clearRowExpand();
  $xeTable.clearTreeExpand();
  $xeTable.clearTreeExpandReserve();
  $xeTable.clearPendingRow();
  if ($xeTable.clearFilter) {
    $xeTable.clearFilter();
  }
  if ($xeTable.clearSelected && (props.keyboardConfig || props.mouseConfig)) {
    $xeTable.clearSelected();
  }
  if ($xeTable.clearCellAreas && props.mouseConfig) {
    $xeTable.clearCellAreas();
    $xeTable.clearCopyCellArea();
  }
  return $xeTable.clearScroll();
}
function clearTableAllStatus($xeTable) {
  if ($xeTable.clearFilter) {
    $xeTable.clearFilter();
  }
  return clearTableDefaultStatus($xeTable);
}
function rowToVisible($xeTable, row) {
  const tableProps = $xeTable.props;
  const reactData = $xeTable.reactData;
  const internalData = $xeTable.internalData;
  const {
    computeLeftFixedWidth,
    computeRightFixedWidth,
    computeRowOpts,
    computeCellOpts,
    computeDefaultRowHeight
  } = $xeTable.getComputeMaps();
  const {
    showOverflow
  } = tableProps;
  const {
    scrollYLoad
  } = reactData;
  const {
    elemStore,
    afterFullData,
    fullAllDataRowIdData,
    isResizeCellHeight
  } = internalData;
  const rowOpts = computeRowOpts.value;
  const cellOpts = computeCellOpts.value;
  const defaultRowHeight = computeDefaultRowHeight.value;
  const leftFixedWidth = computeLeftFixedWidth.value;
  const rightFixedWidth = computeRightFixedWidth.value;
  const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
  const rowid = getRowid($xeTable, row);
  if (bodyScrollElem) {
    const bodyHeight = bodyScrollElem.clientHeight;
    const bodyScrollTop = bodyScrollElem.scrollTop;
    const trElem = bodyScrollElem.querySelector(`[rowid="${rowid}"]`);
    if (trElem) {
      const trOffsetParent = trElem.offsetParent;
      const trOffsetTop = trElem.offsetTop + (trOffsetParent ? trOffsetParent.offsetTop : 0);
      const trHeight = trElem.clientHeight;
      // 检测行是否在可视区中
      if (trOffsetTop < bodyScrollTop || trOffsetTop > bodyScrollTop + bodyHeight) {
        return $xeTable.scrollTo(null, trOffsetTop);
      } else if (trOffsetTop + trHeight >= bodyHeight + bodyScrollTop) {
        return $xeTable.scrollTo(null, bodyScrollTop + trHeight);
      }
    } else {
      // 如果是虚拟渲染滚动
      if (scrollYLoad) {
        const isCustomCellHeight = isResizeCellHeight || cellOpts.height || rowOpts.height;
        if (!isCustomCellHeight && showOverflow) {
          return $xeTable.scrollTo(null, ($xeTable.findRowIndexOf(afterFullData, row) - 1) * defaultRowHeight);
        }
        let scrollTop = 0;
        const rowRest = fullAllDataRowIdData[rowid] || {};
        const rHeight = rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
        for (let i = 0; i < afterFullData.length; i++) {
          const currRow = afterFullData[i];
          const currRowid = getRowid($xeTable, currRow);
          if (currRow === row || currRowid === rowid) {
            break;
          }
          const currRowRest = fullAllDataRowIdData[currRowid] || {};
          scrollTop += currRowRest.resizeHeight || cellOpts.height || rowOpts.height || currRowRest.height || defaultRowHeight;
        }
        if (scrollTop < bodyScrollTop) {
          return $xeTable.scrollTo(null, scrollTop - leftFixedWidth - 1);
        }
        return $xeTable.scrollTo(null, scrollTop + rHeight - (bodyHeight - rightFixedWidth - 1));
      }
    }
  }
  return Promise.resolve();
}
function colToVisible($xeTable, column, row) {
  const reactData = $xeTable.reactData;
  const internalData = $xeTable.internalData;
  const {
    computeLeftFixedWidth,
    computeRightFixedWidth
  } = $xeTable.getComputeMaps();
  const {
    scrollXLoad
  } = reactData;
  const {
    elemStore,
    visibleColumn
  } = internalData;
  const leftFixedWidth = computeLeftFixedWidth.value;
  const rightFixedWidth = computeRightFixedWidth.value;
  const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
  if (column.fixed) {
    return Promise.resolve();
  }
  if (bodyScrollElem) {
    const bodyWidth = bodyScrollElem.clientWidth;
    const bodyScrollLeft = bodyScrollElem.scrollLeft;
    let tdElem = null;
    if (row) {
      const rowid = getRowid($xeTable, row);
      tdElem = bodyScrollElem.querySelector(`[rowid="${rowid}"] .${column.id}`);
    }
    if (!tdElem) {
      tdElem = bodyScrollElem.querySelector(`.${column.id}`);
    }
    if (tdElem) {
      const tdOffsetParent = tdElem.offsetParent;
      const tdOffsetLeft = tdElem.offsetLeft + (tdOffsetParent ? tdOffsetParent.offsetLeft : 0);
      const cellWidth = tdElem.clientWidth;
      // 检测是否在可视区中
      if (tdOffsetLeft < bodyScrollLeft + leftFixedWidth) {
        return $xeTable.scrollTo(tdOffsetLeft - leftFixedWidth - 1);
      } else if (tdOffsetLeft + cellWidth - bodyScrollLeft > bodyWidth - rightFixedWidth) {
        return $xeTable.scrollTo(tdOffsetLeft + cellWidth - (bodyWidth - rightFixedWidth - 1));
      }
    } else {
      // 检测是否在虚拟渲染可视区中
      if (scrollXLoad) {
        let scrollLeft = 0;
        const cellWidth = column.renderWidth;
        for (let i = 0; i < visibleColumn.length; i++) {
          const currCol = visibleColumn[i];
          if (currCol === column || currCol.id === column.id) {
            break;
          }
          scrollLeft += currCol.renderWidth;
        }
        if (scrollLeft < bodyScrollLeft) {
          return $xeTable.scrollTo(scrollLeft - leftFixedWidth - 1);
        }
        return $xeTable.scrollTo(scrollLeft + cellWidth - (bodyWidth - rightFixedWidth - 1));
      }
    }
  }
  return Promise.resolve();
}
;// ./packages/ui/src/vn.ts

function getOnName(type) {
  return 'on' + type.substring(0, 1).toLocaleUpperCase() + type.substring(1);
}
function getModelEvent(renderOpts) {
  switch (renderOpts.name) {
    case 'input':
    case 'textarea':
      return 'input';
    case 'select':
      return 'change';
  }
  return 'update:modelValue';
}
function getChangeEvent(renderOpts) {
  switch (renderOpts.name) {
    case 'input':
    case 'textarea':
    case 'VxeInput':
    case 'VxeNumberInput':
    case 'VxeTextarea':
    case '$input':
    case '$textarea':
      return 'input';
  }
  return 'change';
}
function getSlotVNs(vns) {
  if (vns === null || vns === undefined) {
    return [];
  }
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(vns)) {
    return vns;
  }
  return [vns];
}
;// ./packages/table/src/cell.ts










const {
  getI18n: cell_getI18n,
  getIcon: cell_getIcon,
  renderer: cell_renderer,
  formats: cell_formats,
  renderEmptyElement
} = core_.VxeUI;
function renderTitlePrefixIcon(params) {
  const {
    $table,
    column
  } = params;
  const titlePrefix = column.titlePrefix || column.titleHelp;
  if (titlePrefix) {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
      class: ['vxe-cell-title-prefix-icon', titlePrefix.iconStatus ? `theme--${titlePrefix.iconStatus}` : '', titlePrefix.icon || cell_getIcon().TABLE_TITLE_PREFIX],
      onMouseenter(evnt) {
        $table.triggerHeaderTitleEvent(evnt, titlePrefix, params);
      },
      onMouseleave(evnt) {
        $table.handleTargetLeaveEvent(evnt);
      }
    });
  }
  return renderEmptyElement($table);
}
function renderTitleSuffixIcon(params) {
  const {
    $table,
    column
  } = params;
  const titleSuffix = column.titleSuffix;
  if (titleSuffix) {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
      class: ['vxe-cell-title-suffix-icon', titleSuffix.iconStatus ? `theme--${titleSuffix.iconStatus}` : '', titleSuffix.icon || cell_getIcon().TABLE_TITLE_SUFFIX],
      onMouseenter(evnt) {
        $table.triggerHeaderTitleEvent(evnt, titleSuffix, params);
      },
      onMouseleave(evnt) {
        $table.handleTargetLeaveEvent(evnt);
      }
    });
  }
  return renderEmptyElement($table);
}
function renderCellDragIcon(params) {
  const {
    $table,
    column
  } = params;
  const {
    context
  } = $table;
  const tableSlots = context.slots;
  const tableProps = $table.props;
  const {
    slots
  } = column;
  const {
    dragConfig
  } = tableProps;
  const {
    computeRowDragOpts
  } = $table.getComputeMaps();
  const rowDragOpts = computeRowDragOpts.value;
  const {
    icon,
    trigger,
    disabledMethod
  } = rowDragOpts;
  const rDisabledMethod = disabledMethod || (dragConfig ? dragConfig.rowDisabledMethod : null);
  const isDisabled = rDisabledMethod && rDisabledMethod(params);
  const rowDragIconSlot = (slots ? slots.rowDragIcon || slots['row-drag-icon'] : null) || tableSlots.rowDragIcon || tableSlots['row-drag-icon'];
  const ons = {};
  if (trigger !== 'cell') {
    ons.onMousedown = evnt => {
      if (!isDisabled) {
        $table.handleCellDragMousedownEvent(evnt, params);
      }
    };
    ons.onMouseup = $table.handleCellDragMouseupEvent;
  }
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    key: 'dg',
    class: ['vxe-cell--drag-handle', {
      'is--disabled': isDisabled
    }],
    ...ons
  }, rowDragIconSlot ? $table.callSlot(rowDragIconSlot, params) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
    class: icon || (dragConfig ? dragConfig.rowIcon : '') || cell_getIcon().TABLE_DRAG_ROW
  })]);
}
function renderCellBaseVNs(params, content) {
  const {
    $table,
    column,
    level
  } = params;
  const {
    dragSort
  } = column;
  const tableProps = $table.props;
  const {
    treeConfig,
    dragConfig
  } = tableProps;
  const {
    computeRowOpts,
    computeRowDragOpts,
    computeTreeOpts
  } = $table.getComputeMaps();
  const rowOpts = computeRowOpts.value;
  const rowDragOpts = computeRowDragOpts.value;
  const treeOpts = computeTreeOpts.value;
  const {
    showIcon,
    isPeerDrag,
    isCrossDrag,
    visibleMethod
  } = rowDragOpts;
  const rVisibleMethod = visibleMethod || (dragConfig ? dragConfig.rowVisibleMethod : null);
  const vns = [];
  if (dragSort && rowOpts.drag && (showIcon || (dragConfig ? dragConfig.showRowIcon : false)) && (!rVisibleMethod || rVisibleMethod(params))) {
    if (treeConfig) {
      if (treeOpts.transform && (isPeerDrag || isCrossDrag || !level)) {
        vns.push(renderCellDragIcon(params));
      }
    } else {
      vns.push(renderCellDragIcon(params));
    }
  }
  return vns.concat(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(content) ? content : [content]);
}
function renderHeaderCellDragIcon(params) {
  const {
    $table,
    column
  } = params;
  const {
    context
  } = $table;
  const tableSlots = context.slots;
  const {
    slots
  } = column;
  const {
    computeColumnOpts,
    computeColumnDragOpts
  } = $table.getComputeMaps();
  const columnOpts = computeColumnOpts.value;
  const columnDragOpts = computeColumnDragOpts.value;
  const {
    showIcon,
    icon,
    trigger,
    isPeerDrag,
    isCrossDrag,
    visibleMethod,
    disabledMethod
  } = columnDragOpts;
  if (columnOpts.drag && showIcon && (!visibleMethod || visibleMethod(params))) {
    if (!column.fixed && (isPeerDrag || isCrossDrag || !column.parentId)) {
      const isDisabled = disabledMethod && disabledMethod(params);
      const columnDragIconSlot = (slots ? slots.columnDragIcon || slots['column-drag-icon'] : null) || tableSlots.columnDragIcon || tableSlots['column-drag-icon'];
      const ons = {};
      if (trigger !== 'cell') {
        ons.onMousedown = evnt => {
          if (!isDisabled) {
            $table.handleHeaderCellDragMousedownEvent(evnt, params);
          }
        };
        ons.onMouseup = $table.handleHeaderCellDragMouseupEvent;
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        key: 'dg',
        class: ['vxe-cell--drag-handle', {
          'is--disabled': isDisabled
        }],
        ...ons
      }, columnDragIconSlot ? $table.callSlot(columnDragIconSlot, params) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon || cell_getIcon().TABLE_DRAG_COLUMN
      })]);
    }
  }
  return renderEmptyElement($table);
}
function renderHeaderCellBaseVNs(params, content) {
  const vns = [renderTitlePrefixIcon(params), renderHeaderCellDragIcon(params), ...(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(content) ? content : [content]), renderTitleSuffixIcon(params)];
  return vns;
}
function renderTitleContent(params, content) {
  const {
    $table,
    column
  } = params;
  const tableProps = $table.props;
  const tableReactData = $table.reactData;
  const {
    computeTooltipOpts
  } = $table.getComputeMaps();
  const {
    showHeaderOverflow: allColumnHeaderOverflow
  } = tableProps;
  const {
    type,
    showHeaderOverflow
  } = column;
  const tooltipOpts = computeTooltipOpts.value;
  const showAllTip = tooltipOpts.showAll;
  const headOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(showHeaderOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
  const showTitle = headOverflow === 'title';
  const showTooltip = headOverflow === true || headOverflow === 'tooltip';
  const ons = {};
  if (showTitle || showTooltip || showAllTip) {
    ons.onMouseenter = evnt => {
      if (tableReactData.isDragResize) {
        return;
      }
      if (showTitle) {
        updateCellTitle(evnt.currentTarget, column);
      } else if (showTooltip || showAllTip) {
        $table.triggerHeaderTooltipEvent(evnt, params);
      }
    };
  }
  if (showTooltip || showAllTip) {
    ons.onMouseleave = evnt => {
      if (tableReactData.isDragResize) {
        return;
      }
      if (showTooltip || showAllTip) {
        $table.handleTargetLeaveEvent(evnt);
      }
    };
  }
  return [type === 'html' && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(content) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-cell--title',
    innerHTML: content,
    ...ons
  }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-cell--title',
    ...ons
  }, getSlotVNs(content))];
}
function getFooterContent(params) {
  const {
    $table,
    column,
    _columnIndex,
    items,
    row
  } = params;
  const {
    slots,
    editRender,
    cellRender,
    footerFormatter
  } = column;
  const renderOpts = editRender || cellRender;
  const footerSlot = slots ? slots.footer : null;
  if (footerSlot) {
    return $table.callSlot(footerSlot, params);
  }
  let itemValue = '';
  // 兼容老模式
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(items)) {
    itemValue = items[_columnIndex];
  } else {
    itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
  }
  const footParams = Object.assign(params, {
    itemValue
  });
  if (footerFormatter) {
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerFormatter)) {
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-cell--label'
      }, `${footerFormatter(footParams)}`)];
    }
    const isArr = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(footerFormatter);
    const gFormatOpts = isArr ? cell_formats.get(footerFormatter[0]) : cell_formats.get(footerFormatter);
    const footerFormatMethod = gFormatOpts ? gFormatOpts.tableFooterCellFormatMethod : null;
    if (footerFormatMethod) {
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-cell--label'
      }, `${isArr ? footerFormatMethod(footParams, ...footerFormatter.slice(1)) : footerFormatMethod(footParams)}`)];
    }
    return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-cell--label'
    }, '')];
  }
  if (renderOpts) {
    const compConf = cell_renderer.get(renderOpts.name);
    if (compConf) {
      const rtFooter = compConf.renderTableFooter || compConf.renderFooter;
      if (rtFooter) {
        return getSlotVNs(rtFooter(renderOpts, footParams));
      }
    }
  }
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-cell--label'
  }, formatText(itemValue, 1))];
}
function getDefaultCellLabel(params) {
  const {
    $table,
    row,
    column
  } = params;
  return formatText($table.getCellLabel(row, column), 1);
}
function renderCellHandle(params) {
  const {
    column,
    $table
  } = params;
  const tableProps = $table.props;
  const {
    editConfig
  } = tableProps;
  const {
    type,
    treeNode,
    rowGroupNode,
    editRender
  } = column;
  const {
    computeEditOpts,
    computeCheckboxOpts
  } = $table.getComputeMaps();
  const checkboxOpts = computeCheckboxOpts.value;
  const editOpts = computeEditOpts.value;
  const isDeepCell = treeNode || rowGroupNode;
  switch (type) {
    case 'seq':
      return isDeepCell ? Cell.renderDeepIndexCell(params) : Cell.renderSeqCell(params);
    case 'radio':
      return isDeepCell ? Cell.renderDeepRadioCell(params) : Cell.renderRadioCell(params);
    case 'checkbox':
      return checkboxOpts.checkField ? isDeepCell ? Cell.renderDeepSelectionCellByProp(params) : Cell.renderCheckboxCellByProp(params) : isDeepCell ? Cell.renderDeepSelectionCell(params) : Cell.renderCheckboxCell(params);
    case 'expand':
      return Cell.renderExpandCell(params);
    case 'html':
      return isDeepCell ? Cell.renderDeepHTMLCell(params) : Cell.renderHTMLCell(params);
  }
  if (isEnableConf(editConfig) && editRender) {
    return editOpts.mode === 'cell' ? isDeepCell ? Cell.renderDeepCellEdit(params) : Cell.renderCellEdit(params) : isDeepCell ? Cell.renderDeepRowEdit(params) : Cell.renderRowEdit(params);
  }
  return isDeepCell ? Cell.renderDeepCell(params) : Cell.renderDefaultCell(params);
}
function renderHeaderHandle(params) {
  const {
    column,
    $table
  } = params;
  const tableProps = $table.props;
  const {
    editConfig
  } = tableProps;
  const {
    type,
    filters,
    sortable,
    editRender
  } = column;
  switch (type) {
    case 'seq':
      return Cell.renderSeqHeader(params);
    case 'radio':
      return Cell.renderRadioHeader(params);
    case 'checkbox':
      return Cell.renderCheckboxHeader(params);
    case 'html':
      if (filters && sortable) {
        return Cell.renderSortAndFilterHeader(params);
      } else if (sortable) {
        return Cell.renderSortHeader(params);
      } else if (filters) {
        return Cell.renderFilterHeader(params);
      }
      break;
  }
  if (editConfig && editRender) {
    return Cell.renderEditHeader(params);
  } else if (filters && sortable) {
    return Cell.renderSortAndFilterHeader(params);
  } else if (sortable) {
    return Cell.renderSortHeader(params);
  } else if (filters) {
    return Cell.renderFilterHeader(params);
  }
  return Cell.renderDefaultHeader(params);
}
function renderFooterHandle(params) {
  return Cell.renderDefaultFooter(params);
}
const Cell = {
  createColumn($xeTable, columnOpts) {
    const {
      type
    } = columnOpts;
    const renConfs = {
      renderHeader: renderHeaderHandle,
      renderCell: renderCellHandle,
      renderFooter: renderFooterHandle
    };
    if (type === 'expand') {
      renConfs.renderData = Cell.renderExpandData;
    }
    return createColumn($xeTable, columnOpts, renConfs);
  },
  /**
   * 列头标题
   */
  renderHeaderTitle(params) {
    const {
      $table,
      column
    } = params;
    const {
      slots,
      editRender,
      cellRender
    } = column;
    const renderOpts = editRender || cellRender;
    const headerSlot = slots ? slots.header : null;
    if (headerSlot) {
      return renderTitleContent(params, $table.callSlot(headerSlot, params));
    }
    if (renderOpts) {
      const compConf = cell_renderer.get(renderOpts.name);
      if (compConf) {
        const rtHeader = compConf.renderTableHeader || compConf.renderHeader;
        if (rtHeader) {
          return renderTitleContent(params, getSlotVNs(rtHeader(renderOpts, params)));
        }
      }
    }
    return renderTitleContent(params, formatText(column.getTitle(), 1));
  },
  renderDefaultHeader(params) {
    return renderHeaderCellBaseVNs(params, Cell.renderHeaderTitle(params));
  },
  renderDefaultCell(params) {
    const {
      $table,
      row,
      column
    } = params;
    const tableReactData = $table.reactData;
    const tableInternalData = $table.internalData;
    const {
      isRowGroupStatus
    } = tableReactData;
    const {
      slots,
      editRender,
      cellRender,
      rowGroupNode
    } = column;
    const renderOpts = editRender || cellRender;
    const defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return renderCellBaseVNs(params, $table.callSlot(defaultSlot, params));
    }
    if (renderOpts) {
      const compConf = cell_renderer.get(renderOpts.name);
      if (compConf) {
        const rtCell = compConf.renderTableCell || compConf.renderCell;
        const rtDefault = compConf.renderTableDefault || compConf.renderDefault;
        const renderFn = editRender ? rtCell : rtDefault;
        if (renderFn) {
          return renderCellBaseVNs(params, getSlotVNs(renderFn(renderOpts, Object.assign({
            $type: editRender ? 'edit' : 'cell'
          }, params))));
        }
      }
    }
    let cellValue = '';
    if (isRowGroupStatus && rowGroupNode && row.isAggregate) {
      const {
        fullColumnFieldData
      } = tableInternalData;
      const {
        computeRowGroupOpts
      } = $table.getComputeMaps();
      const rowGroupOpts = computeRowGroupOpts.value;
      const {
        showTotal,
        totalMethod,
        contentMethod,
        mapChildrenField
      } = rowGroupOpts;
      const groupField = row.groupField;
      cellValue = row.groupContent;
      const childList = mapChildrenField ? row[mapChildrenField] || [] : [];
      const totalValue = childList.length;
      const colRest = fullColumnFieldData[groupField] || {};
      const params = {
        $table,
        groupField,
        groupColumn: colRest ? colRest.column : null,
        column,
        groupValue: cellValue,
        children: childList,
        totalValue: totalValue
      };
      if (contentMethod) {
        cellValue = `${contentMethod(params)}`;
      }
      if (showTotal) {
        cellValue = cell_getI18n('vxe.table.rowGroupContentTotal', [cellValue, totalMethod ? totalMethod(params) : totalValue, totalValue]);
      }
    } else if (!(isRowGroupStatus && row.isAggregate)) {
      cellValue = $table.getCellLabel(row, column);
    }
    const cellPlaceholder = editRender ? editRender.placeholder : '';
    return renderCellBaseVNs(params, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-cell--label'
    }, [
    // 如果设置占位符
    editRender && eqEmptyValue(cellValue) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-cell--placeholder'
    }, formatText(getFuncText(cellPlaceholder), 1)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', formatText(cellValue, 1))])]);
  },
  renderDeepCell(params) {
    return Cell.renderDeepNodeBtn(params, Cell.renderDefaultCell(params));
  },
  renderDefaultFooter(params) {
    return getFooterContent(params);
  },
  /**
   * 行分组
   */
  renderRowGroupBtn(params, cellVNodes) {
    const {
      $table
    } = params;
    const tableReactData = $table.reactData;
    const tableInternalData = $table.internalData;
    const {
      row,
      level
    } = params;
    const {
      computeRowGroupOpts
    } = $table.getComputeMaps();
    const {
      rowGroupExpandedFlag
    } = tableReactData;
    const {
      rowGroupExpandedMaps
    } = tableInternalData;
    const rowGroupOpts = computeRowGroupOpts.value;
    const {
      padding,
      indent
    } = rowGroupOpts;
    const rowid = getRowid($table, row);
    const isExpand = !!rowGroupExpandedFlag && !!rowGroupExpandedMaps[rowid];
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: ['vxe-row-group--tree-node', {
        'is--expanded': isExpand
      }],
      style: padding && indent ? {
        paddingLeft: `${level * indent}px`
      } : undefined
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-row-group--node-btn',
      onClick(evnt) {
        $table.triggerRowGroupExpandEvent(evnt, params);
      }
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
      class: isExpand ? cell_getIcon().TABLE_ROW_GROUP_OPEN : cell_getIcon().TABLE_ROW_GROUP_CLOSE
    })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: 'vxe-row-group-cell'
    }, cellVNodes)]);
  },
  /**
   * 树
   */
  renderTreeNodeBtn(params, cellVNodes) {
    const {
      $table,
      isHidden
    } = params;
    const tableReactData = $table.reactData;
    const tableInternalData = $table.internalData;
    const {
      row,
      column,
      level
    } = params;
    const {
      slots
    } = column;
    const iconSlot = slots ? slots.icon : null;
    if (iconSlot) {
      return $table.callSlot(iconSlot, params);
    }
    const {
      computeTreeOpts
    } = $table.getComputeMaps();
    const {
      treeExpandedFlag
    } = tableReactData;
    const {
      fullAllDataRowIdData,
      treeExpandedMaps,
      treeExpandLazyLoadedMaps
    } = tableInternalData;
    const treeOpts = computeTreeOpts.value;
    const {
      padding,
      indent,
      lazy,
      trigger,
      iconLoaded,
      showIcon,
      iconOpen,
      iconClose
    } = treeOpts;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
    const rowChilds = row[childrenField];
    const hasChild = rowChilds && rowChilds.length;
    let hasLazyChilds = false;
    let isActive = false;
    let isLazyLoading = false;
    let isLazyLoaded = false;
    const ons = {};
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isActive = !!treeExpandedFlag && !!treeExpandedMaps[rowid];
      if (lazy) {
        const rest = fullAllDataRowIdData[rowid];
        isLazyLoading = !!treeExpandLazyLoadedMaps[rowid];
        hasLazyChilds = row[hasChildField];
        isLazyLoaded = !!rest.treeLoaded;
      }
    }
    if (!trigger || trigger === 'default') {
      ons.onClick = evnt => {
        $table.triggerTreeExpandEvent(evnt, params);
      };
    }
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: ['vxe-cell--tree-node', {
        'is--active': isActive
      }],
      style: padding && indent ? {
        paddingLeft: `${level * indent}px`
      } : undefined
    }, [showIcon && (lazy ? isLazyLoaded ? hasChild : hasChild || hasLazyChilds : hasChild) ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: 'vxe-cell--tree-btn',
      ...ons
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
      class: isLazyLoading ? iconLoaded || cell_getIcon().TABLE_TREE_LOADED : isActive ? iconOpen || cell_getIcon().TABLE_TREE_OPEN : iconClose || cell_getIcon().TABLE_TREE_CLOSE
    })])] : null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: 'vxe-tree-cell'
    }, cellVNodes)]);
  },
  /**
   * 层级节点。
   * 行分组、树结构
   */
  renderDeepNodeBtn(params, cellVNodes) {
    const {
      row,
      column
    } = params;
    const {
      rowGroupNode
    } = column;
    if (rowGroupNode && row.isAggregate) {
      return [Cell.renderRowGroupBtn(params, cellVNodes)];
    }
    return [Cell.renderTreeNodeBtn(params, cellVNodes)];
  },
  /**
   * 序号
   */
  renderSeqHeader(params) {
    const {
      $table,
      column
    } = params;
    const {
      slots
    } = column;
    const headerSlot = slots ? slots.header : null;
    return renderHeaderCellBaseVNs(params, renderTitleContent(params, headerSlot ? $table.callSlot(headerSlot, params) : formatText(column.getTitle(), 1)));
  },
  renderSeqCell(params) {
    const {
      $table,
      column
    } = params;
    const tableProps = $table.props;
    const {
      treeConfig
    } = tableProps;
    const {
      computeSeqOpts
    } = $table.getComputeMaps();
    const seqOpts = computeSeqOpts.value;
    const {
      slots
    } = column;
    const defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return renderCellBaseVNs(params, $table.callSlot(defaultSlot, params));
    }
    const {
      seq
    } = params;
    const seqMethod = seqOpts.seqMethod;
    return renderCellBaseVNs(params, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', `${formatText(seqMethod ? seqMethod(params) : treeConfig ? seq : (seqOpts.startIndex || 0) + seq, 1)}`)]);
  },
  renderDeepIndexCell(params) {
    return Cell.renderDeepNodeBtn(params, Cell.renderSeqCell(params));
  },
  /**
   * 单选
   */
  renderRadioHeader(params) {
    const {
      $table,
      column
    } = params;
    const {
      slots
    } = column;
    const headerSlot = slots ? slots.header : null;
    const titleSlot = slots ? slots.title : null;
    return renderHeaderCellBaseVNs(params, renderTitleContent(params, headerSlot ? $table.callSlot(headerSlot, params) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-radio--label'
    }, titleSlot ? $table.callSlot(titleSlot, params) : formatText(column.getTitle(), 1))]));
  },
  renderRadioCell(params) {
    const {
      $table,
      column,
      isHidden
    } = params;
    const tableReactData = $table.reactData;
    const {
      computeRadioOpts
    } = $table.getComputeMaps();
    const {
      selectRadioRow
    } = tableReactData;
    const radioOpts = computeRadioOpts.value;
    const {
      slots
    } = column;
    const {
      labelField,
      checkMethod,
      visibleMethod
    } = radioOpts;
    const {
      row
    } = params;
    const defaultSlot = slots ? slots.default : null;
    const radioSlot = slots ? slots.radio : null;
    const isChecked = $table.eqRow(row, selectRadioRow);
    const isVisible = !visibleMethod || visibleMethod({
      $table,
      row
    });
    let isDisabled = !!checkMethod;
    let ons;
    if (!isHidden) {
      ons = {
        onClick(evnt) {
          if (!isDisabled && isVisible) {
            $table.triggerRadioRowEvent(evnt, params);
          }
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({
          $table,
          row
        });
      }
    }
    const radioParams = {
      ...params,
      checked: isChecked,
      disabled: isDisabled,
      visible: isVisible
    };
    if (radioSlot) {
      return renderCellBaseVNs(params, $table.callSlot(radioSlot, radioParams));
    }
    const radioVNs = [];
    if (isVisible) {
      radioVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-radio--icon', isChecked ? cell_getIcon().TABLE_RADIO_CHECKED : cell_getIcon().TABLE_RADIO_UNCHECKED]
      }));
    }
    if (defaultSlot || labelField) {
      radioVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-radio--label'
      }, defaultSlot ? $table.callSlot(defaultSlot, radioParams) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, labelField)));
    }
    return renderCellBaseVNs(params, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: ['vxe-cell--radio', {
        'is--checked': isChecked,
        'is--disabled': isDisabled
      }],
      ...ons
    }, radioVNs)]);
  },
  renderDeepRadioCell(params) {
    return Cell.renderDeepNodeBtn(params, Cell.renderRadioCell(params));
  },
  /**
   * 多选
   */
  renderCheckboxHeader(params) {
    const {
      $table,
      column,
      isHidden
    } = params;
    const tableReactData = $table.reactData;
    const {
      computeIsAllCheckboxDisabled,
      computeCheckboxOpts
    } = $table.getComputeMaps();
    const {
      isAllSelected: isAllCheckboxSelected,
      isIndeterminate: isAllCheckboxIndeterminate
    } = tableReactData;
    const isAllCheckboxDisabled = computeIsAllCheckboxDisabled.value;
    const {
      slots
    } = column;
    const headerSlot = slots ? slots.header : null;
    const titleSlot = slots ? slots.title : null;
    const checkboxOpts = computeCheckboxOpts.value;
    const {
      checkStrictly,
      showHeader,
      headerTitle
    } = checkboxOpts;
    const colTitle = column.getTitle();
    const ons = {};
    if (!isHidden) {
      ons.onClick = evnt => {
        if (!isAllCheckboxDisabled) {
          $table.triggerCheckAllEvent(evnt, !isAllCheckboxSelected);
        }
      };
    }
    const checkboxParams = {
      ...params,
      checked: isAllCheckboxSelected,
      disabled: isAllCheckboxDisabled,
      indeterminate: isAllCheckboxIndeterminate
    };
    if (headerSlot) {
      return renderHeaderCellBaseVNs(params, renderTitleContent(checkboxParams, $table.callSlot(headerSlot, checkboxParams)));
    }
    if (checkStrictly ? !showHeader : showHeader === false) {
      return renderHeaderCellBaseVNs(params, renderTitleContent(checkboxParams, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-checkbox--label'
      }, titleSlot ? $table.callSlot(titleSlot, checkboxParams) : colTitle)]));
    }
    return renderHeaderCellBaseVNs(params, renderTitleContent(checkboxParams, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: ['vxe-cell--checkbox', {
        'is--checked': isAllCheckboxSelected,
        'is--disabled': isAllCheckboxDisabled,
        'is--indeterminate': isAllCheckboxIndeterminate
      }],
      title: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(headerTitle) ? cell_getI18n('vxe.table.allTitle') : `${headerTitle || ''}`,
      ...ons
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: ['vxe-checkbox--icon', isAllCheckboxIndeterminate ? cell_getIcon().TABLE_CHECKBOX_INDETERMINATE : isAllCheckboxSelected ? cell_getIcon().TABLE_CHECKBOX_CHECKED : cell_getIcon().TABLE_CHECKBOX_UNCHECKED]
    })].concat(titleSlot || colTitle ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-checkbox--label'
    }, titleSlot ? $table.callSlot(titleSlot, checkboxParams) : colTitle)] : []))]));
  },
  renderCheckboxCell(params) {
    const {
      $table,
      row,
      column,
      isHidden
    } = params;
    const tableProps = $table.props;
    const tableReactData = $table.reactData;
    const tableInternalData = $table.internalData;
    const {
      treeConfig
    } = tableProps;
    const {
      updateCheckboxFlag,
      isRowGroupStatus
    } = tableReactData;
    const {
      selectCheckboxMaps,
      treeIndeterminateRowMaps
    } = tableInternalData;
    const {
      computeCheckboxOpts
    } = $table.getComputeMaps();
    const checkboxOpts = computeCheckboxOpts.value;
    const {
      labelField,
      checkMethod,
      visibleMethod
    } = checkboxOpts;
    const {
      slots
    } = column;
    const defaultSlot = slots ? slots.default : null;
    const checkboxSlot = slots ? slots.checkbox : null;
    let indeterminate = false;
    let isChecked = false;
    const isVisible = !visibleMethod || visibleMethod({
      $table,
      row
    });
    let isDisabled = !!checkMethod;
    const ons = {};
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isChecked = !!updateCheckboxFlag && !!selectCheckboxMaps[rowid];
      ons.onClick = evnt => {
        if (!isDisabled && isVisible) {
          $table.triggerCheckRowEvent(evnt, params, !isChecked);
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({
          $table,
          row
        });
      }
      if (treeConfig || isRowGroupStatus) {
        indeterminate = !!treeIndeterminateRowMaps[rowid];
      }
    }
    const checkboxParams = {
      ...params,
      checked: isChecked,
      disabled: isDisabled,
      visible: isVisible,
      indeterminate
    };
    if (checkboxSlot) {
      return renderCellBaseVNs(params, $table.callSlot(checkboxSlot, checkboxParams));
    }
    const checkVNs = [];
    if (isVisible) {
      checkVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-checkbox--icon', indeterminate ? cell_getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? cell_getIcon().TABLE_CHECKBOX_CHECKED : cell_getIcon().TABLE_CHECKBOX_UNCHECKED]
      }));
    }
    if (defaultSlot || labelField) {
      checkVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-checkbox--label'
      }, defaultSlot ? $table.callSlot(defaultSlot, checkboxParams) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, labelField)));
    }
    return renderCellBaseVNs(params, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: ['vxe-cell--checkbox', {
        'is--checked': isChecked,
        'is--disabled': isDisabled,
        'is--indeterminate': indeterminate,
        'is--hidden': !isVisible
      }],
      ...ons
    }, checkVNs)]);
  },
  renderDeepSelectionCell(params) {
    return Cell.renderDeepNodeBtn(params, Cell.renderCheckboxCell(params));
  },
  renderCheckboxCellByProp(params) {
    const {
      $table,
      row,
      column,
      isHidden
    } = params;
    const tableProps = $table.props;
    const tableReactData = $table.reactData;
    const tableInternalData = $table.internalData;
    const {
      treeConfig
    } = tableProps;
    const {
      updateCheckboxFlag,
      isRowGroupStatus
    } = tableReactData;
    const {
      treeIndeterminateRowMaps
    } = tableInternalData;
    const {
      computeCheckboxOpts
    } = $table.getComputeMaps();
    const checkboxOpts = computeCheckboxOpts.value;
    const {
      labelField,
      checkField,
      checkMethod,
      visibleMethod
    } = checkboxOpts;
    const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
    const {
      slots
    } = column;
    const defaultSlot = slots ? slots.default : null;
    const checkboxSlot = slots ? slots.checkbox : null;
    let isIndeterminate = false;
    let isChecked = false;
    const isVisible = !visibleMethod || visibleMethod({
      $table,
      row
    });
    let isDisabled = !!checkMethod;
    const ons = {};
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isChecked = !!updateCheckboxFlag && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField);
      ons.onClick = evnt => {
        if (!isDisabled && isVisible) {
          $table.triggerCheckRowEvent(evnt, params, !isChecked);
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({
          $table,
          row
        });
      }
      if (treeConfig || isRowGroupStatus) {
        isIndeterminate = !!treeIndeterminateRowMaps[rowid];
      }
    }
    const checkboxParams = {
      ...params,
      checked: isChecked,
      disabled: isDisabled,
      visible: isVisible,
      indeterminate: isIndeterminate
    };
    if (checkboxSlot) {
      return renderCellBaseVNs(params, $table.callSlot(checkboxSlot, checkboxParams));
    }
    const checkVNs = [];
    if (isVisible) {
      checkVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-checkbox--icon', isIndeterminate ? cell_getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? cell_getIcon().TABLE_CHECKBOX_CHECKED : cell_getIcon().TABLE_CHECKBOX_UNCHECKED]
      }));
      if (defaultSlot || labelField) {
        checkVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-checkbox--label'
        }, defaultSlot ? $table.callSlot(defaultSlot, checkboxParams) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, labelField)));
      }
    }
    return renderCellBaseVNs(params, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: ['vxe-cell--checkbox', {
        'is--checked': isChecked,
        'is--disabled': isDisabled,
        'is--indeterminate': indeterminateField && !isChecked ? row[indeterminateField] : isIndeterminate,
        'is--hidden': !isVisible
      }],
      ...ons
    }, checkVNs)]);
  },
  renderDeepSelectionCellByProp(params) {
    return Cell.renderDeepNodeBtn(params, Cell.renderCheckboxCellByProp(params));
  },
  /**
   * 展开行
   */
  renderExpandCell(params) {
    const {
      $table,
      isHidden,
      row,
      column
    } = params;
    const tableReactData = $table.reactData;
    const tableInternalData = $table.internalData;
    const {
      isRowGroupStatus
    } = tableReactData;
    const {
      rowExpandedMaps,
      rowExpandLazyLoadedMaps
    } = tableInternalData;
    const {
      computeExpandOpts
    } = $table.getComputeMaps();
    const expandOpts = computeExpandOpts.value;
    const {
      lazy,
      labelField,
      iconLoaded,
      showIcon,
      iconOpen,
      iconClose,
      visibleMethod
    } = expandOpts;
    const {
      slots
    } = column;
    const defaultSlot = slots ? slots.default : null;
    const iconSlot = slots ? slots.icon : null;
    let isActive = false;
    let isLazyLoading = false;
    if (isRowGroupStatus && row.isAggregate) {
      return renderCellBaseVNs(params, []);
    }
    if (iconSlot) {
      return renderCellBaseVNs(params, $table.callSlot(iconSlot, params));
    }
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isActive = !!rowExpandedMaps[rowid];
      if (lazy) {
        isLazyLoading = !!rowExpandLazyLoadedMaps[rowid];
      }
    }
    return renderCellBaseVNs(params, [showIcon && (!visibleMethod || visibleMethod(params)) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: ['vxe-table--expanded', {
        'is--active': isActive
      }],
      onMousedown(evnt) {
        evnt.stopPropagation();
      },
      onClick(evnt) {
        $table.triggerRowExpandEvent(evnt, params);
      }
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
      class: ['vxe-table--expand-btn', isLazyLoading ? iconLoaded || cell_getIcon().TABLE_EXPAND_LOADED : isActive ? iconOpen || cell_getIcon().TABLE_EXPAND_OPEN : iconClose || cell_getIcon().TABLE_EXPAND_CLOSE]
    })]) : renderEmptyElement($table), defaultSlot || labelField ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-table--expand-label'
    }, defaultSlot ? $table.callSlot(defaultSlot, params) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, labelField)) : renderEmptyElement($table)]);
  },
  renderExpandData(params) {
    const {
      $table,
      column
    } = params;
    const {
      slots,
      contentRender
    } = column;
    const contentSlot = slots ? slots.content : null;
    if (contentSlot) {
      return $table.callSlot(contentSlot, params);
    }
    if (contentRender) {
      const compConf = cell_renderer.get(contentRender.name);
      if (compConf) {
        const rtExpand = compConf.renderTableExpand || compConf.renderExpand;
        if (rtExpand) {
          return getSlotVNs(rtExpand(contentRender, params));
        }
      }
    }
    return [];
  },
  /**
   * HTML 标签
   */
  renderHTMLCell(params) {
    const {
      $table,
      column
    } = params;
    const {
      slots
    } = column;
    const defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return renderCellBaseVNs(params, $table.callSlot(defaultSlot, params));
    }
    return renderCellBaseVNs(params, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-cell--html',
      innerHTML: getDefaultCellLabel(params)
    })]);
  },
  renderDeepHTMLCell(params) {
    return Cell.renderDeepNodeBtn(params, Cell.renderHTMLCell(params));
  },
  /**
   * 排序和筛选
   */
  renderSortAndFilterHeader(params) {
    return renderHeaderCellBaseVNs(params, Cell.renderHeaderTitle(params).concat(Cell.renderSortIcon(params).concat(Cell.renderFilterIcon(params))));
  },
  /**
   * 排序
   */
  renderSortHeader(params) {
    return renderHeaderCellBaseVNs(params, Cell.renderHeaderTitle(params).concat(Cell.renderSortIcon(params)));
  },
  renderSortIcon(params) {
    const {
      $table,
      column
    } = params;
    const {
      computeSortOpts
    } = $table.getComputeMaps();
    const sortOpts = computeSortOpts.value;
    const {
      showIcon,
      allowBtn,
      ascTitle,
      descTitle,
      iconLayout,
      iconAsc,
      iconDesc,
      iconVisibleMethod
    } = sortOpts;
    const {
      order
    } = column;
    if (showIcon && (!iconVisibleMethod || iconVisibleMethod(params))) {
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-cell--sort', `vxe-cell--sort-${iconLayout}-layout`]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-sort--asc-btn', iconAsc || cell_getIcon().TABLE_SORT_ASC, {
          'sort--active': order === 'asc'
        }],
        title: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(ascTitle) ? cell_getI18n('vxe.table.sortAsc') : `${ascTitle || ''}`,
        onClick: allowBtn ? evnt => {
          evnt.stopPropagation();
          $table.triggerSortEvent(evnt, column, 'asc');
        } : undefined
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-sort--desc-btn', iconDesc || cell_getIcon().TABLE_SORT_DESC, {
          'sort--active': order === 'desc'
        }],
        title: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(descTitle) ? cell_getI18n('vxe.table.sortDesc') : `${descTitle || ''}`,
        onClick: allowBtn ? evnt => {
          evnt.stopPropagation();
          $table.triggerSortEvent(evnt, column, 'desc');
        } : undefined
      })])];
    }
    return [];
  },
  /**
   * 筛选
   */
  renderFilterHeader(params) {
    return renderHeaderCellBaseVNs(params, Cell.renderHeaderTitle(params).concat(Cell.renderFilterIcon(params)));
  },
  renderFilterIcon(params) {
    const {
      $table,
      column,
      hasFilter
    } = params;
    const tableReactData = $table.reactData;
    const {
      filterStore
    } = tableReactData;
    const {
      computeFilterOpts
    } = $table.getComputeMaps();
    const filterOpts = computeFilterOpts.value;
    const {
      showIcon,
      iconNone,
      iconMatch,
      iconVisibleMethod
    } = filterOpts;
    if (showIcon && (!iconVisibleMethod || iconVisibleMethod(params))) {
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-cell--filter', {
          'is--active': filterStore.visible && filterStore.column === column
        }],
        onClick(evnt) {
          if ($table.triggerFilterEvent) {
            $table.triggerFilterEvent(evnt, params.column, params);
          }
        }
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-filter--btn', hasFilter ? iconMatch || cell_getIcon().TABLE_FILTER_MATCH : iconNone || cell_getIcon().TABLE_FILTER_NONE],
        title: cell_getI18n('vxe.table.filter')
      })])];
    }
    return [];
  },
  /**
   * 可编辑
   */
  renderEditHeader(params) {
    const {
      $table,
      column
    } = params;
    const tableProps = $table.props;
    const {
      computeEditOpts
    } = $table.getComputeMaps();
    const {
      editConfig,
      editRules
    } = tableProps;
    const editOpts = computeEditOpts.value;
    const {
      sortable,
      filters,
      editRender
    } = column;
    let isRequired = false;
    if (editRules) {
      const columnRules = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(editRules, column.field);
      if (columnRules) {
        isRequired = columnRules.some(rule => rule.required);
      }
    }
    let editIconVNs = [];
    if (isEnableConf(editConfig)) {
      editIconVNs = [isRequired && editOpts.showAsterisk ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-cell--required-icon'
      }) : renderEmptyElement($table), isEnableConf(editRender) && editOpts.showIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-cell--edit-icon', editOpts.icon || cell_getIcon().TABLE_EDIT]
      }) : renderEmptyElement($table)];
    }
    return renderHeaderCellBaseVNs(params, editIconVNs.concat(Cell.renderHeaderTitle(params)).concat(sortable ? Cell.renderSortIcon(params) : []).concat(filters ? Cell.renderFilterIcon(params) : []));
  },
  // 行格编辑模式
  renderRowEdit(params) {
    const {
      $table,
      column
    } = params;
    const tableReactData = $table.reactData;
    const {
      editStore
    } = tableReactData;
    const {
      actived
    } = editStore;
    const {
      editRender
    } = column;
    return Cell.runRenderer(params, isEnableConf(editRender) && actived && actived.row === params.row);
  },
  renderDeepRowEdit(params) {
    return Cell.renderDeepNodeBtn(params, Cell.renderRowEdit(params));
  },
  // 单元格编辑模式
  renderCellEdit(params) {
    const {
      $table,
      column
    } = params;
    const tableReactData = $table.reactData;
    const {
      editStore
    } = tableReactData;
    const {
      actived
    } = editStore;
    const {
      editRender
    } = column;
    return Cell.runRenderer(params, isEnableConf(editRender) && actived && actived.row === params.row && actived.column === params.column);
  },
  renderDeepCellEdit(params) {
    return Cell.renderDeepNodeBtn(params, Cell.renderCellEdit(params));
  },
  runRenderer(params, isEdit) {
    const {
      $table,
      column
    } = params;
    const {
      slots,
      editRender,
      formatter
    } = column;
    const defaultSlot = slots ? slots.default : null;
    const editSlot = slots ? slots.edit : null;
    const compConf = cell_renderer.get(editRender.name);
    const rtEdit = compConf ? compConf.renderTableEdit || compConf.renderEdit : null;
    const cellParams = Object.assign({
      $type: '',
      isEdit
    }, params);
    if (isEdit) {
      cellParams.$type = 'edit';
      if (editSlot) {
        return $table.callSlot(editSlot, cellParams);
      }
      if (rtEdit) {
        return getSlotVNs(rtEdit(editRender, cellParams));
      }
      return [];
    }
    if (defaultSlot) {
      return renderCellBaseVNs(params, $table.callSlot(defaultSlot, cellParams));
    }
    if (formatter) {
      return renderCellBaseVNs(params, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-cell--label'
      }, getDefaultCellLabel(cellParams))]);
    }
    return Cell.renderDefaultCell(cellParams);
  }
};
/* harmony default export */ var cell = (Cell);
;// ./packages/table/src/column.ts



const columnProps = {
  // 列唯一主键
  colId: [String, Number],
  // 渲染类型 index,radio,checkbox,expand,html
  type: String,
  // 列字段名
  field: String,
  // 列标题
  title: String,
  // 列宽度
  width: [Number, String],
  // 列最小宽度，把剩余宽度按比例分配
  minWidth: [Number, String],
  // 列最大宽度
  maxWidth: [Number, String],
  // 是否允许拖动列宽调整大小
  resizable: {
    type: Boolean,
    default: null
  },
  // 将列固定在左侧或者右侧
  fixed: String,
  // 列对其方式
  align: String,
  // 表头对齐方式
  headerAlign: String,
  // 表尾列的对齐方式
  footerAlign: String,
  // 当内容过长时显示为省略号
  showOverflow: {
    type: [Boolean, String],
    default: null
  },
  // 当表头内容过长时显示为省略号
  showHeaderOverflow: {
    type: [Boolean, String],
    default: null
  },
  // 当表尾内容过长时显示为省略号
  showFooterOverflow: {
    type: [Boolean, String],
    default: null
  },
  // 给单元格附加 className
  className: [String, Function],
  // 给表头单元格附加 className
  headerClassName: [String, Function],
  // 给表尾单元格附加 className
  footerClassName: [String, Function],
  // 格式化显示内容
  formatter: [Function, Array, String],
  // 格式化表尾显示内容
  footerFormatter: [Function, Array, String],
  // 是否显示间距
  padding: {
    type: Boolean,
    default: null
  },
  // 垂直对齐方式
  verticalAlign: {
    type: String,
    default: null
  },
  // 是否允许排序
  sortable: Boolean,
  // 自定义排序的属性
  sortBy: [String, Function],
  // 排序的字段类型，比如字符串转数值等
  sortType: String,
  // 配置筛选条件数组
  filters: {
    type: Array,
    default: null
  },
  // 筛选是否允许多选
  filterMultiple: {
    type: Boolean,
    default: true
  },
  // 自定义筛选方法
  filterMethod: Function,
  // 筛选重置方法
  filterResetMethod: Function,
  // 筛选复原方法
  filterRecoverMethod: Function,
  // 筛选模板配置项
  filterRender: Object,
  // 设置为分组节点
  rowGroupNode: Boolean,
  // 设置为树节点
  treeNode: Boolean,
  // 设置为拖拽排序
  dragSort: Boolean,
  // 设置为行高拖拽
  rowResize: Boolean,
  // 是否可视
  visible: {
    type: Boolean,
    default: null
  },
  // 表头单元格数据导出方法
  headerExportMethod: Function,
  // 单元格数据导出方法
  exportMethod: Function,
  // 表尾单元格数据导出方法
  footerExportMethod: Function,
  // 已废弃，被 titlePrefix 替换
  titleHelp: Object,
  // 标题前缀图标配置项
  titlePrefix: Object,
  // 标题后缀图标配置项
  titleSuffix: Object,
  // 单元格值类型
  cellType: String,
  // 单元格渲染配置项
  cellRender: Object,
  // 单元格编辑渲染配置项
  editRender: Object,
  // 内容渲染配置项
  contentRender: Object,
  // 额外的参数
  params: Object
};
/* harmony default export */ var column = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeColumn',
  props: columnProps,
  setup(props, {
    slots
  }) {
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeColgroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeColgroup', null);
    if (!$xeTable) {
      return () => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    }
    const columnConfig = cell.createColumn($xeTable, props);
    columnConfig.slots = slots;
    const renderVN = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      });
    };
    const $xeColumn = {
      columnConfig,
      renderVN
    };
    watchColumn($xeTable, props, columnConfig);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const elem = refElem.value;
      if (elem) {
        assembleColumn($xeTable, elem, columnConfig, $xeColgroup);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyColumn($xeTable, columnConfig);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeColumn', $xeColumn);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeGrid', null);
    return renderVN;
  }
}));
;// ./packages/column/index.ts


const VxeColumn = Object.assign({}, column, {
  install(app) {
    app.component(column.name, column);
    // 兼容旧用法
    app.component('VxeTableColumn', column);
  }
});
if (core_.VxeUI.dynamicApp) {
  core_.VxeUI.dynamicApp.component(column.name, column);
  // 兼容旧用法
  core_.VxeUI.dynamicApp.component('VxeTableColumn', column);
}
core_.VxeUI.component(column);
const Column = VxeColumn;
/* harmony default export */ var packages_column = ((/* unused pure expression or super */ null && (VxeColumn)));
;// ./packages/table/src/group.ts




/* harmony default export */ var group = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeColgroup',
  props: columnProps,
  setup(props, {
    slots
  }) {
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeParentColgroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeColgroup', null);
    if (!$xeTable) {
      return () => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    }
    const columnConfig = cell.createColumn($xeTable, props);
    const columnSlots = {};
    if (slots.header) {
      columnSlots.header = slots.header;
    }
    columnConfig.slots = columnSlots;
    columnConfig.children = [];
    watchColumn($xeTable, props, columnConfig);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const elem = refElem.value;
      if (elem) {
        assembleColumn($xeTable, elem, columnConfig, $xeParentColgroup);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyColumn($xeTable, columnConfig);
    });
    const renderVN = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      }, slots.default ? slots.default() : []);
    };
    const $xeColgroup = {
      columnConfig
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeColgroup', $xeColgroup);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeGrid', null);
    return renderVN;
  }
}));
;// ./packages/colgroup/index.ts


const VxeColgroup = Object.assign({}, group, {
  install(app) {
    app.component(group.name, group);
    // 兼容旧用法
    app.component('VxeTableColgroup', group);
  }
});
if (core_.VxeUI.dynamicApp) {
  core_.VxeUI.dynamicApp.component(group.name, group);
  // 兼容旧用法
  core_.VxeUI.dynamicApp.component('VxeTableColgroup', group);
}
core_.VxeUI.component(group);
const Colgroup = VxeColgroup;
/* harmony default export */ var colgroup = ((/* unused pure expression or super */ null && (VxeColgroup)));
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.iterator.filter.js
var esnext_iterator_filter = __webpack_require__(4520);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.iterator.every.js
var esnext_iterator_every = __webpack_require__(3215);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.iterator.reduce.js
var esnext_iterator_reduce = __webpack_require__(8872);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.iterator.to-array.js
var esnext_iterator_to_array = __webpack_require__(1795);
;// ./packages/table/src/body.ts











const {
  getI18n: body_getI18n,
  renderer: body_renderer,
  renderEmptyElement: body_renderEmptyElement
} = core_.VxeUI;
const renderType = 'body';
/* harmony default export */ var body = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTableBody',
  props: {
    tableData: Array,
    tableColumn: Array,
    fixedColumn: Array,
    fixedType: {
      type: String,
      default: ''
    }
  },
  setup(props) {
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', {});
    const {
      xID,
      props: tableProps,
      context: tableContext,
      reactData: tableReactData,
      internalData: tableInternalData
    } = $xeTable;
    const {
      computeEditOpts,
      computeMouseOpts,
      computeCellOffsetWidth,
      computeAreaOpts,
      computeDefaultRowHeight,
      computeEmptyOpts,
      computeTooltipOpts,
      computeRadioOpts,
      computeExpandOpts,
      computeTreeOpts,
      computeCheckboxOpts,
      computeCellOpts,
      computeValidOpts,
      computeRowOpts,
      computeColumnOpts,
      computeRowDragOpts,
      computeColumnDragOpts,
      computeResizableOpts,
      computeVirtualXOpts,
      computeVirtualYOpts
    } = $xeTable.getComputeMaps();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBodyScroll = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBodyTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBodyColgroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBodyTBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBodyXSpace = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBodyYSpace = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBodyEmptyBlock = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    // 滚动、拖动过程中不需要触发
    const isVMScrollProcess = () => {
      const {
        delayHover
      } = tableProps;
      const {
        lastScrollTime,
        isDragResize
      } = tableReactData;
      return !!(isDragResize || lastScrollTime && Date.now() < lastScrollTime + delayHover);
    };
    const renderLine = (rowid, params, cellHeight) => {
      const {
        row,
        column
      } = params;
      const {
        afterFullData
      } = tableInternalData;
      const {
        treeConfig
      } = tableProps;
      const treeOpts = computeTreeOpts.value;
      const {
        slots,
        treeNode
      } = column;
      const {
        fullAllDataRowIdData
      } = tableInternalData;
      if (slots && slots.line) {
        return $xeTable.callSlot(slots.line, params);
      }
      const rowRest = fullAllDataRowIdData[rowid];
      let rLevel = 0;
      let prevRow = null;
      if (rowRest) {
        rLevel = rowRest.level;
        prevRow = rowRest.items[rowRest.treeIndex - 1];
      }
      if (treeConfig && treeNode && (treeOpts.showLine || treeOpts.line)) {
        return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 'tl',
          class: 'vxe-tree--line-wrapper'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-tree--line',
          style: {
            height: `${$xeTable.eqRow(afterFullData[0], row) ? 1 : calcTreeLine(params, prevRow)}px`,
            bottom: `-${Math.floor(cellHeight / 2)}px`,
            left: `${rLevel * treeOpts.indent + (rLevel ? 2 - getOffsetSize($xeTable) : 0) + 16}px`
          }
        })])];
      }
      return [];
    };
    /**
     * 渲染列
     */
    const renderTdColumn = (seq, rowid, fixedType, isOptimizeMode, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, columns, items) => {
      const $xeGrid = $xeTable.xeGrid;
      const {
        columnKey,
        resizable: allResizable,
        showOverflow: allShowOverflow,
        border,
        height,
        treeConfig,
        cellClassName: allCellClassName,
        cellStyle,
        align: allAlign,
        spanMethod,
        mouseConfig,
        editConfig,
        editRules,
        tooltipConfig,
        padding: allPadding
      } = tableProps;
      const {
        tableData,
        dragRow,
        overflowX,
        currentColumn,
        scrollXLoad,
        scrollYLoad,
        mergeBodyFlag,
        calcCellHeightFlag,
        resizeHeightFlag,
        resizeWidthFlag,
        editStore,
        isAllOverflow,
        validErrorMaps
      } = tableReactData;
      const {
        fullAllDataRowIdData,
        fullColumnIdData,
        mergeBodyCellMaps,
        visibleColumn,
        afterFullData,
        mergeBodyList,
        scrollXStore,
        scrollYStore
      } = tableInternalData;
      const cellOpts = computeCellOpts.value;
      const validOpts = computeValidOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const editOpts = computeEditOpts.value;
      const tooltipOpts = computeTooltipOpts.value;
      const resizableOpts = computeResizableOpts.value;
      const virtualXOpts = computeVirtualXOpts.value;
      const virtualYOpts = computeVirtualYOpts.value;
      const {
        isAllColumnDrag,
        isAllRowDrag
      } = resizableOpts;
      const rowOpts = computeRowOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const customCellHeight = calcCellHeightFlag ? cellOpts.height || rowOpts.height : 0;
      const {
        disabledMethod: dragDisabledMethod,
        isCrossDrag,
        isPeerDrag
      } = rowDragOpts;
      const columnOpts = computeColumnOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const areaOpts = computeAreaOpts.value;
      const cellOffsetWidth = computeCellOffsetWidth.value;
      const {
        selectCellToRow
      } = areaOpts;
      const {
        type,
        cellRender,
        editRender,
        align,
        showOverflow,
        className,
        treeNode,
        rowResize,
        padding,
        verticalAlign,
        slots
      } = column;
      const {
        verticalAlign: allVerticalAlign
      } = cellOpts;
      const {
        actived
      } = editStore;
      const rowRest = fullAllDataRowIdData[rowid] || {};
      const colid = column.id;
      const colRest = fullColumnIdData[colid] || {};
      const renderOpts = editRender || cellRender;
      const compConf = renderOpts ? body_renderer.get(renderOpts.name) : null;
      const compCellClassName = compConf ? compConf.tableCellClassName || compConf.cellClassName : null;
      const compCellStyle = compConf ? compConf.tableCellStyle || compConf.cellStyle : '';
      const showAllTip = tooltipOpts.showAll;
      const columnIndex = colRest.index;
      const _columnIndex = colRest._index;
      const isEdit = isEnableConf(editRender);
      const resizeHeight = resizeHeightFlag ? rowRest.resizeHeight : 0;
      let fixedHiddenColumn = fixedType ? column.fixed !== fixedType : column.fixed && overflowX;
      const isCellPadding = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(padding) ? allPadding === null ? cellOpts.padding : allPadding : padding;
      const cellOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(showOverflow) ? allShowOverflow : showOverflow;
      const showEllipsis = cellOverflow === 'ellipsis';
      const showTitle = cellOverflow === 'title';
      const showTooltip = cellOverflow === true || cellOverflow === 'tooltip';
      const hasEllipsis = isAllOverflow || showTitle || showTooltip || showEllipsis;
      const showResizable = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable;
      const isCsHeight = !!customCellHeight;
      const isRsHeight = resizeHeight > 0;
      let isDirty;
      const tdOns = {};
      const cellAlign = align || (compConf ? compConf.tableCellAlign : '') || allAlign;
      const cellVerticalAlign = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(verticalAlign) ? allVerticalAlign : verticalAlign;
      const errorValidItem = validErrorMaps[`${rowid}:${colid}`];
      const showValidTip = editRules && validOpts.showMessage && (validOpts.message === 'default' ? height || tableData.length > 1 : validOpts.message === 'inline');
      const tdAttrs = {
        colid
      };
      const cellParams = {
        $table: $xeTable,
        $grid: $xeGrid,
        isEdit: false,
        seq,
        rowid,
        row,
        rowIndex,
        $rowIndex,
        _rowIndex,
        column,
        columnIndex,
        $columnIndex,
        _columnIndex,
        fixed: fixedType,
        type: renderType,
        isHidden: !!fixedHiddenColumn,
        level: rowLevel,
        visibleData: afterFullData,
        data: tableData,
        items
      };
      let isRowDragCell = false;
      let isDisabledDrag = false;
      if (rowOpts.drag) {
        isRowDragCell = rowDragOpts.trigger === 'row' || column.dragSort && rowDragOpts.trigger === 'cell';
      }
      if (isRowDragCell) {
        isDisabledDrag = !!(dragDisabledMethod && dragDisabledMethod(cellParams));
      }
      // hover 进入事件
      if (showTitle || showTooltip || showAllTip || tooltipConfig) {
        tdOns.onMouseenter = evnt => {
          if (isVMScrollProcess()) {
            return;
          }
          if (showTitle) {
            updateCellTitle(evnt.currentTarget, column);
          } else if (showTooltip || showAllTip) {
            // 如果配置了显示 tooltip
            $xeTable.triggerBodyTooltipEvent(evnt, cellParams);
          }
          $xeTable.dispatchEvent('cell-mouseenter', Object.assign({
            cell: evnt.currentTarget
          }, cellParams), evnt);
        };
      }
      // hover 退出事件
      if (showTooltip || showAllTip || tooltipConfig) {
        tdOns.onMouseleave = evnt => {
          if (isVMScrollProcess()) {
            return;
          }
          if (showTooltip || showAllTip) {
            $xeTable.handleTargetLeaveEvent(evnt);
          }
          $xeTable.dispatchEvent('cell-mouseleave', Object.assign({
            cell: evnt.currentTarget
          }, cellParams), evnt);
        };
      }
      // 按下事件处理
      if (isRowDragCell || checkboxOpts.range || mouseConfig) {
        tdOns.onMousedown = evnt => {
          $xeTable.triggerCellMousedownEvent(evnt, cellParams);
        };
      }
      // 拖拽列事件
      if (isRowDragCell) {
        tdOns.onMouseup = $xeTable.triggerCellMouseupEvent;
      }
      // 点击事件处理
      tdOns.onClick = evnt => {
        $xeTable.triggerCellClickEvent(evnt, cellParams);
      };
      // 双击事件处理
      tdOns.onDblclick = evnt => {
        $xeTable.triggerCellDblclickEvent(evnt, cellParams);
      };
      let isMergeCell = false;
      // 合并行或列
      if (mergeBodyFlag && mergeBodyList.length) {
        const spanRest = mergeBodyCellMaps[`${_rowIndex}:${_columnIndex}`];
        if (spanRest) {
          const {
            rowspan,
            colspan
          } = spanRest;
          if (!rowspan || !colspan) {
            return null;
          }
          if (rowspan > 1) {
            isMergeCell = true;
            tdAttrs.rowspan = rowspan;
          }
          if (colspan > 1) {
            isMergeCell = true;
            tdAttrs.colspan = colspan;
          }
        }
      } else if (spanMethod) {
        // 自定义合并行或列的方法
        const {
          rowspan = 1,
          colspan = 1
        } = spanMethod(cellParams) || {};
        if (!rowspan || !colspan) {
          return null;
        }
        if (rowspan > 1) {
          tdAttrs.rowspan = rowspan;
        }
        if (colspan > 1) {
          tdAttrs.colspan = colspan;
        }
      }
      // 如果被合并不可隐藏
      if (fixedHiddenColumn && isMergeCell) {
        if (tdAttrs.colspan > 1 || tdAttrs.rowspan > 1) {
          fixedHiddenColumn = false;
        }
      }
      // 如果编辑列开启显示状态
      if (!fixedHiddenColumn && editConfig && (editRender || cellRender) && (editOpts.showStatus || editOpts.showUpdateStatus)) {
        isDirty = $xeTable.isUpdateByRow(row, column.field);
      }
      const isVNAutoHeight = scrollYLoad && !hasEllipsis;
      const cellHeight = rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
      const isLastColumn = $columnIndex === columns.length - 1;
      const isAutoCellWidth = !column.resizeWidth && (column.minWidth === 'auto' || column.width === 'auto');
      let isVNPreEmptyStatus = false;
      if (!isMergeCell) {
        if (!dragRow || getRowid($xeTable, dragRow) !== rowid) {
          if (scrollYLoad && !treeConfig && !virtualYOpts.immediate && (_rowIndex < scrollYStore.visibleStartIndex - scrollYStore.preloadSize || _rowIndex > scrollYStore.visibleEndIndex + scrollYStore.preloadSize)) {
            isVNPreEmptyStatus = true;
          } else if (scrollXLoad && !virtualXOpts.immediate && !column.fixed && (_columnIndex < scrollXStore.visibleStartIndex - scrollXStore.preloadSize || _columnIndex > scrollXStore.visibleEndIndex + scrollXStore.preloadSize)) {
            isVNPreEmptyStatus = true;
          }
        }
      }
      const tcStyle = {};
      if (hasEllipsis && resizeWidthFlag) {
        let tsColspan = tdAttrs.colspan || 0;
        if (tsColspan > 1) {
          for (let index = 1; index < tsColspan; index++) {
            const nextColumn = visibleColumn[columnIndex + index];
            if (nextColumn) {
              tsColspan += nextColumn.renderWidth;
            }
          }
        }
        tcStyle.width = `${column.renderWidth - cellOffsetWidth * tsColspan}px`;
      }
      if (scrollYLoad || hasEllipsis || isCsHeight || isRsHeight) {
        tcStyle.height = `${cellHeight}px`;
      } else {
        tcStyle.minHeight = `${cellHeight}px`;
      }
      const tdVNs = [];
      if (fixedHiddenColumn && isAllOverflow) {
        tdVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 'tc',
          class: ['vxe-cell', {
            'c--title': showTitle,
            'c--tooltip': showTooltip,
            'c--ellipsis': showEllipsis
          }],
          style: tcStyle
        }));
      } else {
        // 渲染单元格
        tdVNs.push(...renderLine(rowid, cellParams, cellHeight), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 'tc',
          class: ['vxe-cell', {
            'c--title': showTitle,
            'c--tooltip': showTooltip,
            'c--ellipsis': showEllipsis
          }],
          style: tcStyle,
          title: showTitle ? $xeTable.getCellLabel(row, column) : null
        }, isVNPreEmptyStatus ? [] : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          colid,
          rowid,
          class: 'vxe-cell--wrapper'
        }, column.renderCell(cellParams))]));
        if (showValidTip && errorValidItem) {
          const errRule = errorValidItem.rule;
          const validSlot = slots ? slots.valid : null;
          const validParams = {
            ...cellParams,
            ...errorValidItem,
            rule: errorValidItem
          };
          tdVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: 'tcv',
            class: ['vxe-cell--valid-error-tip', getPropClass(validOpts.className, validParams)],
            style: errRule && errRule.maxWidth ? {
              width: `${errRule.maxWidth}px`
            } : null
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: `vxe-cell--valid-error-wrapper vxe-cell--valid-error-theme-${validOpts.theme || 'normal'}`
          }, [validSlot ? $xeTable.callSlot(validSlot, validParams) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-cell--valid-error-msg'
          }, errorValidItem.content)]])]));
        }
      }
      let showAreaRowStatus = false;
      if (mouseConfig && mouseOpts.area && selectCellToRow) {
        if (!_columnIndex && selectCellToRow === true || selectCellToRow === column.field) {
          showAreaRowStatus = true;
        }
      }
      if (!fixedHiddenColumn && showResizable && isAllColumnDrag) {
        tdVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 'tcc',
          class: ['vxe-cell--col-resizable', {
            'is--line': !border || border === 'none'
          }],
          onMousedown: evnt => $xeTable.handleColResizeMousedownEvent(evnt, fixedType, cellParams),
          onDblclick: evnt => $xeTable.handleColResizeDblclickEvent(evnt, cellParams)
        }));
      }
      if ((rowResize || isAllRowDrag) && rowOpts.resizable) {
        tdVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 'tcr',
          class: 'vxe-cell--row-resizable',
          onMousedown: evnt => $xeTable.handleRowResizeMousedownEvent(evnt, cellParams),
          onDblclick: evnt => $xeTable.handleRowResizeDblclickEvent(evnt, cellParams)
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
        class: ['vxe-body--column', colid, cellVerticalAlign ? `col--vertical-${cellVerticalAlign}` : '', cellAlign ? `col--${cellAlign}` : '', type ? `col--${type}` : '', {
          'col--last': isLastColumn,
          'col--tree-node': treeNode,
          'col--edit': isEdit,
          'col--ellipsis': hasEllipsis,
          'col--cs-height': isCsHeight,
          'col--rs-height': isRsHeight,
          'col--to-row': showAreaRowStatus,
          'col--auto-height': isVNAutoHeight,
          'fixed--width': !isAutoCellWidth,
          'fixed--hidden': fixedHiddenColumn,
          'is--padding': isCellPadding,
          'is--progress': fixedHiddenColumn && isAllOverflow || isVNPreEmptyStatus,
          'is--drag-cell': isRowDragCell && (isCrossDrag || isPeerDrag || !rowLevel),
          'is--drag-disabled': isDisabledDrag,
          'col--dirty': isDirty,
          'col--active': editConfig && isEdit && actived.row === row && (actived.column === column || editOpts.mode === 'row'),
          'col--valid-error': !!errorValidItem,
          'col--current': currentColumn === column
        }, getPropClass(compCellClassName, cellParams), getPropClass(className, cellParams), getPropClass(allCellClassName, cellParams)],
        key: columnKey || scrollXLoad || scrollYLoad || columnOpts.useKey || rowOpts.useKey || columnOpts.drag ? colid : $columnIndex,
        ...tdAttrs,
        style: Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(compCellStyle) ? compCellStyle(cellParams) : compCellStyle, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(cellStyle) ? cellStyle(cellParams) : cellStyle),
        ...tdOns
      }, isOptimizeMode && fixedHiddenColumn ? [] : tdVNs);
    };
    const renderRows = (fixedType, isOptimizeMode, tableData, tableColumn) => {
      const $xeGrid = $xeTable.xeGrid;
      const {
        stripe,
        rowKey,
        highlightHoverRow,
        rowClassName,
        rowStyle,
        editConfig,
        treeConfig
      } = tableProps;
      const {
        hasFixedColumn,
        treeExpandedFlag,
        isColLoading,
        scrollXLoad,
        scrollYLoad,
        isAllOverflow,
        rowExpandedFlag,
        expandColumn,
        selectRadioRow,
        pendingRowFlag,
        isDragColMove,
        rowExpandHeightFlag,
        isRowGroupStatus
      } = tableReactData;
      const {
        fullAllDataRowIdData,
        fullColumnIdData,
        treeExpandedMaps,
        pendingRowMaps,
        rowExpandedMaps
      } = tableInternalData;
      const checkboxOpts = computeCheckboxOpts.value;
      const radioOpts = computeRadioOpts.value;
      const treeOpts = computeTreeOpts.value;
      const editOpts = computeEditOpts.value;
      const rowOpts = computeRowOpts.value;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const {
        transform,
        seqMode
      } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const rows = [];
      const {
        handleGetRowId
      } = createHandleGetRowId($xeTable);
      const isDeepRow = treeConfig || isRowGroupStatus;
      tableData.forEach((row, $rowIndex) => {
        const rowid = handleGetRowId(row);
        const rowRest = fullAllDataRowIdData[rowid] || {};
        let rowIndex = $rowIndex;
        let rowLevel = 0;
        let seq = -1;
        let _rowIndex = -1;
        const hasRowGroupAggregate = isRowGroupStatus && row.isAggregate;
        const trOn = {};
        // 当前行事件
        if (rowOpts.isHover || highlightHoverRow) {
          trOn.onMouseenter = evnt => {
            if (isVMScrollProcess()) {
              return;
            }
            $xeTable.triggerHoverEvent(evnt, {
              row,
              rowIndex
            });
          };
          trOn.onMouseleave = () => {
            if (isVMScrollProcess()) {
              return;
            }
            $xeTable.clearHoverRow();
          };
        }
        if (rowRest) {
          rowLevel = rowRest.level;
          if (hasRowGroupAggregate || treeConfig && transform && seqMode === 'increasing') {
            seq = rowRest._index + 1;
          } else {
            seq = rowRest.seq;
          }
          rowIndex = rowRest.index;
          _rowIndex = rowRest._index;
        }
        const params = {
          $table: $xeTable,
          seq,
          rowid,
          fixed: fixedType,
          type: renderType,
          level: rowLevel,
          row,
          rowIndex,
          $rowIndex,
          _rowIndex
        };
        // 行是否被展开
        const isExpandRow = expandColumn && !!rowExpandedFlag && !!rowExpandedMaps[rowid];
        // 树节点是否被展开
        let isExpandTree = false;
        let rowChildren = [];
        let isNewRow = false;
        if (editConfig) {
          isNewRow = $xeTable.isInsertByRow(row);
        }
        if (treeConfig && !scrollYLoad && !transform) {
          rowChildren = row[childrenField];
          isExpandTree = !!treeExpandedFlag && rowChildren && rowChildren.length > 0 && !!treeExpandedMaps[rowid];
        }
        // 拖拽行事件
        if (rowOpts.drag && !isRowGroupStatus && (!treeConfig || transform)) {
          trOn.onDragstart = $xeTable.handleRowDragDragstartEvent;
          trOn.onDragend = $xeTable.handleRowDragDragendEvent;
          trOn.onDragover = $xeTable.handleRowDragDragoverEvent;
        }
        const trClass = ['vxe-body--row', isDeepRow ? `row--level-${rowLevel}` : '', {
          'row--stripe': stripe && (_rowIndex + 1) % 2 === 0,
          'is--new': isNewRow,
          'is--expand-row': isExpandRow,
          'is--expand-tree': isExpandTree,
          'row--new': isNewRow && (editOpts.showStatus || editOpts.showInsertStatus),
          'row--radio': radioOpts.highlight && $xeTable.eqRow(selectRadioRow, row),
          'row--checked': checkboxOpts.highlight && $xeTable.isCheckedByCheckboxRow(row),
          'row--pending': !!pendingRowFlag && !!pendingRowMaps[rowid],
          'row--group': hasRowGroupAggregate
        }, getPropClass(rowClassName, params)];
        const tdVNs = tableColumn.map((column, $columnIndex) => {
          return renderTdColumn(seq, rowid, fixedType, isOptimizeMode, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, tableColumn, tableData);
        });
        rows.push(!isColLoading && columnOpts.drag && columnDragOpts.animation ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.TransitionGroup, {
          name: `vxe-header--col-list${isDragColMove ? '' : '-disabled'}`,
          tag: 'tr',
          class: trClass,
          rowid: rowid,
          style: rowStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(rowStyle) ? rowStyle(params) : rowStyle : null,
          key: rowKey || scrollXLoad || scrollYLoad || rowOpts.useKey || rowOpts.drag || columnOpts.drag || isRowGroupStatus || treeConfig ? rowid : $rowIndex,
          ...trOn
        }, {
          default: () => tdVNs
        }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {
          class: trClass,
          rowid: rowid,
          style: rowStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(rowStyle) ? rowStyle(params) : rowStyle : null,
          key: rowKey || scrollXLoad || scrollYLoad || rowOpts.useKey || rowOpts.drag || columnOpts.drag || isRowGroupStatus || treeConfig ? rowid : $rowIndex,
          ...trOn
        }, tdVNs));
        // 如果行被展开了
        if (isExpandRow) {
          const expandOpts = computeExpandOpts.value;
          const {
            height: expandHeight,
            padding,
            mode: expandMode
          } = expandOpts;
          if (expandMode === 'fixed') {
            rows.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {
              class: 'vxe-body--row-expanded-place',
              key: `expand_${rowid}`,
              rowid
            }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
              class: 'vxe-body--row-expanded-place-column',
              colspan: tableColumn.length,
              style: {
                height: `${rowExpandHeightFlag ? rowRest.expandHeight || expandHeight : 0}px`
              }
            })]));
          } else {
            const cellStyle = {};
            if (expandHeight) {
              cellStyle.height = `${expandHeight}px`;
            }
            if (treeConfig) {
              cellStyle.paddingLeft = `${rowLevel * treeOpts.indent + 30}px`;
            }
            const {
              showOverflow
            } = expandColumn || {};
            const colid = expandColumn.id;
            const colRest = fullColumnIdData[colid] || {};
            const hasEllipsis = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(showOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(showOverflow) ? isAllOverflow : showOverflow;
            let columnIndex = -1;
            let $columnIndex = -1;
            let _columnIndex = -1;
            if (colRest) {
              columnIndex = colRest.index;
              $columnIndex = colRest.$index;
              _columnIndex = colRest._index;
            }
            const expandParams = {
              $grid: $xeGrid,
              $table: $xeTable,
              seq,
              column: expandColumn,
              columnIndex,
              $columnIndex,
              _columnIndex,
              fixed: fixedType,
              type: renderType,
              level: rowLevel,
              row,
              rowid,
              rowIndex,
              $rowIndex,
              _rowIndex,
              isHidden: false,
              isEdit: false,
              visibleData: [],
              data: [],
              items: []
            };
            rows.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {
              class: ['vxe-body--expanded-row', {
                'is--padding': padding
              }],
              key: `expand_${rowid}`
            }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
              class: ['vxe-body--expanded-column', {
                'fixed--hidden': fixedType && !hasFixedColumn,
                'col--ellipsis': hasEllipsis
              }],
              colspan: tableColumn.length
            }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
              class: ['vxe-body--expanded-cell', {
                'is--ellipsis': expandHeight
              }],
              style: cellStyle
            }, [expandColumn.renderData(expandParams)])])]));
          }
        }
        // 如果是树形表格
        if (isExpandTree) {
          rows.push(...renderRows(fixedType, isOptimizeMode, rowChildren, tableColumn));
        }
      });
      return rows;
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          fixedType
        } = props;
        const {
          elemStore
        } = tableInternalData;
        const prefix = `${fixedType || 'main'}-body-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}scroll`] = refBodyScroll;
        elemStore[`${prefix}table`] = refBodyTable;
        elemStore[`${prefix}colgroup`] = refBodyColgroup;
        elemStore[`${prefix}list`] = refBodyTBody;
        elemStore[`${prefix}xSpace`] = refBodyXSpace;
        elemStore[`${prefix}ySpace`] = refBodyYSpace;
        elemStore[`${prefix}emptyBlock`] = refBodyEmptyBlock;
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      const {
        fixedType
      } = props;
      const {
        elemStore
      } = tableInternalData;
      const prefix = `${fixedType || 'main'}-body-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}scroll`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
      elemStore[`${prefix}ySpace`] = null;
      elemStore[`${prefix}emptyBlock`] = null;
    });
    const renderVN = () => {
      const {
        slots
      } = tableContext;
      const $xeGrid = $xeTable.xeGrid;
      const {
        fixedColumn,
        fixedType,
        tableColumn
      } = props;
      const {
        spanMethod,
        footerSpanMethod,
        mouseConfig
      } = tableProps;
      const {
        isGroup,
        tableData,
        isRowLoading,
        isColLoading,
        overflowX,
        scrollXLoad,
        scrollYLoad,
        isAllOverflow,
        isDragRowMove,
        expandColumn,
        dragRow,
        dragCol
      } = tableReactData;
      const {
        visibleColumn,
        fullAllDataRowIdData,
        fullColumnIdData
      } = tableInternalData;
      const rowOpts = computeRowOpts.value;
      const emptyOpts = computeEmptyOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      const expandOpts = computeExpandOpts.value;
      let renderDataList = tableData;
      let renderColumnList = tableColumn;
      let isOptimizeMode = false;
      // 如果是使用优化模式
      if (scrollXLoad || scrollYLoad || isAllOverflow) {
        if (expandColumn && expandOpts.mode !== 'fixed' || spanMethod || footerSpanMethod) {
          // 如果不支持优化模式
        } else {
          isOptimizeMode = true;
        }
      }
      if (!isColLoading && (fixedType || !overflowX)) {
        renderColumnList = visibleColumn;
      }
      if (fixedType) {
        if (isOptimizeMode) {
          renderColumnList = fixedColumn || [];
        }
      }
      // 行拖拽
      if (scrollYLoad && dragRow) {
        if (renderDataList.length > 2) {
          const dRowRest = fullAllDataRowIdData[getRowid($xeTable, dragRow)];
          if (dRowRest) {
            const drIndex = dRowRest._index;
            const firstRow = renderDataList[0];
            const lastRow = renderDataList[renderDataList.length - 1];
            const firstRowRest = fullAllDataRowIdData[getRowid($xeTable, firstRow)];
            const lastRowRest = fullAllDataRowIdData[getRowid($xeTable, lastRow)];
            if (firstRowRest && lastRowRest) {
              const frIndex = firstRowRest._index;
              const lrIndex = lastRowRest._index;
              if (drIndex < frIndex) {
                renderDataList = [dragRow].concat(renderDataList);
              } else if (drIndex > lrIndex) {
                renderDataList = renderDataList.concat([dragRow]);
              }
            }
          }
        }
      }
      if (!fixedType && !isGroup) {
        // 列拖拽
        if (scrollXLoad && dragCol) {
          if (renderColumnList.length > 2) {
            const dCowRest = fullColumnIdData[dragCol.id];
            if (dCowRest) {
              const dcIndex = dCowRest._index;
              const firstCol = renderColumnList[0];
              const lastCol = renderColumnList[renderColumnList.length - 1];
              const firstColRest = fullColumnIdData[firstCol.id];
              const lastColRest = fullColumnIdData[lastCol.id];
              if (firstColRest && lastColRest) {
                const fcIndex = firstColRest._index;
                const lcIndex = lastColRest._index;
                if (dcIndex < fcIndex) {
                  renderColumnList = [dragCol].concat(renderColumnList);
                } else if (dcIndex > lcIndex) {
                  renderColumnList = renderColumnList.concat([dragCol]);
                }
              }
            }
          }
        }
      }
      let emptyContent;
      const emptySlot = slots ? slots.empty : null;
      if (emptySlot) {
        emptyContent = $xeTable.callSlot(emptySlot, {
          $table: $xeTable,
          $grid: $xeGrid
        });
      } else {
        const compConf = emptyOpts.name ? body_renderer.get(emptyOpts.name) : null;
        const rtEmptyView = compConf ? compConf.renderTableEmpty || compConf.renderTableEmptyView || compConf.renderEmpty : null;
        if (rtEmptyView) {
          emptyContent = getSlotVNs(rtEmptyView(emptyOpts, {
            $table: $xeTable
          }));
        } else {
          emptyContent = tableProps.emptyText || body_getI18n('vxe.table.emptyText');
        }
      }
      const ons = {
        onScroll(evnt) {
          $xeTable.triggerBodyScrollEvent(evnt, fixedType);
        }
      };
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-table--body-wrapper', fixedType ? `fixed-${fixedType}--wrapper` : 'body--wrapper'],
        xid: xID
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refBodyScroll,
        class: 'vxe-table--body-inner-wrapper',
        ...ons
      }, [fixedType ? body_renderEmptyElement($xeTable) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refBodyXSpace,
        class: 'vxe-body--x-space'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refBodyYSpace,
        class: 'vxe-body--y-space'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        ref: refBodyTable,
        class: 'vxe-table--body',
        xid: xID,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [
      /**
       * 列宽
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('colgroup', {
        ref: refBodyColgroup
      }, renderColumnList.map((column, $columnIndex) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
          name: column.id,
          key: $columnIndex,
          style: {
            width: `${column.renderWidth}px`
          }
        });
      })),
      /**
       * 内容
       */
      !(isRowLoading || isColLoading) && rowOpts.drag && rowDragOpts.animation ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.TransitionGroup, {
        ref: refBodyTBody,
        name: `vxe-body--row-list${isDragRowMove ? '' : '-disabled'}`,
        tag: 'tbody'
      }, {
        default: () => renderRows(fixedType, isOptimizeMode, renderDataList, renderColumnList)
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', {
        ref: refBodyTBody
      }, renderRows(fixedType, isOptimizeMode, renderDataList, renderColumnList))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--checkbox-range'
      }), mouseConfig && mouseOpts.area ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--cell-area'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-main-area'
      }, mouseOpts.extension ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-main-area-btn',
        onMousedown(evnt) {
          if ($xeTable.triggerCellAreaExtendMousedownEvent) {
            $xeTable.triggerCellAreaExtendMousedownEvent(evnt, {
              $table: $xeTable,
              fixed: fixedType,
              type: renderType
            });
          }
        }
      })] : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-copy-area'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-extend-area'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-multi-area'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-active-area'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-row-status-area'
      })]) : body_renderEmptyElement($xeTable), !fixedType ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--empty-block',
        ref: refBodyEmptyBlock
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--empty-content'
      }, emptyContent)]) : body_renderEmptyElement($xeTable)])]);
    };
    return renderVN;
  }
}));
;// ./packages/table/src/header.ts







const {
  renderer: header_renderer,
  renderEmptyElement: header_renderEmptyElement
} = core_.VxeUI;
const header_renderType = 'header';
/* harmony default export */ var header = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTableHeader',
  props: {
    tableData: Array,
    tableColumn: Array,
    tableGroupColumn: Array,
    fixedColumn: Array,
    fixedType: {
      type: String,
      default: null
    }
  },
  setup(props) {
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', {});
    const {
      xID,
      props: tableProps,
      reactData: tableReactData,
      internalData: tableInternalData
    } = $xeTable;
    const {
      computeColumnOpts,
      computeColumnDragOpts,
      computeCellOpts,
      computeMouseOpts,
      computeHeaderCellOpts,
      computeDefaultRowHeight,
      computeVirtualXOpts
    } = $xeTable.getComputeMaps();
    const headerColumn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderScroll = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderColgroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderTHead = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderXSpace = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderBorderRepair = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const uploadColumn = () => {
      const {
        isGroup
      } = tableReactData;
      headerColumn.value = isGroup ? convertHeaderColumnToRows(props.tableGroupColumn) : [];
    };
    const renderRows = (isGroup, isOptimizeMode, cols, $rowIndex) => {
      const $xeGrid = $xeTable.xeGrid;
      const {
        fixedType
      } = props;
      const {
        resizable: allResizable,
        columnKey,
        headerCellClassName,
        headerCellStyle,
        showHeaderOverflow: allColumnHeaderOverflow,
        headerAlign: allHeaderAlign,
        align: allAlign,
        mouseConfig
      } = tableProps;
      const {
        currentColumn,
        dragCol,
        scrollXLoad,
        scrollYLoad,
        overflowX
      } = tableReactData;
      const {
        fullColumnIdData,
        scrollXStore
      } = tableInternalData;
      const virtualXOpts = computeVirtualXOpts.value;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const cellOpts = computeCellOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const headerCellOpts = computeHeaderCellOpts.value;
      const currCellHeight = getCellHeight(headerCellOpts.height) || defaultRowHeight;
      const {
        disabledMethod: dragDisabledMethod,
        isCrossDrag,
        isPeerDrag
      } = columnDragOpts;
      return cols.map((column, $columnIndex) => {
        const {
          type,
          showHeaderOverflow,
          headerAlign,
          align,
          filters,
          headerClassName,
          editRender,
          cellRender
        } = column;
        const colid = column.id;
        const colRest = fullColumnIdData[colid] || {};
        const renderOpts = editRender || cellRender;
        const compConf = renderOpts ? header_renderer.get(renderOpts.name) : null;
        const isColGroup = column.children && column.children.length;
        const fixedHiddenColumn = fixedType ? column.fixed !== fixedType && !isColGroup : !!column.fixed && overflowX;
        const isPadding = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(headerCellOpts.padding) ? headerCellOpts.padding : cellOpts.padding;
        const headOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
        const headAlign = headerAlign || (compConf ? compConf.tableHeaderCellAlign : '') || allHeaderAlign || align || (compConf ? compConf.tableCellAlign : '') || allAlign;
        const showEllipsis = headOverflow === 'ellipsis';
        const showTitle = headOverflow === 'title';
        const showTooltip = headOverflow === true || headOverflow === 'tooltip';
        const hasEllipsis = showTitle || showTooltip || showEllipsis;
        let hasFilter = false;
        let firstFilterOption = null;
        if (filters) {
          firstFilterOption = filters[0];
          hasFilter = filters.some(item => item.checked);
        }
        const columnIndex = colRest.index;
        const _columnIndex = colRest._index;
        const cellParams = {
          $table: $xeTable,
          $grid: $xeGrid,
          $rowIndex,
          column,
          columnIndex,
          $columnIndex,
          _columnIndex,
          firstFilterOption,
          fixed: fixedType,
          type: header_renderType,
          isHidden: fixedHiddenColumn,
          hasFilter
        };
        const thAttrs = {
          colid,
          colspan: column.colSpan > 1 ? column.colSpan : null,
          rowspan: column.rowSpan > 1 ? column.rowSpan : null
        };
        const thOns = {
          onClick: evnt => $xeTable.triggerHeaderCellClickEvent(evnt, cellParams),
          onDblclick: evnt => $xeTable.triggerHeaderCellDblclickEvent(evnt, cellParams)
        };
        const isColDragCell = columnOpts.drag && columnDragOpts.trigger === 'cell';
        let isDisabledDrag = false;
        if (isColDragCell) {
          isDisabledDrag = !!(dragDisabledMethod && dragDisabledMethod(cellParams));
        }
        // 按下事件处理
        if (mouseConfig || isColDragCell) {
          thOns.onMousedown = evnt => $xeTable.triggerHeaderCellMousedownEvent(evnt, cellParams);
        }
        // 拖拽列事件
        if (columnOpts.drag) {
          thOns.onDragstart = $xeTable.handleHeaderCellDragDragstartEvent;
          thOns.onDragend = $xeTable.handleHeaderCellDragDragendEvent;
          thOns.onDragover = $xeTable.handleHeaderCellDragDragoverEvent;
          if (isColDragCell) {
            thOns.onMouseup = $xeTable.handleHeaderCellDragMouseupEvent;
          }
        }
        const isLastColumn = $columnIndex === cols.length - 1;
        const showResizable = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable;
        const isAutoCellWidth = !column.resizeWidth && (column.minWidth === 'auto' || column.width === 'auto');
        let isVNPreEmptyStatus = false;
        if (isOptimizeMode && !isGroup) {
          if (!dragCol || dragCol.id !== colid) {
            if (scrollXLoad && !column.fixed && !virtualXOpts.immediate && (_columnIndex < scrollXStore.visibleStartIndex - scrollXStore.preloadSize || _columnIndex > scrollXStore.visibleEndIndex + scrollXStore.preloadSize)) {
              isVNPreEmptyStatus = true;
            }
          }
        }
        const tcStyle = {};
        if (hasEllipsis) {
          tcStyle.height = `${currCellHeight}px`;
        } else {
          tcStyle.minHeight = `${currCellHeight}px`;
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', {
          class: ['vxe-header--column', colid, {
            [`col--${headAlign}`]: headAlign,
            [`col--${type}`]: type,
            'col--last': isLastColumn,
            'col--fixed': column.fixed,
            'col--group': isColGroup,
            'col--ellipsis': hasEllipsis,
            'fixed--width': !isAutoCellWidth,
            'fixed--hidden': fixedHiddenColumn,
            'is--padding': isPadding,
            'is--sortable': column.sortable,
            'col--filter': !!filters,
            'is--filter-active': hasFilter,
            'is--drag-active': columnOpts.drag && !column.fixed && !isDisabledDrag && (isCrossDrag || isPeerDrag || !column.parentId),
            'is--drag-disabled': columnOpts.drag && isDisabledDrag,
            'col--current': currentColumn === column
          }, headerClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerClassName) ? headerClassName(cellParams) : headerClassName : '', headerCellClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerCellClassName) ? headerCellClassName(cellParams) : headerCellClassName : ''],
          style: headerCellStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerCellStyle) ? headerCellStyle(cellParams) : headerCellStyle : null,
          ...thAttrs,
          ...thOns,
          key: columnKey || scrollXLoad || scrollYLoad || columnOpts.useKey || columnOpts.drag || isColGroup ? colid : $columnIndex
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-cell', {
            'c--title': showTitle,
            'c--tooltip': showTooltip,
            'c--ellipsis': showEllipsis
          }],
          style: tcStyle
        }, isVNPreEmptyStatus || isOptimizeMode && fixedHiddenColumn ? [] : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          colid,
          class: 'vxe-cell--wrapper'
        }, column.renderHeader(cellParams))]),
        /**
         * 列宽拖动
         */
        !fixedHiddenColumn && showResizable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-cell--col-resizable',
          onMousedown: evnt => $xeTable.handleColResizeMousedownEvent(evnt, fixedType, cellParams),
          onDblclick: evnt => $xeTable.handleColResizeDblclickEvent(evnt, cellParams)
        }) : header_renderEmptyElement($xeTable)]);
      });
    };
    const renderHeads = (isGroup, isOptimizeMode, headerGroups) => {
      const {
        fixedType
      } = props;
      const {
        headerRowClassName,
        headerRowStyle
      } = tableProps;
      const {
        isColLoading,
        isDragColMove
      } = tableReactData;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      return headerGroups.map((cols, $rowIndex) => {
        const params = {
          $table: $xeTable,
          $rowIndex,
          fixed: fixedType,
          type: header_renderType
        };
        if (!isColLoading && columnOpts.drag && columnDragOpts.animation) {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.TransitionGroup, {
            key: $rowIndex,
            name: `vxe-header--col-list${isDragColMove ? '' : '-disabled'}`,
            tag: 'tr',
            class: ['vxe-header--row', headerRowClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerRowClassName) ? headerRowClassName(params) : headerRowClassName : ''],
            style: headerRowStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerRowStyle) ? headerRowStyle(params) : headerRowStyle : null
          }, {
            default: () => renderRows(isGroup, isOptimizeMode, cols, $rowIndex)
          });
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {
          key: $rowIndex,
          class: ['vxe-header--row', headerRowClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerRowClassName) ? headerRowClassName(params) : headerRowClassName : ''],
          style: headerRowStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerRowStyle) ? headerRowStyle(params) : headerRowStyle : null
        }, renderRows(isGroup, isOptimizeMode, cols, $rowIndex));
      });
    };
    const renderVN = () => {
      const {
        fixedType,
        fixedColumn,
        tableColumn
      } = props;
      const {
        mouseConfig,
        showHeaderOverflow: allColumnHeaderOverflow,
        spanMethod,
        footerSpanMethod
      } = tableProps;
      const {
        isGroup,
        isColLoading,
        overflowX,
        scrollXLoad,
        dragCol
      } = tableReactData;
      const {
        visibleColumn,
        fullColumnIdData
      } = tableInternalData;
      const mouseOpts = computeMouseOpts.value;
      let renderHeaderList = headerColumn.value;
      let renderColumnList = tableColumn;
      let isOptimizeMode = false;
      if (isGroup) {
        renderColumnList = visibleColumn;
      } else {
        // 如果是使用优化模式
        if (scrollXLoad && allColumnHeaderOverflow) {
          if (spanMethod || footerSpanMethod) {
            // 如果不支持优化模式
          } else {
            isOptimizeMode = true;
          }
        }
        if (!isOptimizeMode || !isColLoading && (fixedType || !overflowX)) {
          renderColumnList = visibleColumn;
        }
        if (fixedType) {
          // 如果是使用优化模式
          if (isOptimizeMode) {
            renderColumnList = fixedColumn || [];
          }
        }
        renderHeaderList = [renderColumnList];
      }
      if (!fixedType && !isGroup) {
        // 列拖拽
        if (scrollXLoad && dragCol) {
          if (renderColumnList.length > 2) {
            const dCowRest = fullColumnIdData[dragCol.id];
            if (dCowRest) {
              const dcIndex = dCowRest._index;
              const firstCol = renderColumnList[0];
              const lastCol = renderColumnList[renderColumnList.length - 1];
              const firstColRest = fullColumnIdData[firstCol.id];
              const lastColRest = fullColumnIdData[lastCol.id];
              if (firstColRest && lastColRest) {
                const fcIndex = firstColRest._index;
                const lcIndex = lastColRest._index;
                if (dcIndex < fcIndex) {
                  renderColumnList = [dragCol].concat(renderColumnList);
                  renderHeaderList = [[dragCol].concat(renderHeaderList[0])].concat(renderHeaderList.slice(1));
                } else if (dcIndex > lcIndex) {
                  renderColumnList = renderColumnList.concat([dragCol]);
                  renderHeaderList = [renderHeaderList[0].concat([dragCol])].concat(renderHeaderList.slice(1));
                }
              }
            }
          }
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-table--header-wrapper', fixedType ? `fixed-${fixedType}--wrapper` : 'body--wrapper'],
        xid: xID
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refHeaderScroll,
        class: 'vxe-table--header-inner-wrapper',
        onScroll(evnt) {
          $xeTable.triggerHeaderScrollEvent(evnt, fixedType);
        }
      }, [fixedType ? header_renderEmptyElement($xeTable) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refHeaderXSpace,
        class: 'vxe-body--x-space'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        ref: refHeaderTable,
        class: 'vxe-table--header',
        xid: xID,
        cellspacing: 0,
        cellpadding: 0,
        border: 0,
        xvm: isOptimizeMode ? '1' : null
      }, [
      /**
       * 列宽
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('colgroup', {
        ref: refHeaderColgroup
      }, renderColumnList.map((column, $columnIndex) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
          name: column.id,
          key: $columnIndex,
          style: {
            width: `${column.renderWidth}px`
          }
        });
      })),
      /**
      * 头部
      */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('thead', {
        ref: refHeaderTHead
      }, renderHeads(isGroup, isOptimizeMode, renderHeaderList))]), mouseConfig && mouseOpts.area ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--cell-area'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-main-area'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-copy-area'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-extend-area'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-multi-area'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-active-area'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-col-status-area'
      })]) : header_renderEmptyElement($xeTable)])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.tableColumn, uploadColumn);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          fixedType
        } = props;
        const {
          internalData
        } = $xeTable;
        const {
          elemStore
        } = internalData;
        const prefix = `${fixedType || 'main'}-header-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}scroll`] = refHeaderScroll;
        elemStore[`${prefix}table`] = refHeaderTable;
        elemStore[`${prefix}colgroup`] = refHeaderColgroup;
        elemStore[`${prefix}list`] = refHeaderTHead;
        elemStore[`${prefix}xSpace`] = refHeaderXSpace;
        elemStore[`${prefix}repair`] = refHeaderBorderRepair;
        uploadColumn();
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      const {
        fixedType
      } = props;
      const {
        internalData
      } = $xeTable;
      const {
        elemStore
      } = internalData;
      const prefix = `${fixedType || 'main'}-header-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}scroll`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
      elemStore[`${prefix}repair`] = null;
    });
    return renderVN;
  }
}));
;// ./packages/table/src/footer.ts






const {
  renderer: footer_renderer,
  renderEmptyElement: footer_renderEmptyElement
} = core_.VxeUI;
const footer_renderType = 'footer';
/* harmony default export */ var footer = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTableFooter',
  props: {
    footerTableData: {
      type: Array,
      default: () => []
    },
    tableColumn: {
      type: Array,
      default: () => []
    },
    fixedColumn: {
      type: Array,
      default: () => []
    },
    fixedType: {
      type: String,
      default: null
    }
  },
  setup(props) {
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', {});
    const {
      xID,
      props: tableProps,
      reactData: tableReactData,
      internalData: tableInternalData
    } = $xeTable;
    const {
      computeTooltipOpts,
      computeColumnOpts,
      computeColumnDragOpts,
      computeCellOpts,
      computeFooterCellOpts,
      computeDefaultRowHeight,
      computeResizableOpts,
      computeVirtualXOpts
    } = $xeTable.getComputeMaps();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refFooterScroll = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refFooterTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refFooterColgroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refFooterTFoot = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refFooterXSpace = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const renderRows = (isOptimizeMode, tableColumn, footerTableData, row, $rowIndex, _rowIndex) => {
      const $xeGrid = $xeTable.xeGrid;
      const {
        fixedType
      } = props;
      const {
        resizable: allResizable,
        border,
        footerCellClassName,
        footerCellStyle,
        footerAlign: allFooterAlign,
        footerSpanMethod,
        align: allAlign,
        columnKey,
        showFooterOverflow: allColumnFooterOverflow
      } = tableProps;
      const {
        scrollXLoad,
        scrollYLoad,
        overflowX,
        currentColumn
      } = tableReactData;
      const {
        fullColumnIdData,
        mergeFooterList,
        mergeFooterCellMaps,
        scrollXStore
      } = tableInternalData;
      const virtualXOpts = computeVirtualXOpts.value;
      const tooltipOpts = computeTooltipOpts.value;
      const resizableOpts = computeResizableOpts.value;
      const {
        isAllColumnDrag
      } = resizableOpts;
      const columnOpts = computeColumnOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const cellOpts = computeCellOpts.value;
      const footerCellOpts = computeFooterCellOpts.value;
      const currCellHeight = getCellHeight(footerCellOpts.height) || defaultRowHeight;
      return tableColumn.map((column, $columnIndex) => {
        const {
          type,
          showFooterOverflow,
          footerAlign,
          align,
          footerClassName,
          editRender,
          cellRender
        } = column;
        const colid = column.id;
        const colRest = fullColumnIdData[colid] || {};
        const renderOpts = editRender || cellRender;
        const compConf = renderOpts ? footer_renderer.get(renderOpts.name) : null;
        const showAllTip = tooltipOpts.showAll;
        const isColGroup = column.children && column.children.length;
        const fixedHiddenColumn = fixedType ? column.fixed !== fixedType && !isColGroup : column.fixed && overflowX;
        const isPadding = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(footerCellOpts.padding) ? footerCellOpts.padding : cellOpts.padding;
        const footOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;
        const footAlign = footerAlign || (compConf ? compConf.tableFooterCellAlign : '') || allFooterAlign || align || (compConf ? compConf.tableCellAlign : '') || allAlign;
        const showEllipsis = footOverflow === 'ellipsis';
        const showTitle = footOverflow === 'title';
        const showTooltip = footOverflow === true || footOverflow === 'tooltip';
        const hasEllipsis = showTitle || showTooltip || showEllipsis;
        const showResizable = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable;
        const attrs = {
          colid
        };
        const tfOns = {};
        const columnIndex = colRest.index;
        const _columnIndex = colRest._index;
        const itemIndex = _columnIndex;
        const cellParams = {
          $table: $xeTable,
          $grid: $xeGrid,
          row,
          rowIndex: _rowIndex,
          _rowIndex,
          $rowIndex,
          column,
          columnIndex,
          $columnIndex,
          _columnIndex,
          itemIndex,
          items: row,
          fixed: fixedType,
          type: footer_renderType,
          data: footerTableData
        };
        if (showTitle || showTooltip || showAllTip) {
          tfOns.onMouseenter = evnt => {
            if (showTitle) {
              updateCellTitle(evnt.currentTarget, column);
            } else if (showTooltip || showAllTip) {
              $xeTable.triggerFooterTooltipEvent(evnt, cellParams);
            }
          };
        }
        if (showTooltip || showAllTip) {
          tfOns.onMouseleave = evnt => {
            if (showTooltip || showAllTip) {
              $xeTable.handleTargetLeaveEvent(evnt);
            }
          };
        }
        tfOns.onClick = evnt => {
          $xeTable.dispatchEvent('footer-cell-click', Object.assign({
            cell: evnt.currentTarget
          }, cellParams), evnt);
        };
        tfOns.onDblclick = evnt => {
          $xeTable.dispatchEvent('footer-cell-dblclick', Object.assign({
            cell: evnt.currentTarget
          }, cellParams), evnt);
        };
        let isMergeCell = false;
        // 合并行或列
        if (mergeFooterList.length) {
          const spanRest = mergeFooterCellMaps[`${_rowIndex}:${_columnIndex}`];
          if (spanRest) {
            const {
              rowspan,
              colspan
            } = spanRest;
            if (!rowspan || !colspan) {
              return null;
            }
            if (rowspan > 1) {
              isMergeCell = true;
              attrs.rowspan = rowspan;
            }
            if (colspan > 1) {
              isMergeCell = true;
              attrs.colspan = colspan;
            }
          }
        } else if (footerSpanMethod) {
          // 自定义合并方法
          const {
            rowspan = 1,
            colspan = 1
          } = footerSpanMethod(cellParams) || {};
          if (!rowspan || !colspan) {
            return null;
          }
          if (rowspan > 1) {
            attrs.rowspan = rowspan;
          }
          if (colspan > 1) {
            attrs.colspan = colspan;
          }
        }
        const isLastColumn = $columnIndex === tableColumn.length - 1;
        const isAutoCellWidth = !column.resizeWidth && (column.minWidth === 'auto' || column.width === 'auto');
        let isVNPreEmptyStatus = false;
        if (isOptimizeMode && !isMergeCell) {
          if (scrollXLoad && !column.fixed && !virtualXOpts.immediate && (_columnIndex < scrollXStore.visibleStartIndex - scrollXStore.preloadSize || _columnIndex > scrollXStore.visibleEndIndex + scrollXStore.preloadSize)) {
            isVNPreEmptyStatus = true;
          }
        }
        const tcStyle = {};
        if (hasEllipsis) {
          tcStyle.height = `${currCellHeight}px`;
        } else {
          tcStyle.minHeight = `${currCellHeight}px`;
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
          class: ['vxe-footer--column', column.id, {
            [`col--${footAlign}`]: footAlign,
            [`col--${type}`]: type,
            'col--last': isLastColumn,
            'fixed--width': !isAutoCellWidth,
            'fixed--hidden': fixedHiddenColumn,
            'is--padding': isPadding,
            'col--ellipsis': hasEllipsis,
            'col--current': currentColumn === column
          }, getPropClass(footerClassName, cellParams), getPropClass(footerCellClassName, cellParams)],
          ...attrs,
          style: footerCellStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerCellStyle) ? footerCellStyle(cellParams) : footerCellStyle : null,
          ...tfOns,
          key: columnKey || scrollXLoad || scrollYLoad || columnOpts.useKey || columnOpts.drag ? column.id : $columnIndex
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-cell', {
            'c--title': showTitle,
            'c--tooltip': showTooltip,
            'c--ellipsis': showEllipsis
          }],
          style: tcStyle
        }, isVNPreEmptyStatus ? [] : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          colid,
          class: 'vxe-cell--wrapper'
        }, column.renderFooter(cellParams))]),
        /**
         * 列宽拖动
         */
        !fixedHiddenColumn && showResizable && isAllColumnDrag ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-cell--col-resizable', {
            'is--line': !border || border === 'none'
          }],
          onMousedown: evnt => $xeTable.handleColResizeMousedownEvent(evnt, fixedType, cellParams),
          onDblclick: evnt => $xeTable.handleColResizeDblclickEvent(evnt, cellParams)
        }) : footer_renderEmptyElement($xeTable)]);
      });
    };
    const renderHeads = (isOptimizeMode, renderColumnList) => {
      const {
        fixedType,
        footerTableData
      } = props;
      const {
        footerRowClassName,
        footerRowStyle
      } = tableProps;
      const {
        isColLoading,
        isDragColMove
      } = tableReactData;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      return footerTableData.map((row, $rowIndex) => {
        const _rowIndex = $rowIndex;
        const rowParams = {
          $table: $xeTable,
          row,
          _rowIndex,
          $rowIndex,
          fixed: fixedType,
          type: footer_renderType
        };
        if (!isColLoading && columnOpts.drag && columnDragOpts.animation) {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.TransitionGroup, {
            key: $rowIndex,
            name: `vxe-header--col-list${isDragColMove ? '' : '-disabled'}`,
            tag: 'tr',
            class: ['vxe-footer--row', footerRowClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerRowClassName) ? footerRowClassName(rowParams) : footerRowClassName : ''],
            style: footerRowStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerRowStyle) ? footerRowStyle(rowParams) : footerRowStyle : null
          }, {
            default: () => renderRows(isOptimizeMode, renderColumnList, footerTableData, row, $rowIndex, _rowIndex)
          });
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {
          key: $rowIndex,
          class: ['vxe-footer--row', footerRowClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerRowClassName) ? footerRowClassName(rowParams) : footerRowClassName : ''],
          style: footerRowStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerRowStyle) ? footerRowStyle(rowParams) : footerRowStyle : null
        }, renderRows(isOptimizeMode, renderColumnList, footerTableData, row, $rowIndex, _rowIndex));
      });
    };
    const renderVN = () => {
      const {
        fixedType,
        fixedColumn,
        tableColumn
      } = props;
      const {
        spanMethod,
        footerSpanMethod,
        showFooterOverflow: allColumnFooterOverflow
      } = tableProps;
      const {
        visibleColumn,
        fullColumnIdData
      } = tableInternalData;
      const {
        isGroup,
        isColLoading,
        overflowX,
        scrollXLoad,
        dragCol
      } = tableReactData;
      let renderColumnList = tableColumn;
      let isOptimizeMode = false;
      // 如果是使用优化模式
      if (scrollXLoad && allColumnFooterOverflow) {
        if (spanMethod || footerSpanMethod) {
          // 如果不支持优化模式
        } else {
          isOptimizeMode = true;
        }
      }
      if (!isOptimizeMode || !isColLoading && (fixedType || !overflowX)) {
        renderColumnList = visibleColumn;
      }
      if (fixedType) {
        if (isOptimizeMode) {
          renderColumnList = fixedColumn || [];
        }
      }
      if (!fixedType && !isGroup) {
        // 列拖拽
        if (scrollXLoad && dragCol) {
          if (renderColumnList.length > 2) {
            const dCowRest = fullColumnIdData[dragCol.id];
            if (dCowRest) {
              const dcIndex = dCowRest._index;
              const firstCol = renderColumnList[0];
              const lastCol = renderColumnList[renderColumnList.length - 1];
              const firstColRest = fullColumnIdData[firstCol.id];
              const lastColRest = fullColumnIdData[lastCol.id];
              if (firstColRest && lastColRest) {
                const fcIndex = firstColRest._index;
                const lcIndex = lastColRest._index;
                if (dcIndex < fcIndex) {
                  renderColumnList = [dragCol].concat(renderColumnList);
                } else if (dcIndex > lcIndex) {
                  renderColumnList = renderColumnList.concat([dragCol]);
                }
              }
            }
          }
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-table--footer-wrapper', fixedType ? `fixed-${fixedType}--wrapper` : 'body--wrapper'],
        xid: xID
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refFooterScroll,
        class: 'vxe-table--footer-inner-wrapper',
        onScroll(evnt) {
          $xeTable.triggerFooterScrollEvent(evnt, fixedType);
        }
      }, [fixedType ? footer_renderEmptyElement($xeTable) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refFooterXSpace,
        class: 'vxe-body--x-space'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        ref: refFooterTable,
        class: 'vxe-table--footer',
        xid: xID,
        cellspacing: 0,
        cellpadding: 0,
        border: 0,
        xvm: isOptimizeMode ? '1' : null
      }, [
      /**
      * 列宽
      */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('colgroup', {
        ref: refFooterColgroup
      }, renderColumnList.map((column, $columnIndex) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
          name: column.id,
          key: $columnIndex,
          style: {
            width: `${column.renderWidth}px`
          }
        });
      })),
      /**
      * 底部
      */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tfoot', {
        ref: refFooterTFoot
      }, renderHeads(isOptimizeMode, renderColumnList))])])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          fixedType
        } = props;
        const {
          elemStore
        } = tableInternalData;
        const prefix = `${fixedType || 'main'}-footer-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}scroll`] = refFooterScroll;
        elemStore[`${prefix}table`] = refFooterTable;
        elemStore[`${prefix}colgroup`] = refFooterColgroup;
        elemStore[`${prefix}list`] = refFooterTFoot;
        elemStore[`${prefix}xSpace`] = refFooterXSpace;
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      const {
        fixedType
      } = props;
      const {
        elemStore
      } = tableInternalData;
      const prefix = `${fixedType || 'main'}-footer-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}scroll`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
    });
    return renderVN;
  }
}));
;// ./packages/table/src/props.ts

const {
  getConfig: props_getConfig
} = core_.VxeUI;
/* harmony default export */ var src_props = ({
  /** 基本属性 */
  id: [String, Function],
  // 数据
  data: Array,
  // 表格的高度
  height: [Number, String],
  // 表格的最小高度
  minHeight: {
    type: [Number, String],
    default: () => props_getConfig().table.minHeight
  },
  // 表格的最大高度
  maxHeight: [Number, String],
  // 已废弃，被 column-config.resizable 替换
  resizable: {
    type: Boolean,
    default: () => props_getConfig().table.resizable
  },
  // 是否带有斑马纹
  stripe: {
    type: Boolean,
    default: () => props_getConfig().table.stripe
  },
  // 是否带有边框
  border: {
    type: [Boolean, String],
    default: () => props_getConfig().table.border
  },
  // 已废弃，被 cell-config.padding 替换
  padding: {
    type: Boolean,
    default: null
  },
  // 是否圆角边框
  round: {
    type: Boolean,
    default: () => props_getConfig().table.round
  },
  // 表格的尺寸
  size: {
    type: String,
    default: () => props_getConfig().table.size || props_getConfig().size
  },
  // 列的宽度是否自撑开（可能会被废弃的参数，不要使用）
  fit: {
    type: Boolean,
    default: () => props_getConfig().table.fit
  },
  // 表格是否加载中
  loading: Boolean,
  // 所有的列对其方式
  align: {
    type: String,
    default: () => props_getConfig().table.align
  },
  // 所有的表头列的对齐方式
  headerAlign: {
    type: String,
    default: () => props_getConfig().table.headerAlign
  },
  // 所有的表尾列的对齐方式
  footerAlign: {
    type: String,
    default: () => props_getConfig().table.footerAlign
  },
  // 是否显示表头
  showHeader: {
    type: Boolean,
    default: () => props_getConfig().table.showHeader
  },
  // （即将废弃）是否要高亮当前选中行
  highlightCurrentRow: {
    type: Boolean,
    default: () => props_getConfig().table.highlightCurrentRow
  },
  // （即将废弃）鼠标移到行是否要高亮显示
  highlightHoverRow: {
    type: Boolean,
    default: () => props_getConfig().table.highlightHoverRow
  },
  /**
   * （即将废弃）是否要高亮当前选中列
   * @deprecated
   */
  highlightCurrentColumn: {
    type: Boolean,
    default: () => props_getConfig().table.highlightCurrentColumn
  },
  /**
   * （即将废弃）鼠标移到列是否要高亮显示
   * @deprecated
   */
  highlightHoverColumn: {
    type: Boolean,
    default: () => props_getConfig().table.highlightHoverColumn
  },
  // （即将废弃）激活单元格编辑时是否高亮显示
  highlightCell: Boolean,
  // 是否显示表尾合计
  showFooter: Boolean,
  // 表尾数据
  footerData: Array,
  // 表尾合计的计算方法
  footerMethod: Function,
  // 给行附加 className
  rowClassName: [String, Function],
  // 给单元格附加 className
  cellClassName: [String, Function],
  // 给表头的行附加 className
  headerRowClassName: [String, Function],
  // 给表头的单元格附加 className
  headerCellClassName: [String, Function],
  // 给表尾的行附加 className
  footerRowClassName: [String, Function],
  // 给表尾的单元格附加 className
  footerCellClassName: [String, Function],
  // 给单元格附加样式
  cellStyle: [Object, Function],
  // 给表头单元格附加样式
  headerCellStyle: [Object, Function],
  // 给表尾单元格附加样式
  footerCellStyle: [Object, Function],
  // 给行附加样式
  rowStyle: [Object, Function],
  // 给表头行附加样式
  headerRowStyle: [Object, Function],
  // 给表尾行附加样式
  footerRowStyle: [Object, Function],
  // 合并指定单元格
  mergeCells: Array,
  // 合并指定的表尾
  mergeFooterItems: Array,
  // 自定义合并行或列的方法
  spanMethod: Function,
  // 表尾合并行或列
  footerSpanMethod: Function,
  // 设置所有内容过长时显示为省略号
  showOverflow: {
    type: [Boolean, String],
    default: () => props_getConfig().table.showOverflow
  },
  // 设置表头所有内容过长时显示为省略号
  showHeaderOverflow: {
    type: [Boolean, String],
    default: () => props_getConfig().table.showHeaderOverflow
  },
  // 设置表尾所有内容过长时显示为省略号
  showFooterOverflow: {
    type: [Boolean, String],
    default: () => props_getConfig().table.showFooterOverflow
  },
  /** 高级属性 */
  // （即将废弃）columnKey 已废弃，被 column-config.useKey 替换
  columnKey: Boolean,
  // （即将废弃）rowKey 已废弃，被 row-config.useKey 替换
  rowKey: Boolean,
  // （即将废弃）rowId 已废弃，被 row-config.keyField 替换
  rowId: {
    type: String,
    default: () => props_getConfig().table.rowId
  },
  zIndex: Number,
  emptyText: {
    type: String,
    default: () => props_getConfig().table.emptyText
  },
  keepSource: {
    type: Boolean,
    default: () => props_getConfig().table.keepSource
  },
  // 是否自动监听父容器变化去更新响应式表格宽高
  autoResize: {
    type: Boolean,
    default: () => props_getConfig().table.autoResize
  },
  // 是否自动根据状态属性去更新响应式表格宽高
  syncResize: [Boolean, String, Number],
  // 响应式布局配置项
  resizeConfig: Object,
  // 列配置项
  columnConfig: Object,
  // 当前列配置项
  currentColumnConfig: Object,
  // 单元格配置项
  cellConfig: Object,
  // 表头单元格配置项
  headerCellConfig: Object,
  // 表尾单元格配置项
  footerCellConfig: Object,
  // 行配置项
  rowConfig: Object,
  // 行分组配置项
  rowGroupConfig: Object,
  // 当前行配置项
  currentRowConfig: Object,
  // 已废弃，被 rowDragConfig 替换
  dragConfig: Object,
  // 行拖拽排序配置项
  rowDragConfig: Object,
  // 列拖拽排序配置项
  columnDragConfig: Object,
  // 列调整配置项
  resizableConfig: Object,
  // 序号配置项
  seqConfig: Object,
  // 排序配置项
  sortConfig: Object,
  // 筛选配置项
  filterConfig: Object,
  // 单选框配置
  radioConfig: Object,
  // 复选框配置项
  checkboxConfig: Object,
  // tooltip 配置项
  tooltipConfig: Object,
  // 导出配置项
  exportConfig: Object,
  // 导入配置项
  importConfig: Object,
  // 打印配置项
  printConfig: Object,
  // 展开行配置项
  expandConfig: Object,
  // 树形结构配置项
  treeConfig: Object,
  // 快捷菜单配置项
  menuConfig: Object,
  // 鼠标配置项
  mouseConfig: Object,
  // 区域配置项
  areaConfig: Object,
  // 按键配置项
  keyboardConfig: Object,
  // 复制粘/贴配置项
  clipConfig: Object,
  // 查找/替换配置项
  fnrConfig: Object,
  // 编辑配置项
  editConfig: Object,
  // 校验配置项
  validConfig: Object,
  // 校验规则配置项
  editRules: Object,
  // 加载中配置项
  loadingConfig: Object,
  // 空内容渲染配置项
  emptyRender: Object,
  // 自定义列配置项
  customConfig: Object,
  // （即将废弃）横向虚拟滚动配置项
  scrollX: Object,
  // （即将废弃）纵向虚拟滚动配置项
  scrollY: Object,
  // 横向虚拟滚动配置项
  virtualXConfig: Object,
  // 纵向虚拟滚动配置项
  virtualYConfig: Object,
  // 滚动条配置项
  scrollbarConfig: Object,
  // （即将废弃）优化相关
  animat: {
    type: Boolean,
    default: () => props_getConfig().table.animat
  },
  // （可能会被废弃的参数，不要使用）
  delayHover: {
    type: Number,
    default: () => props_getConfig().table.delayHover
  },
  // 额外的参数
  params: Object
});
;// ./packages/table/src/emits.ts
/* harmony default export */ var emits = (['update:data', 'keydown-start', 'keydown', 'keydown-end', 'paste', 'copy', 'cut', 'current-change', 'current-row-change', 'current-row-disabled', 'current-column-change', 'current-column-disabled', 'radio-change', 'checkbox-change', 'checkbox-all', 'checkbox-range-start', 'checkbox-range-change', 'checkbox-range-end', 'checkbox-range-select', 'cell-click', 'cell-dblclick', 'cell-menu', 'cell-mouseenter', 'cell-mouseleave', 'cell-selected', 'cell-delete-value', 'cell-backspace-value', 'header-cell-click', 'header-cell-dblclick', 'header-cell-menu', 'footer-cell-click', 'footer-cell-dblclick', 'footer-cell-menu', 'clear-merge', 'sort-change', 'clear-sort', 'filter-change', 'filter-visible', 'clear-filter', 'resizable-change', 'column-resizable-change', 'row-resizable-change', 'toggle-row-group-expand', 'toggle-row-expand', 'toggle-tree-expand', 'menu-click', 'edit-closed', 'row-dragstart', 'row-dragover', 'row-dragend', 'column-dragstart', 'column-dragover', 'column-dragend', 'enter-append-row', 'edit-actived', 'edit-activated', 'edit-disabled', 'valid-error', 'scroll', 'scroll-boundary', 'custom', 'change-fnr', 'open-fnr', 'show-fnr', 'hide-fnr', 'fnr-change', 'fnr-find', 'fnr-find-all', 'fnr-replace', 'fnr-replace-all', 'cell-area-copy', 'cell-area-cut', 'cell-area-paste', 'cell-area-merge', 'clear-cell-area-selection', 'clear-cell-area-merge', 'header-cell-area-selection', 'cell-area-selection-invalid', 'cell-area-selection-start', 'cell-area-selection-drag', 'cell-area-selection-end', 'cell-area-extension-start', 'cell-area-extension-drag', 'cell-area-extension-end', 'cell-area-selection-all-start', 'cell-area-selection-all-end', 'cell-area-arrows-start', 'cell-area-arrows-end', 'active-cell-change-start', 'active-cell-change-end']);
;// ./packages/table/module/custom/panel.ts











const {
  getI18n: panel_getI18n,
  getIcon: panel_getIcon,
  renderEmptyElement: panel_renderEmptyElement
} = core_.VxeUI;
/* harmony default export */ var panel = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'TableCustomPanel',
  props: {
    customStore: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props) {
    const VxeUIModalComponent = core_.VxeUI.getComponent('VxeModal');
    const VxeUIDrawerComponent = core_.VxeUI.getComponent('VxeDrawer');
    const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
    const VxeUINumberInputComponent = core_.VxeUI.getComponent('VxeNumberInput');
    const VxeUIRadioGroupComponent = core_.VxeUI.getComponent('VxeRadioGroup');
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', {});
    const {
      props: tableProps,
      reactData,
      internalData
    } = $xeTable;
    const {
      computeCustomOpts,
      computeColumnDragOpts,
      computeColumnOpts,
      computeIsMaxFixedColumn,
      computeResizableOpts
    } = $xeTable.getComputeMaps();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const bodyElemRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refDragLineElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refDragTipElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const dragColumnRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    let prevDragCol;
    let prevDragToChild = false;
    let prevDragPos;
    const handleWrapperMouseenterEvent = evnt => {
      const {
        customStore
      } = props;
      customStore.activeWrapper = true;
      $xeTable.customOpenEvent(evnt);
    };
    const handleWrapperMouseleaveEvent = evnt => {
      const {
        customStore
      } = props;
      customStore.activeWrapper = false;
      setTimeout(() => {
        if (!customStore.activeBtn && !customStore.activeWrapper) {
          $xeTable.customCloseEvent(evnt);
        }
      }, 300);
    };
    const confirmCustomEvent = ({
      $event
    }) => {
      reactData.isCustomStatus = true;
      $xeTable.saveCustom();
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent('confirm', $event);
    };
    const cancelCloseEvent = ({
      $event
    }) => {
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent('close', $event);
    };
    const cancelCustomEvent = ({
      $event
    }) => {
      $xeTable.cancelCustom();
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent('cancel', $event);
    };
    const handleResetCustomEvent = evnt => {
      $xeTable.resetCustom(true);
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent('reset', evnt);
    };
    const resetCustomEvent = ({
      $event
    }) => {
      if (core_.VxeUI.modal) {
        core_.VxeUI.modal.confirm({
          content: panel_getI18n('vxe.custom.cstmConfirmRestore'),
          className: 'vxe-table--ignore-clear',
          escClosable: true
        }).then(type => {
          if (type === 'confirm') {
            handleResetCustomEvent($event);
          }
        });
      } else {
        handleResetCustomEvent($event);
      }
    };
    const handleOptionCheck = column => {
      const {
        customColumnList
      } = reactData;
      const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(customColumnList, item => item === column);
      if (matchObj && matchObj.parent) {
        const {
          parent
        } = matchObj;
        if (parent.children && parent.children.length) {
          parent.renderVisible = parent.children.every(column => column.renderVisible);
          parent.halfVisible = !parent.renderVisible && parent.children.some(column => column.renderVisible || column.halfVisible);
          handleOptionCheck(parent);
        }
      }
    };
    const changeCheckboxOption = column => {
      const isChecked = !column.renderVisible;
      const customOpts = computeCustomOpts.value;
      if (customOpts.immediate) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], item => {
          item.visible = isChecked;
          item.renderVisible = isChecked;
          item.halfVisible = false;
        });
        reactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore('update:visible');
      } else {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], item => {
          item.renderVisible = isChecked;
          item.halfVisible = false;
        });
      }
      handleOptionCheck(column);
      $xeTable.checkCustomStatus();
    };
    const changeColumnWidth = column => {
      const customOpts = computeCustomOpts.value;
      if (customOpts.immediate) {
        if (column.renderResizeWidth !== column.renderWidth) {
          column.resizeWidth = column.renderResizeWidth;
          column.renderWidth = column.renderResizeWidth;
          reactData.isCustomStatus = true;
          $xeTable.handleCustom();
          $xeTable.saveCustomStore('update:width');
        }
      }
    };
    const changeFixedOption = (column, colFixed) => {
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const customOpts = computeCustomOpts.value;
      if (customOpts.immediate) {
        if (column.renderFixed === colFixed) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], col => {
            col.fixed = '';
            col.renderFixed = '';
          });
        } else {
          if (!isMaxFixedColumn || column.renderFixed) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], col => {
              col.fixed = colFixed;
              col.renderFixed = colFixed;
            });
          }
        }
        reactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore('update:fixed');
      } else {
        if (column.renderFixed === colFixed) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], col => {
            col.renderFixed = '';
          });
        } else {
          if (!isMaxFixedColumn || column.renderFixed) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], col => {
              col.renderFixed = colFixed;
            });
          }
        }
      }
    };
    const allOptionEvent = () => {
      $xeTable.toggleCustomAllCheckbox();
    };
    const showDropTip = (evnt, optEl, showLine, dragPos) => {
      const el = bodyElemRef.value;
      if (!el) {
        return;
      }
      const wrapperRect = el.getBoundingClientRect();
      if (optEl) {
        const dragLineEl = refDragLineElem.value;
        if (dragLineEl) {
          if (showLine) {
            const optRect = optEl.getBoundingClientRect();
            dragLineEl.style.display = 'block';
            dragLineEl.style.top = `${Math.max(1, optRect.y + el.scrollTop - wrapperRect.y)}px`;
            dragLineEl.style.height = `${optRect.height}px`;
            dragLineEl.style.width = `${optRect.width}px`;
            dragLineEl.setAttribute('drag-pos', dragPos);
            dragLineEl.setAttribute('drag-to-child', prevDragToChild ? 'y' : 'n');
          } else {
            dragLineEl.style.display = '';
          }
        }
      }
      const dragTipEl = refDragTipElem.value;
      if (dragTipEl) {
        dragTipEl.style.display = 'block';
        dragTipEl.style.top = `${Math.min(el.clientHeight + el.scrollTop - dragTipEl.clientHeight, evnt.clientY + el.scrollTop - wrapperRect.y)}px`;
        dragTipEl.style.left = `${Math.min(el.clientWidth + el.scrollLeft - dragTipEl.clientWidth, evnt.clientX + el.scrollLeft - wrapperRect.x)}px`;
        dragTipEl.setAttribute('drag-status', showLine ? prevDragToChild ? 'sub' : 'normal' : 'disabled');
      }
    };
    const hideDropTip = () => {
      const dragTipEl = refDragTipElem.value;
      const dragLineEl = refDragLineElem.value;
      if (dragTipEl) {
        dragTipEl.style.display = '';
      }
      if (dragLineEl) {
        dragLineEl.style.display = '';
      }
    };
    const sortMousedownEvent = evnt => {
      const btnEl = evnt.currentTarget;
      const cellEl = btnEl.parentElement;
      const tdEl = cellEl.parentElement;
      const trEl = tdEl.parentElement;
      const colid = trEl.getAttribute('colid');
      const column = $xeTable.getColumnById(colid);
      trEl.draggable = true;
      dragColumnRef.value = column;
      addClass(trEl, 'active--drag-origin');
    };
    const sortMouseupEvent = evnt => {
      const btnEl = evnt.currentTarget;
      const cellEl = btnEl.parentElement;
      const tdEl = cellEl.parentElement;
      const trEl = tdEl.parentElement;
      hideDropTip();
      trEl.draggable = false;
      dragColumnRef.value = null;
      removeClass(trEl, 'active--drag-origin');
    };
    const sortDragstartEvent = evnt => {
      if (evnt.dataTransfer) {
        evnt.dataTransfer.setDragImage(getTpImg(), 0, 0);
      }
    };
    const sortDragendEvent = evnt => {
      const {
        mouseConfig
      } = tableProps;
      const {
        customColumnList
      } = reactData;
      const {
        collectColumn
      } = internalData;
      const customOpts = computeCustomOpts.value;
      const {
        immediate
      } = customOpts;
      const trEl = evnt.currentTarget;
      const dragCol = dragColumnRef.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const {
        isCrossDrag,
        isSelfToChildDrag,
        isToChildDrag,
        dragEndMethod
      } = columnDragOpts;
      const dragOffsetIndex = prevDragPos === 'bottom' ? 1 : 0;
      if (prevDragCol && dragCol) {
        // 判断是否有拖动
        if (prevDragCol !== dragCol) {
          const dragColumn = dragCol;
          const newColumn = prevDragCol;
          Promise.resolve(dragEndMethod ? dragEndMethod({
            oldColumn: dragColumn,
            newColumn,
            dragColumn,
            dragPos: prevDragPos,
            dragToChild: !!prevDragToChild,
            offsetIndex: dragOffsetIndex
          }) : true).then(status => {
            if (!status) {
              return;
            }
            let oafIndex = -1;
            let nafIndex = -1;
            const oldAllMaps = {};
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([dragColumn], column => {
              oldAllMaps[column.id] = column;
            });
            let isSelfToChildStatus = false;
            // 只有实时拖拽支持跨层级
            if (immediate) {
              if (dragColumn.parentId && newColumn.parentId) {
                // 子到子
                if (!isCrossDrag) {
                  return;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!(isCrossDrag && isSelfToChildDrag)) {
                    if (core_.VxeUI.modal) {
                      core_.VxeUI.modal.message({
                        status: 'error',
                        content: panel_getI18n('vxe.error.treeDragChild')
                      });
                    }
                    return;
                  }
                }
              } else if (dragColumn.parentId) {
                // 子到根
                if (!isCrossDrag) {
                  return;
                }
              } else if (newColumn.parentId) {
                // 根到子
                if (!isCrossDrag) {
                  return;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!(isCrossDrag && isSelfToChildDrag)) {
                    if (core_.VxeUI.modal) {
                      core_.VxeUI.modal.message({
                        status: 'error',
                        content: panel_getI18n('vxe.error.treeDragChild')
                      });
                    }
                    return;
                  }
                }
              } else {
                // 根到根
              }
              const oldewMatchRest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(collectColumn, item => item.id === dragColumn.id);
              // 改变层级
              if (isSelfToChildStatus && isCrossDrag && isSelfToChildDrag) {
                if (oldewMatchRest) {
                  const {
                    items: oCols,
                    index: oIndex
                  } = oldewMatchRest;
                  const childList = dragColumn.children || [];
                  childList.forEach(column => {
                    column.parentId = dragColumn.parentId;
                  });
                  oCols.splice(oIndex, 1, ...childList);
                  dragColumn.children = [];
                }
              } else {
                if (oldewMatchRest) {
                  const {
                    items: oCols,
                    index: oIndex,
                    parent: oParent
                  } = oldewMatchRest;
                  oCols.splice(oIndex, 1);
                  if (!oParent) {
                    oafIndex = oIndex;
                  }
                }
              }
              const newMatchRest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(collectColumn, item => item.id === newColumn.id);
              if (newMatchRest) {
                const {
                  items: nCols,
                  index: nIndex,
                  parent: nParent
                } = newMatchRest;
                // 转子级
                if (isCrossDrag && isToChildDrag && prevDragToChild) {
                  dragColumn.parentId = newColumn.id;
                  newColumn.children = (newColumn.children || []).concat([dragColumn]);
                } else {
                  dragColumn.parentId = newColumn.parentId;
                  nCols.splice(nIndex + dragOffsetIndex, 0, dragColumn);
                }
                if (!nParent) {
                  nafIndex = nIndex;
                }
              }
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn, (column, index, items, path, parent) => {
                if (!parent) {
                  const sortIndex = index + 1;
                  column.renderSortNumber = sortIndex;
                }
              });
            } else {
              oafIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(customColumnList, item => item.id === dragColumn.id);
              customColumnList.splice(oafIndex, 1);
              nafIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(customColumnList, item => item.id === newColumn.id);
              customColumnList.splice(nafIndex + dragOffsetIndex, 0, dragColumn);
            }
            reactData.isDragColMove = true;
            if (mouseConfig) {
              if ($xeTable.clearSelected) {
                $xeTable.clearSelected();
              }
              if ($xeTable.clearCellAreas) {
                $xeTable.clearCellAreas();
                $xeTable.clearCopyCellArea();
              }
            }
            $xeTable.dispatchEvent('column-dragend', {
              oldColumn: dragColumn,
              newColumn,
              dragColumn,
              dragPos: prevDragPos,
              offsetIndex: dragOffsetIndex,
              _index: {
                newIndex: nafIndex,
                oldIndex: oafIndex
              }
            }, evnt);
            if (immediate) {
              reactData.customColumnList = collectColumn.slice(0);
              $xeTable.handleColDragSwapColumn();
            }
          }).catch(() => {});
        }
      }
      hideDropTip();
      dragColumnRef.value = null;
      trEl.draggable = false;
      trEl.removeAttribute('drag-pos');
      removeClass(trEl, 'active--drag-target');
      removeClass(trEl, 'active--drag-origin');
    };
    const sortDragoverEvent = evnt => {
      const customOpts = computeCustomOpts.value;
      const {
        immediate
      } = customOpts;
      const columnDragOpts = computeColumnDragOpts.value;
      const {
        isCrossDrag,
        isToChildDrag
      } = columnDragOpts;
      const optEl = evnt.currentTarget;
      const isControlKey = hasControlKey(evnt);
      const colid = optEl.getAttribute('colid');
      const column = $xeTable.getColumnById(colid);
      const dragCol = dragColumnRef.value;
      // 是否移入有效列
      if (column && (isCrossDrag || column.level === 1)) {
        evnt.preventDefault();
        const offsetY = evnt.clientY - optEl.getBoundingClientRect().y;
        const dragPos = offsetY < optEl.clientHeight / 2 ? 'top' : 'bottom';
        if (dragCol && dragCol.id === column.id || !isCrossDrag && column.level > 1 || !immediate && column.level > 1 || column.renderFixed) {
          showDropTip(evnt, optEl, false, dragPos);
          return;
        }
        prevDragToChild = !!(isCrossDrag && isToChildDrag && isControlKey && immediate);
        prevDragCol = column;
        prevDragPos = dragPos;
        showDropTip(evnt, optEl, true, dragPos);
      }
    };
    const renderDragTip = () => {
      const dragCol = dragColumnRef.value;
      const columnDragOpts = computeColumnDragOpts.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {}, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refDragLineElem,
        class: ['vxe-table-custom-popup--drag-line', {
          'is--guides': columnDragOpts.showGuidesStatus
        }]
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refDragTipElem,
        class: 'vxe-table-custom-popup--drag-tip'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-custom-popup--drag-tip-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-custom-popup--drag-tip-status'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-table-custom-popup--drag-tip-normal-status', panel_getIcon().TABLE_DRAG_STATUS_ROW]
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-table-custom-popup--drag-tip-sub-status', panel_getIcon().TABLE_DRAG_STATUS_SUB_ROW]
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-table-custom-popup--drag-tip-disabled-status', panel_getIcon().TABLE_DRAG_DISABLED]
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-custom-popup--drag-tip-content'
      }, panel_getI18n('vxe.custom.cstmDragTarget', [dragCol && dragCol.type !== 'html' ? dragCol.getTitle() : '']))])])]);
    };
    const renderSimplePanel = () => {
      const $xeGrid = $xeTable.xeGrid;
      const {
        customStore
      } = props;
      const {
        isCustomStatus,
        customColumnList
      } = reactData;
      const customOpts = computeCustomOpts.value;
      const {
        immediate
      } = customOpts;
      const columnDragOpts = computeColumnDragOpts.value;
      const {
        maxHeight
      } = customStore;
      const {
        checkMethod,
        visibleMethod,
        allowVisible,
        allowSort,
        allowFixed,
        trigger,
        placement
      } = customOpts;
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const {
        isCrossDrag
      } = columnDragOpts;
      const slots = customOpts.slots || {};
      const headerSlot = slots.header;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const colVNs = [];
      const customWrapperOns = {};
      const isAllChecked = customStore.isAll;
      const isAllIndeterminate = customStore.isIndeterminate;
      // hover 触发
      if (trigger === 'hover') {
        customWrapperOns.onMouseenter = handleWrapperMouseenterEvent;
        customWrapperOns.onMouseleave = handleWrapperMouseleaveEvent;
      }
      const params = {
        $table: $xeTable,
        $grid: $xeGrid,
        columns: customColumnList,
        isAllChecked,
        isAllIndeterminate,
        isCustomStatus
      };
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(customColumnList, (column, index, items, path, parent) => {
        const isVisible = visibleMethod ? visibleMethod({
          $table: $xeTable,
          column
        }) : true;
        if (isVisible) {
          const isChecked = column.renderVisible;
          const isIndeterminate = column.halfVisible;
          const isColGroup = column.children && column.children.length;
          const colTitle = formatText(column.getTitle(), 1);
          const isDisabled = checkMethod ? !checkMethod({
            $table: $xeTable,
            column
          }) : false;
          const isHidden = !isChecked;
          colVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
            key: column.id,
            colid: column.id,
            class: ['vxe-table-custom--option', `level--${column.level}`, {
              'is--hidden': isDisabled || isHidden,
              'is--group': isColGroup
            }],
            onDragstart: sortDragstartEvent,
            onDragend: sortDragendEvent,
            onDragover: sortDragoverEvent
          }, [allowVisible ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-table-custom--checkbox-option', {
              'is--checked': isChecked,
              'is--indeterminate': isIndeterminate,
              'is--disabled': isDisabled
            }],
            title: panel_getI18n('vxe.custom.setting.colVisible'),
            onClick: () => {
              if (!isDisabled) {
                changeCheckboxOption(column);
              }
            }
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-checkbox--icon', isIndeterminate ? panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? panel_getIcon().TABLE_CHECKBOX_CHECKED : panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
          })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom--name-option'
          }, [allowSort && ((isCrossDrag ? immediate : false) || column.level === 1) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom--sort-option'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-table-custom--sort-btn', {
              'is--disabled': isDisabled || isHidden || column.renderFixed
            }],
            title: panel_getI18n('vxe.custom.setting.sortHelpTip'),
            ...(isDisabled || isHidden || column.renderFixed ? {} : {
              onMousedown: sortMousedownEvent,
              onMouseup: sortMouseupEvent
            })
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
            class: panel_getIcon().TABLE_CUSTOM_SORT
          })])]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), column.type === 'html' ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: '1',
            class: 'vxe-table-custom--checkbox-label',
            innerHTML: colTitle
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: '0',
            class: 'vxe-table-custom--checkbox-label'
          }, colTitle)]), !parent && allowFixed ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom--fixed-option'
          }, [VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            mode: 'text',
            icon: column.renderFixed === 'left' ? panel_getIcon().TOOLBAR_TOOLS_FIXED_LEFT_ACTIVE : panel_getIcon().TOOLBAR_TOOLS_FIXED_LEFT,
            status: column.renderFixed === 'left' ? 'primary' : '',
            disabled: isDisabled || isHidden || isMaxFixedColumn && !column.renderFixed,
            title: panel_getI18n(column.renderFixed === 'left' ? 'vxe.toolbar.cancelFixed' : 'vxe.toolbar.fixedLeft'),
            onClick: () => {
              changeFixedOption(column, 'left');
            }
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            mode: 'text',
            icon: column.renderFixed === 'right' ? panel_getIcon().TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVE : panel_getIcon().TOOLBAR_TOOLS_FIXED_RIGHT,
            status: column.renderFixed === 'right' ? 'primary' : '',
            disabled: isDisabled || isHidden || isMaxFixedColumn && !column.renderFixed,
            title: panel_getI18n(column.renderFixed === 'right' ? 'vxe.toolbar.cancelFixed' : 'vxe.toolbar.fixedRight'),
            onClick: () => {
              changeFixedOption(column, 'right');
            }
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]));
        }
      });
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        key: 'simple',
        class: ['vxe-table-custom-wrapper', `placement--${placement}`, {
          'is--active': customStore.visible
        }],
        style: maxHeight && !['left', 'right'].includes(placement) ? {
          maxHeight: `${maxHeight}px`
        } : {}
      }, customStore.visible ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-custom--header'
      }, headerSlot ? $xeTable.callSlot(headerSlot, params) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-table-custom--panel-list'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
        class: 'vxe-table-custom--option'
      }, [allowVisible ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-table-custom--checkbox-option', {
          'is--checked': isAllChecked,
          'is--indeterminate': isAllIndeterminate
        }],
        title: panel_getI18n('vxe.table.allTitle'),
        onClick: allOptionEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-checkbox--icon', isAllIndeterminate ? panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? panel_getIcon().TABLE_CHECKBOX_CHECKED : panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-checkbox--label'
      }, panel_getI18n('vxe.toolbar.customAll'))]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-checkbox--label'
      }, panel_getI18n('vxe.table.customTitle'))])])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: bodyElemRef,
        class: 'vxe-table-custom--body'
      }, [topSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-custom--panel-top'
      }, $xeTable.callSlot(topSlot, params)) : panel_renderEmptyElement($xeTable), defaultSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-custom--panel-body'
      }, $xeTable.callSlot(defaultSlot, params)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.TransitionGroup, {
        class: 'vxe-table-custom--panel-list',
        name: 'vxe-table-custom--list',
        tag: 'ul',
        ...customWrapperOns
      }, {
        default: () => colVNs
      }), bottomSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-custom--panel-bottom'
      }, $xeTable.callSlot(bottomSlot, params)) : panel_renderEmptyElement($xeTable), renderDragTip()]), customOpts.showFooter ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-custom--footer'
      }, footerSlot ? $xeTable.callSlot(footerSlot, params) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-custom--footer-buttons'
      }, [VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
        mode: 'text',
        content: customOpts.resetButtonText || panel_getI18n('vxe.table.customRestore'),
        disabled: !isCustomStatus,
        onClick: resetCustomEvent
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), immediate ? VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
        mode: 'text',
        content: customOpts.closeButtonText || panel_getI18n('vxe.table.customClose'),
        onClick: cancelCloseEvent
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
        mode: 'text',
        content: customOpts.cancelButtonText || panel_getI18n('vxe.table.customCancel'),
        onClick: cancelCustomEvent
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), immediate ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
        mode: 'text',
        status: 'primary',
        content: customOpts.confirmButtonText || panel_getI18n('vxe.table.customConfirm'),
        onClick: confirmCustomEvent
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])]) : null] : []);
    };
    const renderPopupPanel = () => {
      const $xeGrid = $xeTable.xeGrid;
      const {
        customStore
      } = props;
      const {
        resizable: allResizable
      } = tableProps;
      const {
        isCustomStatus,
        customColumnList
      } = reactData;
      const customOpts = computeCustomOpts.value;
      const {
        immediate
      } = customOpts;
      const columnDragOpts = computeColumnDragOpts.value;
      const {
        mode,
        modalOptions,
        drawerOptions,
        allowVisible,
        allowSort,
        allowFixed,
        allowResizable,
        checkMethod,
        visibleMethod
      } = customOpts;
      const columnOpts = computeColumnOpts.value;
      const {
        maxFixedSize
      } = columnOpts;
      const resizableOpts = computeResizableOpts.value;
      const {
        minWidth: reMinWidth,
        maxWidth: reMaxWidth
      } = resizableOpts;
      const modalOpts = Object.assign({}, modalOptions);
      const drawerOpts = Object.assign({}, drawerOptions);
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const {
        isCrossDrag
      } = columnDragOpts;
      const slots = customOpts.slots || {};
      const headerSlot = slots.header;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const trVNs = [];
      const isAllChecked = customStore.isAll;
      const isAllIndeterminate = customStore.isIndeterminate;
      const params = {
        $table: $xeTable,
        $grid: $xeGrid,
        columns: customColumnList,
        isAllChecked,
        isAllIndeterminate,
        isCustomStatus
      };
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(customColumnList, (column, index, items, path, parent) => {
        const isVisible = visibleMethod ? visibleMethod({
          $table: $xeTable,
          column
        }) : true;
        if (isVisible) {
          // 默认继承调整宽度
          let customMinWidth = 0;
          let customMaxWidth = 0;
          if (allowResizable) {
            const resizeParams = {
              $table: $xeTable,
              column,
              columnIndex: index,
              $columnIndex: index,
              $rowIndex: -1
            };
            if (reMinWidth) {
              customMinWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(reMinWidth) ? reMinWidth(resizeParams) : reMinWidth);
            }
            if (reMaxWidth) {
              customMaxWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(reMaxWidth) ? reMaxWidth(resizeParams) : reMaxWidth);
            }
          }
          const isChecked = column.renderVisible;
          const isIndeterminate = column.halfVisible;
          const colTitle = formatText(column.getTitle(), 1);
          const isColGroup = column.children && column.children.length;
          const isDisabled = checkMethod ? !checkMethod({
            $table: $xeTable,
            column
          }) : false;
          const isHidden = !isChecked;
          trVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {
            key: column.id,
            colid: column.id,
            class: [`vxe-table-custom-popup--row level--${column.level}`, {
              'is--group': isColGroup
            }],
            onDragstart: sortDragstartEvent,
            onDragend: sortDragendEvent,
            onDragover: sortDragoverEvent
          }, [allowVisible ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: 'vxe-table-custom-popup--column-item col--visible'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-table-custom--checkbox-option', {
              'is--checked': isChecked,
              'is--indeterminate': isIndeterminate,
              'is--disabled': isDisabled
            }],
            title: panel_getI18n('vxe.custom.setting.colVisible'),
            onClick: () => {
              if (!isDisabled) {
                changeCheckboxOption(column);
              }
            }
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-checkbox--icon', isIndeterminate ? panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? panel_getIcon().TABLE_CHECKBOX_CHECKED : panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
          })])]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: 'vxe-table-custom-popup--column-item col--name'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom-popup--name'
          }, [allowSort ? (isCrossDrag ? immediate : false) || column.level === 1 ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-table-custom-popup--column-sort-btn', {
              'is--disabled': isDisabled || isHidden || column.renderFixed
            }],
            title: panel_getI18n('vxe.custom.setting.sortHelpTip'),
            ...(isDisabled || isHidden || column.renderFixed ? {} : {
              onMousedown: sortMousedownEvent,
              onMouseup: sortMouseupEvent
            })
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
            class: panel_getIcon().TABLE_CUSTOM_SORT
          })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom-popup--column-sort-placeholder'
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), column.type === 'html' ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: '1',
            class: 'vxe-table-custom-popup--title',
            innerHTML: colTitle
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: '0',
            class: 'vxe-table-custom-popup--title',
            title: colTitle
          }, colTitle)])]), allowResizable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: 'vxe-table-custom-popup--column-item col--resizable'
          }, [column.children && column.children.length || !(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', '-') : VxeUINumberInputComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUINumberInputComponent, {
            type: 'integer',
            immediate: false,
            disabled: isDisabled || isHidden,
            modelValue: column.renderResizeWidth,
            min: customMinWidth || undefined,
            max: customMaxWidth || undefined,
            'onUpdate:modelValue'(value) {
              const width = Math.max(0, Number(value));
              column.renderResizeWidth = width;
            },
            onChange() {
              changeColumnWidth(column);
            }
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), allowFixed ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: 'vxe-table-custom-popup--column-item col--fixed'
          }, [parent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', '-') : VxeUIRadioGroupComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIRadioGroupComponent, {
            modelValue: column.renderFixed || '',
            type: 'button',
            size: 'mini',
            disabled: isDisabled || isHidden,
            options: [{
              label: panel_getI18n('vxe.custom.setting.fixedLeft'),
              value: 'left',
              disabled: isDisabled || isHidden || isMaxFixedColumn
            }, {
              label: panel_getI18n('vxe.custom.setting.fixedUnset'),
              value: '',
              disabled: isDisabled || isHidden
            }, {
              label: panel_getI18n('vxe.custom.setting.fixedRight'),
              value: 'right',
              disabled: isDisabled || isHidden || isMaxFixedColumn
            }],
            'onUpdate:modelValue'(value) {
              changeFixedOption(column, value);
            }
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]));
        }
      });
      const scopedSlots = {
        default: () => {
          if (defaultSlot) {
            return $xeTable.callSlot(defaultSlot, params);
          }
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            ref: bodyElemRef,
            class: 'vxe-table-custom-popup--body'
          }, [topSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom-popup--table-top'
          }, $xeTable.callSlot(topSlot, params)) : panel_renderEmptyElement($xeTable), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom-popup--table-wrapper'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {}, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('colgroup', {}, [allowVisible ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
            class: 'vxe-table-custom-popup--table-col-seq'
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
            class: 'vxe-table-custom-popup--table-col-title'
          }), allowResizable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
            class: 'vxe-table-custom-popup--table-col-width'
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), allowFixed ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
            class: 'vxe-table-custom-popup--table-col-fixed'
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('thead', {}, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {}, [allowVisible ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', {}, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-table-custom--checkbox-option', {
              'is--checked': isAllChecked,
              'is--indeterminate': isAllIndeterminate
            }],
            title: panel_getI18n('vxe.table.allTitle'),
            onClick: allOptionEvent
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-checkbox--icon', isAllIndeterminate ? panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? panel_getIcon().TABLE_CHECKBOX_CHECKED : panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-checkbox--label'
          }, panel_getI18n('vxe.toolbar.customAll'))])]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', {}, panel_getI18n('vxe.custom.setting.colTitle')), allowResizable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', {}, panel_getI18n('vxe.custom.setting.colResizable')) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), allowFixed ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', {}, panel_getI18n(`vxe.custom.setting.${maxFixedSize ? 'colFixedMax' : 'colFixed'}`, [maxFixedSize])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.TransitionGroup, {
            class: 'vxe-table-custom--panel-list',
            tag: 'tbody',
            name: 'vxe-table-custom--list'
          }, {
            default: () => trVNs
          })])]), bottomSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom-popup--table-bottom'
          }, $xeTable.callSlot(bottomSlot, params)) : panel_renderEmptyElement($xeTable), renderDragTip()]);
        },
        footer: () => {
          if (footerSlot) {
            return $xeTable.callSlot(footerSlot, params);
          }
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom-popup--footer'
          }, [VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            content: customOpts.resetButtonText || panel_getI18n('vxe.custom.cstmRestore'),
            disabled: !isCustomStatus,
            onClick: resetCustomEvent
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), immediate ? VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            content: customOpts.closeButtonText || panel_getI18n('vxe.table.customClose'),
            onClick: cancelCloseEvent
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            content: customOpts.cancelButtonText || panel_getI18n('vxe.table.customCancel'),
            onClick: cancelCustomEvent
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), immediate ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            status: 'primary',
            content: customOpts.confirmButtonText || panel_getI18n('vxe.custom.cstmConfirm'),
            onClick: confirmCustomEvent
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
        }
      };
      if (headerSlot) {
        scopedSlots.header = () => $xeTable.callSlot(headerSlot, params);
      }
      if (mode === 'drawer') {
        return VxeUIDrawerComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIDrawerComponent, {
          key: 'drawer',
          className: ['vxe-table-custom-drawer-wrapper', 'vxe-table--ignore-clear', drawerOpts.className || ''].join(' '),
          modelValue: customStore.visible,
          title: drawerOpts.title || panel_getI18n('vxe.custom.cstmTitle'),
          width: drawerOpts.width || Math.min(880, Math.floor(document.documentElement.clientWidth * 0.6)),
          position: drawerOpts.position,
          resize: !!drawerOpts.resize,
          escClosable: !!drawerOpts.escClosable,
          maskClosable: !!drawerOpts.maskClosable,
          destroyOnClose: true,
          showFooter: true,
          'onUpdate:modelValue'(value) {
            customStore.visible = value;
          }
        }, scopedSlots) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
      }
      return VxeUIModalComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIModalComponent, {
        key: 'modal',
        className: ['vxe-table-custom-modal-wrapper', 'vxe-table--ignore-clear', modalOpts.className || ''].join(' '),
        modelValue: customStore.visible,
        title: modalOpts.title || panel_getI18n('vxe.custom.cstmTitle'),
        width: modalOpts.width || Math.min(880, document.documentElement.clientWidth),
        minWidth: modalOpts.minWidth || 700,
        height: modalOpts.height || Math.min(680, document.documentElement.clientHeight),
        minHeight: modalOpts.minHeight || 400,
        showZoom: modalOpts.showZoom,
        showMaximize: modalOpts.showMaximize,
        showMinimize: modalOpts.showMinimize,
        mask: modalOpts.mask,
        lockView: modalOpts.lockView,
        resize: modalOpts.resize,
        escClosable: !!modalOpts.escClosable,
        maskClosable: !!modalOpts.maskClosable,
        destroyOnClose: true,
        showFooter: true,
        'onUpdate:modelValue'(value) {
          customStore.visible = value;
        }
      }, scopedSlots) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderVN = () => {
      const customOpts = computeCustomOpts.value;
      if (['modal', 'drawer', 'popup'].includes(`${customOpts.mode}`)) {
        return renderPopupPanel();
      }
      return renderSimplePanel();
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      const customOpts = computeCustomOpts.value;
      const {
        mode
      } = customOpts;
      if (!VxeUIModalComponent) {
        errLog('vxe.error.reqComp', ['vxe-modal']);
      }
      if (!VxeUIDrawerComponent && mode === 'drawer') {
        errLog('vxe.error.reqComp', ['vxe-drawer']);
      }
      if (!VxeUIButtonComponent) {
        errLog('vxe.error.reqComp', ['vxe-button']);
      }
      if (!VxeUINumberInputComponent) {
        errLog('vxe.error.reqComp', ['vxe-number-input']);
      }
      if (!VxeUIRadioGroupComponent) {
        errLog('vxe.error.reqComp', ['vxe-radio-group']);
      }
    });
    return renderVN;
  }
}));
;// ./packages/table/module/filter/panel.ts











const {
  getI18n: filter_panel_getI18n,
  getIcon: filter_panel_getIcon,
  renderer: panel_renderer
} = core_.VxeUI;
/* harmony default export */ var filter_panel = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTableFilterPanel',
  props: {
    filterStore: Object
  },
  setup(props, context) {
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', {});
    const {
      reactData: tableReactData,
      internalData: tableInternalData,
      getComputeMaps
    } = $xeTable;
    const {
      computeFilterOpts
    } = getComputeMaps();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeFilterPanel = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    const computeHasCheckOption = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        filterStore
      } = props;
      return filterStore && filterStore.options.some(option => option.checked);
    });
    // 全部筛选事件
    const filterCheckAllEvent = (evnt, value) => {
      const {
        filterStore
      } = props;
      filterStore.options.forEach(option => {
        option._checked = value;
        option.checked = value;
      });
      filterStore.isAllSelected = value;
      filterStore.isIndeterminate = false;
    };
    /*************************
     * Publish methods
     *************************/
    // 确认筛选
    const confirmFilter = evnt => {
      $xeTable.handleFilterConfirmFilter(evnt);
    };
    // （单选）筛选发生改变
    const changeRadioOption = (evnt, checked, item) => {
      $xeTable.handleFilterChangeRadioOption(evnt, checked, item);
    };
    /**
     * 重置筛选
     * 当筛选面板中的重置按钮被按下时触发
     * @param {Event} evnt 事件
     */
    const resetFilter = evnt => {
      $xeTable.handleFilterResetFilter(evnt);
    };
    // （多选）筛选发生改变
    const changeMultipleOption = (evnt, checked, item) => {
      $xeTable.handleFilterChangeMultipleOption(evnt, checked, item);
    };
    // 筛选发生改变
    const changeOption = (evnt, checked, item) => {
      $xeTable.handleFilterChangeOption(evnt, checked, item);
    };
    const changeAllOption = (evnt, checked) => {
      const {
        filterStore
      } = props;
      if (filterStore.multiple) {
        filterCheckAllEvent(evnt, checked);
      } else {
        resetFilter(evnt);
      }
    };
    /*************************
     * Publish methods
     *************************/
    const filterPanelMethods = {
      changeRadioOption,
      changeMultipleOption,
      changeAllOption,
      changeOption,
      confirmFilter,
      resetFilter
    };
    Object.assign($xeFilterPanel, filterPanelMethods);
    const renderOptions = (filterRender, compConf) => {
      const {
        filterStore
      } = props;
      const {
        column,
        multiple,
        maxHeight
      } = filterStore;
      const slots = column ? column.slots : null;
      const filterSlot = slots ? slots.filter : null;
      const params = Object.assign({}, tableInternalData._currFilterParams, {
        $panel: $xeFilterPanel,
        $table: $xeTable
      });
      const rtFilter = compConf ? compConf.renderTableFilter || compConf.renderFilter : null;
      if (filterSlot) {
        return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-table--filter-template',
          style: maxHeight ? {
            maxHeight: `${maxHeight}px`
          } : {}
        }, $xeTable.callSlot(filterSlot, params))];
      } else if (rtFilter) {
        return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-table--filter-template',
          style: maxHeight ? {
            maxHeight: `${maxHeight}px`
          } : {}
        }, getSlotVNs(rtFilter(filterRender, params)))];
      }
      const isAllChecked = multiple ? filterStore.isAllSelected : !filterStore.options.some(item => item._checked);
      const isAllIndeterminate = multiple && filterStore.isIndeterminate;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-table--filter-header'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
        class: ['vxe-table--filter-option', {
          'is--checked': isAllChecked,
          'is--indeterminate': isAllIndeterminate
        }],
        title: filter_panel_getI18n(multiple ? 'vxe.table.allTitle' : 'vxe.table.allFilter'),
        onClick: evnt => {
          changeAllOption(evnt, !filterStore.isAllSelected);
        }
      }, (multiple ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-checkbox--icon', isAllIndeterminate ? filter_panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? filter_panel_getIcon().TABLE_CHECKBOX_CHECKED : filter_panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
      })] : []).concat([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-checkbox--label'
      }, filter_panel_getI18n('vxe.table.allFilter'))]))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-table--filter-body',
        style: maxHeight ? {
          maxHeight: `${maxHeight}px`
        } : {}
      }, filterStore.options.map(item => {
        const isChecked = item._checked;
        const isIndeterminate = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          class: ['vxe-table--filter-option', {
            'is--checked': item._checked
          }],
          title: item.label,
          onClick: evnt => {
            changeOption(evnt, !item._checked, item);
          }
        }, (multiple ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-checkbox--icon', isIndeterminate ? filter_panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? filter_panel_getIcon().TABLE_CHECKBOX_CHECKED : filter_panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
        })] : []).concat([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-checkbox--label'
        }, formatText(item.label, 1))]));
      }))];
    };
    const renderFooters = () => {
      const {
        filterStore
      } = props;
      const {
        column,
        multiple
      } = filterStore;
      const filterOpts = computeFilterOpts.value;
      const hasCheckOption = computeHasCheckOption.value;
      const {
        filterRender
      } = column;
      const compConf = isEnableConf(filterRender) ? panel_renderer.get(filterRender.name) : null;
      const isDisabled = !hasCheckOption && !filterStore.isAllSelected && !filterStore.isIndeterminate;
      return multiple && (compConf ? !(compConf.showTableFilterFooter === false || compConf.showFilterFooter === false || compConf.isFooter === false) : true) ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--filter-footer'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: {
          'is--disabled': isDisabled
        },
        disabled: isDisabled,
        onClick: confirmFilter
      }, filterOpts.confirmButtonText || filter_panel_getI18n('vxe.table.confirmFilter')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        onClick: resetFilter
      }, filterOpts.resetButtonText || filter_panel_getI18n('vxe.table.resetFilter'))])] : [];
    };
    const renderVN = () => {
      const {
        filterStore
      } = props;
      const {
        initStore
      } = tableReactData;
      const {
        visible,
        multiple,
        column
      } = filterStore;
      const filterRender = column ? column.filterRender : null;
      const compConf = isEnableConf(filterRender) ? panel_renderer.get(filterRender.name) : null;
      const filterClassName = compConf ? compConf.tableFilterClassName || compConf.filterClassName : '';
      const params = Object.assign({}, tableInternalData._currFilterParams, {
        $panel: $xeFilterPanel,
        $table: $xeTable
      });
      const tableProps = $xeTable.props;
      const {
        computeSize
      } = $xeTable.getComputeMaps();
      const vSize = computeSize.value;
      const filterOpts = computeFilterOpts.value;
      const {
        transfer,
        destroyOnClose
      } = filterOpts;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: !transfer
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-table--filter-wrapper', 'filter--prevent-default', getPropClass(filterClassName, params), {
          [`size--${vSize}`]: vSize,
          'is--animat': tableProps.animat,
          'is--multiple': multiple,
          'is--active': visible
        }],
        style: filterStore.style
      }, initStore.filter && (destroyOnClose ? visible : true) && column ? renderOptions(filterRender, compConf).concat(renderFooters()) : [])]);
    };
    $xeFilterPanel.renderVN = renderVN;
    return $xeFilterPanel;
  },
  render() {
    return this.renderVN();
  }
}));
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.iterator.find.js
var esnext_iterator_find = __webpack_require__(2577);
;// ./packages/table/module/export/import-panel.ts








const {
  getI18n: import_panel_getI18n,
  getIcon: import_panel_getIcon
} = core_.VxeUI;
/* harmony default export */ var import_panel = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTableImportPanel',
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(props) {
    const VxeUIModalComponent = core_.VxeUI.getComponent('VxeModal');
    const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
    const VxeUISelectComponent = core_.VxeUI.getComponent('VxeSelect');
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', {});
    const {
      computeImportOpts
    } = $xeTable.getComputeMaps();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      loading: false
    });
    const refFileBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const computeSelectName = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        storeData
      } = props;
      return `${storeData.filename}.${storeData.type}`;
    });
    const computeHasFile = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        storeData
      } = props;
      return storeData.file && storeData.type;
    });
    const computeParseTypeLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        storeData
      } = props;
      const {
        type,
        typeList
      } = storeData;
      if (type) {
        const selectItem = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(typeList, item => type === item.value);
        return selectItem ? selectItem.label : '*.*';
      }
      return `*.${typeList.map(item => item.value).join(', *.')}`;
    });
    const clearFileEvent = () => {
      const {
        storeData
      } = props;
      Object.assign(storeData, {
        filename: '',
        sheetName: '',
        type: ''
      });
    };
    const selectFileEvent = () => {
      const {
        storeData,
        defaultOptions
      } = props;
      $xeTable.readFile(defaultOptions).then(params => {
        const {
          file
        } = params;
        Object.assign(storeData, parseFile(file), {
          file
        });
      }).catch(e => e);
    };
    const showEvent = () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const targetElem = refFileBtn.value;
        if (targetElem) {
          targetElem.focus();
        }
      });
    };
    const cancelEvent = () => {
      const {
        storeData
      } = props;
      storeData.visible = false;
    };
    const importEvent = () => {
      const {
        storeData,
        defaultOptions
      } = props;
      const importOpts = computeImportOpts.value;
      reactData.loading = true;
      $xeTable.importByFile(storeData.file, Object.assign({}, importOpts, defaultOptions)).then(() => {
        reactData.loading = false;
        storeData.visible = false;
      }).catch(() => {
        reactData.loading = false;
      });
    };
    const renderVN = () => {
      const $xeGrid = $xeTable.xeGrid;
      const {
        defaultOptions,
        storeData
      } = props;
      const selectName = computeSelectName.value;
      const hasFile = computeHasFile.value;
      const parseTypeLabel = computeParseTypeLabel.value;
      const slots = defaultOptions.slots || {};
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      return VxeUIModalComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIModalComponent, {
        id: 'VXE_IMPORT_MODAL',
        modelValue: storeData.visible,
        title: import_panel_getI18n('vxe.import.impTitle'),
        className: 'vxe-table-export-popup-wrapper',
        width: 540,
        minWidth: 360,
        minHeight: 240,
        mask: true,
        lockView: true,
        showFooter: true,
        escClosable: true,
        maskClosable: true,
        showMaximize: true,
        resize: true,
        loading: reactData.loading,
        'onUpdate:modelValue'(value) {
          storeData.visible = value;
        },
        onShow: showEvent
      }, {
        default: () => {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            options: defaultOptions,
            params: defaultOptions.params
          };
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel'
          }, [topSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-top'
          }, $xeTable.callSlot(topSlot, params)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-body'
          }, defaultSlot ? $xeTable.callSlot(defaultSlot, params) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
            class: 'vxe-table-export--panel-table',
            cellspacing: 0,
            cellpadding: 0,
            border: 0
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', import_panel_getI18n('vxe.import.impFile')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [hasFile ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--selected--file',
            title: selectName
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', selectName), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
            class: import_panel_getIcon().INPUT_CLEAR,
            onClick: clearFileEvent
          })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
            ref: refFileBtn,
            class: 'vxe-table-export--select--file',
            onClick: selectFileEvent
          }, import_panel_getI18n('vxe.import.impSelect'))])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', import_panel_getI18n('vxe.import.impType')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', parseTypeLabel)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', import_panel_getI18n('vxe.import.impMode')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [VxeUISelectComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUISelectComponent, {
            modelValue: defaultOptions.mode,
            options: storeData.modeList,
            'onUpdate:modelValue'(value) {
              defaultOptions.mode = value;
            }
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])])])])]), bottomSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-bottom'
          }, $xeTable.callSlot(bottomSlot, params)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
        },
        footer() {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            options: defaultOptions,
            params: defaultOptions.params
          };
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-footer'
          }, footerSlot ? $xeTable.callSlot(footerSlot, params) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-btns'
          }, [VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            content: import_panel_getI18n('vxe.import.impCancel'),
            onClick: cancelEvent
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            status: 'primary',
            disabled: !hasFile || reactData.loading,
            content: import_panel_getI18n('vxe.import.impConfirm'),
            onClick: importEvent
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])]);
        }
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      if (!VxeUIModalComponent) {
        errLog('vxe.error.reqComp', ['vxe-modal']);
      }
      if (!VxeUIButtonComponent) {
        errLog('vxe.error.reqComp', ['vxe-button']);
      }
      if (!VxeUISelectComponent) {
        errLog('vxe.error.reqComp', ['vxe-select']);
      }
    });
    return renderVN;
  }
}));
;// ./packages/table/module/export/export-panel.ts










const {
  getI18n: export_panel_getI18n,
  getIcon: export_panel_getIcon
} = core_.VxeUI;
/* harmony default export */ var export_panel = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTableExportPanel',
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(props) {
    const VxeUIModalComponent = core_.VxeUI.getComponent('VxeModal');
    const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
    const VxeUISelectComponent = core_.VxeUI.getComponent('VxeSelect');
    const VxeUIInputComponent = core_.VxeUI.getComponent('VxeInput');
    const VxeUICheckboxComponent = core_.VxeUI.getComponent('VxeCheckbox');
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', {});
    const {
      computeExportOpts,
      computePrintOpts
    } = $xeTable.getComputeMaps();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      isAll: false,
      isIndeterminate: false,
      loading: false
    });
    const xButtonConfirm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const xInputFilename = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const xInputSheetname = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const computeCheckedAll = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        storeData
      } = props;
      return storeData.columns.every(column => column.checked);
    });
    const computeShowSheet = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        defaultOptions
      } = props;
      return ['html', 'xml', 'xlsx', 'pdf'].indexOf(defaultOptions.type) > -1;
    });
    const computeSupportMerge = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        storeData,
        defaultOptions
      } = props;
      return !defaultOptions.original && defaultOptions.mode === 'current' && (storeData.isPrint || ['html', 'xlsx'].indexOf(defaultOptions.type) > -1);
    });
    // const computeSupportGroup = computed(() => {
    //   const { defaultOptions } = props
    //   return ['html', 'xlsx', 'csv', 'txt'].indexOf(defaultOptions.type) > -1
    // })
    const computeSupportStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        defaultOptions
      } = props;
      return !defaultOptions.original && ['xlsx'].indexOf(defaultOptions.type) > -1;
    });
    const handleOptionCheck = column => {
      const {
        storeData
      } = props;
      const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(storeData.columns, item => item === column);
      if (matchObj && matchObj.parent) {
        const {
          parent
        } = matchObj;
        if (parent.children && parent.children.length) {
          parent.checked = parent.children.every(column => column.checked);
          parent.halfChecked = !parent.checked && parent.children.some(column => column.checked || column.halfChecked);
          handleOptionCheck(parent);
        }
      }
    };
    const checkStatus = () => {
      const {
        storeData
      } = props;
      const columns = storeData.columns;
      reactData.isAll = columns.every(column => column.disabled || column.checked);
      reactData.isIndeterminate = !reactData.isAll && columns.some(column => !column.disabled && (column.checked || column.halfChecked));
    };
    const changeOption = column => {
      const isChecked = !column.checked;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], item => {
        item.checked = isChecked;
        item.halfChecked = false;
      });
      handleOptionCheck(column);
      checkStatus();
    };
    const allColumnEvent = () => {
      const {
        storeData
      } = props;
      const isAll = !reactData.isAll;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(storeData.columns, column => {
        if (!column.disabled) {
          column.checked = isAll;
          column.halfChecked = false;
        }
      });
      reactData.isAll = isAll;
      checkStatus();
    };
    const showEvent = () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const filenameInp = xInputFilename.value;
        const sheetnameInp = xInputSheetname.value;
        const confirmBtn = xButtonConfirm.value;
        const targetElem = filenameInp || sheetnameInp || confirmBtn;
        if (targetElem) {
          targetElem.focus();
        }
      });
      checkStatus();
    };
    const getExportOption = () => {
      const {
        storeData,
        defaultOptions
      } = props;
      const {
        hasMerge,
        columns
      } = storeData;
      const checkedAll = computeCheckedAll.value;
      const supportMerge = computeSupportMerge.value;
      const expColumns = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(columns, column => column.checked, {
        children: 'children',
        mapChildren: 'childNodes',
        original: true
      });
      return Object.assign({}, defaultOptions, {
        columns: expColumns,
        isMerge: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false
      });
    };
    const printEvent = () => {
      const {
        storeData
      } = props;
      const printOpts = computePrintOpts.value;
      storeData.visible = false;
      $xeTable.print(Object.assign({}, printOpts, getExportOption()));
    };
    const exportEvent = () => {
      const {
        storeData
      } = props;
      const exportOpts = computeExportOpts.value;
      reactData.loading = true;
      $xeTable.exportData(Object.assign({}, exportOpts, getExportOption())).then(() => {
        reactData.loading = false;
        storeData.visible = false;
      }).catch(() => {
        reactData.loading = false;
      });
    };
    const cancelEvent = () => {
      const {
        storeData
      } = props;
      storeData.visible = false;
    };
    const confirmEvent = () => {
      const {
        storeData
      } = props;
      if (storeData.isPrint) {
        printEvent();
      } else {
        exportEvent();
      }
    };
    const renderVN = () => {
      const $xeGrid = $xeTable.xeGrid;
      const {
        defaultOptions,
        storeData
      } = props;
      const {
        isAll: isAllChecked,
        isIndeterminate: isAllIndeterminate
      } = reactData;
      const {
        hasTree,
        hasMerge,
        isPrint,
        hasColgroup,
        columns
      } = storeData;
      const {
        isHeader
      } = defaultOptions;
      const cols = [];
      const checkedAll = computeCheckedAll.value;
      const showSheet = computeShowSheet.value;
      const supportMerge = computeSupportMerge.value;
      const supportStyle = computeSupportStyle.value;
      // const supportGroup = computeSupportGroup.value
      const slots = defaultOptions.slots || {};
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const parameterSlot = slots.parameter;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(columns, column => {
        const colTitle = formatText(column.getTitle(), 1);
        const isColGroup = column.children && column.children.length;
        const isChecked = column.checked;
        const indeterminate = column.halfChecked;
        const isHtml = column.type === 'html';
        cols.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: column.id,
          class: ['vxe-table-export--panel-column-option', `level--${column.level}`, {
            'is--group': isColGroup,
            'is--checked': isChecked,
            'is--indeterminate': indeterminate,
            'is--disabled': column.disabled
          }],
          title: isHtml ? '' : colTitle,
          onClick: () => {
            if (!column.disabled) {
              changeOption(column);
            }
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-checkbox--icon', indeterminate ? export_panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? export_panel_getIcon().TABLE_CHECKBOX_CHECKED : export_panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
        }), isHtml ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          key: '1',
          class: 'vxe-checkbox--label',
          innerHTML: colTitle
        }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          key: '0',
          class: 'vxe-checkbox--label'
        }, colTitle)]));
      });
      return VxeUIModalComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIModalComponent, {
        id: 'VXE_EXPORT_MODAL',
        modelValue: storeData.visible,
        title: export_panel_getI18n(isPrint ? 'vxe.export.printTitle' : 'vxe.export.expTitle'),
        className: 'vxe-table-export-popup-wrapper',
        width: 660,
        minWidth: 500,
        minHeight: 400,
        mask: true,
        lockView: true,
        showFooter: true,
        escClosable: true,
        maskClosable: true,
        showMaximize: true,
        resize: true,
        loading: reactData.loading,
        'onUpdate:modelValue'(value) {
          storeData.visible = value;
        },
        onShow: showEvent
      }, {
        default: () => {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            options: defaultOptions,
            columns,
            params: defaultOptions.params
          };
          const hasEmptyData = defaultOptions.mode === 'empty';
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel'
          }, [topSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-top'
          }, $xeTable.callSlot(topSlot, params)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-body'
          }, defaultSlot ? $xeTable.callSlot(defaultSlot, params) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
            class: 'vxe-table-export--panel-table',
            cellspacing: 0,
            cellpadding: 0,
            border: 0
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', [[isPrint ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', export_panel_getI18n('vxe.export.expName')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [VxeUIInputComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIInputComponent, {
            ref: xInputFilename,
            modelValue: defaultOptions.filename,
            type: 'text',
            clearable: true,
            placeholder: export_panel_getI18n('vxe.export.expNamePlaceholder'),
            'onUpdate:modelValue'(value) {
              defaultOptions.filename = value;
            }
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])]), isPrint ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', export_panel_getI18n('vxe.export.expType')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [VxeUISelectComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUISelectComponent, {
            modelValue: defaultOptions.type,
            options: storeData.typeList,
            'onUpdate:modelValue'(value) {
              defaultOptions.type = value;
            }
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])]), isPrint || showSheet ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', export_panel_getI18n('vxe.export.expSheetName')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [VxeUIInputComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIInputComponent, {
            ref: xInputSheetname,
            modelValue: defaultOptions.sheetName,
            type: 'text',
            clearable: true,
            placeholder: export_panel_getI18n('vxe.export.expSheetNamePlaceholder'),
            'onUpdate:modelValue'(value) {
              defaultOptions.sheetName = value;
            }
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', export_panel_getI18n('vxe.export.expMode')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [VxeUISelectComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUISelectComponent, {
            modelValue: defaultOptions.mode,
            options: storeData.modeList.map(item => {
              return {
                value: item.value,
                label: export_panel_getI18n(item.label)
              };
            }),
            'onUpdate:modelValue'(value) {
              defaultOptions.mode = value;
            }
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [export_panel_getI18n('vxe.export.expColumn')]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-column'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
            class: 'vxe-table-export--panel-column-header'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
            class: ['vxe-table-export--panel-column-option', {
              'is--checked': isAllChecked,
              'is--indeterminate': isAllIndeterminate
            }],
            title: export_panel_getI18n('vxe.table.allTitle'),
            onClick: allColumnEvent
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-checkbox--icon', isAllIndeterminate ? export_panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? export_panel_getIcon().TABLE_CHECKBOX_CHECKED : export_panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-checkbox--label'
          }, export_panel_getI18n('vxe.export.expCurrentColumn'))])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
            class: 'vxe-table-export--panel-column-body'
          }, cols)])])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', export_panel_getI18n('vxe.export.expOpts')), parameterSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-option-row'
          }, $xeTable.callSlot(parameterSlot, params))]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-option-row'
          }, [VxeUICheckboxComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUICheckboxComponent, {
            modelValue: hasEmptyData || isHeader,
            disabled: hasEmptyData,
            title: export_panel_getI18n('vxe.export.expHeaderTitle'),
            content: export_panel_getI18n('vxe.export.expOptHeader'),
            'onUpdate:modelValue'(value) {
              defaultOptions.isHeader = value;
            }
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), VxeUICheckboxComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUICheckboxComponent, {
            modelValue: isHeader ? defaultOptions.isTitle : false,
            disabled: !isHeader,
            title: export_panel_getI18n('vxe.export.expTitleTitle'),
            content: export_panel_getI18n('vxe.export.expOptTitle'),
            'onUpdate:modelValue'(value) {
              defaultOptions.isTitle = value;
            }
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), VxeUICheckboxComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUICheckboxComponent, {
            modelValue: isHeader && hasColgroup && supportMerge ? defaultOptions.isColgroup : false,
            title: export_panel_getI18n('vxe.export.expColgroupTitle'),
            disabled: !isHeader || !hasColgroup || !supportMerge,
            content: export_panel_getI18n('vxe.export.expOptColgroup'),
            'onUpdate:modelValue'(value) {
              defaultOptions.isColgroup = value;
            }
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-option-row'
          }, [VxeUICheckboxComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUICheckboxComponent, {
            modelValue: hasEmptyData ? false : defaultOptions.original,
            disabled: hasEmptyData,
            title: export_panel_getI18n('vxe.export.expOriginalTitle'),
            content: export_panel_getI18n('vxe.export.expOptOriginal'),
            'onUpdate:modelValue'(value) {
              defaultOptions.original = value;
            }
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), VxeUICheckboxComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUICheckboxComponent, {
            modelValue: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false,
            title: export_panel_getI18n('vxe.export.expMergeTitle'),
            disabled: hasEmptyData || !hasMerge || !supportMerge || !checkedAll,
            content: export_panel_getI18n('vxe.export.expOptMerge'),
            'onUpdate:modelValue'(value) {
              defaultOptions.isMerge = value;
            }
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), isPrint || !VxeUICheckboxComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUICheckboxComponent, {
            modelValue: supportStyle ? defaultOptions.useStyle : false,
            disabled: !supportStyle,
            title: export_panel_getI18n('vxe.export.expUseStyleTitle'),
            content: export_panel_getI18n('vxe.export.expOptUseStyle'),
            'onUpdate:modelValue'(value) {
              defaultOptions.useStyle = value;
            }
          }), VxeUICheckboxComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUICheckboxComponent, {
            modelValue: hasTree ? defaultOptions.isAllExpand : false,
            disabled: hasEmptyData || !hasTree,
            title: export_panel_getI18n('vxe.export.expAllExpandTitle'),
            content: export_panel_getI18n('vxe.export.expOptAllExpand'),
            'onUpdate:modelValue'(value) {
              defaultOptions.isAllExpand = value;
            }
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-option-row'
          }, [VxeUICheckboxComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUICheckboxComponent, {
            modelValue: defaultOptions.isFooter,
            disabled: !storeData.hasFooter,
            title: export_panel_getI18n('vxe.export.expFooterTitle'),
            content: export_panel_getI18n('vxe.export.expOptFooter'),
            'onUpdate:modelValue'(value) {
              defaultOptions.isFooter = value;
            }
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])])])]])])]), bottomSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-bottom'
          }, $xeTable.callSlot(bottomSlot, params)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
        },
        footer() {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            options: defaultOptions,
            columns,
            params: defaultOptions.params
          };
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-footer'
          }, footerSlot ? $xeTable.callSlot(footerSlot, params) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-btns'
          }, [VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            content: export_panel_getI18n('vxe.export.expCancel'),
            onClick: cancelEvent
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            ref: xButtonConfirm,
            status: 'primary',
            content: export_panel_getI18n(isPrint ? 'vxe.export.expPrint' : 'vxe.export.expConfirm'),
            onClick: confirmEvent
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])]);
        }
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      if (!VxeUIModalComponent) {
        errLog('vxe.error.reqComp', ['vxe-modal']);
      }
      if (!VxeUIButtonComponent) {
        errLog('vxe.error.reqComp', ['vxe-button']);
      }
      if (!VxeUISelectComponent) {
        errLog('vxe.error.reqComp', ['vxe-select']);
      }
      if (!VxeUIInputComponent) {
        errLog('vxe.error.reqComp', ['vxe-input']);
      }
      if (!VxeUICheckboxComponent) {
        errLog('vxe.error.reqComp', ['vxe-checkbox']);
      }
    });
    return renderVN;
  }
}));
;// ./packages/table/module/menu/panel.ts








const {
  getIcon: menu_panel_getIcon
} = core_.VxeUI;
/* harmony default export */ var menu_panel = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTableMenuPanel',
  setup(props, context) {
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', {});
    const {
      reactData: tableReactData
    } = $xeTable;
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeMenuPanel = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    const renderVN = () => {
      const {
        ctxMenuStore
      } = tableReactData;
      const {
        computeMenuOpts
      } = $xeTable.getComputeMaps();
      const menuOpts = computeMenuOpts.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: false
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-table--context-menu-wrapper', menuOpts.className, {
          'is--visible': ctxMenuStore.visible
        }],
        style: ctxMenuStore.style
      }, ctxMenuStore.list.map((options, gIndex) => {
        return options.every(item => item.visible === false) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
          class: 'vxe-context-menu--option-wrapper',
          key: gIndex
        }, options.map((item, index) => {
          const hasChildMenus = item.children && item.children.some(child => child.visible !== false);
          const prefixOpts = Object.assign({}, item.prefixConfig);
          const suffixOpts = Object.assign({}, item.suffixConfig);
          const menuContent = getFuncText(item.name);
          return item.visible === false ? null : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
            class: [item.className, {
              'link--disabled': item.disabled,
              'link--active': item === ctxMenuStore.selected
            }],
            key: `${gIndex}_${index}`
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('a', {
            class: 'vxe-context-menu--link',
            onClick(evnt) {
              $xeTable.ctxMenuLinkEvent(evnt, item);
            },
            onMouseover(evnt) {
              $xeTable.ctxMenuMouseoverEvent(evnt, item);
            },
            onMouseout(evnt) {
              $xeTable.ctxMenuMouseoutEvent(evnt, item);
            }
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-context-menu--link-prefix', prefixOpts.className || '']
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
            class: prefixOpts.icon || item.prefixIcon
          }), prefixOpts.content ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, `${prefixOpts.content}`) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-context-menu--link-content',
            title: menuContent
          }, menuContent), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-context-menu--link-suffix', suffixOpts.className || '']
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
            class: suffixOpts.icon || item.suffixIcon || (hasChildMenus ? menu_panel_getIcon().TABLE_MENU_OPTIONS : '')
          }), suffixOpts.content ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', `${suffixOpts.content}`) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])]), hasChildMenus ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
            class: ['vxe-table--context-menu-clild-wrapper', {
              'is--show': item === ctxMenuStore.selected && ctxMenuStore.showChild
            }]
          }, item.children.map((child, cIndex) => {
            const childPrefixOpts = Object.assign({}, child.prefixConfig);
            const childSuffixOpts = Object.assign({}, child.suffixConfig);
            const childMenuContent = getFuncText(child.name);
            return child.visible === false ? null : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
              class: [child.className, {
                'link--disabled': child.disabled,
                'link--active': child === ctxMenuStore.selectChild
              }],
              key: `${gIndex}_${index}_${cIndex}`
            }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('a', {
              class: 'vxe-context-menu--link',
              onClick(evnt) {
                $xeTable.ctxMenuLinkEvent(evnt, child);
              },
              onMouseover(evnt) {
                $xeTable.ctxMenuMouseoverEvent(evnt, item, child);
              },
              onMouseout(evnt) {
                $xeTable.ctxMenuMouseoutEvent(evnt, item);
              }
            }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
              class: ['vxe-context-menu--link-prefix', childPrefixOpts.className || '']
            }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
              class: childPrefixOpts.icon || child.prefixIcon
            }), childPrefixOpts.content ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', `${childPrefixOpts.content}`) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
              class: 'vxe-context-menu--link-content',
              title: childMenuContent
            }, childMenuContent), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
              class: ['vxe-context-menu--link-suffix', childSuffixOpts.className || '']
            }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
              class: childSuffixOpts.icon
            }), childSuffixOpts.content ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', `${childSuffixOpts.content}`) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])])]);
          })) : null]);
        }));
      }))]);
    };
    $xeMenuPanel.renderVN = renderVN;
    return $xeMenuPanel;
  },
  render() {
    return this.renderVN();
  }
}));
;// ./packages/table/src/table.ts
const{getConfig: table_getConfig,getIcon: table_getIcon,getI18n: table_getI18n,renderer: table_renderer,formats: table_formats,createEvent,globalResize: table_globalResize,interceptor: table_interceptor,hooks: table_hooks,globalEvents: table_globalEvents,GLOBAL_EVENT_KEYS,useFns,renderEmptyElement: table_renderEmptyElement}=core_.VxeUI;const supportMaxRow=5e6;const customStorageKey='VXE_CUSTOM_STORE';const maxYHeight=5e6;const maxXWidth=5e6;/* harmony default export */ var table = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({name:'VxeTable',props:src_props,emits:emits,setup(props,context){const{slots,emit}=context;const xID=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();const browseObj=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().browse();// 使用已安装的组件，如果未安装则不渲染
const VxeUILoadingComponent=core_.VxeUI.getComponent('VxeLoading');const VxeUITooltipComponent=core_.VxeUI.getComponent('VxeTooltip');const $xeTabs=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTabs',null);const{computeSize}=useFns.useSize(props);const reactData=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({// 低性能的静态列
staticColumns:[],// 渲染的列分组
tableGroupColumn:[],// 可视区渲染的列
tableColumn:[],// 渲染中的数据
tableData:[],// 是否启用了横向 X 可视渲染方式加载
scrollXLoad:false,// 是否启用了纵向 Y 可视渲染方式加载
scrollYLoad:false,// 是否存在纵向滚动条
overflowY:true,// 是否存在横向滚动条
overflowX:false,// 纵向滚动条的宽度
scrollbarWidth:0,// 横向滚动条的高度
scrollbarHeight:0,// 最后滚动时间戳
lastScrollTime:0,// 行高
rowHeight:0,// 表格父容器的高度
parentHeight:0,// 是否使用分组表头
isGroup:false,isAllOverflow:false,// 复选框属性，是否全选
isAllSelected:false,// 复选框属性，有选中且非全选状态
isIndeterminate:false,// 当前行
currentRow:null,// 单选框属性，选中列
currentColumn:null,// 单选框属性，选中行
selectRadioRow:null,// 表尾合计数据
footerTableData:[],// 行分组列信息
rowGroupColumn:null,// 展开列信息
expandColumn:null,// 树节点列信息
treeNodeColumn:null,hasFixedColumn:false,// 刷新列标识，当列筛选被改变时，触发表格刷新数据
upDataFlag:0,// 刷新列标识，当列的特定属性被改变时，触发表格刷新列
reColumnFlag:0,// 初始化标识
initStore:{filter:false,import:false,export:false,custom:false},// 自定义列相关的信息
customStore:{btnEl:null,isAll:false,isIndeterminate:false,activeBtn:false,activeWrapper:false,visible:false,maxHeight:0,oldSortMaps:{},oldFixedMaps:{},oldVisibleMaps:{}},customColumnList:[],// 当前选中的筛选列
filterStore:{isAllSelected:false,isIndeterminate:false,style:null,options:[],column:null,multiple:false,visible:false,maxHeight:null},// 存放列相关的信息
columnStore:{leftList:[],centerList:[],rightList:[],resizeList:[],pxList:[],pxMinList:[],autoMinList:[],scaleList:[],scaleMinList:[],autoList:[],remainList:[]},// 存放快捷菜单的信息
ctxMenuStore:{selected:null,visible:false,showChild:false,selectChild:null,list:[],style:null},// 存放可编辑相关信息
editStore:{indexs:{columns:[]},titles:{columns:[]},// 选中源
selected:{row:null,column:null},// 已复制源
copyed:{cut:false,rows:[],columns:[]},// 激活
actived:{row:null,column:null},// 当前被强制聚焦单元格，只会在鼠标点击后算聚焦
focused:{row:null,column:null}},// 存放 tooltip 相关信息
tooltipStore:{row:null,column:null,content:null,visible:false,currOpts:{}},// 存放数据校验相关信息
validStore:{visible:false},validErrorMaps:{},// 导入相关信息
importStore:{inited:false,file:null,type:'',modeList:[],typeList:[],filename:'',visible:false},importParams:{mode:'',types:null,message:true},// 导出相关信息
exportStore:{inited:false,name:'',modeList:[],typeList:[],columns:[],isPrint:false,hasFooter:false,hasMerge:false,hasTree:false,hasColgroup:false,visible:false},exportParams:{filename:'',sheetName:'',mode:'',type:'',isColgroup:false,isMerge:false,isAllExpand:false,useStyle:false,original:false,message:true,isHeader:false,isTitle:false,isFooter:false},visiblwRowsFlag:1,isRowGroupStatus:false,rowGroupList:[],rowGroupExpandedFlag:1,rowExpandedFlag:1,treeExpandedFlag:1,updateCheckboxFlag:1,pendingRowFlag:1,insertRowFlag:1,removeRowFlag:1,mergeBodyFlag:1,mergeFootFlag:1,rowHeightStore:{large:52,default:48,medium:44,small:40,mini:36},scrollVMLoading:false,scrollYHeight:0,scrollYTop:0,isScrollYBig:false,scrollXLeft:0,scrollXWidth:0,isScrollXBig:false,rowExpandHeightFlag:1,calcCellHeightFlag:1,resizeHeightFlag:1,resizeWidthFlag:1,isCustomStatus:false,isDragRowMove:false,dragRow:null,isDragColMove:false,dragCol:null,dragTipText:'',isDragResize:false,isRowLoading:false,isColLoading:false});const internalData={tZindex:0,elemStore:{},// 存放横向 X 虚拟滚动相关的信息
scrollXStore:{preloadSize:0,offsetSize:0,visibleSize:0,visibleStartIndex:0,visibleEndIndex:0,startIndex:0,endIndex:0},// 存放纵向 Y 虚拟滚动相关信息
scrollYStore:{preloadSize:0,offsetSize:0,visibleSize:0,visibleStartIndex:0,visibleEndIndex:0,startIndex:0,endIndex:0},// 表格宽度
tableWidth:0,// 表格高度
tableHeight:0,// 表头高度
headerHeight:0,// 表尾高度
footerHeight:0,customHeight:0,customMinHeight:0,customMaxHeight:0,// 当前 hover 行
hoverRow:null,// 最后滚动位置
lastScrollLeft:0,lastScrollTop:0,// 单选框属性，已选中保留的行
radioReserveRow:null,// 复选框属性，已选中保留的行集合
checkboxReserveRowMap:{},// 行数据，已展开保留的行集合
rowExpandedReserveRowMap:{},// 树结构数据，已展开保留的行集合
treeExpandedReserveRowMap:{},// 树结构数据，不确定状态的集合
treeIndeterminateRowMaps:{},// 列表完整数据、条件处理后
tableFullData:[],afterFullData:[],afterTreeFullData:[],afterGroupFullData:[],// 列表条件处理后数据集合
afterFullRowMaps:{},// 树结构完整数据、条件处理后
tableFullTreeData:[],// 行分组全量数据、条件处理后
tableFullGroupData:[],tableSynchData:[],tableSourceData:[],// 收集的列配置（带分组）
collectColumn:[],// 完整所有列（不带分组）
tableFullColumn:[],// 渲染所有列
visibleColumn:[],// 全量数据集（包括当前和已删除）
fullAllDataRowIdData:{},// 数据集（仅当前）
fullDataRowIdData:{},// 数据集（仅可视）
visibleDataRowIdData:{},// 渲染中缓存数据
sourceDataRowIdData:{},fullColumnIdData:{},fullColumnFieldData:{},// 合并单元格的数据
mergeBodyList:[],mergeBodyMaps:{},// 合并表尾的数据
mergeFooterList:[],mergeFooterMaps:{},// 已合并单元格数据集合
mergeBodyCellMaps:{},// 已合并表尾数据集合
mergeFooterCellMaps:{},// 已展开的行集合
rowExpandedMaps:{},// 懒加载中的展开行的集合
rowExpandLazyLoadedMaps:{},// 已展开的分组行
rowGroupExpandedMaps:{},// 已展开树节点集合
treeExpandedMaps:{},// 懒加载中的树节点的集合
treeExpandLazyLoadedMaps:{},// 复选框属性，已选中的行集合
selectCheckboxMaps:{},// 已标记的对象集
pendingRowMaps:{},// 已新增的临时行
insertRowMaps:{},// 已删除行
removeRowMaps:{},cvCacheMaps:{},inited:false,tooltipTimeout:null,initStatus:false,isActivated:false};let tableMethods={};let tablePrivateMethods={};const refElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refVarElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTooltip=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refCommTooltip=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refValidTooltip=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableMenu=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableFilter=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableCustom=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableViewportElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableHeader=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableBody=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableFooter=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableLeftHeader=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableLeftBody=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableLeftFooter=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableRightHeader=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableRightBody=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableRightFooter=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refLeftContainer=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refRightContainer=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refColResizeBar=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refRowResizeBar=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refEmptyPlaceholder=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refDragTipElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refDragRowLineElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refDragColLineElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refRowExpandElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refRowExpandYSpaceElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollXVirtualElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollYVirtualElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollXHandleElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollXLeftCornerElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollXRightCornerElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollYHandleElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollYTopCornerElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollXWrapperElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollYWrapperElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollYBottomCornerElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollXSpaceElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollYSpaceElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const $xeGrid=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeGrid',null);let $xeToolbar;const computeTableId=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{id}=props;if(id){if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(id)){return`${id({$table:$xeTable,$grid:$xeGrid})||''}`;}return`${id}`;}return'';});const computeValidOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.validConfig,props.validConfig);});/**
         * @deprecated
         */const computeSXOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const virtualXOpts=computeVirtualXOpts.value;return virtualXOpts;});const computeScrollXThreshold=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const virtualXOpts=computeVirtualXOpts.value;const{threshold}=virtualXOpts;if(threshold){return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(threshold);}return 0;});/**
         * @deprecated
         */const computeSYOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const virtualYOpts=computeVirtualYOpts.value;return virtualYOpts;});const computeVirtualXOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.scrollX,table_getConfig().table.virtualXConfig,props.scrollX,props.virtualXConfig);});const computeVirtualYOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.scrollY,table_getConfig().table.virtualYConfig,props.scrollY,props.virtualYConfig);});const computeScrollbarOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.scrollbarConfig,props.scrollbarConfig);});const computeScrollbarXToTop=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const scrollbarOpts=computeScrollbarOpts.value;return!!(scrollbarOpts.x&&scrollbarOpts.x.position==='top');});const computeScrollbarYToLeft=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const scrollbarOpts=computeScrollbarOpts.value;return!!(scrollbarOpts.y&&scrollbarOpts.y.position==='left');});const computeScrollYThreshold=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const virtualYOpts=computeVirtualYOpts.value;const{threshold}=virtualYOpts;if(threshold){return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(threshold);}return 0;});const computeRowHeightMaps=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return reactData.rowHeightStore;});const computeDefaultRowHeight=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const vSize=computeSize.value;const rowHeightMaps=computeRowHeightMaps.value;return rowHeightMaps[vSize||'default']||18;});const computeColumnOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.columnConfig,props.columnConfig);});const computeCurrentColumnOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.currentColumnConfig,props.currentColumnConfig);});const computeCellOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const cellOpts=Object.assign({},table_getConfig().table.cellConfig,props.cellConfig);if(cellOpts.height){cellOpts.height=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellOpts.height);}return cellOpts;});const computeHeaderCellOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const headerCellOpts=Object.assign({},table_getConfig().table.headerCellConfig,props.headerCellConfig);const cellOpts=computeCellOpts.value;headerCellOpts.height=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getCellHeight(headerCellOpts.height||cellOpts.height));return headerCellOpts;});const computeFooterCellOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const footerCellOpts=Object.assign({},table_getConfig().table.footerCellConfig,props.footerCellConfig);const cellOpts=computeCellOpts.value;footerCellOpts.height=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getCellHeight(footerCellOpts.height||cellOpts.height));return footerCellOpts;});const computeRowOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.rowConfig,props.rowConfig);});const computeRowGroupOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.rowGroupConfig,props.rowGroupConfig);});const computeCurrentRowOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.currentRowConfig,props.currentRowConfig);});const computeRowDragOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.rowDragConfig,props.rowDragConfig);});const computeColumnDragOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.columnDragConfig,props.columnDragConfig);});const computeResizeOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.resizeConfig,props.resizeConfig);});const computeResizableOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.resizableConfig,props.resizableConfig);});const computeSeqOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({startIndex:0},table_getConfig().table.seqConfig,props.seqConfig);});const computeRadioOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.radioConfig,props.radioConfig);});const computeCheckboxOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.checkboxConfig,props.checkboxConfig);});const computeTooltipOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().tooltip,table_getConfig().table.tooltipConfig,props.tooltipConfig);});const computeTableTipConfig=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{tooltipStore}=reactData;const tooltipOpts=computeTooltipOpts.value;return Object.assign({},tooltipOpts,tooltipStore.currOpts);});const computeValidTipConfig=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const tooltipOpts=computeTooltipOpts.value;return Object.assign({},tooltipOpts);});const computeEditOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.editConfig,props.editConfig);});const computeSortOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({orders:['asc','desc',null]},table_getConfig().table.sortConfig,props.sortConfig);});const computeFilterOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.filterConfig,props.filterConfig);});const computeMouseOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.mouseConfig,props.mouseConfig);});const computeAreaOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.areaConfig,props.areaConfig);});const computeKeyboardOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.keyboardConfig,props.keyboardConfig);});const computeClipOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.clipConfig,props.clipConfig);});const computeFNROpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.fnrConfig,props.fnrConfig);});const computeMenuOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.menuConfig,props.menuConfig);});const computeLeftFixedWidth=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{columnStore}=reactData;const{leftList}=columnStore;let leftWidth=0;for(let i=0;i<leftList.length;i++){const column=leftList[i];leftWidth+=column.renderWidth;}return leftWidth;});const computeRightFixedWidth=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{columnStore}=reactData;const{rightList}=columnStore;let leftWidth=0;for(let i=0;i<rightList.length;i++){const column=rightList[i];leftWidth+=column.renderWidth;}return leftWidth;});const computeHeaderMenu=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const menuOpts=computeMenuOpts.value;const headerOpts=menuOpts.header;return headerOpts&&headerOpts.options?headerOpts.options:[];});const computeBodyMenu=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const menuOpts=computeMenuOpts.value;const bodyOpts=menuOpts.body;return bodyOpts&&bodyOpts.options?bodyOpts.options:[];});const computeFooterMenu=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const menuOpts=computeMenuOpts.value;const footerOpts=menuOpts.footer;return footerOpts&&footerOpts.options?footerOpts.options:[];});const computeIsMenu=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const menuOpts=computeMenuOpts.value;const headerMenu=computeHeaderMenu.value;const bodyMenu=computeBodyMenu.value;const footerMenu=computeFooterMenu.value;return!!(props.menuConfig&&isEnableConf(menuOpts)&&(headerMenu.length||bodyMenu.length||footerMenu.length));});const computeMenuList=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{ctxMenuStore}=reactData;const rest=[];ctxMenuStore.list.forEach(list=>{list.forEach(item=>{rest.push(item);});});return rest;});const computeExportOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.exportConfig,props.exportConfig);});const computeImportOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.importConfig,props.importConfig);});const computePrintOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.printConfig,props.printConfig);});const computeExpandOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.expandConfig,props.expandConfig);});const computeTreeOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.treeConfig,props.treeConfig);});const computeEmptyOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.emptyRender,props.emptyRender);});const computeLoadingOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.loadingConfig,props.loadingConfig);});const computeCellOffsetWidth=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return props.border?Math.max(2,Math.ceil(reactData.scrollbarWidth/reactData.tableColumn.length)):1;});const computeCustomOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.customConfig,props.customConfig);});const computeTableRowExpandedList=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{treeConfig}=props;const{rowExpandedFlag,expandColumn,rowGroupExpandedFlag,treeExpandedFlag,isRowGroupStatus}=reactData;const{visibleDataRowIdData,rowExpandedMaps}=internalData;const treeOpts=computeTreeOpts.value;const{transform}=treeOpts;const expandList=[];if(expandColumn&&rowExpandedFlag&&rowGroupExpandedFlag&&treeExpandedFlag){if(isRowGroupStatus||treeConfig&&transform){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(rowExpandedMaps,(row,rowid)=>{if(visibleDataRowIdData[rowid]){expandList.push(row);}});}else{return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().values(rowExpandedMaps);}}return expandList;});const computeAutoWidthColumnList=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{visibleColumn}=internalData;const{tableColumn}=reactData;return tableColumn.length||visibleColumn.length?visibleColumn.filter(column=>column.width==='auto'||column.minWidth==='auto'):[];});const computeFixedColumnSize=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{tableColumn}=reactData;const{collectColumn}=internalData;let fixedSize=0;// 只判断第一层
if(tableColumn.length&&collectColumn.length){collectColumn.forEach(column=>{if(column.renderFixed){fixedSize++;}});}return fixedSize;});const computeIsMaxFixedColumn=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const fixedColumnSize=computeFixedColumnSize.value;const columnOpts=computeColumnOpts.value;const{maxFixedSize}=columnOpts;if(maxFixedSize){return fixedColumnSize>=maxFixedSize;}return false;});const computeTableBorder=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{border}=props;if(border===true){return'full';}if(border){return border;}return'default';});const computeIsAllCheckboxDisabled=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{treeConfig}=props;const{tableData}=reactData;const{tableFullData}=internalData;const checkboxOpts=computeCheckboxOpts.value;const{strict,checkMethod}=checkboxOpts;if(strict){if(tableData.length||tableFullData.length){if(checkMethod){if(treeConfig){// 暂时不支持树形结构
}// 如果所有行都被禁用
return tableFullData.every(row=>!checkMethod({$table:$xeTable,row}));}return false;}return true;}return false;});const computeVirtualScrollBars=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{overflowX,scrollXLoad,overflowY,scrollYLoad}=reactData;return{x:overflowX&&scrollXLoad,y:overflowY&&scrollYLoad};});const computeRowGroupFields=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const rowGroupOpts=computeRowGroupOpts.value;return rowGroupOpts.groupFields;});const refMaps={refElem,refTooltip,refValidTooltip,refTableFilter,refTableCustom,refTableMenu,refTableHeader,refTableBody,refTableFooter,refTableLeftHeader,refTableLeftBody,refTableLeftFooter,refTableRightHeader,refTableRightBody,refTableRightFooter,refLeftContainer,refRightContainer,refColResizeBar,refRowResizeBar,refScrollXVirtualElem,refScrollYVirtualElem,refScrollXHandleElem,refScrollYHandleElem,refScrollXSpaceElem,refScrollYSpaceElem};const computeMaps={computeSize,computeTableId,computeValidOpts,computeVirtualXOpts,computeVirtualYOpts,computeScrollbarOpts,computeScrollbarXToTop,computeScrollbarYToLeft,computeColumnOpts,computeCurrentColumnOpts,computeScrollXThreshold,computeScrollYThreshold,computeRowHeightMaps,computeDefaultRowHeight,computeCellOpts,computeHeaderCellOpts,computeFooterCellOpts,computeRowOpts,computeRowGroupOpts,computeCurrentRowOpts,computeRowDragOpts,computeColumnDragOpts,computeResizeOpts,computeResizableOpts,computeSeqOpts,computeRadioOpts,computeCheckboxOpts,computeTooltipOpts,computeEditOpts,computeSortOpts,computeFilterOpts,computeMouseOpts,computeAreaOpts,computeKeyboardOpts,computeClipOpts,computeFNROpts,computeHeaderMenu,computeBodyMenu,computeFooterMenu,computeIsMenu,computeMenuList,computeMenuOpts,computeExportOpts,computeImportOpts,computePrintOpts,computeExpandOpts,computeTreeOpts,computeEmptyOpts,computeLoadingOpts,computeCellOffsetWidth,computeCustomOpts,computeLeftFixedWidth,computeRightFixedWidth,computeFixedColumnSize,computeIsMaxFixedColumn,computeIsAllCheckboxDisabled,computeVirtualScrollBars,computeSXOpts,computeSYOpts};const $xeTable={xID,props:props,context,reactData,internalData,getRefMaps:()=>refMaps,getComputeMaps:()=>computeMaps,xeGrid:$xeGrid,xegrid:$xeGrid};const eqCellValue=(row1,row2,field)=>{const val1=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row1,field);const val2=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row2,field);if(eqEmptyValue(val1)&&eqEmptyValue(val2)){return true;}if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(val1)||external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(val1)){return''+val1===''+val2;}return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val1,val2);};const getNextSortOrder=column=>{const sortOpts=computeSortOpts.value;const{orders}=sortOpts;const currOrder=column.order||null;const oIndex=orders.indexOf(currOrder)+1;return orders[oIndex<orders.length?oIndex:0];};const getCustomStorageMap=id=>{const version=table_getConfig().version;const rest=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringJSON(localStorage.getItem(customStorageKey)||'');const maps=rest&&rest._v===version?rest:{_v:version};return(id?maps[id]:maps)||{};};const setCustomStorageMap=(id,data)=>{const version=table_getConfig().version;const maps=getCustomStorageMap();maps[id]=data||undefined;maps._v=version;localStorage.setItem(customStorageKey,external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toJSONString(maps));};const getRecoverRowMaps=keyMaps=>{const{fullAllDataRowIdData}=internalData;const restKeys={};external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(keyMaps,(row,rowid)=>{if(fullAllDataRowIdData[rowid]){restKeys[rowid]=row;}});return restKeys;};const handleReserveRow=reserveRowMap=>{const{fullDataRowIdData}=internalData;const reserveList=[];external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(reserveRowMap,(item,rowid)=>{if(fullDataRowIdData[rowid]&&$xeTable.findRowIndexOf(reserveList,fullDataRowIdData[rowid].row)===-1){reserveList.push(fullDataRowIdData[rowid].row);}});return reserveList;};const handleVirtualXVisible=()=>{const{isScrollXBig,scrollXWidth}=reactData;const{elemStore,visibleColumn,fullColumnIdData}=internalData;const leftFixedWidth=computeLeftFixedWidth.value;const rightFixedWidth=computeRightFixedWidth.value;const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);if(bodyScrollElem){const clientWidth=bodyScrollElem.clientWidth;let scrollLeft=bodyScrollElem.scrollLeft;if(isScrollXBig){scrollLeft=Math.ceil((scrollXWidth-clientWidth)*Math.min(1,scrollLeft/(maxXWidth-clientWidth)));}const startLeft=scrollLeft+leftFixedWidth;const endLeft=scrollLeft+clientWidth-rightFixedWidth;let leftIndex=0;let rightIndex=visibleColumn.length;while(leftIndex<rightIndex){const cIndex=Math.floor((leftIndex+rightIndex)/2);const column=visibleColumn[cIndex];const colid=column.id;const colRest=fullColumnIdData[colid]||{};if(colRest.oLeft<=startLeft){leftIndex=cIndex+1;}else{rightIndex=cIndex;}}let visibleSize=0;const toVisibleIndex=Math.max(0,leftIndex<visibleColumn.length?leftIndex-2:0);for(let cIndex=toVisibleIndex,cLen=visibleColumn.length;cIndex<cLen;cIndex++){const column=visibleColumn[cIndex];const colid=column.id;const colRest=fullColumnIdData[colid]||{};visibleSize++;if(colRest.oLeft>endLeft||visibleSize>=60){break;}}return{toVisibleIndex:Math.max(0,toVisibleIndex),visibleSize:Math.max(1,visibleSize)};}return{toVisibleIndex:0,visibleSize:6};};const calcVarRowHeightConfig=(sizeKey,sizeEl)=>{const{rowHeightStore}=reactData;if(sizeEl&&sizeEl.clientHeight){rowHeightStore[sizeKey]=sizeEl.clientHeight;}};const computeRowHeight=()=>{const{isAllOverflow}=reactData;const tableHeader=refTableHeader.value;const tableBody=refTableBody.value;const tableBodyElem=tableBody?tableBody.$el:null;const defaultRowHeight=computeDefaultRowHeight.value;let rowHeight=0;if(isAllOverflow){if(tableBodyElem){const tableHeaderElem=tableHeader?tableHeader.$el:null;let firstTrElem;firstTrElem=tableBodyElem.querySelector('tr');if(!firstTrElem&&tableHeaderElem){firstTrElem=tableHeaderElem.querySelector('tr');}if(firstTrElem){rowHeight=firstTrElem.clientHeight;}}if(!rowHeight){rowHeight=defaultRowHeight;}}else{rowHeight=defaultRowHeight;}// 最低支持 18px 行高
return Math.max(18,rowHeight);};const handleVirtualYVisible=()=>{const{isAllOverflow,expandColumn,isScrollYBig,scrollYHeight}=reactData;const{elemStore,isResizeCellHeight,afterFullData,fullAllDataRowIdData}=internalData;const rowOpts=computeRowOpts.value;const cellOpts=computeCellOpts.value;const defaultRowHeight=computeDefaultRowHeight.value;const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);if(bodyScrollElem){const clientHeight=bodyScrollElem.clientHeight;let scrollTop=bodyScrollElem.scrollTop;if(isScrollYBig){scrollTop=Math.ceil((scrollYHeight-clientHeight)*Math.min(1,scrollTop/(maxYHeight-clientHeight)));}const startTop=scrollTop;const endTop=scrollTop+clientHeight;let toVisibleIndex=-1;let visibleSize=0;const isCustomCellHeight=isResizeCellHeight||cellOpts.height||rowOpts.height;if(!isCustomCellHeight&&!expandColumn&&isAllOverflow){toVisibleIndex=Math.floor(startTop/defaultRowHeight)-1;visibleSize=Math.ceil(clientHeight/defaultRowHeight)+1;}else{const{handleGetRowId}=createHandleGetRowId($xeTable);let leftIndex=0;let rightIndex=afterFullData.length;while(leftIndex<rightIndex){const rIndex=Math.floor((leftIndex+rightIndex)/2);const row=afterFullData[rIndex];const rowid=handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid]||{};if(rowRest.oTop<=startTop){leftIndex=rIndex+1;}else{rightIndex=rIndex;}}toVisibleIndex=Math.max(0,leftIndex<afterFullData.length?leftIndex-2:0);for(let rIndex=toVisibleIndex,rLen=afterFullData.length;rIndex<rLen;rIndex++){const row=afterFullData[rIndex];const rowid=handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid]||{};visibleSize++;if(rowRest.oTop>endTop||visibleSize>=100){break;}}}return{toVisibleIndex:Math.max(0,toVisibleIndex),visibleSize:Math.max(6,visibleSize)};}return{toVisibleIndex:0,visibleSize:6};};const calculateMergerOffsetIndex=(list,offsetItem,type)=>{for(let mcIndex=0,len=list.length;mcIndex<len;mcIndex++){const mergeItem=list[mcIndex];const{startIndex,endIndex}=offsetItem;const mergeStartIndex=mergeItem[type];const mergeSpanNumber=mergeItem[type+'span'];const mergeEndIndex=mergeStartIndex+mergeSpanNumber;if(mergeStartIndex<startIndex&&startIndex<mergeEndIndex){offsetItem.startIndex=mergeStartIndex;}if(mergeStartIndex<endIndex&&endIndex<mergeEndIndex){offsetItem.endIndex=mergeEndIndex;}if(offsetItem.startIndex!==startIndex||offsetItem.endIndex!==endIndex){mcIndex=-1;}}};function buildMergeData(mergeConfigs){const mergeMaps={};if(mergeConfigs&&mergeConfigs.length){for(let mIndex=0;mIndex<mergeConfigs.length;mIndex++){const{row:_rowIndex,col:_columnIndex,rowspan:mergeRowspan,colspan:mergeColspan}=mergeConfigs[mIndex];for(let i=0;i<mergeRowspan;i++){for(let j=0;j<mergeColspan;j++){mergeMaps[`${_rowIndex+i}:${_columnIndex+j}`]=!i&&!j?{rowspan:mergeRowspan,colspan:mergeColspan}:{rowspan:0,colspan:0};}}}}return mergeMaps;}const handleBodyMerge=merges=>{const{fullAllDataRowIdData,fullColumnIdData,visibleColumn,afterFullData,mergeBodyList,mergeBodyMaps}=internalData;if(merges){const{handleGetRowId}=createHandleGetRowId($xeTable);if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(merges)){merges=[merges];}merges.forEach(item=>{let{row:margeRow,col:margeCol,rowspan,colspan}=item;let mergeRowIndex=-1;let mergeColumnIndex=-1;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeRow)){mergeRowIndex=margeRow;}else{const rowid=margeRow?handleGetRowId(margeRow):null;const rowRest=rowid?fullAllDataRowIdData[rowid]:null;if(rowRest){mergeRowIndex=rowRest._index;}}if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeCol)){mergeColumnIndex=margeCol;}else{const colid=margeCol?margeCol.id:null;const colRest=colid?fullColumnIdData[colid]:null;if(colRest){mergeColumnIndex=colRest._index;}}if(mergeRowIndex>-1&&mergeColumnIndex>-1&&(rowspan||colspan)){rowspan=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(rowspan)||1;colspan=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(colspan)||1;if(rowspan>1||colspan>1){const row=afterFullData[mergeRowIndex];const column=visibleColumn[mergeColumnIndex];let mergeItem=mergeBodyMaps[`${mergeRowIndex}:${mergeColumnIndex}`];if(mergeItem){mergeItem.rowspan=rowspan;mergeItem.colspan=colspan;mergeItem._rowspan=rowspan;mergeItem._colspan=colspan;}else{mergeItem={row:mergeRowIndex,col:mergeColumnIndex,rowspan,colspan,_row:row,_col:column,_rowspan:rowspan,_colspan:colspan};mergeBodyMaps[`${mergeRowIndex}:${mergeColumnIndex}`]=mergeItem;mergeBodyList.push(mergeItem);}}}});}};const handleFooterMerge=merges=>{const{footerTableData}=reactData;const{mergeFooterList,mergeFooterMaps}=internalData;if(merges){const{visibleColumn}=internalData;if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(merges)){merges=[merges];}merges.forEach(item=>{let{row:margeRow,col:margeCol,rowspan,colspan}=item;const mergeRowIndex=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeRow)?margeRow:-1;let mergeColumnIndex=-1;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeCol)){mergeColumnIndex=margeCol;}if(mergeRowIndex>-1&&mergeColumnIndex>-1&&(rowspan||colspan)){rowspan=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(rowspan)||1;colspan=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(colspan)||1;if(rowspan>1||colspan>1){const row=footerTableData[mergeRowIndex];const column=visibleColumn[mergeColumnIndex];let mergeItem=mergeFooterMaps[`${mergeRowIndex}:${mergeColumnIndex}`];if(mergeItem){mergeItem.rowspan=rowspan;mergeItem.colspan=colspan;mergeItem._rowspan=rowspan;mergeItem._colspan=colspan;}else{mergeItem={row:mergeRowIndex,col:mergeColumnIndex,rowspan,colspan,_row:row,_col:column,_rowspan:rowspan,_colspan:colspan};mergeFooterMaps[`${mergeRowIndex}:${mergeColumnIndex}`]=mergeItem;mergeFooterList.push(mergeItem);}}}});}};const removeMerges=(merges,mList,rowList)=>{const rest=[];if(merges){// const { treeConfig } = props
const{visibleColumn}=internalData;if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(merges)){merges=[merges];}// if (treeConfig && merges.length) {
//   errLog('vxe.error.noTree', ['merge-cells | merge-footer-items'])
// }
merges.forEach(item=>{let{row,col}=item;if(rowList&&external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(row)){row=rowList[row];}if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(col)){col=visibleColumn[col];}const mcIndex=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(mList,item=>(item._row===row||getRowid($xeTable,item._row)===getRowid($xeTable,row))&&(item._col.id===col||item._col.id===col.id));if(mcIndex>-1){const rItems=mList.splice(mcIndex,1);rest.push(rItems[0]);}});}return rest;};const clearAllSort=()=>{const{tableFullColumn}=internalData;tableFullColumn.forEach(column=>{column.order=null;});};const calcTableHeight=key=>{const{parentHeight}=reactData;const val=props[key];let num=0;if(val){if(val==='100%'||val==='auto'){num=parentHeight;}else{const excludeHeight=$xeTable.getExcludeHeight();if(isScale(val)){num=Math.floor((external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(val)||1)/100*parentHeight);}else{num=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(val);}num=Math.max(40,num-excludeHeight);}}return num;};const handleCustomRestore=storeData=>{let{collectColumn}=internalData;const{resizableData,sortData,visibleData,fixedData}=storeData;let hasCustomSort=false;// 处理还原
if(resizableData||sortData||visibleData||fixedData){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn,(column,index,items,path,parentColumn)=>{const colKey=column.getKey();// 支持一级
if(!parentColumn){if(fixedData&&fixedData[colKey]!==undefined){column.fixed=fixedData[colKey];}if(sortData&&external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(sortData[colKey])){hasCustomSort=true;column.renderSortNumber=sortData[colKey];}}if(resizableData&&external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(resizableData[colKey])){column.resizeWidth=resizableData[colKey];}if(visibleData&&external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(visibleData[colKey])){column.visible=visibleData[colKey];}});// 如果自定义了顺序
if(hasCustomSort){collectColumn=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(collectColumn,'renderSortNumber');internalData.collectColumn=collectColumn;internalData.tableFullColumn=getColumnList(collectColumn);}reactData.isCustomStatus=true;}else{reactData.isCustomStatus=false;}};/**
         * 还原自定义列操作状态
         */const restoreCustomStorage=()=>{const{customConfig}=props;const tableId=computeTableId.value;const customOpts=computeCustomOpts.value;const{storage,restoreStore}=customOpts;const isAllCustom=storage===true;const storageOpts=isAllCustom?{}:Object.assign({},storage||{});const isCustomResizable=isAllCustom||storageOpts.resizable;const isCustomVisible=isAllCustom||storageOpts.visible;const isCustomFixed=isAllCustom||storageOpts.fixed;const isCustomSort=isAllCustom||storageOpts.sort;if((customConfig?isEnableConf(customOpts):customOpts.enabled)&&(isCustomResizable||isCustomVisible||isCustomFixed||isCustomSort)){if(!tableId){errLog('vxe.error.reqProp',['id']);return;}const storeData=getCustomStorageMap(tableId);if(restoreStore){return Promise.resolve(restoreStore({$table:$xeTable,id:tableId,type:'restore',storeData})).then(storeData=>{if(!storeData){return;}return handleCustomRestore(storeData);}).catch(e=>e);}else{return handleCustomRestore(storeData);}}};/**
         * 更新数据列的 Map
         * 牺牲数据组装的耗时，用来换取使用过程中的流畅
         */const cacheColumnMap=()=>{const{tableFullColumn,collectColumn}=internalData;const fullColumnIdData=internalData.fullColumnIdData={};const fullColumnFieldData=internalData.fullColumnFieldData={};const mouseOpts=computeMouseOpts.value;const expandOpts=computeExpandOpts.value;const columnOpts=computeColumnOpts.value;const columnDragOpts=computeColumnDragOpts.value;const virtualYOpts=computeVirtualYOpts.value;const{isCrossDrag,isSelfToChildDrag}=columnDragOpts;const customOpts=computeCustomOpts.value;const{storage}=customOpts;const rowOpts=computeRowOpts.value;const isGroup=collectColumn.some(hasChildrenList);let isAllOverflow=!!props.showOverflow;let rowGroupColumn;let expandColumn;let treeNodeColumn;let checkboxColumn;let radioColumn;let htmlColumn;let hasFixed;const handleFunc=(column,index,items,path,parentColumn)=>{const{id:colid,field,fixed,type,treeNode,rowGroupNode}=column;const rest={$index:-1,_index:-1,column,colid,index,items,parent:parentColumn||null,width:0,oLeft:0};if(field){if(fullColumnFieldData[field]){errLog('vxe.error.colRepet',['field',field]);}fullColumnFieldData[field]=rest;}else{if(storage&&!type||columnOpts.drag&&(isCrossDrag||isSelfToChildDrag)){errLog('vxe.error.reqProp',[`${column.getTitle()||type||''} -> column.field=?`]);}}if(!hasFixed&&fixed){hasFixed=fixed;}if(!htmlColumn&&type==='html'){htmlColumn=column;}if(treeNode){if(treeNodeColumn){warnLog('vxe.error.colRepet',['tree-node',treeNode]);}if(!treeNodeColumn){treeNodeColumn=column;}}if(rowGroupNode){if(treeNodeColumn){warnLog('vxe.error.colRepet',['row-group-node',rowGroupNode]);}if(!rowGroupColumn){rowGroupColumn=column;}}if(type==='expand'){if(expandColumn){warnLog('vxe.error.colRepet',['type',type]);}if(!expandColumn){expandColumn=column;}}if(type==='checkbox'){if(checkboxColumn){warnLog('vxe.error.colRepet',['type',type]);}if(!checkboxColumn){checkboxColumn=column;}}else if(type==='radio'){if(radioColumn){warnLog('vxe.error.colRepet',['type',type]);}if(!radioColumn){radioColumn=column;}}if(isAllOverflow&&column.showOverflow===false){isAllOverflow=false;}if(fullColumnIdData[colid]){errLog('vxe.error.colRepet',['colId',colid]);}fullColumnIdData[colid]=rest;};if(isGroup){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn,(column,index,items,path,parentColumn,nodes)=>{column.level=nodes.length;handleFunc(column,index,items,path,parentColumn);});}else{tableFullColumn.forEach(handleFunc);}if(expandColumn&&expandOpts.mode!=='fixed'&&virtualYOpts.enabled){warnLog('vxe.error.notConflictProp',['column.type="expand','virtual-y-config.enabled=false']);}if(expandColumn&&expandOpts.mode!=='fixed'&&mouseOpts.area){errLog('vxe.error.errConflicts',['mouse-config.area','column.type=expand']);}if(htmlColumn){if(!columnOpts.useKey){errLog('vxe.error.reqProp',['column-config.useKey & column.type=html']);}if(!rowOpts.useKey){errLog('vxe.error.reqProp',['row-config.useKey & column.type=html']);}}reactData.isGroup=isGroup;reactData.rowGroupColumn=rowGroupColumn;reactData.treeNodeColumn=treeNodeColumn;reactData.expandColumn=expandColumn;reactData.isAllOverflow=isAllOverflow;};const updateHeight=()=>{internalData.customHeight=calcTableHeight('height');internalData.customMinHeight=calcTableHeight('minHeight');internalData.customMaxHeight=calcTableHeight('maxHeight');// 如果启用虚拟滚动，默认高度
if(reactData.scrollYLoad&&!(internalData.customHeight||internalData.customMinHeight)){internalData.customHeight=300;}};const calcColumnAutoWidth=(column,wrapperEl)=>{const cellElemList=wrapperEl.querySelectorAll(`.vxe-cell--wrapper[colid="${column.id}"]`);let leftRightPadding=0;const firstCellEl=cellElemList[0];if(firstCellEl&&firstCellEl.parentElement){const cellStyle=getComputedStyle(firstCellEl.parentElement);leftRightPadding=Math.ceil(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellStyle.paddingLeft)+external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellStyle.paddingRight));}let colWidth=column.renderAutoWidth-leftRightPadding;for(let i=0;i<cellElemList.length;i++){const celEl=cellElemList[i];colWidth=Math.max(colWidth,celEl?Math.ceil(celEl.scrollWidth)+4:0);}return colWidth+leftRightPadding;};const calcCellWidth=()=>{const autoWidthColumnList=computeAutoWidthColumnList.value;const{fullColumnIdData}=internalData;const el=refElem.value;if(el){el.setAttribute('data-calc-col','Y');autoWidthColumnList.forEach(column=>{const colid=column.id;const colRest=fullColumnIdData[colid];const colWidth=calcColumnAutoWidth(column,el);if(colRest){colRest.width=Math.max(colWidth,colRest.width);}column.renderAutoWidth=colWidth;});$xeTable.analyColumnWidth();el.removeAttribute('data-calc-col');}};/**
         * 列宽算法，计算单元格列宽，动态分配可用剩余空间
         * 支持 px、%、固定 混合分配
         * 支持动态列表调整分配
         * 支持自动分配偏移量
         * 支持 width=60 width=60px width=10% min-width=60 min-width=60px min-width=10%
         */const autoCellWidth=()=>{const{elemStore}=internalData;const bodyWrapperElem=getRefElem(elemStore['main-body-wrapper']);if(!bodyWrapperElem){return;}const yHandleEl=refScrollYHandleElem.value;if(!yHandleEl){return;}const xHandleEl=refScrollXHandleElem.value;if(!xHandleEl){return;}let tWidth=0;const minCellWidth=40;// 列宽最少限制 40px
const bodyWidth=bodyWrapperElem.clientWidth;let remainWidth=bodyWidth;let meanWidth=remainWidth/100;const{fit}=props;const{columnStore}=reactData;const{resizeList,pxMinList,autoMinList,pxList,scaleList,scaleMinList,autoList,remainList}=columnStore;// 最小宽
pxMinList.forEach(column=>{const minWidth=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.minWidth);tWidth+=minWidth;column.renderWidth=minWidth;});// 最小自适应
autoMinList.forEach(column=>{const caWidth=Math.max(60,external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.renderAutoWidth));tWidth+=caWidth;column.renderWidth=caWidth;});// 最小百分比
scaleMinList.forEach(column=>{const smWidth=Math.floor(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.minWidth)*meanWidth);tWidth+=smWidth;column.renderWidth=smWidth;});// 固定百分比
scaleList.forEach(column=>{const sfWidth=Math.floor(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.width)*meanWidth);tWidth+=sfWidth;column.renderWidth=sfWidth;});// 固定宽
pxList.forEach(column=>{const pWidth=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.width);tWidth+=pWidth;column.renderWidth=pWidth;});// 自适应宽
autoList.forEach(column=>{const aWidth=Math.max(60,external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.renderAutoWidth));tWidth+=aWidth;column.renderWidth=aWidth;});// 调整了列宽
resizeList.forEach(column=>{const reWidth=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.resizeWidth);tWidth+=reWidth;column.renderWidth=reWidth;});remainWidth-=tWidth;meanWidth=remainWidth>0?Math.floor(remainWidth/(scaleMinList.length+pxMinList.length+autoMinList.length+remainList.length)):0;if(fit){if(remainWidth>0){scaleMinList.concat(pxMinList).concat(autoMinList).forEach(column=>{tWidth+=meanWidth;column.renderWidth+=meanWidth;});}}else{meanWidth=minCellWidth;}// 剩余均分
remainList.forEach(column=>{const width=Math.max(meanWidth,minCellWidth);column.renderWidth=width;tWidth+=width;});if(fit){/**
                 * 偏移量算法
                 * 如果所有列足够放的情况下，从最后动态列开始分配
                 */const dynamicList=scaleList.concat(scaleMinList).concat(pxMinList).concat(autoMinList).concat(remainList);let dynamicSize=dynamicList.length-1;if(dynamicSize>0){let i=bodyWidth-tWidth;if(i>0){while(i>0&&dynamicSize>=0){i--;dynamicList[dynamicSize--].renderWidth++;}tWidth=bodyWidth;}}}reactData.scrollXWidth=tWidth;reactData.resizeWidthFlag++;updateColumnOffsetLeft();updateHeight();};const calcCellAutoHeight=(rowRest,wrapperEl)=>{const cellElemList=wrapperEl.querySelectorAll(`.vxe-cell--wrapper[rowid="${rowRest.rowid}"]`);let colHeight=rowRest.height;for(let i=0;i<cellElemList.length;i++){const cellElem=cellElemList[i];const tdEl=cellElem.parentElement;const topBottomPadding=Math.ceil(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(tdEl.style.paddingTop)+external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(tdEl.style.paddingBottom));const cellHeight=cellElem?cellElem.clientHeight:0;colHeight=Math.max(colHeight-topBottomPadding,Math.ceil(cellHeight));}return colHeight;};const calcCellHeight=()=>{const{tableData,isAllOverflow,scrollYLoad,scrollXLoad}=reactData;const{fullAllDataRowIdData}=internalData;const defaultRowHeight=computeDefaultRowHeight.value;const el=refElem.value;if(!isAllOverflow&&scrollYLoad&&el){const{handleGetRowId}=createHandleGetRowId($xeTable);el.setAttribute('data-calc-row','Y');tableData.forEach(row=>{const rowid=handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid];if(rowRest){const reHeight=calcCellAutoHeight(rowRest,el);rowRest.height=Math.max(defaultRowHeight,scrollXLoad?Math.max(rowRest.height,reHeight):reHeight);}el.removeAttribute('data-calc-row');});reactData.calcCellHeightFlag++;}};const getOrderField=column=>{const{sortBy,sortType}=column;return row=>{let cellValue;if(sortBy){cellValue=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(sortBy)?sortBy({row,column}):external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,sortBy);}else{cellValue=tableMethods.getCellLabel(row,column);}if(!sortType||sortType==='auto'){return isNaN(cellValue)?cellValue:external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellValue);}else if(sortType==='number'){return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellValue);}else if(sortType==='string'){return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(cellValue);}return cellValue;};};const updateAfterListIndex=()=>{const{treeConfig}=props;const{afterFullData,fullDataRowIdData,fullAllDataRowIdData}=internalData;const{handleGetRowId}=createHandleGetRowId($xeTable);const fullMaps={};afterFullData.forEach((row,index)=>{const rowid=handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid];const seq=index+1;if(rowRest){if(!treeConfig){rowRest.seq=seq;}rowRest._index=index;}else{const rest={row,rowid,seq,index:-1,$index:-1,_index:index,treeIndex:-1,items:[],parent:null,level:0,height:0,resizeHeight:0,oTop:0,expandHeight:0};fullAllDataRowIdData[rowid]=rest;fullDataRowIdData[rowid]=rest;}fullMaps[rowid]=row;});internalData.afterFullRowMaps=fullMaps;};/**
         * 预编译
         * 对渲染中的数据提前解析序号及索引。牺牲提前编译耗时换取渲染中额外损耗，使运行时更加流畅
         */const updateAfterDataIndex=()=>{const{treeConfig}=props;const{fullDataRowIdData,fullAllDataRowIdData,afterTreeFullData}=internalData;const treeOpts=computeTreeOpts.value;const{transform}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;const fullMaps={};if(treeConfig){const{handleGetRowId}=createHandleGetRowId($xeTable);external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterTreeFullData,(row,index,items,path)=>{const rowid=handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid];const seq=path.map((num,i)=>i%2===0?Number(num)+1:'.').join('');if(rowRest){rowRest.seq=seq;rowRest.treeIndex=index;}else{const rest={row,rowid,seq,index:-1,$index:-1,_index:-1,treeIndex:-1,items:[],parent:null,level:0,height:0,resizeHeight:0,oTop:0,expandHeight:0};fullAllDataRowIdData[rowid]=rest;fullDataRowIdData[rowid]=rest;}fullMaps[rowid]=row;},{children:transform?treeOpts.mapChildrenField:childrenField});internalData.afterFullRowMaps=fullMaps;updateAfterListIndex();}else{updateAfterListIndex();}};/**
         * 如果为虚拟树、行分组、则将树结构拍平
         * @returns
         */const handleVirtualTreeToList=()=>{const{treeConfig}=props;const{isRowGroupStatus}=reactData;const{fullAllDataRowIdData,treeExpandedMaps,rowGroupExpandedMaps}=internalData;const rowGroupOpts=computeRowGroupOpts.value;const treeOpts=computeTreeOpts.value;const{handleGetRowId}=createHandleGetRowId($xeTable);const fullData=[];const expandMaps={};if(treeConfig&&treeOpts.transform){const childrenField=treeOpts.children||treeOpts.childrenField;external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(internalData.afterTreeFullData,(row,index,items,path,parentRow)=>{const rowid=handleGetRowId(row);const parentRowid=handleGetRowId(parentRow);if(!parentRow||expandMaps[parentRowid]&&treeExpandedMaps[parentRowid]){const rowRest=fullAllDataRowIdData[rowid];if(rowRest){rowRest._index=fullData.length;}expandMaps[rowid]=1;fullData.push(row);}},{children:childrenField});internalData.afterFullData=fullData;updateScrollYStatus(fullData);return fullData;}else if(isRowGroupStatus){const{childrenField}=rowGroupOpts;external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(internalData.afterGroupFullData,(row,index,items,path,parentRow)=>{const rowid=handleGetRowId(row);const parentRowid=handleGetRowId(parentRow);if(!parentRow||expandMaps[parentRowid]&&rowGroupExpandedMaps[parentRowid]){const rowRest=fullAllDataRowIdData[rowid];if(rowRest){rowRest._index=fullData.length;}expandMaps[rowid]=1;fullData.push(row);}},{children:childrenField});internalData.afterFullData=fullData;updateScrollYStatus(fullData);return fullData;}return internalData.afterFullData;};/**
         * 编译处理后全量的表格数据
         * 如果存在筛选条件，继续处理
         */const updateAfterFullData=()=>{const{treeConfig}=props;const{isRowGroupStatus}=reactData;const{tableFullColumn,tableFullData,tableFullTreeData,tableFullGroupData}=internalData;const filterOpts=computeFilterOpts.value;const sortOpts=computeSortOpts.value;const rowGroupOpts=computeRowGroupOpts.value;const treeOpts=computeTreeOpts.value;const childrenField=treeOpts.children||treeOpts.childrenField;const{transform,rowField,parentField,mapChildrenField}=treeOpts;const{isEvery,remote:allRemoteFilter,filterMethod:allFilterMethod}=filterOpts;const{remote:allRemoteSort,sortMethod:allSortMethod,multiple:sortMultiple,chronological}=sortOpts;let tableData=[];let tableTree=[];// 处理数据
if(!allRemoteFilter||!allRemoteSort){const filterColumns=[];let orderColumns=[];tableFullColumn.forEach(column=>{const{field,sortable,order,filters}=column;if(!allRemoteFilter&&filters&&filters.length){const valueList=[];const itemList=[];filters.forEach(item=>{if(item.checked){itemList.push(item);valueList.push(item.value);}});if(itemList.length){filterColumns.push({column,valueList,itemList});}}if(!allRemoteSort&&sortable&&order){orderColumns.push({column,field,property:field,order:order,sortTime:column.sortTime});}});if(sortMultiple&&chronological&&orderColumns.length>1){orderColumns=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(orderColumns,'sortTime');}// 处理筛选
// 支持单列、多列、组合筛选
if(!allRemoteFilter&&filterColumns.length){const handleFilter=row=>{return filterColumns.every(({column,valueList,itemList})=>{const{filterMethod,filterRender}=column;const compConf=isEnableConf(filterRender)?table_renderer.get(filterRender.name):null;const compFilterMethod=compConf?compConf.tableFilterMethod||compConf.filterMethod:null;const tdFilterMethod=compConf?compConf.tableFilterDefaultMethod||compConf.defaultTableFilterMethod||compConf.defaultFilterMethod:null;const cellValue=getCellValue(row,column);if(filterMethod){return itemList.some(item=>filterMethod({value:item.value,option:item,cellValue,row,column,$table:$xeTable}));}else if(compFilterMethod){return itemList.some(item=>compFilterMethod({value:item.value,option:item,cellValue,row,column,$table:$xeTable}));}else if(allFilterMethod){return allFilterMethod({$table:$xeTable,options:itemList,values:valueList,cellValue,row,column});}else if(tdFilterMethod){return itemList.some(item=>tdFilterMethod({value:item.value,option:item,cellValue,row,column,$table:$xeTable}));}return valueList.indexOf(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,column.field))>-1;});};if(isRowGroupStatus){// 行分组
tableTree=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(tableFullGroupData,handleFilter,{original:true,isEvery:true,children:rowGroupOpts.mapChildrenField,mapChildren:rowGroupOpts.childrenField});tableData=tableTree;}else if(treeConfig&&transform){// 筛选虚拟树
tableTree=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(tableFullTreeData,handleFilter,{original:true,isEvery,children:mapChildrenField,mapChildren:childrenField});tableData=tableTree;}else{tableData=treeConfig?tableFullTreeData.filter(handleFilter):tableFullData.filter(handleFilter);tableTree=tableData;}}else{if(isRowGroupStatus){// 还原行分组
tableTree=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(tableFullGroupData,()=>true,{original:true,isEvery:true,children:rowGroupOpts.mapChildrenField,mapChildren:rowGroupOpts.childrenField});tableData=tableTree;}else if(treeConfig&&transform){// 还原虚拟树
tableTree=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(tableFullTreeData,()=>true,{original:true,isEvery,children:mapChildrenField,mapChildren:childrenField});tableData=tableTree;}else{tableData=treeConfig?tableFullTreeData.slice(0):tableFullData.slice(0);tableTree=tableData;}}// 处理排序
// 支持单列、多列、组合排序
if(!allRemoteSort&&orderColumns.length){if(isRowGroupStatus){// 行分组的排序
if(allSortMethod){const sortRests=allSortMethod({data:tableTree,sortList:orderColumns,$table:$xeTable});tableTree=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(sortRests)?sortRests:tableTree;}else{const treeList=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toTreeArray(tableTree,{key:rowGroupOpts.rowField,parentKey:rowGroupOpts.parentField,children:rowGroupOpts.mapChildrenField});tableTree=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(treeList,orderColumns.map(({column,order})=>[getOrderField(column),order])),{key:rowGroupOpts.rowField,parentKey:rowGroupOpts.parentField,children:rowGroupOpts.childrenField,mapChildren:rowGroupOpts.mapChildrenField});}tableData=tableTree;}else if(treeConfig&&transform){// 虚拟树的排序
if(allSortMethod){const sortRests=allSortMethod({data:tableTree,sortList:orderColumns,$table:$xeTable});tableTree=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(sortRests)?sortRests:tableTree;}else{const treeList=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toTreeArray(tableTree,{children:mapChildrenField});tableTree=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(treeList,orderColumns.map(({column,order})=>[getOrderField(column),order])),{key:rowField,parentKey:parentField,children:childrenField,mapChildren:mapChildrenField});}tableData=tableTree;}else{if(allSortMethod){const sortRests=allSortMethod({data:tableData,sortList:orderColumns,$table:$xeTable});tableData=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(sortRests)?sortRests:tableData;}else{tableData=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(tableData,orderColumns.map(({column,order})=>[getOrderField(column),order]));}tableTree=tableData;}}}else{if(isRowGroupStatus){// 还原行分组
// 还原虚拟树
tableTree=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(tableFullGroupData,()=>true,{original:true,isEvery:true,children:rowGroupOpts.mapChildrenField,mapChildren:rowGroupOpts.childrenField});tableData=tableTree;}else if(treeConfig&&transform){// 还原虚拟树
tableTree=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(tableFullTreeData,()=>true,{original:true,isEvery,children:mapChildrenField,mapChildren:childrenField});tableData=tableTree;}else{tableData=treeConfig?tableFullTreeData.slice(0):tableFullData.slice(0);tableTree=tableData;}}internalData.afterFullData=tableData;internalData.afterTreeFullData=tableTree;internalData.afterGroupFullData=tableTree;updateAfterDataIndex();};const updateStyle=()=>{const{showHeaderOverflow:allColumnHeaderOverflow,showFooterOverflow:allColumnFooterOverflow,mouseConfig,spanMethod,footerSpanMethod}=props;const{isGroup,currentRow,tableColumn,scrollXLoad,scrollYLoad,overflowX,scrollbarWidth,overflowY,scrollbarHeight,scrollXWidth,columnStore,editStore,isAllOverflow,expandColumn,isColLoading}=reactData;const{visibleColumn,tableHeight,headerHeight,footerHeight,elemStore,customHeight,customMinHeight,customMaxHeight}=internalData;const el=refElem.value;if(!el){return;}const containerList=['main','left','right'];const osbWidth=overflowY?scrollbarWidth:0;const osbHeight=overflowX?scrollbarHeight:0;const emptyPlaceholderElem=refEmptyPlaceholder.value;const mouseOpts=computeMouseOpts.value;const expandOpts=computeExpandOpts.value;const bodyWrapperElem=getRefElem(elemStore['main-body-wrapper']);const bodyTableElem=getRefElem(elemStore['main-body-table']);if(emptyPlaceholderElem){emptyPlaceholderElem.style.top=`${headerHeight}px`;emptyPlaceholderElem.style.height=bodyWrapperElem?`${bodyWrapperElem.offsetHeight-osbHeight}px`:'';}let bodyHeight=0;let bodyMaxHeight=0;const bodyMinHeight=customMinHeight-headerHeight-footerHeight-osbHeight;if(customMaxHeight){bodyMaxHeight=Math.max(bodyMinHeight,customMaxHeight-headerHeight-footerHeight-osbHeight);}if(customHeight){bodyHeight=customHeight-headerHeight-footerHeight-osbHeight;}if(!bodyHeight){if(bodyTableElem){bodyHeight=bodyTableElem.clientHeight;}}if(bodyHeight){if(bodyMaxHeight){bodyHeight=Math.min(bodyMaxHeight,bodyHeight);}bodyHeight=Math.max(bodyMinHeight,bodyHeight);}const scrollbarXToTop=computeScrollbarXToTop.value;const xLeftCornerEl=refScrollXLeftCornerElem.value;const xRightCornerEl=refScrollXRightCornerElem.value;const scrollXVirtualEl=refScrollXVirtualElem.value;if(scrollXVirtualEl){scrollXVirtualEl.style.height=`${osbHeight}px`;scrollXVirtualEl.style.visibility=overflowX?'visible':'hidden';}const xWrapperEl=refScrollXWrapperElem.value;if(xWrapperEl){xWrapperEl.style.left=scrollbarXToTop?`${osbWidth}px`:'';xWrapperEl.style.width=`${el.clientWidth-osbWidth}px`;}if(xLeftCornerEl){xLeftCornerEl.style.width=scrollbarXToTop?`${osbWidth}px`:'';xLeftCornerEl.style.display=scrollbarXToTop?overflowX&&osbHeight?'block':'':'';}if(xRightCornerEl){xRightCornerEl.style.width=scrollbarXToTop?'':`${osbWidth}px`;xRightCornerEl.style.display=scrollbarXToTop?'':overflowX&&osbHeight?'block':'';}const scrollYVirtualEl=refScrollYVirtualElem.value;if(scrollYVirtualEl){scrollYVirtualEl.style.width=`${osbWidth}px`;scrollYVirtualEl.style.height=`${bodyHeight+headerHeight+footerHeight}px`;scrollYVirtualEl.style.visibility=overflowY?'visible':'hidden';}const yTopCornerEl=refScrollYTopCornerElem.value;if(yTopCornerEl){yTopCornerEl.style.height=`${headerHeight}px`;yTopCornerEl.style.display=overflowY&&headerHeight?'block':'';}const yWrapperEl=refScrollYWrapperElem.value;if(yWrapperEl){yWrapperEl.style.height=`${bodyHeight}px`;yWrapperEl.style.top=`${headerHeight}px`;}const yBottomCornerEl=refScrollYBottomCornerElem.value;if(yBottomCornerEl){yBottomCornerEl.style.height=`${footerHeight}px`;yBottomCornerEl.style.top=`${headerHeight+bodyHeight}px`;yBottomCornerEl.style.display=overflowY&&footerHeight?'block':'';}const rowExpandEl=refRowExpandElem.value;if(rowExpandEl){rowExpandEl.style.height=`${bodyHeight}px`;rowExpandEl.style.top=`${headerHeight}px`;}containerList.forEach((name,index)=>{const fixedType=index>0?name:'';const layoutList=['header','body','footer'];const isFixedLeft=fixedType==='left';let fixedColumn=[];let fixedWrapperElem;if(fixedType){fixedColumn=isFixedLeft?columnStore.leftList:columnStore.rightList;fixedWrapperElem=isFixedLeft?refLeftContainer.value:refRightContainer.value;}layoutList.forEach(layout=>{const wrapperElem=getRefElem(elemStore[`${name}-${layout}-wrapper`]);const currScrollElem=getRefElem(elemStore[`${name}-${layout}-scroll`]);const tableElem=getRefElem(elemStore[`${name}-${layout}-table`]);if(layout==='header'){// 表头体样式处理
// 横向滚动渲染
let renderColumnList=tableColumn;let isOptimizeMode=false;if(isGroup){renderColumnList=visibleColumn;}else{// 如果是使用优化模式
if(scrollXLoad&&allColumnHeaderOverflow){if(spanMethod||footerSpanMethod){// 如果不支持优化模式
}else{isOptimizeMode=true;}}if(!isOptimizeMode||!isColLoading&&(fixedType||!overflowX)){renderColumnList=visibleColumn;}if(fixedType){// 如果是使用优化模式
if(isOptimizeMode){renderColumnList=fixedColumn||[];}}}const tWidth=renderColumnList.reduce((previous,column)=>previous+column.renderWidth,0);if(fixedType){if(isGroup){if(wrapperElem){wrapperElem.style.width=scrollXWidth?`${scrollXWidth}px`:'';}}else{if(isOptimizeMode){if(wrapperElem){wrapperElem.style.width=tWidth?`${tWidth}px`:'';}}else{if(wrapperElem){wrapperElem.style.width=scrollXWidth?`${scrollXWidth}px`:'';}}}}if(currScrollElem){currScrollElem.style.height=`${headerHeight}px`;}if(tableElem){tableElem.style.width=tWidth?`${tWidth}px`:'';}}else if(layout==='body'){if(currScrollElem){currScrollElem.style.maxHeight=customMaxHeight?`${bodyMaxHeight}px`:'';currScrollElem.style.height=customHeight?`${bodyHeight}px`:'';currScrollElem.style.minHeight=`${bodyMinHeight}px`;}// 如果是固定列
if(fixedWrapperElem){if(wrapperElem){wrapperElem.style.top=`${headerHeight}px`;}fixedWrapperElem.style.height=`${customHeight>0?customHeight:tableHeight+headerHeight+footerHeight+osbHeight}px`;fixedWrapperElem.style.width=`${fixedColumn.reduce((previous,column)=>previous+column.renderWidth,0)}px`;}let renderColumnList=tableColumn;let isOptimizeMode=false;// 如果是使用优化模式
if(scrollXLoad||scrollYLoad||isAllOverflow){if(expandColumn&&expandOpts.mode!=='fixed'||spanMethod||footerSpanMethod){// 如果不支持优化模式
}else{isOptimizeMode=true;}}if(fixedType){renderColumnList=visibleColumn;if(isOptimizeMode){renderColumnList=fixedColumn||[];}}const tWidth=renderColumnList.reduce((previous,column)=>previous+column.renderWidth,0);if(fixedType){if(isOptimizeMode){if(wrapperElem){wrapperElem.style.width=tWidth?`${tWidth}px`:'';}}else{if(wrapperElem){wrapperElem.style.width=scrollXWidth?`${scrollXWidth}px`:'';}}}if(tableElem){tableElem.style.width=tWidth?`${tWidth}px`:'';// 兼容性处理
tableElem.style.paddingRight=osbWidth&&fixedType&&(browseObj.firefox||browseObj.safari)?`${osbWidth}px`:'';}const emptyBlockElem=getRefElem(elemStore[`${name}-${layout}-emptyBlock`]);if(emptyBlockElem){emptyBlockElem.style.width=tWidth?`${tWidth}px`:'';}}else if(layout==='footer'){let renderColumnList=tableColumn;let isOptimizeMode=false;// 如果是使用优化模式
if(scrollXLoad&&allColumnFooterOverflow){if(spanMethod||footerSpanMethod){// 如果不支持优化模式
}else{isOptimizeMode=true;}}if(!isOptimizeMode||!isColLoading&&(fixedType||!overflowX)){renderColumnList=visibleColumn;}if(fixedType){if(isOptimizeMode){renderColumnList=fixedColumn||[];}}const tWidth=renderColumnList.reduce((previous,column)=>previous+column.renderWidth,0);if(fixedType){if(isOptimizeMode){if(wrapperElem){wrapperElem.style.width=tWidth?`${tWidth}px`:'';}}else{if(wrapperElem){wrapperElem.style.width=scrollXWidth?`${scrollXWidth}px`:'';}}}if(currScrollElem){currScrollElem.style.height=`${footerHeight}px`;// 如果是固定列
if(fixedWrapperElem){if(wrapperElem){wrapperElem.style.top=`${customHeight>0?customHeight-footerHeight-osbHeight:tableHeight+headerHeight}px`;}}}if(tableElem){tableElem.style.width=tWidth?`${tWidth}px`:'';}}});});if(currentRow){$xeTable.setCurrentRow(currentRow);}if(mouseConfig&&mouseOpts.selected&&editStore.selected.row&&editStore.selected.column){$xeTable.addCellSelectedClass();}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();};const checkValidate=type=>{if($xeTable.triggerValidate){return $xeTable.triggerValidate(type);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();};/**
         * 当单元格发生改变时
         * 如果存在规则，则校验
         */const handleChangeCell=(evnt,params)=>{checkValidate('blur').catch(e=>e).then(()=>{$xeTable.handleEdit(params,evnt).then(()=>checkValidate('change')).catch(e=>e);});};const handleDefaultSort=()=>{const{sortConfig}=props;if(sortConfig){const sortOpts=computeSortOpts.value;let{defaultSort}=sortOpts;if(defaultSort){if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(defaultSort)){defaultSort=[defaultSort];}if(defaultSort.length){(sortConfig.multiple?defaultSort:defaultSort.slice(0,1)).forEach((item,index)=>{const{field,order}=item;if(field&&order){const column=$xeTable.getColumnByField(field);if(column&&column.sortable){column.order=order;column.sortTime=Date.now()+index;}}});if(!sortOpts.remote){$xeTable.handleTableData(true).then(updateStyle);}}}}};/**
         * 处理默认勾选
         */const handleDefaultSelectionChecked=()=>{const{checkboxConfig}=props;if(checkboxConfig){const{fullDataRowIdData}=internalData;const checkboxOpts=computeCheckboxOpts.value;const{checkAll,checkRowKeys}=checkboxOpts;if(checkAll){handleCheckedAllCheckboxRow(true,true);}else if(checkRowKeys){const defSelection=[];checkRowKeys.forEach(rowid=>{if(fullDataRowIdData[rowid]){defSelection.push(fullDataRowIdData[rowid].row);}});handleCheckedCheckboxRow(defSelection,true,true);}}};/**
         * 处理单选框默认勾选
         */const handleDefaultRadioChecked=()=>{const{radioConfig}=props;if(radioConfig){const{fullDataRowIdData}=internalData;const radioOpts=computeRadioOpts.value;const{checkRowKey:rowid,reserve}=radioOpts;if(rowid){if(fullDataRowIdData[rowid]){handleCheckedRadioRow(fullDataRowIdData[rowid].row,true);}if(reserve){const rowkey=getRowkey($xeTable);internalData.radioReserveRow={[rowkey]:rowid};}}}};/**
         * 处理默认展开行
         */const handleDefaultRowExpand=()=>{const{expandConfig}=props;if(expandConfig){const{fullDataRowIdData}=internalData;const expandOpts=computeExpandOpts.value;const{expandAll,expandRowKeys}=expandOpts;if(expandAll){$xeTable.setAllRowExpand(true);}else if(expandRowKeys){const defExpandeds=[];expandRowKeys.forEach(rowid=>{if(fullDataRowIdData[rowid]){defExpandeds.push(fullDataRowIdData[rowid].row);}});$xeTable.setRowExpand(defExpandeds,true);}}};const handleRadioReserveRow=row=>{const radioOpts=computeRadioOpts.value;if(radioOpts.reserve){internalData.radioReserveRow=row;}};const handleCheckboxReserveRow=(row,checked)=>{const{checkboxReserveRowMap}=internalData;const checkboxOpts=computeCheckboxOpts.value;if(checkboxOpts.reserve){const rowid=getRowid($xeTable,row);if(checked){checkboxReserveRowMap[rowid]=row;}else if(checkboxReserveRowMap[rowid]){delete checkboxReserveRowMap[rowid];}}};const handleCheckedRadioRow=(row,isForce)=>{const radioOpts=computeRadioOpts.value;const{checkMethod}=radioOpts;if(row&&(isForce||!checkMethod||checkMethod({$table:$xeTable,row}))){reactData.selectRadioRow=row;handleRadioReserveRow(row);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();};const handleCheckedCheckboxRow=(rows,value,isForce)=>{if(rows&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){rows=[rows];}$xeTable.handleBatchSelectRows(rows,!!value,isForce);$xeTable.checkSelectionStatus();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();};const handleCheckedAllCheckboxRow=(checked,isForce)=>{const{treeConfig}=props;const{isRowGroupStatus}=reactData;const{afterFullData,afterTreeFullData,afterGroupFullData,checkboxReserveRowMap,selectCheckboxMaps}=internalData;const treeOpts=computeTreeOpts.value;const rowGroupOpts=computeRowGroupOpts.value;const childrenField=treeOpts.children||treeOpts.childrenField;const checkboxOpts=computeCheckboxOpts.value;const{checkField,reserve,checkMethod}=checkboxOpts;const{handleGetRowId}=createHandleGetRowId($xeTable);// indeterminateField 仅支持读取
const indeterminateField=checkboxOpts.indeterminateField||checkboxOpts.halfField;const selectRowMaps={};/**
             * 绑定属性方式（有污染）
             * 必须在行数据存在对应的属性，否则将不响应
             */if(checkField){const checkValFn=row=>{if(isForce||!checkMethod||checkMethod({$table:$xeTable,row})){if(checked){selectRowMaps[handleGetRowId(row)]=row;}external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row,checkField,checked);}if((treeConfig||isRowGroupStatus)&&indeterminateField){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row,indeterminateField,false);}};// 如果存在选中方法
// 如果方法成立，则更新值，否则忽略该数据
if(treeConfig||isRowGroupStatus){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterFullData,checkValFn,{children:childrenField});}else{afterFullData.forEach(checkValFn);}}else{/**
                 * 默认方式（无污染）
                 * 无需任何属性，直接绑定
                 */if(isRowGroupStatus){if(checked){/**
                         * 如果是行分组勾选
                         * 如果方法成立，则添加到临时集合中
                         */external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterGroupFullData,row=>{if(isForce||!checkMethod||checkMethod({$table:$xeTable,row})){const rowid=handleGetRowId(row);selectRowMaps[rowid]=row;}},{children:rowGroupOpts.mapChildrenField});}else{/**
                         * 如果是树取消
                         * 如果方法成立，则不添加到临时集合中
                         */if(!isForce&&checkMethod){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterGroupFullData,row=>{const rowid=handleGetRowId(row);if(checkMethod({$table:$xeTable,row})?false:selectCheckboxMaps[rowid]){selectRowMaps[rowid]=row;}},{children:rowGroupOpts.mapChildrenField});}}}else if(treeConfig){if(checked){/**
                         * 如果是树勾选
                         * 如果方法成立，则添加到临时集合中
                         */external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterTreeFullData,row=>{if(isForce||!checkMethod||checkMethod({$table:$xeTable,row})){const rowid=handleGetRowId(row);selectRowMaps[rowid]=row;}},{children:childrenField});}else{/**
                         * 如果是树取消
                         * 如果方法成立，则不添加到临时集合中
                         */if(!isForce&&checkMethod){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterTreeFullData,row=>{const rowid=handleGetRowId(row);if(checkMethod({$table:$xeTable,row})?false:selectCheckboxMaps[rowid]){selectRowMaps[rowid]=row;}},{children:childrenField});}}}else{if(checked){/**
                         * 如果是行勾选
                         * 如果存在选中方法且成立或者本身已勾选，则添加到临时集合中
                         * 如果不存在选中方法，则添加所有数据到临时集合中
                         */if(!isForce&&checkMethod){afterFullData.forEach(row=>{const rowid=handleGetRowId(row);if(selectCheckboxMaps[rowid]||checkMethod({$table:$xeTable,row})){selectRowMaps[rowid]=row;}});}else{afterFullData.forEach(row=>{const rowid=handleGetRowId(row);selectRowMaps[rowid]=row;});}}else{/**
                         * 如果是行取消
                         * 如果方法成立，则不添加到临时集合中；如果方法不成立则判断当前是否已勾选，如果已被勾选则添加到新集合中
                         * 如果不存在选中方法，无需处理，临时集合默认为空
                         */if(!isForce&&checkMethod){afterFullData.forEach(row=>{const rowid=handleGetRowId(row);if(checkMethod({$table:$xeTable,row})?false:selectCheckboxMaps[rowid]){selectRowMaps[rowid]=row;}});}}}}if(reserve){if(checked){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(selectRowMaps,(row,rowid)=>{checkboxReserveRowMap[rowid]=row;});}else{afterFullData.forEach(row=>handleCheckboxReserveRow(row,false));}}reactData.updateCheckboxFlag++;internalData.selectCheckboxMaps=checkField?{}:selectRowMaps;reactData.isAllSelected=checked;reactData.isIndeterminate=false;internalData.treeIndeterminateRowMaps={};$xeTable.checkSelectionStatus();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();};// 还原展开、选中等相关状态
const handleReserveStatus=()=>{const{treeConfig}=props;const{expandColumn,currentRow,selectRadioRow}=reactData;const{fullDataRowIdData,fullAllDataRowIdData,radioReserveRow,selectCheckboxMaps,treeExpandedMaps,rowExpandedMaps}=internalData;const expandOpts=computeExpandOpts.value;const treeOpts=computeTreeOpts.value;const radioOpts=computeRadioOpts.value;const checkboxOpts=computeCheckboxOpts.value;// 单选框
if(selectRadioRow&&!fullAllDataRowIdData[getRowid($xeTable,selectRadioRow)]){reactData.selectRadioRow=null;// 刷新单选行状态
}// 还原保留选中状态
if(radioOpts.reserve&&radioReserveRow){const rowid=getRowid($xeTable,radioReserveRow);if(fullDataRowIdData[rowid]){handleCheckedRadioRow(fullDataRowIdData[rowid].row,true);}}// 复选框
internalData.selectCheckboxMaps=getRecoverRowMaps(selectCheckboxMaps);// 刷新多选行状态
reactData.updateCheckboxFlag++;// 还原保留选中状态
if(checkboxOpts.reserve){handleCheckedCheckboxRow(handleReserveRow(internalData.checkboxReserveRowMap),true,true);}if(currentRow&&!fullAllDataRowIdData[getRowid($xeTable,currentRow)]){reactData.currentRow=null;// 刷新当前行状态
}// 行展开
internalData.rowExpandedMaps=expandColumn?getRecoverRowMaps(rowExpandedMaps):{};// 刷新行展开状态
reactData.rowExpandedFlag++;// 还原保留状态
if(expandColumn&&expandOpts.reserve){$xeTable.setRowExpand(handleReserveRow(internalData.rowExpandedReserveRowMap),true);}// 树展开
internalData.treeExpandedMaps=treeConfig?getRecoverRowMaps(treeExpandedMaps):{};// 刷新树展开状态
reactData.treeExpandedFlag++;if(treeConfig&&treeOpts.reserve){$xeTable.setTreeExpand(handleReserveRow(internalData.treeExpandedReserveRowMap),true);}};/**
         * 处理默认展开树节点
         */const handleDefaultTreeExpand=()=>{const{treeConfig}=props;if(treeConfig){const{tableFullData}=internalData;const treeOpts=computeTreeOpts.value;const{expandAll,expandRowKeys}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;if(expandAll){$xeTable.setAllTreeExpand(true);}else if(expandRowKeys){const defExpandeds=[];const rowkey=getRowkey($xeTable);expandRowKeys.forEach(rowid=>{const matchObj=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullData,item=>rowid===external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(item,rowkey),{children:childrenField});if(matchObj){defExpandeds.push(matchObj.item);}});$xeTable.setTreeExpand(defExpandeds,true);}}};const handleAsyncTreeExpandChilds=row=>{const treeOpts=computeTreeOpts.value;const checkboxOpts=computeCheckboxOpts.value;const{transform,loadMethod}=treeOpts;const{checkStrictly}=checkboxOpts;return new Promise(resolve=>{if(loadMethod){const{fullAllDataRowIdData,treeExpandLazyLoadedMaps}=internalData;const rowid=getRowid($xeTable,row);const rowRest=fullAllDataRowIdData[rowid];treeExpandLazyLoadedMaps[rowid]=row;Promise.resolve(loadMethod({$table:$xeTable,row})).then(childRecords=>{if(rowRest){rowRest.treeLoaded=true;}if(treeExpandLazyLoadedMaps[rowid]){delete treeExpandLazyLoadedMaps[rowid];}if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(childRecords)){childRecords=[];}if(childRecords){return $xeTable.loadTreeChildren(row,childRecords).then(childRows=>{const{treeExpandedMaps}=internalData;if(childRows.length&&!treeExpandedMaps[rowid]){treeExpandedMaps[rowid]=row;}reactData.treeExpandedFlag++;// 如果当前节点已选中，则展开后子节点也被选中
if(!checkStrictly&&$xeTable.isCheckedByCheckboxRow(row)){handleCheckedCheckboxRow(childRows,true);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{if(transform){$xeTable.handleTableData();updateAfterDataIndex();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}});});}}).catch(()=>{const{treeExpandLazyLoadedMaps}=internalData;if(rowRest){rowRest.treeLoaded=false;}if(treeExpandLazyLoadedMaps[rowid]){delete treeExpandLazyLoadedMaps[rowid];}}).finally(()=>{reactData.treeExpandedFlag++;(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>$xeTable.recalculate()).then(()=>resolve());});}else{resolve();}});};const handleTreeExpandReserve=(row,expanded)=>{const{treeExpandedReserveRowMap}=internalData;const treeOpts=computeTreeOpts.value;if(treeOpts.reserve){const rowid=getRowid($xeTable,row);if(expanded){treeExpandedReserveRowMap[rowid]=row;}else if(treeExpandedReserveRowMap[rowid]){delete treeExpandedReserveRowMap[rowid];}}};const handleAsyncRowExpand=row=>{return new Promise(resolve=>{const expandOpts=computeExpandOpts.value;const{loadMethod}=expandOpts;if(loadMethod){const{fullAllDataRowIdData,rowExpandLazyLoadedMaps}=internalData;const rowid=getRowid($xeTable,row);const rowRest=fullAllDataRowIdData[rowid];rowExpandLazyLoadedMaps[rowid]=row;loadMethod({$table:$xeTable,row,rowIndex:$xeTable.getRowIndex(row),$rowIndex:$xeTable.getVMRowIndex(row)}).then(()=>{const{rowExpandedMaps}=internalData;if(rowRest){rowRest.expandLoaded=true;}rowExpandedMaps[rowid]=row;reactData.rowExpandedFlag++;}).catch(()=>{if(rowRest){rowRest.expandLoaded=false;}}).finally(()=>{const{rowExpandLazyLoadedMaps}=internalData;if(rowExpandLazyLoadedMaps[rowid]){delete rowExpandLazyLoadedMaps[rowid];}reactData.rowExpandedFlag++;(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>$xeTable.recalculate()).then(()=>$xeTable.updateCellAreas()).then(()=>resolve());});}else{resolve();}});};const handleRowExpandReserve=(row,expanded)=>{const{rowExpandedReserveRowMap}=internalData;const expandOpts=computeExpandOpts.value;if(expandOpts.reserve){const rowid=getRowid($xeTable,row);if(expanded){rowExpandedReserveRowMap[rowid]=row;}else if(rowExpandedReserveRowMap[rowid]){delete rowExpandedReserveRowMap[rowid];}}};const handleDefaultMergeCells=()=>{const{mergeCells}=props;if(mergeCells){$xeTable.setMergeCells(mergeCells);}};const handleDefaultMergeFooterItems=()=>{const{mergeFooterItems}=props;if(mergeFooterItems){$xeTable.setMergeFooterItems(mergeFooterItems);}};// 计算可视渲染相关数据
const computeScrollLoad=()=>{return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{const{scrollXLoad,scrollYLoad}=reactData;const{scrollXStore,scrollYStore}=internalData;const virtualYOpts=computeVirtualYOpts.value;const virtualXOpts=computeVirtualXOpts.value;// 计算 X 逻辑
if(scrollXLoad){const{toVisibleIndex:toXVisibleIndex,visibleSize:visibleXSize}=handleVirtualXVisible();const offsetXSize=Math.max(0,virtualXOpts.oSize?external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(virtualXOpts.oSize):0);scrollXStore.preloadSize=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(virtualXOpts.preSize);scrollXStore.offsetSize=offsetXSize;scrollXStore.visibleSize=visibleXSize;scrollXStore.endIndex=Math.max(scrollXStore.startIndex+scrollXStore.visibleSize+offsetXSize,scrollXStore.endIndex);scrollXStore.visibleStartIndex=Math.max(scrollXStore.startIndex,toXVisibleIndex);scrollXStore.visibleEndIndex=Math.min(scrollXStore.endIndex,toXVisibleIndex+visibleXSize);$xeTable.updateScrollXData().then(()=>{loadScrollXData();});}else{$xeTable.updateScrollXSpace();}// 计算 Y 逻辑
const rowHeight=computeRowHeight();scrollYStore.rowHeight=rowHeight;// 已废弃
reactData.rowHeight=rowHeight;const{toVisibleIndex:toYVisibleIndex,visibleSize:visibleYSize}=handleVirtualYVisible();if(scrollYLoad){const offsetYSize=Math.max(0,virtualYOpts.oSize?external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(virtualYOpts.oSize):0);scrollYStore.preloadSize=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(virtualYOpts.preSize);scrollYStore.offsetSize=offsetYSize;scrollYStore.visibleSize=visibleYSize;scrollYStore.endIndex=Math.max(scrollYStore.startIndex+visibleYSize+offsetYSize,scrollYStore.endIndex);scrollYStore.visibleStartIndex=Math.max(scrollYStore.startIndex,toYVisibleIndex);scrollYStore.visibleEndIndex=Math.min(scrollYStore.endIndex,toYVisibleIndex+visibleYSize);$xeTable.updateScrollYData().then(()=>{loadScrollYData();});}else{$xeTable.updateScrollYSpace();}});};const calcScrollbar=()=>{const{scrollXWidth,scrollYHeight}=reactData;const{elemStore}=internalData;const scrollbarOpts=computeScrollbarOpts.value;const bodyWrapperElem=getRefElem(elemStore['main-body-wrapper']);const headerTableElem=getRefElem(elemStore['main-header-table']);const footerTableElem=getRefElem(elemStore['main-footer-table']);const xHandleEl=refScrollXHandleElem.value;const yHandleEl=refScrollYHandleElem.value;let overflowY=false;let overflowX=false;if(bodyWrapperElem){overflowY=scrollYHeight>bodyWrapperElem.clientHeight;if(yHandleEl){reactData.scrollbarWidth=scrollbarOpts.width||yHandleEl.offsetWidth-yHandleEl.clientWidth||14;}reactData.overflowY=overflowY;overflowX=scrollXWidth>bodyWrapperElem.clientWidth;if(xHandleEl){reactData.scrollbarHeight=scrollbarOpts.height||xHandleEl.offsetHeight-xHandleEl.clientHeight||14;}const headerHeight=headerTableElem?headerTableElem.clientHeight:0;const footerHeight=footerTableElem?footerTableElem.clientHeight:0;internalData.tableHeight=bodyWrapperElem.offsetHeight;internalData.headerHeight=headerHeight;internalData.footerHeight=footerHeight;reactData.overflowX=overflowX;reactData.parentHeight=Math.max(internalData.headerHeight+footerHeight+20,$xeTable.getParentHeight());}if(overflowX){$xeTable.checkScrolling();}};const handleRecalculateLayout=reFull=>{const el=refElem.value;internalData.rceRunTime=Date.now();if(!el||!el.clientWidth){return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}const varEl=refVarElem.value;if(varEl){const[defEl,mediumEl,smallEl,miniEl]=varEl.children;calcVarRowHeightConfig('default',defEl);calcVarRowHeightConfig('medium',mediumEl);calcVarRowHeightConfig('small',smallEl);calcVarRowHeightConfig('mini',miniEl);}calcCellWidth();autoCellWidth();calcScrollbar();updateStyle();updateRowExpandStyle();return computeScrollLoad().then(()=>{// 初始化时需要在列计算之后再执行优化运算，达到最优显示效果
calcCellWidth();if(reFull){autoCellWidth();}calcScrollbar();updateStyle();if(reFull){updateRowOffsetTop();}updateRowExpandStyle();if(reFull){return computeScrollLoad();}});};const handleUpdateRowGroup=groupFields=>{reactData.rowGroupList=groupFields?(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(groupFields)?groupFields:[groupFields]).map(field=>{return{field};}):[];};const handleGroupData=(list,rowGroups)=>{let fullData=list;let treeData=list;if(rowGroups){const rowGroupOpts=computeRowGroupOpts.value;const{rowField,parentField,childrenField,mapChildrenField}=rowGroupOpts;const checkboxOpts=computeCheckboxOpts.value;const{checkField}=checkboxOpts;const indeterminateField=checkboxOpts.indeterminateField||checkboxOpts.halfField;const rgItem=rowGroups[0];if(rgItem&&rowField&&parentField&&childrenField&&mapChildrenField){fullData=[];treeData=[];const groupField=rgItem.field;const groupColumn=$xeTable.getColumnByField(groupField);const groupMaps={};const rowkey=getRowkey($xeTable);list.forEach(row=>{const cellValue=groupColumn?$xeTable.getCellLabel(row,groupColumn):external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,groupField);const groupValue=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(cellValue)?'':cellValue;let childList=groupMaps[groupValue];if(!childList){childList=[];groupMaps[groupValue]=childList;}if(row.isAggregate){row.isAggregate=undefined;}childList.push(row);});external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(groupMaps,(childList,groupValue)=>{const{fullData:childFullData,treeData:childTreeData}=handleGroupData(childList,rowGroups.slice(1));const groupRow={isAggregate:true,groupContent:groupValue,groupField,[rowField]:getRowUniqueId(),[parentField]:null,[rowkey]:getRowUniqueId(),[childrenField]:childTreeData,[mapChildrenField]:childTreeData};if(checkField){groupRow[checkField]=false;}if(indeterminateField){groupRow[indeterminateField]=false;}treeData.push(groupRow);fullData.push(groupRow);if(childFullData.length){fullData.push(...childFullData);}});}}return{treeData,fullData};};/**
         * 加载表格数据
         * @param {Array} datas 数据
         */const loadTableData=(datas,isReset)=>{const{keepSource,treeConfig,rowGroupConfig}=props;const{rowGroupList,scrollYLoad:oldScrollYLoad}=reactData;const{scrollYStore,scrollXStore,lastScrollLeft,lastScrollTop}=internalData;const rowOpts=computeRowOpts.value;const treeOpts=computeTreeOpts.value;const expandOpts=computeExpandOpts.value;const{transform}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;let treeData=[];let fullData=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(datas?datas.slice(0):[]);// 转为响应式数据
if(fullData.length>supportMaxRow){errLog('vxe.error.errMaxRow',[supportMaxRow]);}if(treeConfig&&rowGroupList.length){errLog('vxe.error.noTree',['row-group-config']);return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}if(rowOpts.drag&&rowGroupList.length){errLog('vxe.error.errConflicts',['row-config.drag','row-group-config']);return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}let isRGroup=false;if(treeConfig){if(transform){// 树结构自动转换
if(!treeOpts.rowField){errLog('vxe.error.reqProp',['tree-config.rowField']);}if(!treeOpts.parentField){errLog('vxe.error.reqProp',['tree-config.parentField']);}if(!childrenField){errLog('vxe.error.reqProp',['tree-config.childrenField']);}if(!treeOpts.mapChildrenField){errLog('vxe.error.reqProp',['tree-config.mapChildrenField']);}if(childrenField===treeOpts.mapChildrenField){errLog('vxe.error.errConflicts',['tree-config.childrenField','tree-config.mapChildrenField']);}// fullData.forEach(row => {
//   if (row[treeOpts.children] && row[treeOpts.children].length) {
//     warnLog('vxe.error.errConflicts', ['tree-config.transform', `row.${treeOpts.children}`])
//   }
// })
treeData=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(fullData,{key:treeOpts.rowField,parentKey:treeOpts.parentField,children:childrenField,mapChildren:treeOpts.mapChildrenField});fullData=treeData.slice(0);}else{treeData=fullData.slice(0);}}else if(rowGroupConfig&&rowGroupList.length){const groupRest=handleGroupData(fullData,rowGroupList);treeData=groupRest.treeData;fullData=groupRest.fullData;isRGroup=true;}reactData.isRowGroupStatus=isRGroup;scrollYStore.startIndex=0;scrollYStore.endIndex=1;scrollXStore.startIndex=0;scrollXStore.endIndex=1;internalData.cvCacheMaps={};reactData.isRowLoading=true;reactData.scrollVMLoading=false;internalData.treeExpandedMaps={};reactData.treeExpandedFlag++;internalData.rowExpandedMaps={};reactData.rowExpandedFlag++;internalData.insertRowMaps={};reactData.insertRowFlag++;internalData.removeRowMaps={};reactData.removeRowFlag++;const sYLoad=updateScrollYStatus(fullData);reactData.isDragColMove=false;reactData.isDragRowMove=false;// 全量数据
internalData.tableFullData=fullData;internalData.tableFullTreeData=isRGroup?[]:treeData;internalData.tableFullGroupData=isRGroup?treeData:[];// 缓存数据
$xeTable.cacheRowMap(isReset);// 原始数据
internalData.tableSynchData=datas;if(isReset){internalData.isResizeCellHeight=false;}// 克隆原数据，用于显示编辑状态，与编辑值做对比
if(keepSource){$xeTable.cacheSourceMap(fullData);}if($xeTable.clearCellAreas&&props.mouseConfig){$xeTable.clearCellAreas();$xeTable.clearCopyCellArea();}$xeTable.clearMergeCells();$xeTable.clearMergeFooterItems();$xeTable.handleTableData(true);$xeTable.updateFooter();$xeTable.handleUpdateBodyMerge();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{updateHeight();updateStyle();}).then(()=>{computeScrollLoad();}).then(()=>{// 是否启用了虚拟滚动
if(sYLoad){scrollYStore.endIndex=scrollYStore.visibleSize;}if(sYLoad){if(reactData.expandColumn&&expandOpts.mode!=='fixed'){errLog('vxe.error.notConflictProp',['column.type="expand','expand-config.mode="fixed"']);}// if (showOverflow) {
//   if (!rowOpts.height) {
//     const errColumn = internalData.tableFullColumn.find(column => column.showOverflow === false)
//     if (errColumn) {
//       errLog('vxe.error.errProp', [`column[field="${errColumn.field}"].show-overflow=false`, 'show-overflow=true'])
//     }
//   }
// }
if(!(props.height||props.maxHeight)){errLog('vxe.error.reqProp',['height | max-height | virtual-y-config={enabled: false}']);}// if (!props.showOverflow) {
//   warnLog('vxe.error.reqProp', ['table.show-overflow'])
// }
if(props.spanMethod){errLog('vxe.error.scrollErrProp',['table.span-method']);}}handleReserveStatus();$xeTable.checkSelectionStatus();return new Promise(resolve=>{(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>handleRecalculateLayout(false)).then(()=>{calcCellHeight();updateRowOffsetTop();return handleRecalculateLayout(false);}).then(()=>{let targetScrollLeft=lastScrollLeft;let targetScrollTop=lastScrollTop;const virtualXOpts=computeVirtualXOpts.value;const virtualYOpts=computeVirtualYOpts.value;// 是否在更新数据之后自动滚动重置滚动条
if(virtualXOpts.scrollToLeftOnChange){targetScrollLeft=0;}if(virtualYOpts.scrollToTopOnChange){targetScrollTop=0;}reactData.isRowLoading=false;handleRecalculateLayout(false);// 是否变更虚拟滚动
if(oldScrollYLoad===sYLoad){restoreScrollLocation($xeTable,targetScrollLeft,targetScrollTop).then(()=>{resolve();});}else{setTimeout(()=>{restoreScrollLocation($xeTable,targetScrollLeft,targetScrollTop).then(()=>{resolve();});});}});});});};/**
         * 处理数据加载默认行为
         * 默认执行一次，除非被重置
         */const handleLoadDefaults=()=>{handleDefaultSelectionChecked();handleDefaultRadioChecked();handleDefaultRowExpand();handleDefaultTreeExpand();handleDefaultMergeCells();handleDefaultMergeFooterItems();(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>setTimeout(()=>$xeTable.recalculate()));};/**
         * 处理初始化的默认行为
         * 只会执行一次
         */const handleInitDefaults=()=>{handleDefaultSort();};const handleTableColumn=()=>{const{scrollXLoad}=reactData;const{visibleColumn,scrollXStore,fullColumnIdData}=internalData;const tableColumn=scrollXLoad?visibleColumn.slice(scrollXStore.startIndex,scrollXStore.endIndex):visibleColumn.slice(0);tableColumn.forEach((column,$index)=>{const colid=column.id;const colRest=fullColumnIdData[colid];if(colRest){colRest.$index=$index;}});reactData.tableColumn=tableColumn;};const handleUpdateColumn=()=>{const columnList=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(internalData.collectColumn,'renderSortNumber');internalData.collectColumn=columnList;const tableFullColumn=getColumnList(columnList);internalData.tableFullColumn=tableFullColumn;cacheColumnMap();};const loadScrollXData=()=>{const{isScrollXBig}=reactData;const{mergeBodyList,mergeFooterList,scrollXStore}=internalData;const{preloadSize,startIndex,endIndex,offsetSize}=scrollXStore;const{toVisibleIndex,visibleSize}=handleVirtualXVisible();const offsetItem={startIndex:Math.max(0,isScrollXBig?toVisibleIndex-1:toVisibleIndex-1-offsetSize-preloadSize),endIndex:isScrollXBig?toVisibleIndex+visibleSize:toVisibleIndex+visibleSize+offsetSize+preloadSize};scrollXStore.visibleStartIndex=toVisibleIndex-1;scrollXStore.visibleEndIndex=toVisibleIndex+visibleSize+1;calculateMergerOffsetIndex(mergeBodyList.concat(mergeFooterList),offsetItem,'col');const{startIndex:offsetStartIndex,endIndex:offsetEndIndex}=offsetItem;if(toVisibleIndex<=startIndex||toVisibleIndex>=endIndex-visibleSize-1){if(startIndex!==offsetStartIndex||endIndex!==offsetEndIndex){scrollXStore.startIndex=offsetStartIndex;scrollXStore.endIndex=offsetEndIndex;$xeTable.updateScrollXData();}}$xeTable.closeTooltip();};// 获取所有的列，排除分组
const getColumnList=columns=>{const result=[];columns.forEach(column=>{result.push(...(column.children&&column.children.length?getColumnList(column.children):[column]));});return result;};const parseColumns=isReset=>{// const { showOverflow } = props
// const rowOpts = computeRowOpts.value
const leftList=[];const centerList=[];const rightList=[];const{isGroup,columnStore}=reactData;const virtualXOpts=computeVirtualXOpts.value;const{collectColumn,tableFullColumn,scrollXStore,fullColumnIdData}=internalData;// 如果是分组表头，如果子列全部被隐藏，则根列也隐藏
if(isGroup){const leftGroupList=[];const centerGroupList=[];const rightGroupList=[];external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn,(column,index,items,path,parentColumn)=>{const isColGroup=hasChildrenList(column);// 如果是分组，必须按组设置固定列，不允许给子列设置固定
if(parentColumn&&parentColumn.fixed){column.fixed=parentColumn.fixed;}if(parentColumn&&column.fixed!==parentColumn.fixed){errLog('vxe.error.groupFixed');}if(isColGroup){column.visible=!!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(column.children,subColumn=>hasChildrenList(subColumn)?false:subColumn.visible);}else if(column.visible){if(column.fixed==='left'){leftList.push(column);}else if(column.fixed==='right'){rightList.push(column);}else{centerList.push(column);}}});collectColumn.forEach(column=>{if(column.visible){if(column.fixed==='left'){leftGroupList.push(column);}else if(column.fixed==='right'){rightGroupList.push(column);}else{centerGroupList.push(column);}}});reactData.tableGroupColumn=leftGroupList.concat(centerGroupList).concat(rightGroupList);}else{// 重新分配列
tableFullColumn.forEach(column=>{if(column.visible){if(column.fixed==='left'){leftList.push(column);}else if(column.fixed==='right'){rightList.push(column);}else{centerList.push(column);}}});}const visibleColumn=leftList.concat(centerList).concat(rightList);// 如果gt为0，则总是启用
const scrollXLoad=!!virtualXOpts.enabled&&virtualXOpts.gt>-1&&(virtualXOpts.gt===0||virtualXOpts.gt<tableFullColumn.length);reactData.hasFixedColumn=leftList.length>0||rightList.length>0;Object.assign(columnStore,{leftList,centerList,rightList});if(scrollXLoad){// if (showOverflow) {
//   if (!rowOpts.height) {
//     const errColumn = internalData.tableFullColumn.find(column => column.showOverflow === false)
//     if (errColumn) {
//       errLog('vxe.error.errProp', [`column[field="${errColumn.field}"].show-overflow=false`, 'show-overflow=true'])
//     }
//   }
// }
// if (process.env.VUE_APP_VXE_ENV === 'development') {
// if (props.showHeader && !props.showHeaderOverflow) {
//   warnLog('vxe.error.reqProp', ['show-header-overflow'])
// }
// if (props.showFooter && !props.showFooterOverflow) {
//   warnLog('vxe.error.reqProp', ['show-footer-overflow'])
// }
if(props.spanMethod){warnLog('vxe.error.scrollErrProp',['span-method']);}if(props.footerSpanMethod){warnLog('vxe.error.scrollErrProp',['footer-span-method']);}// }
if(isReset){const{visibleSize}=handleVirtualXVisible();scrollXStore.startIndex=0;scrollXStore.endIndex=visibleSize;scrollXStore.visibleSize=visibleSize;scrollXStore.visibleStartIndex=0;scrollXStore.visibleEndIndex=visibleSize;}}// 如果列被显示/隐藏，则清除合并状态
// 如果列被设置为固定，则清除合并状态
if(visibleColumn.length!==internalData.visibleColumn.length||!internalData.visibleColumn.every((column,index)=>column===visibleColumn[index])){$xeTable.clearMergeCells();$xeTable.clearMergeFooterItems();}reactData.scrollXLoad=scrollXLoad;visibleColumn.forEach((column,index)=>{const colid=column.id;const colRest=fullColumnIdData[colid];if(colRest){colRest._index=index;}});internalData.visibleColumn=visibleColumn;handleTableColumn();if(isReset){updateColumnOffsetLeft();return $xeTable.updateFooter().then(()=>{return $xeTable.recalculate();}).then(()=>{$xeTable.updateCellAreas();return $xeTable.recalculate();});}return $xeTable.updateFooter();};const initColumnSort=()=>{const{collectColumn}=internalData;collectColumn.forEach((column,index)=>{const sortIndex=index+1;column.sortNumber=sortIndex;column.renderSortNumber=sortIndex;});};const handleColumn=collectColumn=>{const expandOpts=computeExpandOpts.value;internalData.collectColumn=collectColumn;const tableFullColumn=getColumnList(collectColumn);internalData.tableFullColumn=tableFullColumn;reactData.isColLoading=true;reactData.isDragColMove=false;initColumnSort();return Promise.resolve(restoreCustomStorage()).then(()=>{const{scrollXLoad,scrollYLoad,expandColumn}=reactData;cacheColumnMap();parseColumns(true).then(()=>{if(reactData.scrollXLoad){loadScrollXData();}});$xeTable.clearMergeCells();$xeTable.clearMergeFooterItems();$xeTable.handleTableData(true);if((scrollXLoad||scrollYLoad)&&expandColumn&&expandOpts.mode!=='fixed'){warnLog('vxe.error.scrollErrProp',['column.type=expand']);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{if($xeToolbar){$xeToolbar.syncUpdate({collectColumn:internalData.collectColumn,$table:$xeTable});}if($xeTable.handleUpdateCustomColumn){$xeTable.handleUpdateCustomColumn();}reactData.isColLoading=false;return $xeTable.recalculate();});});};const updateScrollYStatus=fullData=>{const{treeConfig}=props;const virtualYOpts=computeVirtualYOpts.value;const treeOpts=computeTreeOpts.value;const{transform}=treeOpts;const allList=fullData||internalData.tableFullData;// 如果gt为0，则总是启用
const scrollYLoad=(transform||!treeConfig)&&!!virtualYOpts.enabled&&virtualYOpts.gt>-1&&(virtualYOpts.gt===0||virtualYOpts.gt<allList.length);reactData.scrollYLoad=scrollYLoad;return scrollYLoad;};/**
         * 展开与收起树节点
         * @param rows
         * @param expanded
         * @returns
         */const handleBaseTreeExpand=(rows,expanded)=>{const{treeNodeColumn}=reactData;const{fullAllDataRowIdData,tableFullTreeData,treeExpandedMaps,treeExpandLazyLoadedMaps}=internalData;const treeOpts=computeTreeOpts.value;const{reserve,lazy,accordion,toggleMethod}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;const hasChildField=treeOpts.hasChild||treeOpts.hasChildField;const result=[];const columnIndex=$xeTable.getColumnIndex(treeNodeColumn);const $columnIndex=$xeTable.getVMColumnIndex(treeNodeColumn);const{handleGetRowId}=createHandleGetRowId($xeTable);let validRows=toggleMethod?rows.filter(row=>toggleMethod({$table:$xeTable,expanded,column:treeNodeColumn,columnIndex,$columnIndex,row})):rows;if(accordion){validRows=validRows.length?[validRows[validRows.length-1]]:[];// 同一级只能展开一个
const matchObj=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData,item=>item===validRows[0],{children:childrenField});if(matchObj){matchObj.items.forEach(item=>{const rowid=handleGetRowId(item);if(treeExpandedMaps[rowid]){delete treeExpandedMaps[rowid];}});}}if(expanded){validRows.forEach(row=>{const rowid=handleGetRowId(row);if(!treeExpandedMaps[rowid]){const rowRest=fullAllDataRowIdData[rowid];if(rowRest){const isLoad=lazy&&row[hasChildField]&&!rowRest.treeLoaded&&!treeExpandLazyLoadedMaps[rowid];// 是否使用懒加载
if(isLoad){result.push(handleAsyncTreeExpandChilds(row));}else{if(row[childrenField]&&row[childrenField].length){treeExpandedMaps[rowid]=row;}}}}});}else{validRows.forEach(item=>{const rowid=handleGetRowId(item);if(treeExpandedMaps[rowid]){delete treeExpandedMaps[rowid];}});}if(reserve){validRows.forEach(row=>handleTreeExpandReserve(row,expanded));}reactData.treeExpandedFlag++;return Promise.all(result).then(()=>{return $xeTable.recalculate();});};/**
         * 虚拟树的展开与收起
         * @param rows
         * @param expanded
         * @returns
         */const handleVirtualTreeExpand=(rows,expanded)=>{return handleBaseTreeExpand(rows,expanded).then(()=>{handleVirtualTreeToList();$xeTable.handleTableData();reactData.treeExpandedFlag++;updateAfterDataIndex();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}).then(()=>{return $xeTable.recalculate(true);}).then(()=>{setTimeout(()=>{$xeTable.updateCellAreas();},30);});};/**
         * 展开与收起行分组节点
         * @param rows
         * @param expanded
         * @returns
         */const handleRowGroupBaseExpand=(rows,expanded)=>{const{fullAllDataRowIdData,tableFullGroupData,rowGroupExpandedMaps}=internalData;const rowGroupOpts=computeRowGroupOpts.value;const{mapChildrenField,accordion}=rowGroupOpts;const{handleGetRowId}=createHandleGetRowId($xeTable);let validRows=rows;if(mapChildrenField){if(accordion){validRows=validRows.length?[validRows[validRows.length-1]]:[];// 同一级只能展开一个
const matchObj=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullGroupData,item=>getRowid($xeTable,item)===getRowid($xeTable,validRows[0]),{children:mapChildrenField});if(matchObj){matchObj.items.forEach(item=>{const rowid=handleGetRowId(item);if(rowGroupExpandedMaps[rowid]){delete rowGroupExpandedMaps[rowid];}});}}if(expanded){validRows.forEach(row=>{const rowid=handleGetRowId(row);if(!rowGroupExpandedMaps[rowid]){const rowRest=fullAllDataRowIdData[rowid];if(rowRest){if(row[mapChildrenField]&&row[mapChildrenField].length){rowGroupExpandedMaps[rowid]=row;}}}});}else{validRows.forEach(item=>{const rowid=handleGetRowId(item);if(rowGroupExpandedMaps[rowid]){delete rowGroupExpandedMaps[rowid];}});}}reactData.rowGroupExpandedFlag++;return $xeTable.recalculate();};/**
         * 行分组的展开与收起
         * @param rows
         * @param expanded
         * @returns
         */const handleRowGroupVirtualExpand=(rows,expanded)=>{return handleRowGroupBaseExpand(rows,expanded).then(()=>{handleVirtualTreeToList();$xeTable.handleTableData();reactData.rowGroupExpandedFlag++;updateAfterDataIndex();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}).then(()=>{return $xeTable.recalculate(true);}).then(()=>{setTimeout(()=>{$xeTable.updateCellAreas();},30);});};const handleCheckAllEvent=(evnt,value)=>{handleCheckedAllCheckboxRow(value);if(evnt){dispatchEvent('checkbox-all',{records:()=>$xeTable.getCheckboxRecords(),reserves:()=>$xeTable.getCheckboxReserveRecords(),indeterminates:()=>$xeTable.getCheckboxIndeterminateRecords(),checked:value},evnt);}};/**
         * 纵向 Y 可视渲染处理
         */const loadScrollYData=()=>{const{isAllOverflow,isScrollYBig}=reactData;const{mergeBodyList,scrollYStore}=internalData;const{preloadSize,startIndex,endIndex,offsetSize}=scrollYStore;const autoOffsetYSize=isAllOverflow?offsetSize:offsetSize+1;const{toVisibleIndex,visibleSize}=handleVirtualYVisible();const offsetItem={startIndex:Math.max(0,isScrollYBig?toVisibleIndex-1:toVisibleIndex-1-offsetSize-preloadSize),endIndex:isScrollYBig?toVisibleIndex+visibleSize:toVisibleIndex+visibleSize+autoOffsetYSize+preloadSize};scrollYStore.visibleStartIndex=toVisibleIndex-1;scrollYStore.visibleEndIndex=toVisibleIndex+visibleSize+1;calculateMergerOffsetIndex(mergeBodyList,offsetItem,'row');const{startIndex:offsetStartIndex,endIndex:offsetEndIndex}=offsetItem;if(toVisibleIndex<=startIndex||toVisibleIndex>=endIndex-visibleSize-1){if(startIndex!==offsetStartIndex||endIndex!==offsetEndIndex){scrollYStore.startIndex=offsetStartIndex;scrollYStore.endIndex=offsetEndIndex;$xeTable.updateScrollYData();}}};const createGetRowCacheProp=prop=>{const{handleGetRowId}=createHandleGetRowId($xeTable);return function(row){const{fullAllDataRowIdData}=internalData;if(row){const rowid=handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid];if(rowRest){return rowRest[prop];}}return-1;};};const createGetColumnCacheProp=prop=>{return function(column){const{fullColumnIdData}=internalData;if(column){const colRest=fullColumnIdData[column.id];if(colRest){return colRest[prop];}}return-1;};};const lazyScrollXData=()=>{const{lxTimeout,lxRunTime,scrollXStore}=internalData;const{visibleSize}=scrollXStore;const fpsTime=visibleSize>26?26:visibleSize>16?14:6;if(lxTimeout){clearTimeout(lxTimeout);}if(!lxRunTime||lxRunTime+fpsTime<Date.now()){internalData.lxRunTime=Date.now();loadScrollXData();}internalData.lxTimeout=setTimeout(()=>{internalData.lxTimeout=undefined;internalData.lxRunTime=undefined;loadScrollXData();},fpsTime);};const lazyScrollYData=()=>{const{lyTimeout,lyRunTime,scrollYStore}=internalData;const{visibleSize}=scrollYStore;const fpsTime=visibleSize>30?32:visibleSize>20?18:8;if(lyTimeout){clearTimeout(lyTimeout);}if(!lyRunTime||lyRunTime+fpsTime<Date.now()){internalData.lyRunTime=Date.now();loadScrollYData();}internalData.lyTimeout=setTimeout(()=>{internalData.lyTimeout=undefined;internalData.lyRunTime=undefined;loadScrollYData();},fpsTime);};const checkLastSyncScroll=(isRollX,isRollY)=>{const{scrollXLoad,scrollYLoad}=reactData;const{lcsTimeout}=internalData;if(lcsTimeout){clearTimeout(lcsTimeout);}internalData.lcsTimeout=setTimeout(()=>{internalData.lcsRunTime=Date.now();internalData.lcsTimeout=undefined;internalData.intoRunScroll=false;internalData.inVirtualScroll=false;internalData.inWheelScroll=false;internalData.inHeaderScroll=false;internalData.inBodyScroll=false;internalData.inFooterScroll=false;internalData.scrollRenderType='';calcCellHeight();if(isRollX&&scrollXLoad){$xeTable.updateScrollXData();}if(isRollY&&scrollYLoad){$xeTable.updateScrollYData().then(()=>{calcCellHeight();$xeTable.updateScrollYSpace();});}updateRowExpandStyle();$xeTable.updateCellAreas();},200);};const getWheelSpeed=lastScrollTime=>{let multiple=1;const currTime=Date.now();if(lastScrollTime+25>currTime){multiple=1.18;}else if(lastScrollTime+30>currTime){multiple=1.15;}else if(lastScrollTime+40>currTime){multiple=1.12;}else if(lastScrollTime+55>currTime){multiple=1.09;}else if(lastScrollTime+75>currTime){multiple=1.06;}else if(lastScrollTime+100>currTime){multiple=1.03;}return multiple;};const wheelScrollLeftTo=(scrollLeft,cb)=>{requestAnimationFrame(()=>{cb(scrollLeft);});};const wheelScrollTopTo=(diffNum,cb)=>{const duration=Math.abs(diffNum);const startTime=performance.now();let countTop=0;const step=timestamp=>{let progress=(timestamp-startTime)/duration;if(progress>1){progress=1;}const easedProgress=Math.pow(progress,2);const offsetTop=Math.floor(diffNum*easedProgress)-countTop;countTop+=offsetTop;cb(offsetTop);if(progress<1){requestAnimationFrame(step);}};requestAnimationFrame(step);};const dispatchEvent=(type,params,evnt)=>{emit(type,createEvent(evnt,{$table:$xeTable,$grid:$xeGrid},params));};const handleScrollToRowColumn=(fieldOrColumn,row)=>{const{fullColumnIdData}=internalData;const column=handleFieldOrColumn($xeTable,fieldOrColumn);if(column&&fullColumnIdData[column.id]){return colToVisible($xeTable,column,row);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();};const handleUpdateResize=()=>{const el=refElem.value;if(el&&el.clientWidth&&el.clientHeight){tableMethods.recalculate();}};const handleUpdateColResize=(evnt,params)=>{$xeTable.analyColumnWidth();$xeTable.recalculate().then(()=>{$xeTable.saveCustomStore('update:width');$xeTable.updateCellAreas();$xeTable.dispatchEvent('column-resizable-change',params,evnt);// 已废弃 resizable-change
$xeTable.dispatchEvent('resizable-change',params,evnt);setTimeout(()=>$xeTable.recalculate(true),300);});};const handleUpdateRowResize=(evnt,params)=>{reactData.resizeHeightFlag++;$xeTable.recalculate().then(()=>{$xeTable.updateCellAreas();$xeTable.dispatchEvent('row-resizable-change',params,evnt);setTimeout(()=>$xeTable.recalculate(true),300);});};const updateColumnOffsetLeft=()=>{const{visibleColumn,fullColumnIdData}=internalData;let offsetLeft=0;for(let cIndex=0,rLen=visibleColumn.length;cIndex<rLen;cIndex++){const column=visibleColumn[cIndex];const colid=column.id;const colRest=fullColumnIdData[colid];colRest.oLeft=offsetLeft;offsetLeft+=column.renderWidth;}};const updateRowOffsetTop=()=>{const{expandColumn}=reactData;const{afterFullData,fullAllDataRowIdData,rowExpandedMaps}=internalData;const expandOpts=computeExpandOpts.value;const rowOpts=computeRowOpts.value;const cellOpts=computeCellOpts.value;const defaultRowHeight=computeDefaultRowHeight.value;const{handleGetRowId}=createHandleGetRowId($xeTable);let offsetTop=0;for(let rIndex=0,rLen=afterFullData.length;rIndex<rLen;rIndex++){const row=afterFullData[rIndex];const rowid=handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid]||{};rowRest.oTop=offsetTop;offsetTop+=rowRest.resizeHeight||cellOpts.height||rowOpts.height||rowRest.height||defaultRowHeight;// 是否展开行
if(expandColumn&&rowExpandedMaps[rowid]){offsetTop+=rowRest.expandHeight||expandOpts.height||0;}}};const updateRowExpandStyle=()=>{const{expandColumn,scrollYLoad,scrollYTop,isScrollYBig}=reactData;const expandOpts=computeExpandOpts.value;const rowOpts=computeRowOpts.value;const cellOpts=computeCellOpts.value;const defaultRowHeight=computeDefaultRowHeight.value;const{mode}=expandOpts;if(expandColumn&&mode==='fixed'){const{elemStore,fullAllDataRowIdData}=internalData;const rowExpandEl=refRowExpandElem.value;const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);if(rowExpandEl&&bodyScrollElem){let isUpdateHeight=false;external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(rowExpandEl.children,reEl=>{const expandEl=reEl;const rowid=expandEl.getAttribute('rowid')||'';const rowRest=fullAllDataRowIdData[rowid];if(rowRest){const expandHeight=expandEl.offsetHeight+1;const trEl=bodyScrollElem.querySelector(`.vxe-body--row[rowid="${rowid}"]`);let offsetTop=0;if(scrollYLoad){if(isScrollYBig&&trEl){offsetTop=trEl.offsetTop+trEl.offsetHeight;}else{offsetTop=rowRest.oTop+(rowRest.resizeHeight||cellOpts.height||rowOpts.height||rowRest.height||defaultRowHeight);}}else{if(trEl){offsetTop=trEl.offsetTop+trEl.offsetHeight;}}if(isScrollYBig){offsetTop+=scrollYTop;}expandEl.style.top=toCssUnit(offsetTop);if(!isUpdateHeight){if(rowRest.expandHeight!==expandHeight){isUpdateHeight=true;}}rowRest.expandHeight=expandHeight;}});if(isUpdateHeight){reactData.rowExpandHeightFlag++;(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{updateRowOffsetTop();});}}}};const handleRowExpandScroll=()=>{const{elemStore}=internalData;const rowExpandEl=refRowExpandElem.value;const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);if(rowExpandEl&&bodyScrollElem){rowExpandEl.scrollTop=bodyScrollElem.scrollTop;}};tableMethods={dispatchEvent,getEl(){return refElem.value;},/**
             * 重置表格的一切数据状态
             */clearAll(){return clearTableAllStatus($xeTable);},/**
             * 同步 data 数据（即将废弃）
             * 如果用了该方法，那么组件将不再记录增删改的状态，只能自行实现对应逻辑
             * 对于某些特殊的场景，比如深层树节点元素发生变动时可能会用到
             */syncData(){errLog('vxe.error.delFunc',['syncData','getData']);return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{reactData.tableData=[];emit('update:data',internalData.tableFullData);return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();});},/**
             * 手动处理数据，用于手动排序与筛选
             * 对于手动更改了排序、筛选...等条件后需要重新处理数据时可能会用到
             */updateData(){const{scrollXLoad,scrollYLoad}=reactData;return tablePrivateMethods.handleTableData(true).then(()=>{tableMethods.updateFooter();if(scrollXLoad||scrollYLoad){if(scrollXLoad){tablePrivateMethods.updateScrollXSpace();}if(scrollYLoad){tablePrivateMethods.updateScrollYSpace();}return tableMethods.refreshScroll();}}).then(()=>{tableMethods.updateCellAreas();return tableMethods.recalculate(true);}).then(()=>{// 存在滚动行为未结束情况
setTimeout(()=>$xeTable.recalculate(),50);});},/**
             * 重新加载数据，不会清空表格状态
             * @param {Array} datas 数据
             */loadData(datas){const{initStatus}=internalData;return loadTableData(datas,false).then(()=>{internalData.inited=true;internalData.initStatus=true;if(!initStatus){handleLoadDefaults();}return tableMethods.recalculate();});},/**
             * 重新加载数据，会清空表格状态
             * @param {Array} datas 数据
             */reloadData(datas){return tableMethods.clearAll().then(()=>{internalData.inited=true;internalData.initStatus=true;return loadTableData(datas,true);}).then(()=>{handleLoadDefaults();return tableMethods.recalculate();});},/**
             * 修改行数据
             */setRow(rows,record){if(rows&&record){let rest=rows;if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){rest=[rows];}const rowkey=getRowkey($xeTable);rest.forEach(row=>{const rowid=getRowid($xeTable,row);const newRecord=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(Object.assign({},record),true);external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(newRecord,rowkey,rowid);Object.assign(row,newRecord);});}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 局部加载行数据并恢复到初始状态
             * 对于行数据需要局部更改的场景中可能会用到
             * @param {Row} row 行对象
             * @param {Object} record 新数据
             * @param {String} field 字段名
             */reloadRow(row,record,field){const{keepSource}=props;const{tableData}=reactData;const{tableSourceData}=internalData;if(keepSource){const rowIndex=tableMethods.getRowIndex(row);const oRow=tableSourceData[rowIndex];if(oRow&&row){if(field){const newValue=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(record||row,field),true);external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row,field,newValue);external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(oRow,field,newValue);}else{const rowkey=getRowkey($xeTable);const rowid=getRowid($xeTable,row);const newRecord=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(Object.assign({},record),true);external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(newRecord,rowkey,rowid);external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().destructuring(oRow,Object.assign(row,newRecord));}}reactData.tableData=tableData.slice(0);}else{if(true){warnLog('vxe.error.reqProp',['keep-source']);}}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},getParams(){return props.params;},/**
             * 用于树结构，给行数据加载子节点
             */loadTreeChildren(row,childRecords){const{keepSource}=props;const{tableSourceData,fullDataRowIdData,fullAllDataRowIdData,sourceDataRowIdData}=internalData;const treeOpts=computeTreeOpts.value;const{transform,mapChildrenField}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;const parentRest=fullAllDataRowIdData[getRowid($xeTable,row)];const parentLevel=parentRest?parentRest.level:0;return tableMethods.createData(childRecords).then(rows=>{if(keepSource){const rowid=getRowid($xeTable,row);const matchObj=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableSourceData,item=>rowid===getRowid($xeTable,item),{children:childrenField});if(matchObj){matchObj.item[childrenField]=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(rows,true);}rows.forEach(childRow=>{const rowid=getRowid($xeTable,childRow);sourceDataRowIdData[rowid]=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(childRow,true);});}external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(rows,(childRow,index,items,path,parentItem,nodes)=>{const rowid=getRowid($xeTable,childRow);const parentRow=parentItem||parentRest.row;const rest={row:childRow,rowid,seq:-1,index,_index:-1,$index:-1,treeIndex:-1,items,parent:parentRow,level:parentLevel+nodes.length,height:0,resizeHeight:0,oTop:0,expandHeight:0};fullDataRowIdData[rowid]=rest;fullAllDataRowIdData[rowid]=rest;},{children:childrenField});row[childrenField]=rows;if(transform){row[mapChildrenField]=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(rows,false);}updateAfterDataIndex();return rows;});},/**
             * 加载列配置
             * 对于表格列需要重载、局部递增场景下可能会用到
             * @param {ColumnInfo} columns 列配置
             */loadColumn(columns){const collectColumn=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().mapTree(columns,column=>(0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(cell.createColumn($xeTable,column)));return handleColumn(collectColumn);},/**
             * 加载列配置并恢复到初始状态
             * 对于表格列需要重载、局部递增场景下可能会用到
             * @param {ColumnInfo} columns 列配置
             */reloadColumn(columns){return tableMethods.clearAll().then(()=>{return tableMethods.loadColumn(columns);});},/**
             * 根据 tr 元素获取对应的 row 信息
             * @param {Element} tr 元素
             */getRowNode(tr){if(tr){const{fullAllDataRowIdData}=internalData;const rowid=tr.getAttribute('rowid');if(rowid){const rowRest=fullAllDataRowIdData[rowid];if(rowRest){return{rowid:rowRest.rowid,item:rowRest.row,index:rowRest.index,items:rowRest.items,parent:rowRest.parent};}}}return null;},/**
             * 根据 th/td 元素获取对应的 column 信息
             * @param {Element} cell 元素
             */getColumnNode(cell){if(cell){const{fullColumnIdData}=internalData;const colid=cell.getAttribute('colid');if(colid){const colRest=fullColumnIdData[colid];if(colRest){return{colid:colRest.colid,item:colRest.column,index:colRest.index,items:colRest.items,parent:colRest.parent};}}}return null;},/**
             * 根据 row 获取序号
             * @param {Row} row 行对象
             */getRowSeq:createGetRowCacheProp('seq'),/**
             * 根据 row 获取相对于 data 中的索引
             * @param {Row} row 行对象
             */getRowIndex:createGetRowCacheProp('index'),/**
             * 根据 row 获取相对于当前数据中的索引
             * @param {Row} row 行对象
             */getVTRowIndex:createGetRowCacheProp('_index'),/**
             * 根据 row 获取渲染中的虚拟索引
             * @param {Row} row 行对象
             */getVMRowIndex:createGetRowCacheProp('$index'),/**
             * 根据 column 获取相对于 columns 中的索引
             * @param {ColumnInfo} column 列配置
             */getColumnIndex:createGetColumnCacheProp('index'),/**
             * 根据 column 获取相对于当前表格列中的索引
             * @param {ColumnInfo} column 列配置
             */getVTColumnIndex:createGetColumnCacheProp('_index'),/**
             * 根据 column 获取渲染中的虚拟索引
             * @param {ColumnInfo} column 列配置
             */getVMColumnIndex:createGetColumnCacheProp('$index'),/**
             * 创建 data 对象
             * 对于某些特殊场景可能会用到，会自动对数据的字段名进行检测，如果不存在就自动定义
             * @param {Array} records 新数据
             */createData(records){return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(tablePrivateMethods.defineField(records));});},/**
             * 创建 Row|Rows 对象
             * 对于某些特殊场景需要对数据进行手动插入时可能会用到
             * @param {Array/Object} records 新数据
             */createRow(records){const isArr=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(records);if(!isArr){records=[records||{}];}return tableMethods.createData(records).then(rows=>isArr?rows:rows[0]);},/**
             * 还原数据
             * 如果不传任何参数，则还原整个表格
             * 如果传 row 则还原一行
             * 如果传 rows 则还原多行
             * 如果还额外传了 field 则还原指定的单元格数据
             */revertData(rows,field){const{keepSource,treeConfig}=props;const{fullAllDataRowIdData,fullDataRowIdData,tableSourceData,sourceDataRowIdData,tableFullData,afterFullData,removeRowMaps}=internalData;const treeOpts=computeTreeOpts.value;const{transform}=treeOpts;const{handleGetRowId}=createHandleGetRowId($xeTable);if(!keepSource){if(true){errLog('vxe.error.reqProp',['keep-source']);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}let targetRows=rows;if(rows){if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){targetRows=[rows];}}else{targetRows=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArray($xeTable.getUpdateRecords());}let reDelFlag=false;if(targetRows.length){targetRows.forEach(item=>{const rowid=handleGetRowId(item);const rowRest=fullAllDataRowIdData[rowid];if(rowRest){const row=rowRest.row;if(!$xeTable.isInsertByRow(row)){const oRow=sourceDataRowIdData[rowid];if(oRow&&row){if(field){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row,field,external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(oRow,field),true));}else{external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().destructuring(row,external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(oRow,true));}if(!fullDataRowIdData[rowid]&&$xeTable.isRemoveByRow(row)){if(removeRowMaps[rowid]){delete removeRowMaps[rowid];}tableFullData.unshift(row);afterFullData.unshift(row);reDelFlag=true;}}}}});}if(rows){if(reDelFlag){reactData.removeRowFlag++;$xeTable.updateFooter();$xeTable.cacheRowMap(false);$xeTable.handleTableData(treeConfig&&transform);if(!(treeConfig&&transform)){$xeTable.updateAfterDataIndex();}$xeTable.checkSelectionStatus();if(reactData.scrollYLoad){$xeTable.updateScrollYSpace();}}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{$xeTable.updateCellAreas();return $xeTable.recalculate();});}return $xeTable.reloadData(tableSourceData);},/**
             * 清空单元格内容
             * 如果不创参数，则清空整个表格内容
             * 如果传 row 则清空一行内容
             * 如果传 rows 则清空多行内容
             * 如果还额外传了 field 则清空指定单元格内容
             * @param {Array/Row} rows 行数据
             * @param {String} field 字段名
             */clearData(rows,field){const{tableFullData,visibleColumn}=internalData;if(!arguments.length){rows=tableFullData;}else if(rows&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){rows=[rows];}if(field){rows.forEach(row=>external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row,field,null));}else{rows.forEach(row=>{visibleColumn.forEach(column=>{if(column.field){setCellValue(row,column,null);}});});}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},getCellElement(row,fieldOrColumn){const{elemStore}=internalData;const column=handleFieldOrColumn($xeTable,fieldOrColumn);if(!column){return null;}const rowid=getRowid($xeTable,row);const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const leftScrollElem=getRefElem(elemStore['left-body-scroll']);const rightScrollElem=getRefElem(elemStore['right-body-scroll']);let bodyElem;if(column){if(column.fixed){if(column.fixed==='left'){if(leftScrollElem){bodyElem=leftScrollElem;}}else{if(rightScrollElem){bodyElem=rightScrollElem;}}}if(!bodyElem){bodyElem=bodyScrollElem;}if(bodyElem){return bodyElem.querySelector(`.vxe-body--row[rowid="${rowid}"] .${column.id}`);}}return null;},getCellLabel(row,fieldOrColumn){const column=handleFieldOrColumn($xeTable,fieldOrColumn);if(!column){return null;}const{formatter}=column;const cellValue=getCellValue(row,column);let cellLabel=cellValue;if(formatter){let formatData;const{fullAllDataRowIdData}=internalData;const rowid=getRowid($xeTable,row);const colid=column.id;const rowRest=fullAllDataRowIdData[rowid];if(rowRest){formatData=rowRest.formatData;if(!formatData){formatData=fullAllDataRowIdData[rowid].formatData={};}if(rowRest&&formatData[colid]){if(formatData[colid].value===cellValue){return formatData[colid].label;}}}const formatParams={cellValue,row,rowIndex:tableMethods.getRowIndex(row),column,columnIndex:tableMethods.getColumnIndex(column)};if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(formatter)){const gFormatOpts=table_formats.get(formatter);const tcFormatMethod=gFormatOpts?gFormatOpts.tableCellFormatMethod||gFormatOpts.cellFormatMethod:null;cellLabel=tcFormatMethod?tcFormatMethod(formatParams):'';}else if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(formatter)){const gFormatOpts=table_formats.get(formatter[0]);const tcFormatMethod=gFormatOpts?gFormatOpts.tableCellFormatMethod||gFormatOpts.cellFormatMethod:null;cellLabel=tcFormatMethod?tcFormatMethod(formatParams,...formatter.slice(1)):'';}else{cellLabel=formatter(formatParams);}if(formatData){formatData[colid]={value:cellValue,label:cellLabel};}}return cellLabel;},/**
             * 检查是否为临时行数据
             * @param {Row} row 行对象
             */isInsertByRow(row){const rowid=getRowid($xeTable,row);return!!reactData.insertRowFlag&&!!internalData.insertRowMaps[rowid];},isRemoveByRow(row){const rowid=getRowid($xeTable,row);return!!reactData.removeRowFlag&&!!internalData.removeRowMaps[rowid];},/**
             * 删除所有新增的临时数据
             * @returns
             */removeInsertRow(){internalData.insertRowMaps={};return $xeTable.remove($xeTable.getInsertRecords());},/**
             * 检查行或列数据是否发生改变
             * @param {Row} rowidOrRow 行对象、行主键
             * @param {String} field 字段名
             */isUpdateByRow(rowidOrRow,field){const{keepSource}=props;const{tableFullColumn,fullDataRowIdData,sourceDataRowIdData}=internalData;if(keepSource){const rowid=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(rowidOrRow)||external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(rowidOrRow)?rowidOrRow:getRowid($xeTable,rowidOrRow);const rowRest=fullDataRowIdData[rowid];// 新增的数据不需要检测
if(!rowRest){return false;}const row=rowRest.row;const oRow=sourceDataRowIdData[rowid];if(oRow){if(arguments.length>1){return!eqCellValue(oRow,row,field);}for(let index=0,len=tableFullColumn.length;index<len;index++){const property=tableFullColumn[index].field;if(property&&!eqCellValue(oRow,row,property)){return true;}}}}return false;},/**
             * 获取表格的可视列，也可以指定索引获取列
             * @param {Number} columnIndex 索引
             */getColumns(columnIndex){const{visibleColumn}=internalData;return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(columnIndex)?visibleColumn.slice(0):visibleColumn[columnIndex];},/**
             * 根据列获取列的唯一主键
             */getColid(fieldOrColumn){const column=handleFieldOrColumn($xeTable,fieldOrColumn);return column?column.id:null;},/**
             * 根据列的唯一主键获取列
             * @param {String} colid 列主键
             */getColumnById(colid){const{fullColumnIdData}=internalData;return colid&&fullColumnIdData[colid]?fullColumnIdData[colid].column:null;},/**
             * 根据列的字段名获取列
             * @param {String} field 字段名
             */getColumnByField(field){const fullColumnFieldData=internalData.fullColumnFieldData;return field&&fullColumnFieldData[field]?fullColumnFieldData[field].column:null;},getParentColumn(fieldOrColumn){const{fullColumnIdData}=internalData;const column=handleFieldOrColumn($xeTable,fieldOrColumn);return column&&column.parentId&&fullColumnIdData[column.parentId]?fullColumnIdData[column.parentId].column:null;},/**
             * 获取当前表格的列
             * 收集到的全量列、全量表头列、处理条件之后的全量表头列、当前渲染中的表头列
             */getTableColumn(){return{collectColumn:internalData.collectColumn.slice(0),fullColumn:internalData.tableFullColumn.slice(0),visibleColumn:internalData.visibleColumn.slice(0),tableColumn:reactData.tableColumn.slice(0)};},/**
             * 移动列到指定列的位置
             * @param fieldOrColumn
             * @param targetFieldOrColumn
             * @param options
             */moveColumnTo(fieldOrColumn,targetFieldOrColumn,options){const{fullColumnIdData,visibleColumn}=internalData;const{dragToChild,dragPos,isCrossDrag}=Object.assign({},options);const dragCol=handleFieldOrColumn($xeTable,fieldOrColumn);let prevDragCol=null;const colRest=dragCol?fullColumnIdData[dragCol.id]:null;let defPos='left';if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(targetFieldOrColumn)){if(colRest&&targetFieldOrColumn){let currList=colRest.items;let offsetIndex=colRest._index+targetFieldOrColumn;if(isCrossDrag){currList=visibleColumn;offsetIndex=colRest._index+targetFieldOrColumn;}if(offsetIndex>0&&offsetIndex<currList.length-1){prevDragCol=currList[offsetIndex];}if(targetFieldOrColumn>0){defPos='right';}}}else{prevDragCol=handleFieldOrColumn($xeTable,targetFieldOrColumn);const targetColRest=prevDragCol?fullColumnIdData[prevDragCol.id]:null;if(colRest&&targetColRest){if(targetColRest._index>colRest._index){defPos='right';}}}return $xeTable.handleColDragSwapEvent(null,true,dragCol,prevDragCol,dragPos||defPos,dragToChild===true);},/**
             * 移动行到指定行的位置
             * @param rowidOrRow
             * @param targetRowidOrRow
             * @param options
             */moveRowTo(rowidOrRow,targetRowidOrRow,options){const{treeConfig}=props;const{fullAllDataRowIdData,afterFullData}=internalData;const{dragToChild,dragPos,isCrossDrag}=Object.assign({},options);const treeOpts=computeTreeOpts.value;const dragRow=handleRowidOrRow($xeTable,rowidOrRow);let prevDragRow=null;let defPos='top';const rowRest=dragRow?fullAllDataRowIdData[getRowid($xeTable,dragRow)]:null;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(targetRowidOrRow)){if(rowRest&&targetRowidOrRow){let currList=afterFullData;let offsetIndex=rowRest._index+targetRowidOrRow;if(treeConfig){currList=rowRest.items;if(treeOpts.transform){offsetIndex=rowRest.treeIndex+targetRowidOrRow;if(isCrossDrag){currList=afterFullData;offsetIndex=rowRest._index+targetRowidOrRow;}}}if(offsetIndex>=0&&offsetIndex<=currList.length-1){prevDragRow=currList[offsetIndex];}if(targetRowidOrRow>0){defPos='bottom';}}}else{prevDragRow=handleRowidOrRow($xeTable,targetRowidOrRow);const targetRowRest=prevDragRow?fullAllDataRowIdData[getRowid($xeTable,prevDragRow)]:null;if(rowRest&&targetRowRest){if(targetRowRest._index>rowRest._index){defPos='bottom';}}}return $xeTable.handleRowDragSwapEvent(null,true,dragRow,prevDragRow,dragPos||defPos,dragToChild===true);},/**
             * 获取表格的全量列
             */getFullColumns(){const{collectColumn}=internalData;return collectColumn.slice(0);},/**
             * 获取数据，和 data 的行为一致，也可以指定索引获取数据
             */getData(rowIndex){const tableSynchData=props.data||internalData.tableSynchData;return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(rowIndex)?tableSynchData.slice(0):tableSynchData[rowIndex];},/**
             * 用于多选行，获取已选中的数据
             */getCheckboxRecords(isFull){const{treeConfig}=props;const{updateCheckboxFlag}=reactData;const{tableFullData,afterFullData,tableFullTreeData,fullDataRowIdData,afterFullRowMaps,selectCheckboxMaps}=internalData;const treeOpts=computeTreeOpts.value;const checkboxOpts=computeCheckboxOpts.value;const{transform,mapChildrenField}=treeOpts;const{checkField}=checkboxOpts;const childrenField=treeOpts.children||treeOpts.childrenField;let rowList=[];if(updateCheckboxFlag){if(checkField){if(treeConfig){// 如果开启 transform 默认就是完整数据
const currTableData=isFull?transform?tableFullTreeData:tableFullData:transform?tableFullTreeData:afterFullData;rowList=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().filterTree(currTableData,row=>external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,checkField),{children:transform?mapChildrenField:childrenField});}else{const currTableData=isFull?tableFullData:afterFullData;rowList=currTableData.filter(row=>external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,checkField));}}else{external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(selectCheckboxMaps,(row,rowid)=>{if(isFull){if(fullDataRowIdData[rowid]){rowList.push(fullDataRowIdData[rowid].row);}}else{if(afterFullRowMaps[rowid]){rowList.push(afterFullRowMaps[rowid]);}}});}}return rowList;},/**
             * 只对 tree-config 有效，获取行的子级
             */getTreeRowChildren(rowOrRowid){const{treeConfig}=props;const{fullAllDataRowIdData}=internalData;const treeOpts=computeTreeOpts.value;const{transform,mapChildrenField}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;if(rowOrRowid&&treeConfig){let rowid;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(rowOrRowid)){rowid=rowOrRowid;}else{rowid=getRowid($xeTable,rowOrRowid);}if(rowid){const rest=fullAllDataRowIdData[rowid];const row=rest?rest.row:null;if(row){return row[transform?mapChildrenField:childrenField]||[];}}}return[];},/**
             * 只对 tree-config 有效，获取行的父级
             */getTreeParentRow(rowOrRowid){const{treeConfig}=props;const{fullAllDataRowIdData}=internalData;if(rowOrRowid&&treeConfig){let rowid;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(rowOrRowid)){rowid=rowOrRowid;}else{rowid=getRowid($xeTable,rowOrRowid);}if(rowid){const rest=fullAllDataRowIdData[rowid];return rest?rest.parent:null;}}return null;},getParentRow(rowOrRowid){warnLog('vxe.error.delFunc',['getParentRow','getTreeParentRow']);return $xeTable.getTreeParentRow(rowOrRowid);},/**
             * 根据行的唯一主键获取行
             * @param {String/Number} rowid 行主键
             */getRowById(cellValue){const{fullAllDataRowIdData}=internalData;const rowid=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(cellValue)?'':encodeURIComponent(cellValue||'');return fullAllDataRowIdData[rowid]?fullAllDataRowIdData[rowid].row:null;},/**
             * 根据行获取行的唯一主键
             * @param {Row} row 行对象
             */getRowid(row){return getRowid($xeTable,row);},/**
             * 获取处理后的表格数据
             * 如果存在筛选条件，继续处理
             * 如果存在排序，继续处理
             */getTableData(){const{tableData,footerTableData}=reactData;const{tableFullData,afterFullData,tableFullTreeData}=internalData;return{fullData:props.treeConfig?tableFullTreeData.slice(0):tableFullData.slice(0),visibleData:afterFullData.slice(0),tableData:tableData.slice(0),footerData:footerTableData.slice(0)};},/**
             * 获取表格的全量数据，如果是 tree-config 则返回带层级的树结构
             */getFullData(){const{treeConfig}=props;const{tableFullData,tableFullTreeData}=internalData;if(treeConfig){const treeOpts=computeTreeOpts.value;const{transform,mapChildrenField,rowField,parentField}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;if(transform){return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toTreeArray(tableFullTreeData,{children:mapChildrenField}),{key:rowField,parentKey:parentField,children:childrenField,mapChildren:mapChildrenField});}return tableFullTreeData.slice(0);}return tableFullData.slice(0);},/**
             * 设置为固定列
             */setColumnFixed(fieldOrColumn,fixed){let status=false;const cols=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn)?fieldOrColumn:[fieldOrColumn];const columnOpts=computeColumnOpts.value;const isMaxFixedColumn=computeIsMaxFixedColumn.value;for(let i=0;i<cols.length;i++){const item=cols[i];const column=handleFieldOrColumn($xeTable,item);const targetColumn=getRootColumn($xeTable,column);if(targetColumn&&targetColumn.fixed!==fixed){// 是否超过最大固定列数量
if(!targetColumn.fixed&&isMaxFixedColumn){if(core_.VxeUI.modal){core_.VxeUI.modal.message({status:'error',content:table_getI18n('vxe.table.maxFixedCol',[columnOpts.maxFixedSize])});}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([targetColumn],column=>{column.fixed=fixed;});tablePrivateMethods.saveCustomStore('update:fixed');if(!status){status=true;}}}if(status){return tableMethods.refreshColumn();}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 取消指定固定列
             */clearColumnFixed(fieldOrColumn){let status=false;const cols=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn)?fieldOrColumn:[fieldOrColumn];cols.forEach(item=>{const column=handleFieldOrColumn($xeTable,item);const targetColumn=getRootColumn($xeTable,column);if(targetColumn&&targetColumn.fixed){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([targetColumn],column=>{column.fixed=null;});tablePrivateMethods.saveCustomStore('update:fixed');if(!status){status=true;}}});if(status){return tableMethods.refreshColumn();}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 隐藏指定列
             */hideColumn(fieldOrColumn){let status=false;const cols=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn)?fieldOrColumn:[fieldOrColumn];cols.forEach(item=>{const column=handleFieldOrColumn($xeTable,item);if(column&&column.visible){column.visible=false;if(!status){status=true;}}});if(status){return tablePrivateMethods.handleCustom();}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 显示指定列
             */showColumn(fieldOrColumn){let status=false;const cols=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn)?fieldOrColumn:[fieldOrColumn];cols.forEach(item=>{const column=handleFieldOrColumn($xeTable,item);if(column&&!column.visible){column.visible=true;if(!status){status=true;}}});if(status){return tablePrivateMethods.handleCustom();}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},setColumnWidth(fieldOrColumn,width){const{elemStore}=internalData;let status=false;const cols=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn)?fieldOrColumn:[fieldOrColumn];let cWidth=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(width);if(isScale(width)){const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const bodyWidth=bodyScrollElem?bodyScrollElem.clientWidth-1:0;cWidth=Math.floor(cWidth*bodyWidth);}if(cWidth){cols.forEach(item=>{const column=handleFieldOrColumn($xeTable,item);if(column){column.resizeWidth=cWidth;if(!status){status=true;}}});if(status){return $xeTable.refreshColumn().then(()=>{return{status};});}}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{return{status};});},getColumnWidth(fieldOrColumn){const column=handleFieldOrColumn($xeTable,fieldOrColumn);if(column){return column.renderWidth;}return 0;},/**
             * 手动重置列的显示隐藏、列宽拖动的状态、固定列、排序列；
             * 如果为 true 则重置所有状态
             * 如果已关联工具栏，则会同步更新
             */resetColumn(options){warnLog('vxe.error.delFunc',['resetColumn','resetCustom']);return $xeTable.resetCustom(options);},/**
             * 刷新列信息
             * 将固定的列左边、右边分别靠边
             * 如果传 true 则会检查列顺序并排序
             */refreshColumn(initSort){if(initSort){handleUpdateColumn();}return parseColumns(true).then(()=>{return tableMethods.refreshScroll();}).then(()=>{return tableMethods.recalculate();});},setRowHeightConf(heightConf){const{fullAllDataRowIdData}=internalData;let status=false;if(heightConf){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(heightConf,(height,rowid)=>{const rowRest=fullAllDataRowIdData[rowid];if(rowRest){const rHeight=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(height);if(rHeight){rowRest.resizeHeight=rHeight;if(!status){status=true;}}}});if(status){internalData.isResizeCellHeight=true;reactData.resizeHeightFlag++;}}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{updateRowOffsetTop();return{status};});},getRowHeightConf(isFull){const{fullAllDataRowIdData,afterFullData}=internalData;const{handleGetRowId}=createHandleGetRowId($xeTable);const rowOpts=computeRowOpts.value;const cellOpts=computeCellOpts.value;const defaultRowHeight=computeDefaultRowHeight.value;const rest={};afterFullData.forEach(row=>{const rowid=handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid];if(rowRest){const resizeHeight=rowRest.resizeHeight;if(resizeHeight||isFull){const currCellHeight=resizeHeight||cellOpts.height||rowOpts.height||rowRest.height||defaultRowHeight;rest[rowid]=currCellHeight;}}});return rest;},setRowHeight(rowOrId,height){const{fullAllDataRowIdData}=internalData;let status=false;const rows=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rowOrId)?rowOrId:[rowOrId];let rHeight=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(height);if(isScale(height)){const tableBody=refTableBody.value;const bodyElem=tableBody?tableBody.$el:null;const bodyHeight=bodyElem?bodyElem.clientHeight-1:0;rHeight=Math.floor(rHeight*bodyHeight);}if(rHeight){const{handleGetRowId}=createHandleGetRowId($xeTable);rows.forEach(row=>{const rowid=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(row)||external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(row)?row:handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid];if(rowRest){rowRest.resizeHeight=rHeight;if(!status){status=true;}}});if(status){internalData.isResizeCellHeight=true;reactData.resizeHeightFlag++;}}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{return{status};});},getRowHeight(rowOrId){const{fullAllDataRowIdData}=internalData;const rowOpts=computeRowOpts.value;const cellOpts=computeCellOpts.value;const defaultRowHeight=computeDefaultRowHeight.value;const rowid=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(rowOrId)||external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(rowOrId)?rowOrId:getRowid($xeTable,rowOrId);const rowRest=fullAllDataRowIdData[rowid];if(rowRest){return rowRest.resizeHeight||cellOpts.height||rowOpts.height||rowRest.height||defaultRowHeight;}return 0;},/**
             * 刷新滚动操作，手动同步滚动相关位置（对于某些特殊的操作，比如滚动条错位、固定列不同步）
             */refreshScroll(){const{elemStore,lastScrollLeft,lastScrollTop}=internalData;const headerScrollElem=getRefElem(elemStore['main-header-scroll']);const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const footerScrollElem=getRefElem(elemStore['main-footer-scroll']);const leftScrollElem=getRefElem(elemStore['left-body-scroll']);const rightScrollElem=getRefElem(elemStore['right-body-scroll']);const xHandleEl=refScrollXHandleElem.value;const yHandleEl=refScrollYHandleElem.value;return new Promise(resolve=>{// 还原滚动条位置
if(lastScrollLeft||lastScrollTop){return restoreScrollLocation($xeTable,lastScrollLeft,lastScrollTop).then().then(()=>{// 存在滚动行为未结束情况
setTimeout(resolve,10);});}internalData.intoRunScroll=true;// 重置
setScrollTop(yHandleEl,lastScrollTop);setScrollTop(bodyScrollElem,lastScrollTop);setScrollTop(leftScrollElem,lastScrollTop);setScrollTop(rightScrollElem,lastScrollTop);setScrollLeft(xHandleEl,lastScrollLeft);setScrollLeft(bodyScrollElem,lastScrollLeft);setScrollLeft(headerScrollElem,lastScrollLeft);setScrollLeft(footerScrollElem,lastScrollLeft);// 存在滚动行为未结束情况
setTimeout(()=>{internalData.intoRunScroll=false;resolve();},10);});},/**
             * 重新渲染布局
             * 刷新布局
             */recalculate(reFull){return new Promise(resolve=>{const{rceTimeout,rceRunTime}=internalData;const resizeOpts=computeResizeOpts.value;const refreshDelay=resizeOpts.refreshDelay||20;const el=refElem.value;if(el&&el.clientWidth){autoCellWidth();updateRowExpandStyle();}if(rceTimeout){clearTimeout(rceTimeout);if(rceRunTime&&rceRunTime+(refreshDelay-5)<Date.now()){resolve(handleRecalculateLayout(!!reFull));}else{(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{resolve();});}}else{resolve(handleRecalculateLayout(!!reFull));}internalData.rceTimeout=setTimeout(()=>{internalData.rceTimeout=undefined;handleRecalculateLayout(!!reFull);},refreshDelay);});},openTooltip(target,content){const $commTip=refCommTooltip.value;if($commTip&&$commTip.open){return $commTip.open(target,content);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 关闭 tooltip
             */closeTooltip(){const{tooltipStore}=reactData;const $tooltip=refTooltip.value;const $commTip=refCommTooltip.value;if(tooltipStore.visible){Object.assign(tooltipStore,{row:null,column:null,content:null,visible:false,currOpts:{}});if($tooltip&&$tooltip.close){$tooltip.close();}}if($commTip&&$commTip.close){$commTip.close();}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 判断列头复选框是否被选中
             */isAllCheckboxChecked(){return reactData.isAllSelected;},/**
             * 判断列头复选框是否被半选
             */isAllCheckboxIndeterminate(){return!reactData.isAllSelected&&reactData.isIndeterminate;},/**
             * 获取复选框半选状态的行数据
             */getCheckboxIndeterminateRecords(isFull){const{treeConfig}=props;const{fullDataRowIdData,treeIndeterminateRowMaps}=internalData;if(treeConfig){const fullRest=[];const defRest=[];external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(treeIndeterminateRowMaps,(item,rowid)=>{if(item){fullRest.push(item);if(fullDataRowIdData[rowid]){defRest.push(item);}}});if(isFull){return fullRest;}return defRest;}return[];},/**
             * 用于多选行，设置行为选中状态，第二个参数为选中与否
             * @param {Array/Row} rows 行数据
             * @param {Boolean} value 是否选中
             */setCheckboxRow(rows,checked){if(rows&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){rows=[rows];}return handleCheckedCheckboxRow(rows,checked,true);},setCheckboxRowKey(keys,checked){const{fullAllDataRowIdData}=internalData;if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(keys)){keys=[keys];}const rows=[];keys.forEach(rowid=>{const rowRest=fullAllDataRowIdData[rowid];if(rowRest){rows.push(rowRest.row);}});return handleCheckedCheckboxRow(rows,checked,true);},isCheckedByCheckboxRow(row){const{updateCheckboxFlag}=reactData;const{selectCheckboxMaps}=internalData;const checkboxOpts=computeCheckboxOpts.value;const{checkField}=checkboxOpts;if(checkField){return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,checkField);}return!!updateCheckboxFlag&&!!selectCheckboxMaps[getRowid($xeTable,row)];},isCheckedByCheckboxRowKey(rowid){const{updateCheckboxFlag}=reactData;const{fullAllDataRowIdData,selectCheckboxMaps}=internalData;const checkboxOpts=computeCheckboxOpts.value;const{checkField}=checkboxOpts;if(checkField){const rowRest=fullAllDataRowIdData[rowid];if(rowRest){return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rowRest.row,checkField);}return false;}return!!updateCheckboxFlag&&!!selectCheckboxMaps[rowid];},isIndeterminateByCheckboxRow(row){const{treeIndeterminateRowMaps}=internalData;return!!treeIndeterminateRowMaps[getRowid($xeTable,row)]&&!$xeTable.isCheckedByCheckboxRow(row);},isIndeterminateByCheckboxRowKey(rowid){const{treeIndeterminateRowMaps}=internalData;return!!treeIndeterminateRowMaps[rowid]&&!$xeTable.isCheckedByCheckboxRowKey(rowid);},/**
             * 多选，切换某一行的选中状态
             */toggleCheckboxRow(row){const{selectCheckboxMaps}=internalData;const checkboxOpts=computeCheckboxOpts.value;const{checkField}=checkboxOpts;const checked=checkField?!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,checkField):!selectCheckboxMaps[getRowid($xeTable,row)];tablePrivateMethods.handleBatchSelectRows([row],checked,true);tablePrivateMethods.checkSelectionStatus();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 用于多选行，设置所有行的选中状态
             * @param {Boolean} value 是否选中
             */setAllCheckboxRow(value){return handleCheckedAllCheckboxRow(value,true);},/**
             * 获取单选框保留选中的行
             */getRadioReserveRecord(isFull){const{treeConfig}=props;const{fullDataRowIdData,radioReserveRow,afterFullData}=internalData;const radioOpts=computeRadioOpts.value;const treeOpts=computeTreeOpts.value;const childrenField=treeOpts.children||treeOpts.childrenField;if(radioOpts.reserve&&radioReserveRow){const rowid=getRowid($xeTable,radioReserveRow);if(isFull){if(!fullDataRowIdData[rowid]){return radioReserveRow;}}else{const rowkey=getRowkey($xeTable);if(treeConfig){const matchObj=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(afterFullData,row=>rowid===external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,rowkey),{children:childrenField});if(matchObj){return radioReserveRow;}}else{if(!afterFullData.some(row=>rowid===external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,rowkey))){return radioReserveRow;}}}}return null;},clearRadioReserve(){internalData.radioReserveRow=null;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 获取复选框保留选中的行
             */getCheckboxReserveRecords(isFull){const{treeConfig}=props;const{afterFullData,fullDataRowIdData,checkboxReserveRowMap}=internalData;const checkboxOpts=computeCheckboxOpts.value;const treeOpts=computeTreeOpts.value;const childrenField=treeOpts.children||treeOpts.childrenField;const reserveSelection=[];if(checkboxOpts.reserve){const{handleGetRowId}=createHandleGetRowId($xeTable);const afterFullIdMaps={};if(treeConfig){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterFullData,row=>{afterFullIdMaps[handleGetRowId(row)]=1;},{children:childrenField});}else{afterFullData.forEach(row=>{afterFullIdMaps[handleGetRowId(row)]=1;});}external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(checkboxReserveRowMap,(oldRow,oldRowid)=>{if(oldRow){if(isFull){if(!fullDataRowIdData[oldRowid]){reserveSelection.push(oldRow);}}else{if(!afterFullIdMaps[oldRowid]){reserveSelection.push(oldRow);}}}});}return reserveSelection;},clearCheckboxReserve(){internalData.checkboxReserveRowMap={};return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 多选，切换所有行的选中状态
             */toggleAllCheckboxRow(){handleCheckAllEvent(null,!reactData.isAllSelected);return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 用于多选行，手动清空用户的选择
             * 清空行为不管是否被禁用还是保留记录，都将彻底清空选中状态
             */clearCheckboxRow(){const{treeConfig}=props;const{tableFullData}=internalData;const treeOpts=computeTreeOpts.value;const childrenField=treeOpts.children||treeOpts.childrenField;const checkboxOpts=computeCheckboxOpts.value;const{checkField,reserve}=checkboxOpts;// indeterminateField 仅支持读取
const indeterminateField=checkboxOpts.indeterminateField||checkboxOpts.halfField;if(checkField){const handleClearChecked=item=>{if(treeConfig&&indeterminateField){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(item,indeterminateField,false);}external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(item,checkField,false);};if(treeConfig){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullData,handleClearChecked,{children:childrenField});}else{tableFullData.forEach(handleClearChecked);}}if(reserve){tableFullData.forEach(row=>handleCheckboxReserveRow(row,false));}reactData.isAllSelected=false;reactData.isIndeterminate=false;internalData.selectCheckboxMaps={};internalData.treeIndeterminateRowMaps={};reactData.updateCheckboxFlag++;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 用于当前行，设置某一行为高亮状态
             * @param {Row} row 行对象
             */setCurrentRow(row){const rowOpts=computeRowOpts.value;const el=refElem.value;tableMethods.clearCurrentRow();// tableMethods.clearCurrentColumn()
reactData.currentRow=row;if(rowOpts.isCurrent||props.highlightCurrentRow){if(el){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll(`[rowid="${getRowid($xeTable,row)}"]`),elem=>addClass(elem,'row--current'));}}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},isCheckedByRadioRow(row){const{selectRadioRow}=reactData;if(row&&selectRadioRow){return $xeTable.eqRow(selectRadioRow,row);}return false;},isCheckedByRadioRowKey(key){const{selectRadioRow}=reactData;if(selectRadioRow){return key===getRowid($xeTable,selectRadioRow);}return false;},/**
             * 用于单选行，设置某一行为选中状态
             * @param {Row} row 行对象
             */setRadioRow(row){return handleCheckedRadioRow(row,true);},/**
             * 用于单选行，设置某一行为选中状态
             * @param key 行主键
             */setRadioRowKey(rowid){const{fullAllDataRowIdData}=internalData;const rowRest=fullAllDataRowIdData[rowid];if(rowRest){return handleCheckedRadioRow(rowRest.row,true);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 用于当前行，手动清空当前高亮的状态
             */clearCurrentRow(){const el=refElem.value;reactData.currentRow=null;internalData.hoverRow=null;if(el){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll('.row--current'),elem=>removeClass(elem,'row--current'));}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 用于单选行，手动清空用户的选择
             */clearRadioRow(){reactData.selectRadioRow=null;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 用于当前行，获取当前行的数据
             */getCurrentRecord(){const rowOpts=computeRowOpts.value;return rowOpts.isCurrent||props.highlightCurrentRow?reactData.currentRow:null;},/**
             * 用于单选行，获取当已选中的数据
             */getRadioRecord(isFull){const{fullDataRowIdData,afterFullRowMaps}=internalData;const{selectRadioRow}=reactData;if(selectRadioRow){const rowid=getRowid($xeTable,selectRadioRow);if(isFull){if(fullDataRowIdData[rowid]){return selectRadioRow;}}else{if(afterFullRowMaps[rowid]){return selectRadioRow;}}}return null;},getCurrentColumn(){const columnOpts=computeColumnOpts.value;return columnOpts.isCurrent||props.highlightCurrentColumn?reactData.currentColumn:null;},/**
             * 用于当前列，设置某列行为高亮状态
             */setCurrentColumn(fieldOrColumn){const{mouseConfig}=props;const mouseOpts=computeMouseOpts.value;const isMouseSelected=mouseConfig&&mouseOpts.selected;const column=handleFieldOrColumn($xeTable,fieldOrColumn);if(column){$xeTable.clearCurrentColumn();reactData.currentColumn=column;}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{// 更新状选中态
if(isMouseSelected){$xeTable.addCellSelectedClass();}});},/**
             * 用于当前列，手动清空当前高亮的状态
             */clearCurrentColumn(){reactData.currentColumn=null;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},setPendingRow(rows,status){const{handleGetRowId}=createHandleGetRowId($xeTable);const{pendingRowMaps}=internalData;if(rows&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){rows=[rows];}if(status){rows.forEach(row=>{const rowid=handleGetRowId(row);if(rowid&&!pendingRowMaps[rowid]){pendingRowMaps[rowid]=row;}});}else{rows.forEach(row=>{const rowid=handleGetRowId(row);if(rowid&&pendingRowMaps[rowid]){delete pendingRowMaps[rowid];}});}reactData.pendingRowFlag++;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},togglePendingRow(rows){const{handleGetRowId}=createHandleGetRowId($xeTable);const{pendingRowMaps}=internalData;if(rows&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){rows=[rows];}rows.forEach(row=>{const rowid=handleGetRowId(row);if(rowid){if(pendingRowMaps[rowid]){delete pendingRowMaps[rowid];}else{pendingRowMaps[rowid]=row;}}});reactData.pendingRowFlag++;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},hasPendingByRow(row){return tableMethods.isPendingByRow(row);},isPendingByRow(row){const{pendingRowMaps}=internalData;const rowid=getRowid($xeTable,row);return!!pendingRowMaps[rowid];},getPendingRecords(){const{fullAllDataRowIdData,pendingRowMaps}=internalData;const insertRecords=[];external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(pendingRowMaps,(row,rowid)=>{if(fullAllDataRowIdData[rowid]){insertRecords.push(row);}});return insertRecords;},clearPendingRow(){internalData.pendingRowMaps={};reactData.pendingRowFlag++;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},sort(sortConfs,sortOrder){const sortOpts=computeSortOpts.value;const{multiple,remote,orders}=sortOpts;if(sortConfs){if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(sortConfs)){sortConfs=[{field:sortConfs,order:sortOrder}];}}if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(sortConfs)){sortConfs=[sortConfs];}if(sortConfs.length){if(!multiple){clearAllSort();}(multiple?sortConfs:[sortConfs[0]]).forEach((confs,index)=>{let{field,order}=confs;let column=field;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(field)){column=tableMethods.getColumnByField(field);}if(column&&column.sortable){if(orders&&orders.indexOf(order)===-1){order=getNextSortOrder(column);}if(column.order!==order){column.order=order;}column.sortTime=Date.now()+index;}});// 如果是服务端排序，则跳过本地排序处理
if(!remote){tablePrivateMethods.handleTableData(true);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{updateRowOffsetTop();tableMethods.updateCellAreas();return updateStyle();});}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},setSort(sortConfs,isUpdate){const sortOpts=computeSortOpts.value;const{multiple,remote,orders}=sortOpts;if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(sortConfs)){sortConfs=[sortConfs];}if(sortConfs&&sortConfs.length){if(!multiple){sortConfs=[sortConfs[0]];clearAllSort();}let firstColumn=null;sortConfs.forEach((confs,index)=>{let{field,order}=confs;let column=field;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(field)){column=tableMethods.getColumnByField(field);}if(!firstColumn){firstColumn=column;}if(column&&column.sortable){if(orders&&orders.indexOf(order)===-1){order=getNextSortOrder(column);}if(column.order!==order){column.order=order;}column.sortTime=Date.now()+index;}});if(isUpdate){if(!remote){$xeTable.handleTableData(true);}$xeTable.handleColumnSortEvent(new Event('click'),firstColumn);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{updateRowOffsetTop();tableMethods.updateCellAreas();return updateStyle();});}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 清空指定列的排序条件
             * 如果为空则清空所有列的排序条件
             * @param {String} fieldOrColumn 列或字段名
             */clearSort(fieldOrColumn){const sortOpts=computeSortOpts.value;if(fieldOrColumn){const column=handleFieldOrColumn($xeTable,fieldOrColumn);if(column){column.order=null;}}else{clearAllSort();}if(!sortOpts.remote){$xeTable.handleTableData(true);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{updateRowOffsetTop();return updateStyle();});},isSort(fieldOrColumn){if(fieldOrColumn){const column=handleFieldOrColumn($xeTable,fieldOrColumn);return column?column.sortable&&!!column.order:false;}return tableMethods.getSortColumns().length>0;},getSortColumns(){const sortOpts=computeSortOpts.value;const{multiple,chronological}=sortOpts;const sortList=[];const{tableFullColumn}=internalData;tableFullColumn.forEach(column=>{const{field,order}=column;if(column.sortable&&order){sortList.push({column,field,property:field,order:order,sortTime:column.sortTime});}});if(multiple&&chronological&&sortList.length>1){return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(sortList,'sortTime');}return sortList;},/**
             * 关闭筛选
             * @param {Event} evnt 事件
             */closeFilter(){const{filterStore}=reactData;const{column,visible}=filterStore;filterStore.isAllSelected=false;filterStore.isIndeterminate=false;filterStore.options=[];filterStore.visible=false;if(visible){dispatchEvent('filter-visible',{column,property:column.field,field:column.field,filterList:()=>$xeTable.getCheckedFilters(),visible:false},null);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 判断指定列是否为筛选状态，如果为空则判断所有列
             * @param {String} fieldOrColumn 字段名
             */isActiveFilterByColumn(fieldOrColumn){const column=handleFieldOrColumn($xeTable,fieldOrColumn);if(column){return column.filters&&column.filters.some(option=>option.checked);}return $xeTable.getCheckedFilters().length>0;},isFilter(fieldOrColumn){return tableMethods.isActiveFilterByColumn(fieldOrColumn);},/**
             * 判断展开行是否懒加载完成
             * @param {Row} row 行对象
             */isRowExpandLoaded(row){const{fullAllDataRowIdData}=internalData;const rowRest=fullAllDataRowIdData[getRowid($xeTable,row)];return rowRest&&!!rowRest.expandLoaded;},clearRowExpandLoaded(row){const{fullAllDataRowIdData,rowExpandLazyLoadedMaps}=internalData;const expandOpts=computeExpandOpts.value;const{lazy}=expandOpts;const rowid=getRowid($xeTable,row);const rowRest=fullAllDataRowIdData[rowid];if(lazy&&rowRest){rowRest.expandLoaded=false;delete rowExpandLazyLoadedMaps[rowid];}reactData.rowExpandedFlag++;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 重新懒加载展开行，并展开内容
             * @param {Row} row 行对象
             */reloadRowExpand(row){const{rowExpandLazyLoadedMaps}=internalData;const expandOpts=computeExpandOpts.value;const{lazy}=expandOpts;const rowid=getRowid($xeTable,row);if(lazy&&!rowExpandLazyLoadedMaps[rowid]){$xeTable.clearRowExpandLoaded(row).then(()=>handleAsyncRowExpand(row));}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},reloadExpandContent(row){if(true){warnLog('vxe.error.delFunc',['reloadExpandContent','reloadRowExpand']);}// 即将废弃
return $xeTable.reloadRowExpand(row);},/**
             * 切换展开行
             */toggleRowExpand(row){return $xeTable.setRowExpand(row,!$xeTable.isRowExpandByRow(row));},/**
             * 设置所有行的展开与否
             * @param {Boolean} expanded 是否展开
             */setAllRowExpand(expanded){const treeOpts=computeTreeOpts.value;const{tableFullData,tableFullTreeData}=internalData;const childrenField=treeOpts.children||treeOpts.childrenField;let expandedRows=[];if(props.treeConfig){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullTreeData,row=>{expandedRows.push(row);},{children:childrenField});}else{expandedRows=tableFullData;}return tableMethods.setRowExpand(expandedRows,expanded);},/**
             * 设置展开行，二个参数设置这一行展开与否
             * 支持单行
             * 支持多行
             * @param {Array/Row} rows 行数据
             * @param {Boolean} expanded 是否展开
             */setRowExpand(rows,expanded){const{expandColumn}=reactData;let{fullAllDataRowIdData,rowExpandedMaps,rowExpandLazyLoadedMaps}=internalData;const{handleGetRowId}=createHandleGetRowId($xeTable);const expandOpts=computeExpandOpts.value;const{reserve,lazy,accordion,toggleMethod}=expandOpts;const lazyRests=[];const columnIndex=expandColumn?$xeTable.getColumnIndex(expandColumn):-1;const $columnIndex=expandColumn?$xeTable.getVMColumnIndex(expandColumn):-1;if(rows){if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){rows=[rows];}if(accordion){// 只能同时展开一个
rowExpandedMaps={};internalData.rowExpandedMaps=rowExpandedMaps;rows=rows.slice(rows.length-1,rows.length);}const validRows=toggleMethod?rows.filter(row=>toggleMethod({$table:$xeTable,expanded,column:expandColumn,columnIndex,$columnIndex,row,rowIndex:$xeTable.getRowIndex(row),$rowIndex:$xeTable.getVMRowIndex(row)})):rows;if(expanded){validRows.forEach(row=>{const rowid=handleGetRowId(row);if(!rowExpandedMaps[rowid]){const rowRest=fullAllDataRowIdData[rowid];const isLoad=lazy&&!rowRest.expandLoaded&&!rowExpandLazyLoadedMaps[rowid];if(isLoad){lazyRests.push(handleAsyncRowExpand(row));}else{rowExpandedMaps[rowid]=row;}}});}else{validRows.forEach(item=>{const rowid=handleGetRowId(item);if(rowExpandedMaps[rowid]){delete rowExpandedMaps[rowid];}});}if(reserve){validRows.forEach(row=>handleRowExpandReserve(row,expanded));}}reactData.rowExpandedFlag++;return Promise.all(lazyRests).then(()=>(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)()).then(()=>$xeTable.recalculate(true)).then(()=>{updateRowOffsetTop();updateRowExpandStyle();handleRowExpandScroll();return $xeTable.updateCellAreas();});},/**
             * 判断行是否为展开状态
             * @param {Row} row 行对象
             */isRowExpandByRow(row){const{rowExpandedFlag}=reactData;const{rowExpandedMaps}=internalData;const rowid=getRowid($xeTable,row);return!!rowExpandedFlag&&!!rowExpandedMaps[rowid];},isExpandByRow(row){// 已废弃
if(true){warnLog('vxe.error.delFunc',['isExpandByRow','isRowExpandByRow']);}return tableMethods.isRowExpandByRow(row);},/**
             * 手动清空展开行状态，数据会恢复成未展开的状态
             */clearRowExpand(){const{tableFullData}=internalData;const expandOpts=computeExpandOpts.value;const{reserve}=expandOpts;const expList=$xeTable.getRowExpandRecords();internalData.rowExpandedMaps={};reactData.rowExpandedFlag++;if(reserve){tableFullData.forEach(row=>handleRowExpandReserve(row,false));}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{if(expList.length){return $xeTable.recalculate(true);}}).then(()=>{updateRowOffsetTop();updateRowExpandStyle();handleRowExpandScroll();return $xeTable.updateCellAreas();});},clearRowExpandReserve(){internalData.rowExpandedReserveRowMap={};return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},getRowExpandRecords(){const rest=[];external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(internalData.rowExpandedMaps,item=>{if(item){rest.push(item);}});return rest;},setRowGroups(fieldOrColumns){const{rowGroupConfig}=props;if(!rowGroupConfig){errLog('vxe.error.reqProp',['row-group-config']);return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}if(fieldOrColumns){handleUpdateRowGroup((external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumns)?fieldOrColumns:[fieldOrColumns]).map(fieldOrColumn=>{return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrColumn)?fieldOrColumn:fieldOrColumn.field;}));return loadTableData(internalData.tableSynchData,true);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},clearRowGroups(){const{rowGroupConfig}=props;if(!rowGroupConfig){errLog('vxe.error.reqProp',['row-group-config']);return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}handleUpdateRowGroup([]);return loadTableData(internalData.tableSynchData,true);},isRowGroupRecord(row){const{isRowGroupStatus}=reactData;return isRowGroupStatus&&row.isAggregate;},isRowGroupExpandByRow(row){const{rowGroupExpandedFlag}=reactData;const{rowGroupExpandedMaps}=internalData;return!!rowGroupExpandedFlag&&!!rowGroupExpandedMaps[getRowid($xeTable,row)];},setRowGroupExpand(rows,expanded){if(rows){if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){rows=[rows];}return handleRowGroupVirtualExpand(rows,expanded);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},setAllRowGroupExpand(expanded){const{tableFullGroupData}=internalData;const rowGroupOpts=computeRowGroupOpts.value;const{mapChildrenField}=rowGroupOpts;const rgExpandedMaps={};if(expanded&&mapChildrenField){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullGroupData,row=>{if(row[mapChildrenField]&&row[mapChildrenField].length){rgExpandedMaps[getRowid($xeTable,row)]=row;}},{children:mapChildrenField});}internalData.rowGroupExpandedMaps=rgExpandedMaps;handleVirtualTreeToList();reactData.rowGroupExpandedFlag++;return $xeTable.handleTableData();},clearRowGroupExpand(){internalData.rowGroupExpandedMaps={};handleVirtualTreeToList();reactData.rowGroupExpandedFlag++;return $xeTable.handleTableData();},getTreeExpandRecords(){const rest=[];external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(internalData.treeExpandedMaps,item=>{if(item){rest.push(item);}});return rest;},/**
             * 判断树节点是否懒加载完成
             * @param {Row} row 行对象
             */isTreeExpandLoaded(row){const{fullAllDataRowIdData}=internalData;const rowRest=fullAllDataRowIdData[getRowid($xeTable,row)];return rowRest&&!!rowRest.treeLoaded;},clearTreeExpandLoaded(rows){const{fullAllDataRowIdData,treeExpandedMaps}=internalData;const treeOpts=computeTreeOpts.value;const{transform}=treeOpts;if(rows){if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){rows=[rows];}rows.forEach(row=>{const rowid=getRowid($xeTable,row);const rowRest=fullAllDataRowIdData[rowid];if(rowRest){rowRest.treeLoaded=false;if(treeExpandedMaps[rowid]){delete treeExpandedMaps[rowid];}}});}else{external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(fullAllDataRowIdData,rowRest=>{rowRest.treeLoaded=false;});}internalData.treeExpandedMaps={};if(transform){handleVirtualTreeToList();$xeTable.handleTableData();}reactData.treeExpandedFlag++;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 重新懒加载树节点，并展开该节点
             * @param {Row} row 行对象
             */reloadTreeExpand(row){const{treeExpandLazyLoadedMaps}=internalData;const treeOpts=computeTreeOpts.value;const hasChildField=treeOpts.hasChild||treeOpts.hasChildField;const{transform,lazy}=treeOpts;const rowid=getRowid($xeTable,row);if(lazy&&row[hasChildField]&&!treeExpandLazyLoadedMaps[rowid]){return $xeTable.clearTreeExpandLoaded(row).then(()=>{return handleAsyncTreeExpandChilds(row);}).then(()=>{if(transform){handleVirtualTreeToList();$xeTable.handleTableData();}reactData.treeExpandedFlag++;}).then(()=>{return $xeTable.recalculate();});}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},reloadTreeChilds(row){if(true){warnLog('vxe.error.delFunc',['reloadTreeChilds','reloadTreeExpand']);}// 即将废弃
return $xeTable.reloadTreeExpand(row);},/**
             * 切换/展开树节点
             */toggleTreeExpand(row){return $xeTable.setTreeExpand(row,!$xeTable.isTreeExpandByRow(row));},/**
             * 设置所有树节点的展开与否
             * @param {Boolean} expanded 是否展开
             */setAllTreeExpand(expanded){const{tableFullData}=internalData;const treeOpts=computeTreeOpts.value;const{transform,lazy}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;const expandeds=[];external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullData,row=>{const rowChildren=row[childrenField];if(lazy||rowChildren&&rowChildren.length){expandeds.push(row);}},{children:childrenField});return $xeTable.setTreeExpand(expandeds,expanded).then(()=>{if(transform){handleVirtualTreeToList();reactData.treeExpandedFlag++;return $xeTable.recalculate();}});},/**
             * 设置展开树形节点，二个参数设置这一行展开与否
             * 支持单行
             * 支持多行
             * @param {Array/Row} rows 行数据
             * @param {Boolean} expanded 是否展开
             */setTreeExpand(rows,expanded){const treeOpts=computeTreeOpts.value;const{transform}=treeOpts;if(rows){if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){rows=[rows];}if(rows.length){// 如果为虚拟树
if(transform){return handleVirtualTreeExpand(rows,expanded);}else{return handleBaseTreeExpand(rows,expanded);}}}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 判断行是否为树形节点展开状态
             * @param {Row} row 行对象
             */isTreeExpandByRow(row){const{treeExpandedFlag}=reactData;const{treeExpandedMaps}=internalData;return!!treeExpandedFlag&&!!treeExpandedMaps[getRowid($xeTable,row)];},/**
             * 手动清空树形节点的展开状态，数据会恢复成未展开的状态
             */clearTreeExpand(){const{tableFullTreeData}=internalData;const treeOpts=computeTreeOpts.value;const childrenField=treeOpts.children||treeOpts.childrenField;const{transform,reserve}=treeOpts;const expList=$xeTable.getTreeExpandRecords();internalData.treeExpandedMaps={};if(reserve){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullTreeData,row=>handleTreeExpandReserve(row,false),{children:childrenField});}return $xeTable.handleTableData().then(()=>{if(transform){handleVirtualTreeToList();$xeTable.handleTableData();}reactData.treeExpandedFlag++;}).then(()=>{if(expList.length){return $xeTable.recalculate();}});},clearTreeExpandReserve(){internalData.treeExpandedReserveRowMap={};return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 获取表格的滚动状态
             */getScroll(){const{scrollXLoad,scrollYLoad}=reactData;const{elemStore}=internalData;const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);return{virtualX:scrollXLoad,virtualY:scrollYLoad,scrollTop:bodyScrollElem?bodyScrollElem.scrollTop:0,scrollLeft:bodyScrollElem?bodyScrollElem.scrollLeft:0};},/**
             * 如果有滚动条，则滚动到对应的位置
             * @param {Number} scrollLeft 左距离
             * @param {Number} scrollTop 上距离
             */scrollTo(scrollLeft,scrollTop){const{elemStore}=internalData;const headerScrollElem=getRefElem(elemStore['main-header-scroll']);const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const footerScrollElem=getRefElem(elemStore['main-footer-scroll']);const leftScrollElem=getRefElem(elemStore['left-body-scroll']);const rightScrollElem=getRefElem(elemStore['right-body-scroll']);const xHandleEl=refScrollXHandleElem.value;const yHandleEl=refScrollYHandleElem.value;internalData.intoRunScroll=true;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollLeft)){setScrollLeft(xHandleEl,scrollLeft);setScrollLeft(bodyScrollElem,scrollLeft);setScrollLeft(headerScrollElem,scrollLeft);setScrollLeft(footerScrollElem,scrollLeft);loadScrollXData();}if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollTop)){setScrollTop(yHandleEl,scrollTop);setScrollTop(bodyScrollElem,scrollTop);setScrollTop(leftScrollElem,scrollTop);setScrollTop(rightScrollElem,scrollTop);loadScrollYData();}if(reactData.scrollXLoad||reactData.scrollYLoad){return new Promise(resolve=>{setTimeout(()=>{(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{internalData.intoRunScroll=false;resolve();});},30);});}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 如果有滚动条，则滚动到对应的行
             * @param {Row} row 行对象
             * @param {ColumnInfo} fieldOrColumn 列配置
             */scrollToRow(row,fieldOrColumn){const{isAllOverflow,scrollYLoad,scrollXLoad}=reactData;const rest=[];if(row){if(props.treeConfig){rest.push($xeTable.scrollToTreeRow(row));}else{rest.push(rowToVisible($xeTable,row));}}if(fieldOrColumn){rest.push(handleScrollToRowColumn(fieldOrColumn,row));}return Promise.all(rest).then(()=>{if(row){if(!isAllOverflow&&(scrollYLoad||scrollXLoad)){calcCellHeight();calcCellWidth();}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}});},/**
             * 如果有滚动条，则滚动到对应的列
             */scrollToColumn(fieldOrColumn){const{fullColumnIdData}=internalData;const column=handleFieldOrColumn($xeTable,fieldOrColumn);if(column&&fullColumnIdData[column.id]){return colToVisible($xeTable,column);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 手动清除滚动相关信息，还原到初始状态
             */clearScroll(){const{elemStore,scrollXStore,scrollYStore}=internalData;const headerScrollElem=getRefElem(elemStore['main-header-scroll']);const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const footerScrollElem=getRefElem(elemStore['main-footer-scroll']);const leftScrollElem=getRefElem(elemStore['left-body-scroll']);const rightScrollElem=getRefElem(elemStore['right-body-scroll']);const xHandleEl=refScrollXHandleElem.value;const yHandleEl=refScrollYHandleElem.value;internalData.intoRunScroll=true;setScrollLeft(xHandleEl,0);setScrollLeft(bodyScrollElem,0);setScrollLeft(headerScrollElem,0);setScrollLeft(footerScrollElem,0);setScrollTop(yHandleEl,0);setScrollTop(bodyScrollElem,0);setScrollTop(leftScrollElem,0);setScrollTop(rightScrollElem,0);scrollXStore.startIndex=0;scrollXStore.visibleStartIndex=0;scrollXStore.endIndex=scrollXStore.visibleSize;scrollXStore.visibleEndIndex=scrollXStore.visibleSize;scrollYStore.startIndex=0;scrollYStore.visibleStartIndex=0;scrollYStore.endIndex=scrollYStore.visibleSize;scrollYStore.visibleEndIndex=scrollYStore.visibleSize;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{internalData.intoRunScroll=false;});},/**
             * 更新表尾合计
             */updateFooter(){const{showFooter,footerData,footerMethod}=props;const{visibleColumn,afterFullData}=internalData;let footData=[];if(showFooter&&footerData&&footerData.length){footData=footerData.slice(0);}else if(showFooter&&footerMethod){footData=visibleColumn.length?footerMethod({columns:visibleColumn,data:afterFullData,$table:$xeTable,$grid:$xeGrid}):[];}reactData.footerTableData=footData;$xeTable.handleUpdateFooterMerge();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 更新列状态 updateStatus({ row, column }, cellValue)
             * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一列编辑状态
             * 如果单元格配置了校验规则，则会进行校验
             */updateStatus(slotParams,cellValue){return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{const{editRules}=props;if(slotParams&&editRules){return $xeTable.handleCellRuleUpdateStatus('change',slotParams,cellValue);}});},/**
             * 设置合并单元格
             * @param {TableMergeConfig[]} merges { row: Row|number, column: ColumnInfo|number, rowspan: number, colspan: number }
             */setMergeCells(merges){if(props.spanMethod){errLog('vxe.error.errConflicts',['merge-cells','span-method']);}handleBodyMerge(merges);$xeTable.handleUpdateBodyMerge();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{$xeTable.updateCellAreas();return updateStyle();});},/**
             * 移除单元格合并
             * @param {TableMergeConfig[]} merges 多个或数组 [{row:Row|number, col:ColumnInfo|number}]
             */removeMergeCells(merges){if(props.spanMethod){errLog('vxe.error.errConflicts',['merge-cells','span-method']);}const rest=removeMerges(merges,internalData.mergeBodyList,internalData.afterFullData);return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{$xeTable.updateCellAreas();updateStyle();return rest;});},/**
             * 获取所有被合并的单元格
             */getMergeCells(){return internalData.mergeBodyList.slice(0);},/**
             * 清除所有单元格合并
             */clearMergeCells(){internalData.mergeBodyList=[];internalData.mergeBodyMaps={};internalData.mergeBodyCellMaps={};return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{return updateStyle();});},setMergeFooterItems(merges){if(props.footerSpanMethod){errLog('vxe.error.errConflicts',['merge-footer-items','footer-span-method']);}handleFooterMerge(merges);$xeTable.handleUpdateFooterMerge();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{tableMethods.updateCellAreas();return updateStyle();});},removeMergeFooterItems(merges){if(props.footerSpanMethod){errLog('vxe.error.errConflicts',['merge-footer-items','footer-span-method']);}const rest=removeMerges(merges,internalData.mergeFooterList);return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{tableMethods.updateCellAreas();updateStyle();return rest;});},/**
             * 获取所有被合并的表尾
             */getMergeFooterItems(){return internalData.mergeFooterList.slice(0);},/**
             * 清除所有表尾合并
             */clearMergeFooterItems(){internalData.mergeFooterList=[];internalData.mergeFooterMaps={};internalData.mergeFooterCellMaps={};return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{return updateStyle();});},updateCellAreas(){const{mouseConfig}=props;const mouseOpts=computeMouseOpts.value;if(mouseConfig&&mouseOpts.area&&$xeTable.handleRecalculateCellAreaEvent){return $xeTable.handleRecalculateCellAreaEvent();}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},getCustomStoreData(){const{id}=props;const customOpts=computeCustomOpts.value;const{collectColumn}=internalData;const{storage,checkMethod}=customOpts;const isAllCustom=storage===true;const storageOpts=isAllCustom?{}:Object.assign({},storage||{});const isCustomResizable=isAllCustom||storageOpts.resizable;const isCustomVisible=isAllCustom||storageOpts.visible;const isCustomFixed=isAllCustom||storageOpts.fixed;const isCustomSort=isAllCustom||storageOpts.sort;const resizableData={};const sortData={};const visibleData={};const fixedData={};const storeData={resizableData:undefined,sortData:undefined,visibleData:undefined,fixedData:undefined};if(!id){errLog('vxe.error.reqProp',['id']);return storeData;}let hasResizable=0;let hasSort=0;let hasFixed=0;let hasVisible=0;external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn,(column,index,items,path,parentColumn)=>{const colKey=column.getKey();if(!colKey){errLog('vxe.error.reqProp',[`${column.getTitle()||column.type||''} -> column.field=?`]);return;}// 只支持一级
if(!parentColumn){if(isCustomSort){hasSort=1;sortData[colKey]=column.renderSortNumber;}if(isCustomFixed&&column.fixed!==column.defaultFixed){hasFixed=1;fixedData[colKey]=column.fixed;}}if(isCustomResizable&&column.resizeWidth){hasResizable=1;resizableData[colKey]=column.renderWidth;}if(isCustomVisible&&(!checkMethod||checkMethod({$table:$xeTable,column}))){if(!column.visible&&column.defaultVisible){hasVisible=1;visibleData[colKey]=false;}else if(column.visible&&!column.defaultVisible){hasVisible=1;visibleData[colKey]=true;}}});if(hasResizable){storeData.resizableData=resizableData;}if(hasSort){storeData.sortData=sortData;}if(hasFixed){storeData.fixedData=fixedData;}if(hasVisible){storeData.visibleData=visibleData;}return storeData;},focus(){internalData.isActivated=true;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},blur(){internalData.isActivated=false;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 连接工具栏
             * @param $toolbar
             */connect($toolbar){if($toolbar){$xeToolbar=$toolbar;$xeToolbar.syncUpdate({collectColumn:internalData.collectColumn,$table:$xeTable});}else{errLog('vxe.error.barUnableLink');}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}};/**
         * 全局按下事件处理
         */const handleGlobalMousedownEvent=evnt=>{const{editStore,ctxMenuStore,filterStore,customStore}=reactData;const{mouseConfig,editRules}=props;const el=refElem.value;const editOpts=computeEditOpts.value;const validOpts=computeValidOpts.value;const areaOpts=computeAreaOpts.value;const{actived}=editStore;const $validTooltip=refValidTooltip.value;const tableFilter=refTableFilter.value;const tableCustom=refTableCustom.value;const tableMenu=refTableMenu.value;// 筛选
if(tableFilter){if(getEventTargetNode(evnt,el,'vxe-cell--filter').flag){// 如果点击了筛选按钮
}else if(getEventTargetNode(evnt,tableFilter.getRefMaps().refElem.value).flag){// 如果点击筛选容器
}else{if(!getEventTargetNode(evnt,document.body,'vxe-table--ignore-clear').flag){tablePrivateMethods.preventEvent(evnt,'event.clearFilter',filterStore.args,tableMethods.closeFilter);}}}// 自定义列
if(tableCustom){if(customStore.btnEl===evnt.target||getEventTargetNode(evnt,document.body,'vxe-toolbar-custom-target').flag){// 如果点击了自定义列按钮
}else if(getEventTargetNode(evnt,tableCustom.$el).flag){// 如果点击自定义列容器
}else{if(!getEventTargetNode(evnt,document.body,'vxe-table--ignore-clear').flag){tablePrivateMethods.preventEvent(evnt,'event.clearCustom',{},()=>{if($xeTable.closeCustom){$xeTable.closeCustom();}});}}}// 如果已激活了编辑状态
if(actived.row){if(!(editOpts.autoClear===false)){// 如果是激活状态，点击了单元格之外
const cell=actived.args.cell;if(!cell||!getEventTargetNode(evnt,cell).flag){if($validTooltip&&getEventTargetNode(evnt,$validTooltip.$el).flag){// 如果是激活状态，且点击了校验提示框
}else if(!internalData._lastCallTime||internalData._lastCallTime+50<Date.now()){// 如果是激活状态，点击了单元格之外
if(!getEventTargetNode(evnt,document.body,'vxe-table--ignore-clear').flag){// 如果手动调用了激活单元格，避免触发源被移除后导致重复关闭
tablePrivateMethods.preventEvent(evnt,'event.clearEdit',actived.args,()=>{let isClear;if(editOpts.mode==='row'){const rowTargetNode=getEventTargetNode(evnt,el,'vxe-body--row');const rowNodeRest=rowTargetNode.flag?tableMethods.getRowNode(rowTargetNode.targetElem):null;// row 方式，如果点击了不同行
isClear=rowNodeRest?!$xeTable.eqRow(rowNodeRest.item,actived.args.row):false;}else{// cell 方式，如果是非编辑列
isClear=!getEventTargetNode(evnt,el,'col--edit').flag;}// 如果点击表头行，则清除激活状态
if(!isClear){isClear=getEventTargetNode(evnt,el,'vxe-header--row').flag;}// 如果点击表尾行，则清除激活状态
if(!isClear){isClear=getEventTargetNode(evnt,el,'vxe-footer--row').flag;}// 如果固定了高度且点击了行之外的空白处，则清除激活状态
if(!isClear&&props.height&&!reactData.overflowY){const bodyWrapperElem=evnt.target;if(hasClass(bodyWrapperElem,'vxe-table--body-wrapper')){isClear=evnt.offsetY<bodyWrapperElem.clientHeight;}}if(isClear||// 如果点击了当前表格之外
!getEventTargetNode(evnt,el).flag){setTimeout(()=>{$xeTable.handleClearEdit(evnt).then(()=>{// 如果存在校验，点击了表格之外则清除
if(!internalData.isActivated&&editRules&&validOpts.autoClear){reactData.validErrorMaps={};}});});}});}}}}}else if(mouseConfig){if(!getEventTargetNode(evnt,el).flag&&!($xeGrid&&getEventTargetNode(evnt,$xeGrid.getRefMaps().refElem.value).flag)&&!(tableMenu&&getEventTargetNode(evnt,tableMenu.getRefMaps().refElem.value).flag)&&!($xeToolbar&&getEventTargetNode(evnt,$xeToolbar.getRefMaps().refElem.value).flag)){if($xeTable.clearSelected){$xeTable.clearSelected();}if(areaOpts.autoClear){if($xeTable.getCellAreas){const cellAreas=$xeTable.getCellAreas();if(cellAreas&&cellAreas.length&&!getEventTargetNode(evnt,document.body,'vxe-table--ignore-areas-clear').flag){tablePrivateMethods.preventEvent(evnt,'event.clearAreas',{},()=>{$xeTable.clearCellAreas();$xeTable.clearCopyCellArea();dispatchEvent('clear-cell-area-selection',{cellAreas},evnt);});}}}}}// 如果配置了快捷菜单且，点击了其他地方则关闭
if($xeTable.closeMenu){if(ctxMenuStore.visible&&tableMenu&&!getEventTargetNode(evnt,tableMenu.getRefMaps().refElem.value).flag){$xeTable.closeMenu();}}const isActivated=getEventTargetNode(evnt,$xeGrid?$xeGrid.getRefMaps().refElem.value:el).flag;// 如果存在校验，点击了表格之外则清除
if(!isActivated&&editRules&&validOpts.autoClear){reactData.validErrorMaps={};}// 最后激活的表格
internalData.isActivated=isActivated;};/**
         * 窗口失焦事件处理
         */const handleGlobalBlurEvent=()=>{tableMethods.closeFilter();if($xeTable.closeMenu){$xeTable.closeMenu();}};/**
         * 全局滚动事件
         */const handleGlobalMousewheelEvent=()=>{tableMethods.closeTooltip();if($xeTable.closeMenu){$xeTable.closeMenu();}};/**
         * 表格键盘事件
         */const keydownEvent=evnt=>{const{mouseConfig,keyboardConfig}=props;const{filterStore,ctxMenuStore,editStore}=reactData;const mouseOpts=computeMouseOpts.value;const keyboardOpts=computeKeyboardOpts.value;const{actived}=editStore;const isEsc=table_globalEvents.hasKey(evnt,GLOBAL_EVENT_KEYS.ESCAPE);if(isEsc){tablePrivateMethods.preventEvent(evnt,'event.keydown',null,()=>{dispatchEvent('keydown-start',{},evnt);if(keyboardConfig&&mouseConfig&&mouseOpts.area&&$xeTable.handleKeyboardCellAreaEvent){$xeTable.handleKeyboardCellAreaEvent(evnt);}else if(actived.row||filterStore.visible||ctxMenuStore.visible){evnt.stopPropagation();// 如果按下了 Esc 键，关闭快捷菜单、筛选
if($xeTable.closeMenu){$xeTable.closeMenu();}tableMethods.closeFilter();if(keyboardConfig&&keyboardOpts.isEsc){// 如果是激活编辑状态，则取消编辑
if(actived.row){const params=actived.args;$xeTable.handleClearEdit(evnt);// 如果配置了选中功能，则为选中状态
if(mouseOpts.selected){(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>$xeTable.handleSelected(params,evnt));}}}}dispatchEvent('keydown',{},evnt);dispatchEvent('keydown-end',{},evnt);});}};/**
         * 全局键盘事件
         */const handleGlobalKeydownEvent=evnt=>{// 该行为只对当前激活的表格有效
if(internalData.isActivated){$xeTable.preventEvent(evnt,'event.keydown',null,()=>{const{mouseConfig,keyboardConfig,treeConfig,editConfig,highlightCurrentRow,highlightCurrentColumn}=props;const{ctxMenuStore,editStore,currentRow}=reactData;const{afterFullData}=internalData;const isMenu=computeIsMenu.value;const bodyMenu=computeBodyMenu.value;const keyboardOpts=computeKeyboardOpts.value;const mouseOpts=computeMouseOpts.value;const editOpts=computeEditOpts.value;const treeOpts=computeTreeOpts.value;const menuList=computeMenuList.value;const rowOpts=computeRowOpts.value;const columnOpts=computeColumnOpts.value;const{selected,actived}=editStore;const childrenField=treeOpts.children||treeOpts.childrenField;const keyCode=evnt.keyCode;const isEsc=table_globalEvents.hasKey(evnt,GLOBAL_EVENT_KEYS.ESCAPE);const hasBackspaceKey=table_globalEvents.hasKey(evnt,GLOBAL_EVENT_KEYS.BACKSPACE);const isTab=table_globalEvents.hasKey(evnt,GLOBAL_EVENT_KEYS.TAB);const isEnter=table_globalEvents.hasKey(evnt,GLOBAL_EVENT_KEYS.ENTER);const isSpacebar=table_globalEvents.hasKey(evnt,GLOBAL_EVENT_KEYS.SPACEBAR);const isLeftArrow=table_globalEvents.hasKey(evnt,GLOBAL_EVENT_KEYS.ARROW_LEFT);const isUpArrow=table_globalEvents.hasKey(evnt,GLOBAL_EVENT_KEYS.ARROW_UP);const isRightArrow=table_globalEvents.hasKey(evnt,GLOBAL_EVENT_KEYS.ARROW_RIGHT);const isDwArrow=table_globalEvents.hasKey(evnt,GLOBAL_EVENT_KEYS.ARROW_DOWN);const hasDeleteKey=table_globalEvents.hasKey(evnt,GLOBAL_EVENT_KEYS.DELETE);const isF2=table_globalEvents.hasKey(evnt,GLOBAL_EVENT_KEYS.F2);const isContextMenu=table_globalEvents.hasKey(evnt,GLOBAL_EVENT_KEYS.CONTEXT_MENU);const isControlKey=hasControlKey(evnt);const hasShiftKey=evnt.shiftKey;const isAltKey=evnt.altKey;const operArrow=isLeftArrow||isUpArrow||isRightArrow||isDwArrow;const operCtxMenu=isMenu&&ctxMenuStore.visible&&(isEnter||isSpacebar||operArrow);const isEditStatus=isEnableConf(editConfig)&&actived.column&&actived.row;const beforeEditMethod=editOpts.beforeEditMethod||editOpts.activeMethod;if(operCtxMenu){// 如果配置了右键菜单; 支持方向键操作、回车
evnt.preventDefault();if(ctxMenuStore.showChild&&hasChildrenList(ctxMenuStore.selected)){$xeTable.moveCtxMenu(evnt,ctxMenuStore,'selectChild',isLeftArrow,false,ctxMenuStore.selected.children);}else{$xeTable.moveCtxMenu(evnt,ctxMenuStore,'selected',isRightArrow,true,menuList);}}else if(keyboardConfig&&mouseConfig&&mouseOpts.area&&$xeTable.handleKeyboardCellAreaEvent){$xeTable.handleKeyboardCellAreaEvent(evnt);}else if(isEsc){// 如果按下了 Esc 键，关闭快捷菜单、筛选
if($xeTable.closeMenu){$xeTable.closeMenu();}$xeTable.closeFilter();if(keyboardConfig&&keyboardOpts.isEsc){// 如果是激活编辑状态，则取消编辑
if(actived.row){const params=actived.args;$xeTable.handleClearEdit(evnt);// 如果配置了选中功能，则为选中状态
if(mouseOpts.selected){(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>$xeTable.handleSelected(params,evnt));}}}}else if(isSpacebar&&keyboardConfig&&keyboardOpts.isChecked&&selected.row&&selected.column&&(selected.column.type==='checkbox'||selected.column.type==='radio')){// 空格键支持选中复选框
evnt.preventDefault();if(selected.column.type==='checkbox'){tablePrivateMethods.handleToggleCheckRowEvent(evnt,selected.args);}else{tablePrivateMethods.triggerRadioRowEvent(evnt,selected.args);}}else if(isF2&&isEnableConf(editConfig)){if(!isEditStatus){// 如果按下了 F2 键
if(selected.row&&selected.column){evnt.preventDefault();$xeTable.handleEdit(selected.args,evnt);}}}else if(isContextMenu){// 如果按下上下文键
internalData._keyCtx=selected.row&&selected.column&&bodyMenu.length;clearTimeout(internalData.keyCtxTimeout);internalData.keyCtxTimeout=setTimeout(()=>{internalData._keyCtx=false;},1000);}else if(isEnter&&!isAltKey&&keyboardConfig&&keyboardOpts.isEnter&&(selected.row||actived.row||treeConfig&&(rowOpts.isCurrent||highlightCurrentRow)&&currentRow)){const{isLastEnterAppendRow,beforeEnterMethod,enterMethod}=keyboardOpts;// 退出选中
if(isControlKey){// 如果是激活编辑状态，则取消编辑
if(actived.row){const params=actived.args;$xeTable.handleClearEdit(evnt);// 如果配置了选中功能，则为选中状态
if(mouseOpts.selected){(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{$xeTable.handleSelected(params,evnt);});}}}else{// 如果是激活状态，退则出到上一行/下一行
if(selected.row||actived.row){const activeParams=selected.row?selected.args:actived.args;if(hasShiftKey){if(keyboardOpts.enterToTab){$xeTable.moveTabSelected(activeParams,hasShiftKey,evnt);}else{$xeTable.moveEnterSelected(activeParams,isLeftArrow,true,isRightArrow,false,evnt);}}else{if(keyboardOpts.enterToTab){$xeTable.moveTabSelected(activeParams,hasShiftKey,evnt);}else{const activeRow=selected.row||actived.row;const activeColumn=selected.column||actived.column;const _rowIndex=$xeTable.getVTRowIndex(activeRow);const etrParams={row:activeRow,rowIndex:$xeTable.getRowIndex(activeRow),$rowIndex:$xeTable.getVMRowIndex(activeRow),_rowIndex,column:activeColumn,columnIndex:$xeTable.getColumnIndex(activeColumn),$columnIndex:$xeTable.getVMColumnIndex(activeColumn),_columnIndex:$xeTable.getVTColumnIndex(activeColumn),$table:$xeTable};if(!beforeEnterMethod||beforeEnterMethod(etrParams)!==false){// 最后一行按下回车键，自动追加一行
if(isLastEnterAppendRow){if(_rowIndex>=afterFullData.length-1){$xeTable.insertAt({},-1).then(({row:newRow})=>{$xeTable.scrollToRow(newRow,activeColumn);$xeTable.handleSelected({...activeParams,row:newRow},evnt);});$xeTable.dispatchEvent('enter-append-row',etrParams,evnt);return;}}$xeTable.moveEnterSelected(activeParams,isLeftArrow,false,isRightArrow,true,evnt);if(enterMethod){enterMethod(etrParams);}}}}}else if(treeConfig&&(rowOpts.isCurrent||highlightCurrentRow)&&currentRow){// 如果是树形表格当前行回车移动到子节点
const childrens=currentRow[childrenField];if(childrens&&childrens.length){evnt.preventDefault();const targetRow=childrens[0];const params={$table:$xeTable,row:targetRow,rowIndex:$xeTable.getRowIndex(targetRow),$rowIndex:$xeTable.getVMRowIndex(targetRow)};$xeTable.setTreeExpand(currentRow,true).then(()=>$xeTable.scrollToRow(targetRow)).then(()=>$xeTable.triggerCurrentRowEvent(evnt,params));}}}}else if(operArrow&&keyboardConfig&&keyboardOpts.isArrow){if(!isEditStatus){// 如果按下了方向键
if(mouseOpts.selected&&selected.row&&selected.column){$xeTable.moveArrowSelected(selected.args,isLeftArrow,isUpArrow,isRightArrow,isDwArrow,evnt);}else{// 当前行按键上下移动
if((isUpArrow||isDwArrow)&&(rowOpts.isCurrent||highlightCurrentRow)){$xeTable.moveCurrentRow(isUpArrow,isDwArrow,evnt);}// 当前行按键左右移动
if((isLeftArrow||isRightArrow)&&(columnOpts.isCurrent||highlightCurrentColumn)){$xeTable.moveCurrentColumn(isLeftArrow,isRightArrow,evnt);}}}}else if(isTab&&keyboardConfig&&keyboardOpts.isTab){// 如果按下了 Tab 键切换
if(selected.row||selected.column){$xeTable.moveTabSelected(selected.args,hasShiftKey,evnt);}else if(actived.row||actived.column){$xeTable.moveTabSelected(actived.args,hasShiftKey,evnt);}}else if(keyboardConfig&&keyboardOpts.isDel&&hasDeleteKey&&isEnableConf(editConfig)&&(selected.row||selected.column)){// 如果是删除键
if(!isEditStatus){const{delMethod}=keyboardOpts;const params={row:selected.row,rowIndex:tableMethods.getRowIndex(selected.row),column:selected.column,columnIndex:tableMethods.getColumnIndex(selected.column),$table:$xeTable,$grid:$xeGrid};// 是否被禁用
if(!beforeEditMethod||beforeEditMethod(params)){if(delMethod){delMethod(params);}else{setCellValue(selected.row,selected.column,null);}// 如果按下 del 键，更新表尾数据
tableMethods.updateFooter();dispatchEvent('cell-delete-value',params,evnt);}}}else if(hasBackspaceKey&&keyboardConfig&&keyboardOpts.isBack&&isEnableConf(editConfig)&&(selected.row||selected.column)){if(!isEditStatus){const{backMethod}=keyboardOpts;// 如果是删除键
if(keyboardOpts.isDel&&isEnableConf(editConfig)&&(selected.row||selected.column)){const params={row:selected.row,rowIndex:$xeTable.getRowIndex(selected.row),column:selected.column,columnIndex:$xeTable.getColumnIndex(selected.column),$table:$xeTable,$grid:$xeGrid};// 是否被禁用
if(!beforeEditMethod||beforeEditMethod(params)){if(backMethod){backMethod(params);}else{setCellValue(selected.row,selected.column,null);$xeTable.handleEdit(selected.args,evnt);}dispatchEvent('cell-backspace-value',params,evnt);}}}}else if(hasBackspaceKey&&keyboardConfig&&treeConfig&&keyboardOpts.isBack&&(rowOpts.isCurrent||highlightCurrentRow)&&currentRow){// 如果树形表格回退键关闭当前行返回父节点
const{parent:parentRow}=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(internalData.afterTreeFullData,item=>item===currentRow,{children:childrenField});if(parentRow){evnt.preventDefault();const params={row:parentRow,rowIndex:$xeTable.getRowIndex(parentRow),$rowIndex:$xeTable.getVMRowIndex(parentRow),$table:$xeTable,$grid:$xeGrid};$xeTable.setTreeExpand(parentRow,false).then(()=>$xeTable.scrollToRow(parentRow)).then(()=>$xeTable.triggerCurrentRowEvent(evnt,params));}}else if(keyboardConfig&&isEnableConf(editConfig)&&keyboardOpts.isEdit&&!isControlKey&&(isSpacebar||keyCode>=48&&keyCode<=57||keyCode>=65&&keyCode<=90||keyCode>=96&&keyCode<=111||keyCode>=186&&keyCode<=192||keyCode>=219&&keyCode<=222)){const{editMode,editMethod}=keyboardOpts;// 启用编辑后，空格键功能将失效
// if (isSpacebar) {
//   evnt.preventDefault()
// }
// 如果是按下非功能键之外允许直接编辑
if(selected.column&&selected.row&&isEnableConf(selected.column.editRender)){const beforeEditMethod=editOpts.beforeEditMethod||editOpts.activeMethod;const params={row:selected.row,rowIndex:$xeTable.getRowIndex(selected.row),column:selected.column,columnIndex:$xeTable.getColumnIndex(selected.column),$table:$xeTable,$grid:$xeGrid};if(!beforeEditMethod||beforeEditMethod({...selected.args,$table:$xeTable,$grid:$xeGrid})){if(editMethod){editMethod(params);}else{// 追加方式与覆盖式
if(editMode!=='insert'){setCellValue(selected.row,selected.column,null);}$xeTable.handleEdit(selected.args,evnt);}}}}dispatchEvent('keydown',{},evnt);});}};const handleGlobalPasteEvent=evnt=>{const{keyboardConfig,mouseConfig}=props;const{editStore,filterStore}=reactData;const{isActivated}=internalData;const mouseOpts=computeMouseOpts.value;const keyboardOpts=computeKeyboardOpts.value;const{actived}=editStore;if(isActivated&&!filterStore.visible){if(!(actived.row||actived.column)){if(keyboardConfig&&keyboardOpts.isClip&&mouseConfig&&mouseOpts.area&&$xeTable.handlePasteCellAreaEvent){$xeTable.handlePasteCellAreaEvent(evnt);}}dispatchEvent('paste',{},evnt);}};const handleGlobalCopyEvent=evnt=>{const{keyboardConfig,mouseConfig}=props;const{editStore,filterStore}=reactData;const{isActivated}=internalData;const mouseOpts=computeMouseOpts.value;const keyboardOpts=computeKeyboardOpts.value;const{actived}=editStore;if(isActivated&&!filterStore.visible){if(!(actived.row||actived.column)){if(keyboardConfig&&keyboardOpts.isClip&&mouseConfig&&mouseOpts.area&&$xeTable.handleCopyCellAreaEvent){$xeTable.handleCopyCellAreaEvent(evnt);}}dispatchEvent('copy',{},evnt);}};const handleGlobalCutEvent=evnt=>{const{keyboardConfig,mouseConfig}=props;const{editStore,filterStore}=reactData;const{isActivated}=internalData;const mouseOpts=computeMouseOpts.value;const keyboardOpts=computeKeyboardOpts.value;const{actived}=editStore;if(isActivated&&!filterStore.visible){if(!(actived.row||actived.column)){if(keyboardConfig&&keyboardOpts.isClip&&mouseConfig&&mouseOpts.area&&$xeTable.handleCutCellAreaEvent){$xeTable.handleCutCellAreaEvent(evnt);}}dispatchEvent('cut',{},evnt);}};const handleGlobalResizeEvent=()=>{if($xeTable.closeMenu){$xeTable.closeMenu();}const el=refElem.value;if(!el||!el.clientWidth){return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}tableMethods.recalculate(true);tableMethods.updateCellAreas();};const handleTargetEnterEvent=isClear=>{const $tooltip=refTooltip.value;clearTimeout(internalData.tooltipTimeout);if(isClear){tableMethods.closeTooltip();}else{if($tooltip&&$tooltip.setActived){$tooltip.setActived(true);}}};const clearDragStatus=()=>{const{dragRow,dragCol}=reactData;if(dragRow||dragCol){clearColDropOrigin();clearRowDropOrigin();hideDropTip();reactData.dragRow=null;reactData.dragCol=null;reactData.isDragColMove=false;reactData.isDragRowMove=false;}};const clearRowDropOrigin=()=>{const el=refElem.value;if(el){const clss='row--drag-origin';external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll(`.${clss}`),elem=>{elem.draggable=false;removeClass(elem,clss);});}};const updateRowDropOrigin=row=>{const el=refElem.value;if(el){const clss='row--drag-origin';const rowid=getRowid($xeTable,row);external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll(`[rowid="${rowid}"]`),elem=>{addClass(elem,clss);});}};const updateRowDropTipContent=tdEl=>{const{dragConfig}=props;const{dragRow}=reactData;const rowDragOpts=computeRowDragOpts.value;const{tooltipMethod}=rowDragOpts;const rTooltipMethod=tooltipMethod||(dragConfig?dragConfig.rowTooltipMethod:null);let tipContent='';if(rTooltipMethod){const rtParams={$table:$xeTable,row:dragRow};tipContent=`${rTooltipMethod(rtParams)||''}`;}else{tipContent=table_getI18n('vxe.table.dragTip',[tdEl.textContent||'']);}reactData.dragTipText=tipContent;};const updateColDropOrigin=column=>{const el=refElem.value;if(el){const colQuerys=[];external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column],item=>{colQuerys.push(`[colid="${item.id}"]`);});const clss='col--drag-origin';external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll(colQuerys.join(',')),elem=>{addClass(elem,clss);});}};const clearColDropOrigin=()=>{const el=refElem.value;if(el){const clss='col--drag-origin';external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll(`.${clss}`),elem=>{elem.draggable=false;removeClass(elem,clss);});}};const updateColDropTipContent=tdEl=>{const{dragCol}=reactData;const columnDragOpts=computeColumnDragOpts.value;const{tooltipMethod}=columnDragOpts;let tipContent='';if(tooltipMethod){const dtParams={$table:$xeTable,column:dragCol};tipContent=`${tooltipMethod(dtParams)||''}`;}else{tipContent=table_getI18n('vxe.table.dragTip',[tdEl.textContent||'']);}reactData.dragTipText=tipContent;};const showDropTip=(evnt,trEl,thEl,showLine,dragPos)=>{const el=refElem.value;if(!el){return;}const{overflowX,scrollbarWidth,overflowY,scrollbarHeight}=reactData;const{prevDragToChild}=internalData;const wrapperRect=el.getBoundingClientRect();const osbWidth=overflowY?scrollbarWidth:0;const osbHeight=overflowX?scrollbarHeight:0;const tableWrapperWidth=el.clientWidth;const tableWrapperHeight=el.clientHeight;if(trEl){const rdLineEl=refDragRowLineElem.value;if(rdLineEl){if(showLine){const scrollbarYToLeft=computeScrollbarYToLeft.value;const trRect=trEl.getBoundingClientRect();let trHeight=trEl.clientHeight;const offsetTop=Math.max(1,trRect.y-wrapperRect.y);if(offsetTop+trHeight>tableWrapperHeight-osbHeight){trHeight=tableWrapperHeight-offsetTop-osbHeight;}rdLineEl.style.display='block';rdLineEl.style.left=`${scrollbarYToLeft?osbWidth:0}px`;rdLineEl.style.top=`${offsetTop}px`;rdLineEl.style.height=`${trHeight}px`;rdLineEl.style.width=`${tableWrapperWidth-osbWidth}px`;rdLineEl.setAttribute('drag-pos',dragPos);rdLineEl.setAttribute('drag-to-child',prevDragToChild?'y':'n');}else{rdLineEl.style.display='';}}}else if(thEl){const cdLineEl=refDragColLineElem.value;if(cdLineEl){if(showLine){const scrollbarXToTop=computeScrollbarXToTop.value;const leftContainerElem=refLeftContainer.value;const leftContainerWidth=leftContainerElem?leftContainerElem.clientWidth:0;const rightContainerElem=refRightContainer.value;const rightContainerWidth=rightContainerElem?rightContainerElem.clientWidth:0;const thRect=thEl.getBoundingClientRect();let thWidth=thEl.clientWidth;const offsetTop=Math.max(0,thRect.y-wrapperRect.y);const startX=leftContainerWidth;let offsetLeft=thRect.x-wrapperRect.x;if(offsetLeft<startX){thWidth-=startX-offsetLeft;offsetLeft=startX;}const endX=tableWrapperWidth-rightContainerWidth-(rightContainerWidth?0:osbWidth);if(offsetLeft+thWidth>endX){thWidth=endX-offsetLeft;}cdLineEl.style.display='block';cdLineEl.style.top=`${offsetTop}px`;cdLineEl.style.left=`${offsetLeft}px`;cdLineEl.style.width=`${thWidth}px`;if(prevDragToChild){cdLineEl.style.height=`${thRect.height}px`;}else{cdLineEl.style.height=`${tableWrapperHeight-offsetTop-(scrollbarXToTop?0:osbHeight)}px`;}cdLineEl.setAttribute('drag-pos',dragPos);cdLineEl.setAttribute('drag-to-child',prevDragToChild?'y':'n');}else{cdLineEl.style.display='';}}}const rdTipEl=refDragTipElem.value;if(rdTipEl){rdTipEl.style.display='block';rdTipEl.style.top=`${Math.min(el.clientHeight-el.scrollTop-rdTipEl.clientHeight,evnt.clientY-wrapperRect.y)}px`;rdTipEl.style.left=`${Math.min(el.clientWidth-el.scrollLeft-rdTipEl.clientWidth-16,evnt.clientX-wrapperRect.x)}px`;rdTipEl.setAttribute('drag-status',showLine?prevDragToChild?'sub':'normal':'disabled');}};const hideDropTip=()=>{const rdTipEl=refDragTipElem.value;const rdLineEl=refDragRowLineElem.value;const cdLineEl=refDragColLineElem.value;if(rdTipEl){rdTipEl.style.display='';}if(rdLineEl){rdLineEl.style.display='';}if(cdLineEl){cdLineEl.style.display='';}};/**
         * 处理显示 tooltip
         * @param {Event} evnt 事件
         * @param {Row} row 行对象
         */const handleTooltip=(evnt,tdEl,overflowElem,tipElem,params)=>{const tipOverEl=overflowElem||tdEl;if(!tipOverEl){return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}params.cell=tdEl;const{tooltipStore}=reactData;const tooltipOpts=computeTooltipOpts.value;const{column,row}=params;const{showAll,contentMethod}=tooltipOpts;const customContent=contentMethod?contentMethod(params):null;const useCustom=contentMethod&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(customContent);const content=useCustom?customContent:external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toString(column.type==='html'?tipOverEl.innerText:tipOverEl.textContent).trim();const isOver=tipOverEl.scrollWidth>tipOverEl.clientWidth;if(content&&(showAll||useCustom||isOver)){Object.assign(tooltipStore,{row,column,visible:true,currOpts:{}});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{const $tooltip=refTooltip.value;if($tooltip&&$tooltip.open){$tooltip.open(isOver?tipOverEl:tipElem,formatText(content));}});}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();};const callSlot=(slotFunc,params)=>{if(slotFunc){if($xeGrid){return $xeGrid.callSlot(slotFunc,params);}// if (XEUtils.isString(slotFunc)) {
//   slotFunc = slots[slotFunc] || null
// }
if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)){return getSlotVNs(slotFunc(params));}}return[];};/**
         * 内部方法
         */tablePrivateMethods={getSetupOptions(){return table_getConfig();},updateAfterDataIndex,callSlot,/**
             * 获取父容器元素
             */getParentElem(){const el=refElem.value;if($xeGrid){const gridEl=$xeGrid.getRefMaps().refElem.value;return gridEl?gridEl.parentNode:null;}return el?el.parentNode:null;},/**
             * 获取父容器的高度
             */getParentHeight(){const{height}=props;const el=refElem.value;if(el){const parentElem=el.parentNode;const parentPaddingSize=height==='100%'||height==='auto'?getPaddingTopBottomSize(parentElem):0;let parentWrapperHeight=0;if(parentElem){if($xeGrid&&hasClass(parentElem,'vxe-grid--table-wrapper')){parentWrapperHeight=$xeGrid.getParentHeight();}else{parentWrapperHeight=parentElem.clientHeight;}}return Math.floor(parentWrapperHeight-parentPaddingSize);}return 0;},/**
             * 获取需要排除的高度
             * 但渲染表格高度时，需要排除工具栏或分页等相关组件的高度
             * 如果存在表尾合计滚动条，则需要排除滚动条高度
             */getExcludeHeight(){return $xeGrid?$xeGrid.getExcludeHeight():0;},/**
             * 定义行数据中的列属性，如果不存在则定义
             * @param {Row} records 行数据
             */defineField(records){const{treeConfig}=props;const expandOpts=computeExpandOpts.value;const treeOpts=computeTreeOpts.value;const radioOpts=computeRadioOpts.value;const checkboxOpts=computeCheckboxOpts.value;const childrenField=treeOpts.children||treeOpts.childrenField;const rowkey=getRowkey($xeTable);if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(records)){records=[records];}return records.map(record=>{internalData.tableFullColumn.forEach(column=>{const{field,editRender}=column;if(field&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().has(record,field)&&!record[field]){let cellValue=null;if(editRender){const{defaultValue}=editRender;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(defaultValue)){cellValue=defaultValue({column});}else if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(defaultValue)){cellValue=defaultValue;}}external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(record,field,cellValue);}});const otherFields=[radioOpts.labelField,checkboxOpts.checkField,checkboxOpts.labelField,expandOpts.labelField];otherFields.forEach(key=>{if(key&&eqEmptyValue(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(record,key))){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(record,key,null);}});if(treeConfig&&treeOpts.lazy&&external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(record[childrenField])){record[childrenField]=null;}// 必须有行数据的唯一主键，可以自行设置；也可以默认生成一个随机数
if(eqEmptyValue(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(record,rowkey))){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(record,rowkey,getRowUniqueId());}return record;});},handleTableData(force){const{scrollYLoad}=reactData;const{scrollYStore,fullDataRowIdData}=internalData;let fullList=internalData.afterFullData;// 是否进行数据处理
if(force){// 更新数据，处理筛选和排序
updateAfterFullData();// 如果为虚拟树，将树结构拍平
fullList=handleVirtualTreeToList();}const tableData=scrollYLoad?fullList.slice(scrollYStore.startIndex,scrollYStore.endIndex):fullList.slice(0);const visibleDataRowIdMaps={};tableData.forEach((row,$index)=>{const rowid=getRowid($xeTable,row);const rest=fullDataRowIdData[rowid];if(rest){rest.$index=$index;}visibleDataRowIdMaps[rowid]=row;});reactData.tableData=tableData;internalData.visibleDataRowIdData=visibleDataRowIdMaps;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 更新数据行的 Map
             */cacheRowMap(isReset){const{treeConfig}=props;const{isRowGroupStatus}=reactData;const{fullAllDataRowIdData,tableFullData,tableFullTreeData,tableFullGroupData,treeExpandedMaps}=internalData;const fullAllDataRowIdMaps=isReset?{}:{...fullAllDataRowIdData};// 存在已删除数据
const fullDataRowIdMaps={};const{handleUpdateRowId}=createHandleUpdateRowId($xeTable);const handleRowCache=(row,index,items,currIndex,parentRow,rowid,level,seq)=>{let rowRest=fullAllDataRowIdMaps[rowid];if(!rowRest){rowRest={row,rowid,seq,index:-1,_index:-1,$index:-1,treeIndex:index,items,parent:parentRow,level,height:0,resizeHeight:0,oTop:0,expandHeight:0};fullDataRowIdMaps[rowid]=rowRest;fullAllDataRowIdMaps[rowid]=rowRest;}rowRest.treeLoaded=false;rowRest.expandLoaded=false;rowRest.row=row;rowRest.items=items;rowRest.parent=parentRow;rowRest.level=level;rowRest.index=currIndex;rowRest.treeIndex=index;fullDataRowIdMaps[rowid]=rowRest;fullAllDataRowIdMaps[rowid]=rowRest;};if(treeConfig){const treeOpts=computeTreeOpts.value;const{lazy}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;const hasChildField=treeOpts.hasChild||treeOpts.hasChildField;external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullTreeData,(row,index,items,path,parentRow,nodes)=>{const rowid=handleUpdateRowId(row);if(treeConfig&&lazy){if(row[hasChildField]&&row[childrenField]===undefined){row[childrenField]=null;}if(treeExpandedMaps[rowid]){if(!row[childrenField]||!row[childrenField].length){delete treeExpandedMaps[rowid];}}}handleRowCache(row,index,items,parentRow?-1:index,parentRow,rowid,nodes.length-1,toTreePathSeq(path));},{children:childrenField});}else if(isRowGroupStatus){const rowGroupOpts=computeRowGroupOpts.value;const{mapChildrenField}=rowGroupOpts;external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullGroupData,(row,index,items,path,parentRow,nodes)=>{const rowid=handleUpdateRowId(row);handleRowCache(row,index,items,parentRow?-1:index,parentRow,rowid,nodes.length-1,toTreePathSeq(path));},{children:mapChildrenField});}else{tableFullData.forEach((row,index,items)=>{handleRowCache(row,index,items,index,null,handleUpdateRowId(row),0,index+1);});}internalData.fullDataRowIdData=fullDataRowIdMaps;internalData.fullAllDataRowIdData=fullAllDataRowIdMaps;reactData.treeExpandedFlag++;},cacheSourceMap(fullData){const{treeConfig}=props;const treeOpts=computeTreeOpts.value;const sourceData=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(fullData,true);const{handleUpdateRowId}=createHandleUpdateRowId($xeTable);const sourceRowIdData={};const handleSourceRow=row=>{const rowid=handleUpdateRowId(row);sourceRowIdData[rowid]=row;};// 源数据缓存
if(treeConfig){const childrenField=treeOpts.children||treeOpts.childrenField;external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(sourceData,handleSourceRow,{children:treeOpts.transform?treeOpts.mapChildrenField:childrenField});}else{sourceData.forEach(handleSourceRow);}internalData.sourceDataRowIdData=sourceRowIdData;internalData.tableSourceData=sourceData;},/**
             * 指定列宽的列进行拆分
             */analyColumnWidth(){const{tableFullColumn}=internalData;const columnOpts=computeColumnOpts.value;const{width:defaultWidth,minWidth:defaultMinWidth}=columnOpts;const resizeList=[];const pxList=[];const pxMinList=[];const autoMinList=[];const scaleList=[];const scaleMinList=[];const autoList=[];const remainList=[];tableFullColumn.forEach(column=>{if(defaultWidth&&!column.width){column.width=defaultWidth;}if(defaultMinWidth&&!column.minWidth){column.minWidth=defaultMinWidth;}if(column.visible){if(column.resizeWidth){resizeList.push(column);}else if(column.width==='auto'){autoList.push(column);}else if(isPx(column.width)){pxList.push(column);}else if(isScale(column.width)){scaleList.push(column);}else if(isPx(column.minWidth)){pxMinList.push(column);}else if(column.minWidth==='auto'){autoMinList.push(column);}else if(isScale(column.minWidth)){scaleMinList.push(column);}else{remainList.push(column);}}});Object.assign(reactData.columnStore,{resizeList,pxList,pxMinList,autoMinList,scaleList,scaleMinList,autoList,remainList});},handleColResizeMousedownEvent(evnt,fixedType,params){evnt.stopPropagation();evnt.preventDefault();const{column}=params;const{overflowX,scrollbarHeight}=reactData;const{elemStore,visibleColumn}=internalData;const resizableOpts=computeResizableOpts.value;const osbHeight=overflowX?scrollbarHeight:0;const tableEl=refElem.value;const leftContainerElem=refLeftContainer.value;const rightContainerElem=refRightContainer.value;const resizeBarElem=refColResizeBar.value;if(!resizeBarElem){return;}const resizeTipElem=resizeBarElem.firstElementChild;const scrollbarXToTop=computeScrollbarXToTop.value;const{clientX:dragClientX}=evnt;const wrapperElem=refElem.value;const dragBtnElem=evnt.target;let resizeColumn=column;if(column.children&&column.children.length){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(column.children,childColumn=>{resizeColumn=childColumn;});}const cell=dragBtnElem.parentNode;const cellParams=Object.assign(params,{cell});let dragLeft=0;const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);if(!bodyScrollElem){return;}const pos=getOffsetPos(dragBtnElem,wrapperElem);const dragBtnWidth=dragBtnElem.clientWidth;const dragBtnOffsetWidth=Math.floor(dragBtnWidth/2);const minInterval=getColReMinWidth(cellParams)-dragBtnOffsetWidth;// 列之间的最小间距
let dragMinLeft=pos.left-cell.clientWidth+dragBtnWidth+minInterval;let dragPosLeft=pos.left+dragBtnOffsetWidth;const isLeftFixed=fixedType==='left';const isRightFixed=fixedType==='right';// 计算左右侧固定列偏移量
let fixedOffsetWidth=0;if(isLeftFixed||isRightFixed){const siblingProp=isLeftFixed?'nextElementSibling':'previousElementSibling';let tempCellElem=cell[siblingProp];while(tempCellElem){if(hasClass(tempCellElem,'fixed--hidden')){break;}else if(!hasClass(tempCellElem,'col--group')){fixedOffsetWidth+=tempCellElem.offsetWidth;}tempCellElem=tempCellElem[siblingProp];}if(isRightFixed&&rightContainerElem){dragPosLeft=rightContainerElem.offsetLeft+fixedOffsetWidth;}}// 处理拖动事件
const updateEvent=evnt=>{evnt.stopPropagation();evnt.preventDefault();const tableHeight=tableEl.clientHeight;const offsetX=evnt.clientX-dragClientX;let left=dragPosLeft+offsetX;const scrollLeft=fixedType?0:bodyScrollElem.scrollLeft;if(isLeftFixed){// 左固定列（不允许超过右侧固定列、不允许超过右边距）
left=Math.min(left,(rightContainerElem?rightContainerElem.offsetLeft:bodyScrollElem.clientWidth)-fixedOffsetWidth-minInterval);}else if(isRightFixed){// 右侧固定列（不允许超过左侧固定列、不允许超过左边距）
dragMinLeft=(leftContainerElem?leftContainerElem.clientWidth:0)+fixedOffsetWidth+minInterval;left=Math.min(left,dragPosLeft+cell.clientWidth-minInterval);}else{dragMinLeft=Math.max(bodyScrollElem.scrollLeft,dragMinLeft);// left = Math.min(left, bodyScrollElem.clientWidth + bodyScrollElem.scrollLeft - 40)
}dragLeft=Math.max(left,dragMinLeft);const resizeBarLeft=Math.max(1,dragLeft-scrollLeft);resizeBarElem.style.left=`${resizeBarLeft}px`;resizeBarElem.style.top=`${scrollbarXToTop?osbHeight:0}px`;resizeBarElem.style.height=`${scrollbarXToTop?tableHeight-osbHeight:tableHeight}px`;if(resizableOpts.showDragTip&&resizeTipElem){resizeTipElem.textContent=table_getI18n('vxe.table.resizeColTip',[resizeColumn.renderWidth+(isRightFixed?dragPosLeft-dragLeft:dragLeft-dragPosLeft)]);const tableWrapperWidth=tableEl.clientWidth;const wrapperRect=wrapperElem.getBoundingClientRect();const resizeBarWidth=resizeBarElem.clientWidth;const resizeTipWidth=resizeTipElem.clientWidth;const resizeTipHeight=resizeTipElem.clientHeight;let resizeTipLeft=-resizeTipWidth;if(resizeBarLeft<resizeTipWidth+resizeBarWidth){resizeTipLeft=0;}else if(resizeBarLeft>tableWrapperWidth){resizeTipLeft+=tableWrapperWidth-resizeBarLeft;}resizeTipElem.style.left=`${resizeTipLeft}px`;resizeTipElem.style.top=`${Math.min(tableHeight-resizeTipHeight,Math.max(0,evnt.clientY-wrapperRect.y-resizeTipHeight/2))}px`;}reactData.isDragResize=true;};reactData.isDragResize=true;addClass(tableEl,'col-drag--resize');resizeBarElem.style.display='block';document.onmousemove=updateEvent;document.onmouseup=function(evnt){document.onmousemove=null;document.onmouseup=null;resizeBarElem.style.display='none';internalData._lastResizeTime=Date.now();setTimeout(()=>{reactData.isDragResize=false;},50);const resizeWidth=resizeColumn.renderWidth+(isRightFixed?dragPosLeft-dragLeft:dragLeft-dragPosLeft);const resizeParams={...params,resizeWidth,resizeColumn};if(resizableOpts.dragMode==='fixed'){visibleColumn.forEach(item=>{if(item.id!==resizeColumn.id){if(!item.resizeWidth){item.resizeWidth=item.renderWidth;}}});}if($xeTable.handleColResizeCellAreaEvent){$xeTable.handleColResizeCellAreaEvent(evnt,resizeParams);}else{resizeColumn.resizeWidth=resizeWidth;handleUpdateColResize(evnt,resizeParams);}removeClass(tableEl,'col-drag--resize');};updateEvent(evnt);if($xeTable.closeMenu){$xeTable.closeMenu();}},handleColResizeDblclickEvent(evnt,params){const resizableOpts=computeResizableOpts.value;const{isDblclickAutoWidth}=resizableOpts;const el=refElem.value;if(isDblclickAutoWidth&&el){evnt.stopPropagation();evnt.preventDefault();const{fullColumnIdData}=internalData;const{column}=params;let resizeColumn=column;if(column.children&&column.children.length){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(column.children,childColumn=>{resizeColumn=childColumn;});}const colid=resizeColumn.id;const colRest=fullColumnIdData[colid];const dragBtnElem=evnt.target;const cell=dragBtnElem.parentNode;const cellParams=Object.assign(params,{cell});const colMinWidth=getColReMinWidth(cellParams);el.setAttribute('data-calc-col','Y');let resizeWidth=calcColumnAutoWidth(resizeColumn,el);el.removeAttribute('data-calc-col');if(colRest){resizeWidth=Math.max(resizeWidth,colRest.width);}resizeWidth=Math.max(colMinWidth,resizeWidth);const resizeParams={...params,resizeWidth,resizeColumn};reactData.isDragResize=false;internalData._lastResizeTime=Date.now();if($xeTable.handleColResizeDblclickCellAreaEvent){$xeTable.handleColResizeDblclickCellAreaEvent(evnt,resizeParams);}else{resizeColumn.resizeWidth=resizeWidth;handleUpdateColResize(evnt,resizeParams);}}},handleRowResizeMousedownEvent(evnt,params){evnt.stopPropagation();evnt.preventDefault();const{row}=params;const{overflowX,scrollbarWidth,overflowY,scrollbarHeight}=reactData;const{elemStore,fullAllDataRowIdData}=internalData;const osbWidth=overflowY?scrollbarWidth:0;const osbHeight=overflowX?scrollbarHeight:0;const scrollbarYToLeft=computeScrollbarYToLeft.value;const resizableOpts=computeResizableOpts.value;const rowOpts=computeRowOpts.value;const cellOpts=computeCellOpts.value;const tableEl=refElem.value;const resizeBarElem=refRowResizeBar.value;if(!resizeBarElem){return;}const{clientY:dragClientY}=evnt;const resizeTipElem=resizeBarElem.firstElementChild;const dragBtnElem=evnt.currentTarget;const tdEl=dragBtnElem.parentNode;const trEl=tdEl.parentNode;const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);if(!bodyScrollElem){return;}const rowid=getRowid($xeTable,row);const rowRest=fullAllDataRowIdData[rowid];if(!rowRest){return;}const defaultRowHeight=computeDefaultRowHeight.value;const currCellHeight=rowRest.resizeHeight||cellOpts.height||rowOpts.height||rowRest.height||defaultRowHeight;const tableRect=tableEl.getBoundingClientRect();const trRect=trEl.getBoundingClientRect();const targetOffsetY=dragClientY-trRect.y-trEl.clientHeight;let resizeHeight=currCellHeight;const cellEl=tdEl.querySelector('.vxe-cell');let cellMinHeight=0;if(cellEl){const cellStyle=getComputedStyle(cellEl);cellMinHeight=Math.max(1,Math.ceil(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellStyle.paddingTop)+external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellStyle.paddingBottom)));}const minTop=trRect.y-tableRect.y+cellMinHeight;// 处理拖动事件
const updateEvent=evnt=>{evnt.stopPropagation();evnt.preventDefault();const rtWidth=tableEl.clientWidth-osbWidth;const tableHeight=tableEl.clientHeight-osbHeight;let dragTop=evnt.clientY-tableRect.y-targetOffsetY;if(dragTop<minTop){dragTop=minTop;}else{resizeHeight=Math.max(cellMinHeight,currCellHeight+evnt.clientY-dragClientY);}resizeBarElem.style.left=`${scrollbarYToLeft?osbWidth:0}px`;resizeBarElem.style.top=`${dragTop}px`;resizeBarElem.style.width=`${rtWidth}px`;if(resizableOpts.showDragTip&&resizeTipElem){resizeTipElem.textContent=table_getI18n('vxe.table.resizeRowTip',[resizeHeight]);const resizeTipWidth=resizeTipElem.clientWidth;const resizeTipHeight=resizeTipElem.clientHeight;let resizeBarLeft=Math.max(2,evnt.clientX-tableRect.x);let resizeBarTop=0;if(resizeBarLeft+resizeTipWidth>=rtWidth-2){resizeBarLeft=rtWidth-resizeTipWidth-2;}if(dragTop+resizeTipHeight>=tableHeight){resizeBarTop=tableHeight-(dragTop+resizeTipHeight);}resizeTipElem.style.left=`${resizeBarLeft}px`;resizeTipElem.style.top=`${resizeBarTop}px`;}reactData.isDragResize=true;};reactData.isDragResize=true;addClass(tableEl,'row-drag--resize');resizeBarElem.style.display='block';document.onmousemove=updateEvent;document.onmouseup=function(evnt){document.onmousemove=null;document.onmouseup=null;resizeBarElem.style.display='none';internalData._lastResizeTime=Date.now();setTimeout(()=>{reactData.isDragResize=false;},50);if(resizeHeight!==currCellHeight){const resizeParams={...params,resizeHeight,resizeRow:row};internalData.isResizeCellHeight=true;if($xeTable.handleRowResizeCellAreaEvent){$xeTable.handleRowResizeCellAreaEvent(evnt,resizeParams);}else{rowRest.resizeHeight=resizeHeight;handleUpdateRowResize(evnt,resizeParams);updateRowOffsetTop();}}removeClass(tableEl,'row-drag--resize');};updateEvent(evnt);},handleRowResizeDblclickEvent(evnt,params){const resizableOpts=computeResizableOpts.value;const{isDblclickAutoHeight}=resizableOpts;const el=refElem.value;if(isDblclickAutoHeight&&el){evnt.stopPropagation();evnt.preventDefault();const{editStore}=reactData;const{fullAllDataRowIdData}=internalData;const{actived}=editStore;const{row}=params;const rowid=getRowid($xeTable,row);const rowRest=fullAllDataRowIdData[rowid];if(!rowRest){return;}const handleRsHeight=()=>{el.setAttribute('data-calc-row','Y');const resizeHeight=calcCellAutoHeight(rowRest,el);el.removeAttribute('data-calc-row');const resizeParams={...params,resizeHeight,resizeRow:row};reactData.isDragResize=false;internalData._lastResizeTime=Date.now();if($xeTable.handleRowResizeDblclickCellAreaEvent){$xeTable.handleRowResizeDblclickCellAreaEvent(evnt,resizeParams);}else{rowRest.resizeHeight=resizeHeight;handleUpdateRowResize(evnt,resizeParams);}};if(actived.row||actived.column){$xeTable.clearEdit().then(handleRsHeight);}else{handleRsHeight();}}},saveCustomStore(type){const{customConfig}=props;const tableId=computeTableId.value;const customOpts=computeCustomOpts.value;const{updateStore,storage}=customOpts;const isAllCustom=storage===true;const storageOpts=isAllCustom?{}:Object.assign({},storage||{});const isCustomResizable=isAllCustom||storageOpts.resizable;const isCustomVisible=isAllCustom||storageOpts.visible;const isCustomFixed=isAllCustom||storageOpts.fixed;const isCustomSort=isAllCustom||storageOpts.sort;if(type!=='reset'){// fix：修复拖动列宽，重置按钮无法点击的问题
reactData.isCustomStatus=true;}if((customConfig?isEnableConf(customOpts):customOpts.enabled)&&(isCustomResizable||isCustomVisible||isCustomFixed||isCustomSort)){if(!tableId){errLog('vxe.error.reqProp',['id']);return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}const storeData=type==='reset'?{resizableData:{},sortData:{},visibleData:{},fixedData:{}}:tableMethods.getCustomStoreData();if(updateStore){return updateStore({$table:$xeTable,id:tableId,type,storeData});}else{setCustomStorageMap(tableId,type==='reset'?null:storeData);}}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},handleCustom(){const{mouseConfig}=props;if(mouseConfig){if($xeTable.clearSelected){$xeTable.clearSelected();}if($xeTable.clearCellAreas){$xeTable.clearCellAreas();$xeTable.clearCopyCellArea();}}tablePrivateMethods.analyColumnWidth();return tableMethods.refreshColumn(true);},handleUpdateDataQueue(){reactData.upDataFlag++;},handleRefreshColumnQueue(){reactData.reColumnFlag++;},preventEvent(evnt,type,args,next,end){let evntList=table_interceptor.get(type);// 兼容老版本
if(!evntList.length&&type==='event.clearEdit'){evntList=table_interceptor.get('event.clearActived');if(true){if(evntList.length){warnLog('vxe.error.delEvent',['event.clearActived','event.clearEdit']);}}}// 兼容老版本
let rest=null;let isStop=false;for(let i=0;i<evntList.length;i++){const func=evntList[i];const fnRest=func(Object.assign({$grid:$xeGrid,$table:$xeTable,$event:evnt},args));if(fnRest===false){isStop=true;break;}else if(fnRest&&fnRest.status===false){rest=fnRest.result;isStop=true;break;}}if(!isStop){if(next){rest=next();}}if(end){end();}return rest;},updateCheckboxStatus(){const{treeConfig}=props;const{isRowGroupStatus}=reactData;const{afterTreeFullData,afterGroupFullData,selectCheckboxMaps,treeIndeterminateRowMaps}=internalData;const rowGroupOpts=computeRowGroupOpts.value;const treeOpts=computeTreeOpts.value;const childrenField=treeOpts.children||treeOpts.childrenField;const checkboxOpts=computeCheckboxOpts.value;const{checkField,checkStrictly,checkMethod}=checkboxOpts;if(checkStrictly){return;}if(isRowGroupStatus||treeConfig){const{handleGetRowId}=createHandleGetRowId($xeTable);const childRowMaps={};const childRowList=[];if(isRowGroupStatus){// 行分组
const mapChildrenField=rowGroupOpts.mapChildrenField;if(mapChildrenField){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterGroupFullData,row=>{const rowid=handleGetRowId(row);const childList=row[mapChildrenField];if(childList&&childList.length&&!childRowMaps[rowid]){childRowMaps[rowid]=1;childRowList.unshift([row,rowid,childList]);}},{children:mapChildrenField});}}else if(treeConfig){// 树结构
const{transform,mapChildrenField}=treeOpts;external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterTreeFullData,row=>{const rowid=handleGetRowId(row);const childList=row[transform?mapChildrenField:childrenField];if(childList&&childList.length&&!childRowMaps[rowid]){childRowMaps[rowid]=1;childRowList.unshift([row,rowid,childList]);}},{children:transform?mapChildrenField:childrenField});}childRowList.forEach(vals=>{const row=vals[0];const rowid=vals[1];const childList=vals[2];let sLen=0;// 已选
let hLen=0;// 半选
let vLen=0;// 有效行
childList.forEach(checkMethod?item=>{const childRowid=handleGetRowId(item);const isSelect=checkField?external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(item,checkField):selectCheckboxMaps[childRowid];if(checkMethod({$table:$xeTable,row:item})){if(isSelect){sLen++;}else if(treeIndeterminateRowMaps[childRowid]){hLen++;}vLen++;}else{if(isSelect){sLen++;}else if(treeIndeterminateRowMaps[childRowid]){hLen++;}}}:item=>{const childRowid=handleGetRowId(item);const isSelect=checkField?external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(item,checkField):selectCheckboxMaps[childRowid];if(isSelect){sLen++;}else if(treeIndeterminateRowMaps[childRowid]){hLen++;}vLen++;});const isSelected=sLen>=vLen;const halfSelect=!isSelected&&(sLen>=1||hLen>=1);if(checkField){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row,checkField,isSelected);}if(isSelected){if(!checkField){selectCheckboxMaps[rowid]=row;}if(treeIndeterminateRowMaps[rowid]){delete treeIndeterminateRowMaps[rowid];}}else{if(!checkField){if(selectCheckboxMaps[rowid]){delete selectCheckboxMaps[rowid];}}if(halfSelect){treeIndeterminateRowMaps[rowid]=row;}else{if(treeIndeterminateRowMaps[rowid]){delete treeIndeterminateRowMaps[rowid];}}}});}reactData.updateCheckboxFlag++;},updateAllCheckboxStatus(){const{treeConfig}=props;const{isRowGroupStatus}=reactData;const{afterFullData,afterTreeFullData,afterGroupFullData,checkboxReserveRowMap,selectCheckboxMaps,treeIndeterminateRowMaps}=internalData;const checkboxOpts=computeCheckboxOpts.value;const{checkField,checkMethod,showReserveStatus}=checkboxOpts;const{handleGetRowId}=createHandleGetRowId($xeTable);let sLen=0;// 已选
let hLen=0;// 半选
let vLen=0;// 有效行
const rootList=treeConfig?afterTreeFullData:isRowGroupStatus?afterGroupFullData:afterFullData;rootList.forEach(checkMethod?row=>{const childRowid=handleGetRowId(row);const selected=checkField?external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,checkField):selectCheckboxMaps[childRowid];if(checkMethod({$table:$xeTable,row})){if(selected){sLen++;}else if(treeIndeterminateRowMaps[childRowid]){hLen++;}vLen++;}else{if(selected){sLen++;}else if(treeIndeterminateRowMaps[childRowid]){hLen++;}}}:row=>{const childRowid=handleGetRowId(row);const selected=checkField?external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,checkField):selectCheckboxMaps[childRowid];if(selected){sLen++;}else if(treeIndeterminateRowMaps[childRowid]){hLen++;}vLen++;});const isSelected=rootList.length>0?vLen>0?sLen>=vLen:sLen>=rootList.length:false;let halfSelect=!isSelected&&(sLen>=1||hLen>=1);// 如果复选框启用保留记录，当保留数据存在时显示半选
if(!isSelected&&!halfSelect&&showReserveStatus){halfSelect=!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEmpty(checkboxReserveRowMap);}reactData.isAllSelected=isSelected;reactData.isIndeterminate=halfSelect;},checkSelectionStatus(){$xeTable.updateCheckboxStatus();$xeTable.updateAllCheckboxStatus();},/**
             * 切换选中
             * 多选，行选中事件
             */handleBatchSelectRows(rows,checked,isForce){const{treeConfig}=props;const{isRowGroupStatus}=reactData;const{selectCheckboxMaps}=internalData;const rowGroupOpts=computeRowGroupOpts.value;const treeOpts=computeTreeOpts.value;const{transform,mapChildrenField}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;const checkboxOpts=computeCheckboxOpts.value;const{checkField,checkStrictly,checkMethod}=checkboxOpts;const{handleGetRowId}=createHandleGetRowId($xeTable);// indeterminateField 仅支持读取
const indeterminateField=checkboxOpts.indeterminateField||checkboxOpts.halfField;if(checkField){// 树结构
if((treeConfig||isRowGroupStatus)&&!checkStrictly){// 更新子节点状态
external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(rows,row=>{if(isForce||!checkMethod||checkMethod({$table:$xeTable,row})){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row,checkField,checked);if(indeterminateField){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row,indeterminateField,false);}handleCheckboxReserveRow(row,checked);}},{children:transform?mapChildrenField:childrenField});reactData.updateCheckboxFlag++;return;}// 列表
rows.forEach(row=>{if(isForce||!checkMethod||checkMethod({$table:$xeTable,row})){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row,checkField,checked);handleCheckboxReserveRow(row,checked);}});reactData.updateCheckboxFlag++;return;}// 树结构
if(!checkStrictly){if(isRowGroupStatus){// 更新行分组节点状态
external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(rows,row=>{const rowid=handleGetRowId(row);if(isForce||!checkMethod||checkMethod({$table:$xeTable,row})){if(checked){selectCheckboxMaps[rowid]=row;}else{if(selectCheckboxMaps[rowid]){delete selectCheckboxMaps[rowid];}}handleCheckboxReserveRow(row,checked);}},{children:rowGroupOpts.mapChildrenField});reactData.updateCheckboxFlag++;return;}else if(treeConfig){// 更新子节点状态
external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(rows,row=>{const rowid=handleGetRowId(row);if(isForce||!checkMethod||checkMethod({$table:$xeTable,row})){if(checked){selectCheckboxMaps[rowid]=row;}else{if(selectCheckboxMaps[rowid]){delete selectCheckboxMaps[rowid];}}handleCheckboxReserveRow(row,checked);}},{children:transform?mapChildrenField:childrenField});reactData.updateCheckboxFlag++;return;}}// 列表
rows.forEach(row=>{const rowid=handleGetRowId(row);if(isForce||!checkMethod||checkMethod({$table:$xeTable,row})){if(checked){if(!selectCheckboxMaps[rowid]){selectCheckboxMaps[rowid]=row;}}else{if(selectCheckboxMaps[rowid]){delete selectCheckboxMaps[rowid];}}handleCheckboxReserveRow(row,checked);reactData.updateCheckboxFlag++;}});},/**
             * 即将移除
             * @deprecated
             */handleSelectRow({row},checked,isForce){$xeTable.handleBatchSelectRows([row],checked,isForce);},/**
             * 处理合并
             */handleUpdateBodyMerge(){const{mergeBodyList}=internalData;internalData.mergeBodyCellMaps=buildMergeData(mergeBodyList);reactData.mergeBodyFlag++;},handleUpdateFooterMerge(){const{mergeFooterList}=internalData;internalData.mergeFooterCellMaps=buildMergeData(mergeFooterList);reactData.mergeFootFlag++;},triggerHeaderTitleEvent(evnt,iconParams,params){const tipContent=iconParams.content||iconParams.message;if(tipContent){const{tooltipStore}=reactData;const{column}=params;const content=getFuncText(tipContent);handleTargetEnterEvent(true);tooltipStore.row=null;tooltipStore.column=column;tooltipStore.visible=true;tooltipStore.currOpts=iconParams;(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{const $tooltip=refTooltip.value;if($tooltip&&$tooltip.open){$tooltip.open(evnt.currentTarget,content);}});}},/**
             * 触发表头 tooltip 事件
             */triggerHeaderTooltipEvent(evnt,params){const{tooltipStore}=reactData;const{column}=params;handleTargetEnterEvent(true);const titleElem=evnt.currentTarget;if(!titleElem){return;}const cellEl=titleElem.parentElement;if(!cellEl){return;}const thEl=cellEl.parentElement;if(!thEl){return;}if(tooltipStore.column!==column||!tooltipStore.visible){handleTooltip(evnt,thEl,thEl.querySelector('.vxe-cell--wrapper'),thEl.querySelector('.vxe-cell--title')||cellEl,params);}},/**
             * 触发单元格 tooltip 事件
             */triggerBodyTooltipEvent(evnt,params){const{editConfig}=props;const{editStore}=reactData;const{tooltipStore}=reactData;const editOpts=computeEditOpts.value;const{actived}=editStore;const{row,column}=params;const tdEl=evnt.currentTarget;handleTargetEnterEvent(tooltipStore.column!==column||tooltipStore.row!==row);// 单元格处于编辑状态时不触发提示框
if(column.editRender&&isEnableConf(editConfig)){// 如果是行编辑模式
if(editOpts.mode==='row'&&actived.row===row){return;}// 如果是单元格编辑模式
if(actived.row===row&&actived.column===column){return;}}if(tooltipStore.column!==column||tooltipStore.row!==row||!tooltipStore.visible){handleTooltip(evnt,tdEl,tdEl.querySelector('.vxe-cell--wrapper'),tdEl.querySelector('.vxe-cell--label')||tdEl.querySelector('.vxe-cell--wrapper'),params);}},/**
             * 触发表尾 tooltip 事件
             */triggerFooterTooltipEvent(evnt,params){const{column}=params;const{tooltipStore}=reactData;const tdEl=evnt.currentTarget;handleTargetEnterEvent(tooltipStore.column!==column||!!tooltipStore.row);if(tooltipStore.column!==column||!tooltipStore.visible){handleTooltip(evnt,tdEl,tdEl.querySelector('.vxe-cell--wrapper'),tdEl.querySelector('.vxe-cell--label')||tdEl.querySelector('.vxe-cell--wrapper'),params);}},handleTargetLeaveEvent(){const tooltipOpts=computeTooltipOpts.value;let $tooltip=refTooltip.value;if($tooltip&&$tooltip.setActived){$tooltip.setActived(false);}if(tooltipOpts.enterable){internalData.tooltipTimeout=setTimeout(()=>{$tooltip=refTooltip.value;if($tooltip&&$tooltip.isActived&&!$tooltip.isActived()){$xeTable.closeTooltip();}},tooltipOpts.leaveDelay);}else{$xeTable.closeTooltip();}},triggerHeaderCellClickEvent(evnt,params){const{_lastResizeTime}=internalData;const sortOpts=computeSortOpts.value;const columnOpts=computeColumnOpts.value;const currentColumnOpts=computeCurrentColumnOpts.value;const{column}=params;const cell=evnt.currentTarget;const triggerResizable=_lastResizeTime&&_lastResizeTime>Date.now()-300;const triggerSort=getEventTargetNode(evnt,cell,'vxe-cell--sort').flag;const triggerFilter=getEventTargetNode(evnt,cell,'vxe-cell--filter').flag;if(sortOpts.trigger==='cell'&&!(triggerResizable||triggerSort||triggerFilter)){$xeTable.triggerSortEvent(evnt,column,getNextSortOrder(column));}dispatchEvent('header-cell-click',Object.assign({triggerResizable,triggerSort,triggerFilter,cell},params),evnt);if((columnOpts.isCurrent||props.highlightCurrentColumn)&&(!currentColumnOpts.trigger||['header','default'].includes(currentColumnOpts.trigger))){$xeTable.triggerCurrentColumnEvent(evnt,params);}},triggerHeaderCellDblclickEvent(evnt,params){dispatchEvent('header-cell-dblclick',Object.assign({cell:evnt.currentTarget},params),evnt);},/**
             * 列点击事件
             * 如果是单击模式，则激活为编辑状态
             * 如果是双击模式，则单击后选中状态
             */triggerCellClickEvent(evnt,params){const{highlightCurrentRow,highlightCurrentColumn,editConfig}=props;const{editStore,isDragResize}=reactData;if(isDragResize){return;}const expandOpts=computeExpandOpts.value;const editOpts=computeEditOpts.value;const treeOpts=computeTreeOpts.value;const radioOpts=computeRadioOpts.value;const checkboxOpts=computeCheckboxOpts.value;const keyboardOpts=computeKeyboardOpts.value;const rowGroupOpts=computeRowGroupOpts.value;const rowOpts=computeRowOpts.value;const columnOpts=computeColumnOpts.value;const currentColumnOpts=computeCurrentColumnOpts.value;const{actived,focused}=editStore;const{row,column}=params;const{type,treeNode,rowGroupNode}=column;const isRadioType=type==='radio';const isCheckboxType=type==='checkbox';const isExpandType=type==='expand';const cell=evnt.currentTarget;const triggerRadio=isRadioType&&getEventTargetNode(evnt,cell,'vxe-cell--radio').flag;const triggerCheckbox=isCheckboxType&&getEventTargetNode(evnt,cell,'vxe-cell--checkbox').flag;const triggerTreeNode=treeNode&&getEventTargetNode(evnt,cell,'vxe-cell--tree-btn').flag;const triggerExpandNode=isExpandType&&getEventTargetNode(evnt,cell,'vxe-table--expanded').flag;const triggerRowGroupNode=isExpandType&&getEventTargetNode(evnt,cell,'vxe-row-group--node-btn').flag;params=Object.assign({cell,triggerRadio,triggerCheckbox,triggerTreeNode,triggerExpandNode},params);if(!triggerCheckbox&&!triggerRadio){// 如果是展开行
if(!triggerExpandNode&&(expandOpts.trigger==='row'||isExpandType&&expandOpts.trigger==='cell')){$xeTable.triggerRowExpandEvent(evnt,params);}// 如果是树形表格
if(treeOpts.trigger==='row'||treeNode&&treeOpts.trigger==='cell'){$xeTable.triggerTreeExpandEvent(evnt,params);}// 如果是行分组
if(rowGroupOpts.trigger==='row'||rowGroupNode&&rowGroupOpts.trigger==='cell'){$xeTable.triggerRowGroupExpandEvent(evnt,params);}}// 如果点击了树节点
if(!triggerTreeNode){if(!triggerExpandNode&&!triggerRowGroupNode){// 如果是当前行
if(rowOpts.isCurrent||highlightCurrentRow){if(!triggerCheckbox&&!triggerRadio){$xeTable.triggerCurrentRowEvent(evnt,params);}}// 如果是当前列
if((columnOpts.isCurrent||highlightCurrentColumn)&&(!currentColumnOpts.trigger||['cell','default'].includes(currentColumnOpts.trigger))){if(!triggerCheckbox&&!triggerRadio){$xeTable.triggerCurrentColumnEvent(evnt,params);}}// 如果是单选框
if(!triggerRadio&&(radioOpts.trigger==='row'||isRadioType&&radioOpts.trigger==='cell')){$xeTable.triggerRadioRowEvent(evnt,params);}// 如果是复选框
if(!triggerCheckbox&&(checkboxOpts.trigger==='row'||isCheckboxType&&checkboxOpts.trigger==='cell')){$xeTable.handleToggleCheckRowEvent(evnt,params);}}// 如果设置了单元格选中功能，则不会使用点击事件去处理（只能支持双击模式）
if(isEnableConf(editConfig)){// 记录点击输入框聚焦状态
if(keyboardOpts.arrowCursorLock&&evnt&&editOpts.mode==='cell'&&evnt.target&&/^input|textarea$/i.test(evnt.target.tagName)){focused.column=column;focused.row=row;}if(editOpts.trigger==='manual'){if(actived.args&&actived.row===row&&column!==actived.column){handleChangeCell(evnt,params);}}else if(!actived.args||row!==actived.row||column!==actived.column){if(editOpts.trigger==='click'){handleChangeCell(evnt,params);}else if(editOpts.trigger==='dblclick'){if(editOpts.mode==='row'&&actived.row===row){handleChangeCell(evnt,params);}}}}}// 如果是双击编辑模式
if(isEnableConf(editConfig)&&editOpts.trigger==='dblclick'){if(actived.row&&actived.column){if(editOpts.mode==='row'){if(!$xeTable.eqRow(actived.row,row)){$xeTable.handleClearEdit(evnt);}}else if(editOpts.mode==='cell'){if(!$xeTable.eqRow(actived.row,row)||actived.column.id!==column.id){$xeTable.handleClearEdit(evnt);}}}}dispatchEvent('cell-click',params,evnt);},/**
             * 列双击点击事件
             * 如果是双击模式，则激活为编辑状态
             */triggerCellDblclickEvent(evnt,params){const{editConfig}=props;const{editStore,isDragResize}=reactData;if(isDragResize){return;}const editOpts=computeEditOpts.value;const{actived}=editStore;const cell=evnt.currentTarget;params=Object.assign({cell},params);if(isEnableConf(editConfig)&&editOpts.trigger==='dblclick'){if(!actived.args||evnt.currentTarget!==actived.args.cell){if(editOpts.mode==='row'){checkValidate('blur').catch(e=>e).then(()=>{$xeTable.handleEdit(params,evnt).then(()=>checkValidate('change')).catch(e=>e);});}else if(editOpts.mode==='cell'){$xeTable.handleEdit(params,evnt).then(()=>checkValidate('change')).catch(e=>e);}}}dispatchEvent('cell-dblclick',params,evnt);},handleToggleCheckRowEvent(evnt,params){const{selectCheckboxMaps}=internalData;const checkboxOpts=computeCheckboxOpts.value;const{checkField,trigger}=checkboxOpts;const{row}=params;if(trigger==='manual'){return;}let checked=false;if(checkField){checked=!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,checkField);}else{checked=!selectCheckboxMaps[getRowid($xeTable,row)];}if(evnt){$xeTable.triggerCheckRowEvent(evnt,params,checked);}else{$xeTable.handleBatchSelectRows([row],checked);$xeTable.checkSelectionStatus();}},triggerCheckRowEvent(evnt,params,checked){const{treeConfig}=props;const{row}=params;const{isRowGroupStatus}=reactData;const{afterFullData}=internalData;const checkboxOpts=computeCheckboxOpts.value;const{checkMethod,trigger}=checkboxOpts;if(trigger==='manual'){return;}evnt.stopPropagation();if(checkboxOpts.isShiftKey&&evnt.shiftKey&&!(treeConfig||isRowGroupStatus)){const checkboxRecords=$xeTable.getCheckboxRecords();if(checkboxRecords.length){const firstRow=checkboxRecords[0];const _rowIndex=$xeTable.getVTRowIndex(row);const _firstRowIndex=$xeTable.getVTRowIndex(firstRow);if(_rowIndex!==_firstRowIndex){$xeTable.setAllCheckboxRow(false);const rangeRows=_rowIndex<_firstRowIndex?afterFullData.slice(_rowIndex,_firstRowIndex+1):afterFullData.slice(_firstRowIndex,_rowIndex+1);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{handleCheckedCheckboxRow(rangeRows,true,false);});dispatchEvent('checkbox-range-select',Object.assign({rangeRecords:rangeRows},params),evnt);return;}}}if(!checkMethod||checkMethod({$table:$xeTable,row})){$xeTable.handleBatchSelectRows([row],checked);$xeTable.checkSelectionStatus();dispatchEvent('checkbox-change',Object.assign({records:()=>$xeTable.getCheckboxRecords(),reserves:()=>$xeTable.getCheckboxReserveRecords(),indeterminates:()=>$xeTable.getCheckboxIndeterminateRecords(),checked},params),evnt);}},/**
             * 多选，选中所有事件
             */triggerCheckAllEvent(evnt,value){const checkboxOpts=computeCheckboxOpts.value;const{trigger}=checkboxOpts;if(trigger==='manual'){return;}if(evnt){evnt.stopPropagation();}handleCheckAllEvent(evnt,value);},/**
             * 单选，行选中事件
             */triggerRadioRowEvent(evnt,params){const{selectRadioRow:oldValue}=reactData;const{row}=params;const radioOpts=computeRadioOpts.value;const{trigger}=radioOpts;if(trigger==='manual'){return;}evnt.stopPropagation();let newValue=row;let isChange=oldValue!==newValue;if(isChange){handleCheckedRadioRow(newValue);}else if(!radioOpts.strict){isChange=oldValue===newValue;if(isChange){newValue=null;$xeTable.clearRadioRow();}}if(isChange){dispatchEvent('radio-change',{oldValue,newValue,...params},evnt);}},triggerCurrentColumnEvent(evnt,params){const{currentColumn:oldValue}=reactData;const columnOpts=computeColumnOpts.value;const currentColumnOpts=computeCurrentColumnOpts.value;const beforeRowMethod=currentColumnOpts.beforeSelectMethod||columnOpts.currentMethod;const{column:newValue}=params;const{trigger}=currentColumnOpts;if(trigger==='manual'){return;}const isChange=oldValue!==newValue;if(!beforeRowMethod||beforeRowMethod({column:newValue,$table:$xeTable})){$xeTable.setCurrentColumn(newValue);if(isChange){dispatchEvent('current-column-change',{oldValue,newValue,...params},evnt);}}else{dispatchEvent('current-column-disabled',params,evnt);}},triggerCurrentRowEvent(evnt,params){const{currentRow:oldValue}=reactData;const rowOpts=computeRowOpts.value;const currentRowOpts=computeCurrentRowOpts.value;const beforeRowMethod=currentRowOpts.beforeSelectMethod||rowOpts.currentMethod;const{row:newValue}=params;const{trigger}=currentRowOpts;if(trigger==='manual'){return;}const isChange=oldValue!==newValue;if(!beforeRowMethod||beforeRowMethod({row:newValue,$table:$xeTable})){$xeTable.setCurrentRow(newValue);if(isChange){dispatchEvent('current-row-change',{oldValue,newValue,...params},evnt);// 已废弃
dispatchEvent('current-change',{oldValue,newValue,...params},evnt);}}else{dispatchEvent('current-row-disabled',params,evnt);}},/**
             * 展开行事件
             */triggerRowExpandEvent(evnt,params){const{expandColumn}=reactData;const{rowExpandLazyLoadedMaps}=internalData;const expandOpts=computeExpandOpts.value;const{row}=params;const{lazy,trigger}=expandOpts;if(trigger==='manual'){return;}evnt.stopPropagation();const rowid=getRowid($xeTable,row);if(!lazy||!rowExpandLazyLoadedMaps[rowid]){const expanded=!$xeTable.isRowExpandByRow(row);const columnIndex=expandColumn?$xeTable.getColumnIndex(expandColumn):-1;const $columnIndex=expandColumn?$xeTable.getVMColumnIndex(expandColumn):-1;$xeTable.setRowExpand(row,expanded);dispatchEvent('toggle-row-expand',{expanded,column:expandColumn,columnIndex,$columnIndex,row,rowIndex:$xeTable.getRowIndex(row),$rowIndex:$xeTable.getVMRowIndex(row)},evnt);}},/**
             * 行分组事件
             */triggerRowGroupExpandEvent(evnt,params){const{rowGroupExpandedMaps}=internalData;const rowGroupOpts=computeRowGroupOpts.value;const{row,column}=params;const{trigger}=rowGroupOpts;if(trigger==='manual'){return;}evnt.stopPropagation();const rowid=getRowid($xeTable,row);const expanded=!rowGroupExpandedMaps[rowid];const columnIndex=$xeTable.getColumnIndex(column);const $columnIndex=$xeTable.getVMColumnIndex(column);$xeTable.setRowGroupExpand(row,expanded);dispatchEvent('toggle-row-group-expand',{expanded,column,columnIndex,$columnIndex,row},evnt);},/**
             * 展开树节点事件
             */triggerTreeExpandEvent(evnt,params){const{treeExpandLazyLoadedMaps,treeEATime}=internalData;const treeOpts=computeTreeOpts.value;const{row,column}=params;const{lazy,trigger,accordion}=treeOpts;if(trigger==='manual'){return;}evnt.stopPropagation();const rowid=getRowid($xeTable,row);if(!lazy||!treeExpandLazyLoadedMaps[rowid]){const expanded=!$xeTable.isTreeExpandByRow(row);const columnIndex=$xeTable.getColumnIndex(column);const $columnIndex=$xeTable.getVMColumnIndex(column);if(treeEATime){clearTimeout(treeEATime);}$xeTable.setTreeExpand(row,expanded).then(()=>{if(accordion){internalData.treeEATime=setTimeout(()=>{internalData.treeEATime=undefined;$xeTable.scrollToRow(row);},30);}});dispatchEvent('toggle-tree-expand',{expanded,column,columnIndex,$columnIndex,row},evnt);}},handleColumnSortEvent(evnt,column){const{mouseConfig}=props;const mouseOpts=computeMouseOpts.value;const{field,sortable}=column;if(sortable){const params={$table:$xeTable,$event:evnt,column,field,property:field,order:column.order,sortList:tableMethods.getSortColumns(),sortTime:column.sortTime};if(mouseConfig&&mouseOpts.area&&$xeTable.handleSortEvent){$xeTable.handleSortEvent(evnt,params);}dispatchEvent('sort-change',params,evnt);}},/**
             * 点击排序事件
             */triggerSortEvent(evnt,column,order){const sortOpts=computeSortOpts.value;const{multiple,allowClear}=sortOpts;const{field,sortable}=column;if(sortable){if(!order||column.order===order){if(allowClear){tableMethods.clearSort(multiple?column:null);}}else{tableMethods.sort({field,order});}$xeTable.handleColumnSortEvent(evnt,column);}},handleCellRuleUpdateStatus(type,cellParams,cellValue){const{validStore}=reactData;const{row,column}=cellParams;if($xeTable.hasCellRules){if($xeTable.hasCellRules(type,row,column)){const cell=$xeTable.getCellElement(row,column);if(cell){const customVal=!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(cellValue);return $xeTable.validCellRules(type,row,column,cellValue).then(()=>{if(customVal&&validStore.visible){setCellValue(row,column,cellValue);}$xeTable.clearValidate(row,column);}).catch(({rule})=>{if(customVal){setCellValue(row,column,cellValue);}$xeTable.showValidTooltip({rule,row,column,cell});});}}}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 表头单元格按下事件
             */triggerHeaderCellMousedownEvent(evnt,params){const{mouseConfig}=props;const mouseOpts=computeMouseOpts.value;const columnOpts=computeColumnOpts.value;const columnDragOpts=computeColumnDragOpts.value;const{trigger,isCrossDrag,isPeerDrag,disabledMethod}=columnDragOpts;const cell=evnt.currentTarget;const triggerInput=cell&&cell.tagName&&cell.tagName.toLowerCase()==='input';const triggerCheckbox=getEventTargetNode(evnt,cell,'vxe-cell--checkbox').flag;const triggerSort=getEventTargetNode(evnt,cell,'vxe-cell--sort').flag;const triggerFilter=getEventTargetNode(evnt,cell,'vxe-cell--filter').flag;let triggerDrag=false;const isColDragCell=columnOpts.drag&&trigger==='cell';if(!(triggerInput||triggerCheckbox||triggerSort||triggerFilter)){const{column}=params;if(isColDragCell&&!column.fixed&&(isCrossDrag||isPeerDrag||!column.parentId)&&!(disabledMethod&&disabledMethod(params))){triggerDrag=true;$xeTable.handleHeaderCellDragMousedownEvent(evnt,params);}}if(!triggerDrag&&mouseConfig&&mouseOpts.area&&$xeTable.handleHeaderCellAreaEvent){$xeTable.handleHeaderCellAreaEvent(evnt,Object.assign({cell,triggerSort,triggerFilter},params));}$xeTable.focus();if($xeTable.closeMenu){$xeTable.closeMenu();}},/**
             * 单元格按下事件
             */triggerCellMousedownEvent(evnt,params){const{column}=params;const{type,treeNode}=column;const isRadioType=type==='radio';const isCheckboxType=type==='checkbox';const isExpandType=type==='expand';const rowOpts=computeRowOpts.value;const rowDragOpts=computeRowDragOpts.value;const{trigger,isCrossDrag,isPeerDrag,disabledMethod}=rowDragOpts;const cell=evnt.currentTarget;params.cell=cell;const triggerInput=cell&&cell.tagName&&cell.tagName.toLowerCase()==='input';const triggerRadio=isRadioType&&getEventTargetNode(evnt,cell,'vxe-cell--radio').flag;const triggerCheckbox=isCheckboxType&&getEventTargetNode(evnt,cell,'vxe-cell--checkbox').flag;const triggerTreeNode=treeNode&&getEventTargetNode(evnt,cell,'vxe-cell--tree-btn').flag;const triggerExpandNode=isExpandType&&getEventTargetNode(evnt,cell,'vxe-table--expanded').flag;let isColDragCell=false;if(rowOpts.drag){isColDragCell=trigger==='row'||column.dragSort&&trigger==='cell';}let triggerDrag=false;if(!(triggerInput||triggerRadio||triggerCheckbox||triggerTreeNode||triggerExpandNode)){if(isColDragCell&&(isCrossDrag||isPeerDrag||!params.level)&&!(disabledMethod&&disabledMethod(params))){triggerDrag=true;$xeTable.handleCellDragMousedownEvent(evnt,params);}}if(!triggerDrag&&$xeTable.handleCellMousedownEvent){$xeTable.handleCellMousedownEvent(evnt,params);}$xeTable.focus();$xeTable.closeFilter();if($xeTable.closeMenu){$xeTable.closeMenu();}},triggerCellMouseupEvent(){clearDragStatus();},/**
             * 行拖拽
             */handleRowDragDragstartEvent(evnt){if(evnt.dataTransfer){evnt.dataTransfer.setDragImage(getTpImg(),0,0);}},handleRowDragSwapEvent(evnt,isSyncRow,dragRow,prevDragRow,prevDragPos,prevDragToChild){const{treeConfig,dragConfig}=props;const rowDragOpts=computeRowDragOpts.value;const{afterFullData,tableFullData,fullAllDataRowIdData}=internalData;const{isPeerDrag,isCrossDrag,isSelfToChildDrag,dragEndMethod,dragToChildMethod}=rowDragOpts;const treeOpts=computeTreeOpts.value;const{transform,rowField,mapChildrenField,parentField}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;const dEndMethod=dragEndMethod||(dragConfig?dragConfig.dragEndMethod:null);const dragOffsetIndex=prevDragPos==='bottom'?1:0;const errRest={status:false};if(prevDragRow&&dragRow){// 判断是否有拖动
if(prevDragRow!==dragRow){const dragParams={oldRow:dragRow,newRow:prevDragRow,dragRow,dragPos:prevDragPos,dragToChild:!!prevDragToChild,offsetIndex:dragOffsetIndex};const isDragToChildFlag=isSelfToChildDrag&&dragToChildMethod?dragToChildMethod(dragParams):prevDragToChild;return Promise.resolve(dEndMethod?dEndMethod(dragParams):true).then(status=>{if(!status){return errRest;}let oafIndex=-1;let nafIndex=-1;// 如果为树结构
if(treeConfig){if(transform){// 移出源位置
const oldRowid=getRowid($xeTable,dragRow);const oldRest=fullAllDataRowIdData[oldRowid];const newRowid=getRowid($xeTable,prevDragRow);const newRest=fullAllDataRowIdData[newRowid];if(oldRest&&newRest){const{level:oldLevel}=oldRest;const{level:newLevel}=newRest;const oldAllMaps={};external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([dragRow],item=>{oldAllMaps[getRowid($xeTable,item)]=item;},{children:mapChildrenField});let isSelfToChildStatus=false;if(oldLevel&&newLevel){// 子到子
if(isPeerDrag&&!isCrossDrag){if(oldRest.row[parentField]!==newRest.row[parentField]){// 非同级
return errRest;}}else{if(!isCrossDrag){return errRest;}if(oldAllMaps[newRowid]){isSelfToChildStatus=true;if(!(isCrossDrag&&isSelfToChildDrag)){if(core_.VxeUI.modal){core_.VxeUI.modal.message({status:'error',content:table_getI18n('vxe.error.treeDragChild')});}return errRest;}}}}else if(oldLevel){// 子到根
if(!isCrossDrag){return errRest;}}else if(newLevel){// 根到子
if(!isCrossDrag){return errRest;}if(oldAllMaps[newRowid]){isSelfToChildStatus=true;if(!(isCrossDrag&&isSelfToChildDrag)){if(core_.VxeUI.modal){core_.VxeUI.modal.message({status:'error',content:table_getI18n('vxe.error.treeDragChild')});}return errRest;}}}else{// 根到根
}const fullList=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toTreeArray(internalData.afterTreeFullData,{key:rowField,parentKey:parentField,children:mapChildrenField});// 移出
const otfIndex=$xeTable.findRowIndexOf(fullList,dragRow);fullList.splice(otfIndex,1);// 插入
const ptfIndex=$xeTable.findRowIndexOf(fullList,prevDragRow);const ntfIndex=ptfIndex+dragOffsetIndex;fullList.splice(ntfIndex,0,dragRow);// 改变层级
if(isSelfToChildStatus&&isCrossDrag&&isSelfToChildDrag){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(dragRow[childrenField],childRow=>{childRow[parentField]=dragRow[parentField];});}dragRow[parentField]=isDragToChildFlag?prevDragRow[rowField]:prevDragRow[parentField];internalData.tableFullTreeData=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(fullList,{key:rowField,parentKey:parentField,children:childrenField,mapChildren:mapChildrenField});}}}else{// 移出
oafIndex=$xeTable.findRowIndexOf(afterFullData,dragRow);const otfIndex=$xeTable.findRowIndexOf(tableFullData,dragRow);afterFullData.splice(oafIndex,1);tableFullData.splice(otfIndex,1);// 插入
const pafIndex=$xeTable.findRowIndexOf(afterFullData,prevDragRow);const ptfIndex=$xeTable.findRowIndexOf(tableFullData,prevDragRow);nafIndex=pafIndex+dragOffsetIndex;const ntfIndex=ptfIndex+dragOffsetIndex;afterFullData.splice(nafIndex,0,dragRow);tableFullData.splice(ntfIndex,0,dragRow);}reactData.isDragRowMove=true;$xeTable.handleTableData(treeConfig&&transform);$xeTable.cacheRowMap(false);updateScrollYStatus();if(!(treeConfig&&transform)){$xeTable.updateAfterDataIndex();}$xeTable.checkSelectionStatus();if(reactData.scrollYLoad){$xeTable.updateScrollYSpace();}if(evnt){dispatchEvent('row-dragend',{oldRow:dragRow,newRow:prevDragRow,dragRow,dragPos:prevDragPos,dragToChild:isDragToChildFlag,offsetIndex:dragOffsetIndex,_index:{newIndex:nafIndex,oldIndex:oafIndex}},evnt);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{$xeTable.updateCellAreas();$xeTable.recalculate();}).then(()=>{return{status:true};});}).catch(()=>{return errRest;});}}return Promise.resolve(errRest);},handleRowDragDragendEvent(evnt){const{treeConfig}=props;const{fullAllDataRowIdData,prevDragToChild}=internalData;const{dragRow}=reactData;const treeOpts=computeTreeOpts.value;const{lazy}=treeOpts;const hasChildField=treeOpts.hasChild||treeOpts.hasChildField;const{prevDragRow,prevDragPos}=internalData;if(treeConfig&&lazy&&prevDragToChild){// 懒加载
const newRowid=getRowid($xeTable,prevDragRow);const rowRest=fullAllDataRowIdData[newRowid];if(prevDragRow[hasChildField]){if(rowRest&&rowRest.treeLoaded){$xeTable.handleRowDragSwapEvent(evnt,true,dragRow,prevDragRow,prevDragPos,prevDragToChild);}}else{$xeTable.handleRowDragSwapEvent(evnt,true,dragRow,prevDragRow,prevDragPos,prevDragToChild);}}else{$xeTable.handleRowDragSwapEvent(evnt,true,dragRow,prevDragRow,prevDragPos,prevDragToChild);}hideDropTip();clearRowDropOrigin();internalData.prevDragToChild=false;reactData.dragRow=null;reactData.dragCol=null;setTimeout(()=>{reactData.isDragRowMove=false;},500);},handleRowDragDragoverEvent(evnt){const{treeConfig}=props;const{fullAllDataRowIdData}=internalData;const{dragRow}=reactData;const treeOpts=computeTreeOpts.value;const{lazy,transform,parentField}=treeOpts;const hasChildField=treeOpts.hasChild||treeOpts.hasChildField;const rowDragOpts=computeRowDragOpts.value;const{isPeerDrag,isCrossDrag,isToChildDrag}=rowDragOpts;if(!dragRow){evnt.preventDefault();return;}const isControlKey=hasControlKey(evnt);const trEl=evnt.currentTarget;const rowid=trEl.getAttribute('rowid')||'';const rest=fullAllDataRowIdData[rowid];if(rest){const row=rest.row;const rowid=getRowid($xeTable,row);const rowRest=fullAllDataRowIdData[rowid];evnt.preventDefault();const{dragRow}=reactData;const offsetY=evnt.clientY-trEl.getBoundingClientRect().y;const dragPos=offsetY<trEl.clientHeight/2?'top':'bottom';internalData.prevDragToChild=!!(treeConfig&&transform&&isCrossDrag&&isToChildDrag&&isControlKey);internalData.prevDragRow=row;internalData.prevDragPos=dragPos;if($xeTable.eqRow(dragRow,row)||isControlKey&&treeConfig&&lazy&&row[hasChildField]&&rowRest&&!rowRest.treeLoaded||!isCrossDrag&&treeConfig&&transform&&(isPeerDrag?dragRow[parentField]!==row[parentField]:rest.level)){showDropTip(evnt,trEl,null,false,dragPos);return;}showDropTip(evnt,trEl,null,true,dragPos);dispatchEvent('row-dragover',{oldRow:dragRow,targetRow:row,dragPos},evnt);}},handleCellDragMousedownEvent(evnt,params){evnt.stopPropagation();const{dragConfig}=props;const rowDragOpts=computeRowDragOpts.value;const{trigger,dragStartMethod}=rowDragOpts;const{row}=params;const dragEl=evnt.currentTarget;const tdEl=trigger==='cell'||trigger==='row'?dragEl:dragEl.parentElement?.parentElement;const trEl=tdEl.parentElement;const dStartMethod=dragStartMethod||(dragConfig?dragConfig.dragStartMethod:null);clearRowDropOrigin();if(dStartMethod&&!dStartMethod(params)){trEl.draggable=false;reactData.dragRow=null;reactData.dragCol=null;hideDropTip();return;}reactData.dragRow=row;reactData.dragCol=null;trEl.draggable=true;updateRowDropOrigin(row);updateRowDropTipContent(tdEl);dispatchEvent('row-dragstart',params,evnt);},handleCellDragMouseupEvent(){clearDragStatus();},/**
             * 列拖拽
             */handleHeaderCellDragDragstartEvent(evnt){if(evnt.dataTransfer){evnt.dataTransfer.setDragImage(getTpImg(),0,0);}},handleColDragSwapColumn(){handleUpdateColumn();parseColumns(false).then(()=>{$xeTable.updateCellAreas();$xeTable.saveCustomStore('update:sort');});},handleColDragSwapEvent(evnt,isSyncColumn,dragCol,prevDragCol,prevDragPos,prevDragToChild){const{mouseConfig}=props;const columnDragOpts=computeColumnDragOpts.value;const{isPeerDrag,isCrossDrag,isSelfToChildDrag,isToChildDrag,dragEndMethod,dragToChildMethod}=columnDragOpts;const{collectColumn}=internalData;const dragOffsetIndex=prevDragPos==='right'?1:0;const errRest={status:false};if(prevDragCol&&dragCol){// 判断是否有拖动
if(prevDragCol!==dragCol){const dragColumn=dragCol;const newColumn=prevDragCol;const dragParams={oldColumn:dragColumn,newColumn,dragColumn,dragPos:prevDragPos,dragToChild:!!prevDragToChild,offsetIndex:dragOffsetIndex};const isDragToChildFlag=isSelfToChildDrag&&dragToChildMethod?dragToChildMethod(dragParams):prevDragToChild;return Promise.resolve(dragEndMethod?dragEndMethod(dragParams):true).then(status=>{if(!status){return errRest;}let oafIndex=-1;let nafIndex=-1;const oldAllMaps={};external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([dragColumn],column=>{oldAllMaps[column.id]=column;});let isSelfToChildStatus=false;if(dragColumn.parentId&&newColumn.parentId){// 子到子
if(isPeerDrag&&!isCrossDrag){if(dragColumn.parentId!==newColumn.parentId){// 非同级
return errRest;}}else{if(!isCrossDrag){return errRest;}if(oldAllMaps[newColumn.id]){isSelfToChildStatus=true;if(!(isCrossDrag&&isSelfToChildDrag)){if(core_.VxeUI.modal){core_.VxeUI.modal.message({status:'error',content:table_getI18n('vxe.error.treeDragChild')});}return errRest;}}}}else if(dragColumn.parentId){// 子到根
if(!isCrossDrag){return errRest;}}else if(newColumn.parentId){// 根到子
if(!isCrossDrag){return errRest;}if(oldAllMaps[newColumn.id]){isSelfToChildStatus=true;if(!(isCrossDrag&&isSelfToChildDrag)){if(core_.VxeUI.modal){core_.VxeUI.modal.message({status:'error',content:table_getI18n('vxe.error.treeDragChild')});}return errRest;}}}else{// 根到根
}const oldewMatchRest=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(collectColumn,item=>item.id===dragColumn.id);// 改变层级
if(isSelfToChildStatus&&isCrossDrag&&isSelfToChildDrag){if(oldewMatchRest){const{items:oCols,index:oIndex}=oldewMatchRest;const childList=dragColumn.children||[];childList.forEach(column=>{column.parentId=dragColumn.parentId;});oCols.splice(oIndex,1,...childList);dragColumn.children=[];}}else{if(oldewMatchRest){const{items:oCols,index:oIndex,parent:oParent}=oldewMatchRest;oCols.splice(oIndex,1);if(!oParent){oafIndex=oIndex;}}}const newMatchRest=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(collectColumn,item=>item.id===newColumn.id);if(newMatchRest){const{items:nCols,index:nIndex,parent:nParent}=newMatchRest;// 转子级
if(isCrossDrag&&isToChildDrag&&isDragToChildFlag){dragColumn.parentId=newColumn.id;newColumn.children=(newColumn.children||[]).concat([dragColumn]);}else{dragColumn.parentId=newColumn.parentId;nCols.splice(nIndex+dragOffsetIndex,0,dragColumn);}if(!nParent){nafIndex=nIndex;}}external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn,(column,index,items,path,parentColumn)=>{if(!parentColumn){const sortIndex=index+1;column.renderSortNumber=sortIndex;}});reactData.isDragColMove=true;if(mouseConfig){if($xeTable.clearSelected){$xeTable.clearSelected();}if($xeTable.clearCellAreas){$xeTable.clearCellAreas();$xeTable.clearCopyCellArea();}}if(evnt){dispatchEvent('column-dragend',{oldColumn:dragColumn,newColumn,dragColumn,dragPos:prevDragPos,dragToChild:isDragToChildFlag,offsetIndex:dragOffsetIndex,_index:{newIndex:nafIndex,oldIndex:oafIndex}},evnt);}if(isSyncColumn){$xeTable.handleColDragSwapColumn();}return{status:true};}).catch(()=>{return errRest;});}}return Promise.resolve(errRest);},handleHeaderCellDragDragendEvent(evnt){const{dragCol}=reactData;const{prevDragCol,prevDragPos,prevDragToChild}=internalData;$xeTable.handleColDragSwapEvent(evnt,true,dragCol,prevDragCol,prevDragPos,prevDragToChild);hideDropTip();clearColDropOrigin();internalData.prevDragToChild=false;reactData.dragRow=null;reactData.dragCol=null;setTimeout(()=>{reactData.isDragColMove=false;$xeTable.recalculate().then(()=>{loadScrollXData();});},500);},handleHeaderCellDragDragoverEvent(evnt){const{dragCol}=reactData;const columnDragOpts=computeColumnDragOpts.value;const{isToChildDrag,isPeerDrag,isCrossDrag}=columnDragOpts;if(!dragCol){evnt.preventDefault();return;}const isControlKey=hasControlKey(evnt);const thEl=evnt.currentTarget;const colid=thEl.getAttribute('colid');const column=$xeTable.getColumnById(colid);if(column){evnt.preventDefault();const{clientX}=evnt;const offsetX=clientX-thEl.getBoundingClientRect().x;const dragPos=offsetX<thEl.clientWidth/2?'left':'right';internalData.prevDragToChild=!!(isCrossDrag&&isToChildDrag&&isControlKey);internalData.prevDragCol=column;internalData.prevDragPos=dragPos;if(column.fixed||dragCol&&dragCol.id===column.id||!isCrossDrag&&(isPeerDrag?dragCol.parentId!==column.parentId:column.parentId)){showDropTip(evnt,null,thEl,false,dragPos);return;}showDropTip(evnt,null,thEl,true,dragPos);dispatchEvent('column-dragover',{oldColumn:dragCol,targetColumn:column,dragPos},evnt);// 边缘滚动
const el=refElem.value;if(!el){return;}const xHandleEl=refScrollXHandleElem.value;const tableBody=refTableBody.value;const tableBodyElem=tableBody?tableBody.$el:null;const scrollTargetEl=xHandleEl||tableBodyElem;if(scrollTargetEl){const wrapperRect=el.getBoundingClientRect();const tableWrapperWidth=el.clientWidth;const leftContainerElem=refLeftContainer.value;const leftContainerWidth=leftContainerElem?leftContainerElem.clientWidth:0;const rightContainerElem=refRightContainer.value;const rightContainerWidth=rightContainerElem?rightContainerElem.clientWidth:0;const srartX=wrapperRect.x+leftContainerWidth;const endX=wrapperRect.x+tableWrapperWidth-rightContainerWidth;const distSize=28;const startDistSize=clientX-srartX;const endDistSize=endX-clientX;if(startDistSize>0&&startDistSize<=distSize){const scrollRatio=Math.floor(tableWrapperWidth/(startDistSize>distSize/2?240:120));scrollTargetEl.scrollLeft-=scrollRatio*(distSize-startDistSize);}else if(endDistSize>0&&endDistSize<=distSize){const scrollRatio=Math.floor(tableWrapperWidth/(endDistSize>distSize/2?240:120));scrollTargetEl.scrollLeft+=scrollRatio*(distSize-endDistSize);}}}},handleHeaderCellDragMousedownEvent(evnt,params){evnt.stopPropagation();const columnDragOpts=computeColumnDragOpts.value;const{trigger,dragStartMethod}=columnDragOpts;const{column}=params;const dragEl=evnt.currentTarget;const thEl=trigger==='cell'?dragEl:dragEl.parentElement?.parentElement;reactData.isDragColMove=false;clearColDropOrigin();if(dragStartMethod&&!dragStartMethod(params)){thEl.draggable=false;reactData.dragRow=null;reactData.dragCol=null;hideDropTip();return;}reactData.dragCol=column;reactData.dragRow=null;thEl.draggable=true;updateColDropOrigin(column);updateColDropTipContent(thEl);dispatchEvent('column-dragstart',params,evnt);},handleHeaderCellDragMouseupEvent(){clearColDropOrigin();hideDropTip();reactData.dragRow=null;reactData.dragCol=null;reactData.isDragColMove=false;},handleScrollEvent(evnt,isRollY,isRollX,scrollTop,scrollLeft,params){const{highlightHoverRow}=props;const{lastScrollLeft,lastScrollTop}=internalData;const xHandleEl=refScrollXHandleElem.value;const yHandleEl=refScrollYHandleElem.value;if(!xHandleEl||!yHandleEl){return;}const rowOpts=computeRowOpts.value;const validTip=refValidTooltip.value;const tooltip=refTooltip.value;const bodyHeight=yHandleEl.clientHeight;const bodyWidth=xHandleEl.clientWidth;const scrollHeight=yHandleEl.scrollHeight;const scrollWidth=xHandleEl.scrollWidth;let isTop=false;let isBottom=false;let isLeft=false;let isRight=false;let direction='';let isTopBoundary=false;let isBottomBoundary=false;let isLeftBoundary=false;let isRightBoundary=false;if(isRollX){const xThreshold=computeScrollXThreshold.value;isLeft=scrollLeft<=0;if(!isLeft){isRight=scrollLeft+bodyWidth>=scrollWidth;}if(scrollLeft>lastScrollLeft){direction='right';if(scrollLeft+bodyWidth>=scrollWidth-xThreshold){isRightBoundary=true;}}else{direction='left';if(scrollLeft<=xThreshold){isLeftBoundary=true;}}$xeTable.checkScrolling();internalData.lastScrollLeft=scrollLeft;}if(isRollY){const yThreshold=computeScrollYThreshold.value;isTop=scrollTop<=0;if(!isTop){isBottom=scrollTop+bodyHeight>=scrollHeight;}if(scrollTop>lastScrollTop){direction='bottom';if(scrollTop+bodyHeight>=scrollHeight-yThreshold){isBottomBoundary=true;}}else{direction='top';if(scrollTop<=yThreshold){isTopBoundary=true;}}internalData.lastScrollTop=scrollTop;}reactData.isDragColMove=false;reactData.isDragRowMove=false;reactData.lastScrollTime=Date.now();const evntParams={scrollTop,scrollLeft,bodyHeight,bodyWidth,scrollHeight,scrollWidth,isX:isRollX,isY:isRollY,isTop,isBottom,isLeft,isRight,direction,...params};updateRowExpandStyle();checkLastSyncScroll(isRollX,isRollY);if(isRollX){$xeTable.closeFilter();}if(rowOpts.isHover||highlightHoverRow){$xeTable.clearHoverRow();}if(validTip&&validTip.reactData.visible){validTip.close();}if(tooltip&&tooltip.reactData.visible){tooltip.close();}if(isBottomBoundary||isTopBoundary||isRightBoundary||isLeftBoundary){dispatchEvent('scroll-boundary',evntParams,evnt);}dispatchEvent('scroll',evntParams,evnt);},/**
             * 横向 X 可视渲染事件处理
             */triggerScrollXEvent(){const virtualXOpts=computeVirtualXOpts.value;if(virtualXOpts.immediate){loadScrollXData();}else{lazyScrollXData();}},/**
             * 纵向 Y 可视渲染事件处理
             */triggerScrollYEvent(){const virtualYOpts=computeVirtualYOpts.value;if(virtualYOpts.immediate){loadScrollYData();}else{lazyScrollYData();}},triggerBodyScrollEvent(evnt,fixedType){const{scrollYLoad,scrollXLoad}=reactData;const{elemStore,intoRunScroll,lastScrollTop,lastScrollLeft,inWheelScroll,inVirtualScroll,inHeaderScroll,inBodyScroll,scrollRenderType,inFooterScroll}=internalData;if(inWheelScroll||inVirtualScroll||inHeaderScroll||inFooterScroll){return;}const xHandleEl=refScrollXHandleElem.value;const yHandleEl=refScrollYHandleElem.value;const leftScrollElem=getRefElem(elemStore['left-body-scroll']);const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const rightScrollElem=getRefElem(elemStore['right-body-scroll']);const headerScrollElem=getRefElem(elemStore['main-header-scroll']);const footerScrollElem=getRefElem(elemStore['main-footer-scroll']);const rowExpandEl=refRowExpandElem.value;if(intoRunScroll){return;}if(!bodyScrollElem){return;}if(!xHandleEl){return;}if(!yHandleEl){return;}if(inBodyScroll){if(scrollRenderType!==fixedType){return;}}let scrollTop=yHandleEl.scrollTop;let scrollLeft=xHandleEl.scrollLeft;if(leftScrollElem&&fixedType==='left'){scrollTop=leftScrollElem.scrollTop;}else if(rightScrollElem&&fixedType==='right'){scrollTop=rightScrollElem.scrollTop;}else{scrollTop=bodyScrollElem.scrollTop;scrollLeft=bodyScrollElem.scrollLeft;}const isRollX=scrollLeft!==lastScrollLeft;const isRollY=scrollTop!==lastScrollTop;internalData.inBodyScroll=true;internalData.scrollRenderType=fixedType;if(isRollY){if(fixedType==='left'){setScrollTop(bodyScrollElem,scrollTop);setScrollTop(rightScrollElem,scrollTop);}else if(fixedType==='right'){setScrollTop(bodyScrollElem,scrollTop);setScrollTop(leftScrollElem,scrollTop);}else{setScrollTop(leftScrollElem,scrollTop);setScrollTop(rightScrollElem,scrollTop);}setScrollTop(yHandleEl,scrollTop);setScrollTop(rowExpandEl,scrollTop);if(scrollYLoad){$xeTable.triggerScrollYEvent(evnt);}}if(isRollX){setScrollLeft(xHandleEl,scrollLeft);setScrollLeft(headerScrollElem,scrollLeft);setScrollLeft(footerScrollElem,scrollLeft);if(scrollXLoad){$xeTable.triggerScrollXEvent(evnt);}}$xeTable.handleScrollEvent(evnt,isRollY,isRollX,scrollTop,scrollLeft,{type:'body',fixed:fixedType});},triggerHeaderScrollEvent(evnt,fixedType){const{scrollXLoad}=reactData;const{elemStore,intoRunScroll,inWheelScroll,inVirtualScroll,inBodyScroll,inFooterScroll}=internalData;if(inWheelScroll||inVirtualScroll||inBodyScroll||inFooterScroll){return;}const yHandleEl=refScrollYHandleElem.value;const xHandleEl=refScrollXHandleElem.value;const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const headerScrollElem=getRefElem(elemStore['main-header-scroll']);const footerScrollElem=getRefElem(elemStore['main-footer-scroll']);if(intoRunScroll){return;}if(!headerScrollElem){return;}if(!xHandleEl){return;}if(!yHandleEl){return;}const scrollTop=yHandleEl.scrollTop;const scrollLeft=headerScrollElem.scrollLeft;const isRollX=true;const isRollY=false;internalData.inHeaderScroll=true;setScrollLeft(xHandleEl,scrollLeft);setScrollLeft(footerScrollElem,scrollLeft);setScrollLeft(bodyScrollElem,scrollLeft);if(scrollXLoad){$xeTable.triggerScrollXEvent(evnt);}$xeTable.handleScrollEvent(evnt,isRollY,isRollX,scrollTop,scrollLeft,{type:'header',fixed:fixedType});},triggerFooterScrollEvent(evnt,fixedType){const{scrollXLoad}=reactData;const{elemStore,intoRunScroll,inWheelScroll,inVirtualScroll,inHeaderScroll,inBodyScroll}=internalData;if(inWheelScroll||inVirtualScroll||inHeaderScroll||inBodyScroll){return;}const yHandleEl=refScrollYHandleElem.value;const xHandleEl=refScrollXHandleElem.value;const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const headerScrollElem=getRefElem(elemStore['main-header-scroll']);const footerScrollElem=getRefElem(elemStore['main-footer-scroll']);if(intoRunScroll){return;}if(!footerScrollElem){return;}if(!xHandleEl){return;}if(!yHandleEl){return;}const scrollTop=yHandleEl.scrollTop;const scrollLeft=footerScrollElem.scrollLeft;const isRollX=true;const isRollY=false;internalData.inFooterScroll=true;setScrollLeft(xHandleEl,scrollLeft);setScrollLeft(headerScrollElem,scrollLeft);setScrollLeft(bodyScrollElem,scrollLeft);if(scrollXLoad){$xeTable.triggerScrollXEvent(evnt);}$xeTable.handleScrollEvent(evnt,isRollY,isRollX,scrollTop,scrollLeft,{type:'footer',fixed:fixedType});},triggerBodyWheelEvent(evnt){const{target,deltaY,deltaX,shiftKey}=evnt;if(target&&/^textarea$/i.test(target.tagName)){return;}const{highlightHoverRow}=src_props;const{scrollXLoad,scrollYLoad,expandColumn}=reactData;const leftFixedWidth=computeLeftFixedWidth.value;const rightFixedWidth=computeRightFixedWidth.value;if(!(leftFixedWidth||rightFixedWidth||expandColumn)){return;}const{elemStore,lastScrollTop,lastScrollLeft}=internalData;const rowOpts=computeRowOpts.value;const xHandleEl=refScrollXHandleElem.value;const yHandleEl=refScrollYHandleElem.value;const leftScrollElem=getRefElem(elemStore['left-body-scroll']);const headerScrollElem=getRefElem(elemStore['main-header-scroll']);const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const footerScrollElem=getRefElem(elemStore['main-footer-scroll']);const rightScrollElem=getRefElem(elemStore['right-body-scroll']);const rowExpandEl=refRowExpandElem.value;if(!xHandleEl){return;}if(!yHandleEl){return;}if(!bodyScrollElem){return;}const wheelSpeed=getWheelSpeed(reactData.lastScrollTime);const deltaTop=shiftKey?0:Math.ceil(deltaY*wheelSpeed);const deltaLeft=shiftKey?Math.ceil((shiftKey?deltaY||deltaX:deltaX)*wheelSpeed):0;const isTopWheel=deltaTop<0;const currScrollTop=bodyScrollElem.scrollTop;// 如果滚动位置已经是顶部或底部，则不需要触发
if(isTopWheel?currScrollTop<=0:currScrollTop>=bodyScrollElem.scrollHeight-bodyScrollElem.clientHeight){return;}const scrollTop=currScrollTop+deltaTop;const scrollLeft=bodyScrollElem.scrollLeft+deltaLeft;const isRollX=scrollLeft!==lastScrollLeft;const isRollY=scrollTop!==lastScrollTop;if(rowOpts.isHover||highlightHoverRow){$xeTable.clearHoverRow();}// 用于鼠标纵向滚轮处理
if(isRollX){evnt.preventDefault();internalData.inWheelScroll=true;if(browseObj.firefox||browseObj.safari){const currLeftNum=scrollLeft;setScrollLeft(xHandleEl,currLeftNum);setScrollLeft(bodyScrollElem,currLeftNum);setScrollLeft(headerScrollElem,currLeftNum);setScrollLeft(footerScrollElem,currLeftNum);if(scrollXLoad){$xeTable.triggerScrollXEvent(evnt);}$xeTable.handleScrollEvent(evnt,isRollY,isRollX,bodyScrollElem.scrollTop,currLeftNum,{type:'table',fixed:''});}else{wheelScrollLeftTo(scrollLeft,offsetLeft=>{internalData.inWheelScroll=true;const currLeftNum=offsetLeft;setScrollLeft(xHandleEl,currLeftNum);setScrollLeft(bodyScrollElem,currLeftNum);setScrollLeft(headerScrollElem,currLeftNum);setScrollLeft(footerScrollElem,currLeftNum);if(scrollXLoad){$xeTable.triggerScrollXEvent(evnt);}$xeTable.handleScrollEvent(evnt,isRollY,isRollX,bodyScrollElem.scrollTop,currLeftNum,{type:'table',fixed:''});});}}if(isRollY){evnt.preventDefault();internalData.inWheelScroll=true;if(browseObj.firefox||browseObj.safari){const currTopNum=scrollTop;setScrollTop(yHandleEl,currTopNum);setScrollTop(bodyScrollElem,currTopNum);setScrollTop(leftScrollElem,currTopNum);setScrollTop(rightScrollElem,currTopNum);setScrollTop(rowExpandEl,currTopNum);if(scrollYLoad){$xeTable.triggerScrollYEvent(evnt);}$xeTable.handleScrollEvent(evnt,isRollY,isRollX,currTopNum,bodyScrollElem.scrollLeft,{type:'table',fixed:''});}else{wheelScrollTopTo(scrollTop-currScrollTop,offsetTop=>{internalData.inWheelScroll=true;const currTopNum=bodyScrollElem.scrollTop+offsetTop;setScrollTop(yHandleEl,currTopNum);setScrollTop(bodyScrollElem,currTopNum);setScrollTop(leftScrollElem,currTopNum);setScrollTop(rightScrollElem,currTopNum);setScrollTop(rowExpandEl,currTopNum);if(scrollYLoad){$xeTable.triggerScrollYEvent(evnt);}$xeTable.handleScrollEvent(evnt,isRollY,isRollX,currTopNum,bodyScrollElem.scrollLeft,{type:'table',fixed:''});});}}},triggerVirtualScrollXEvent(evnt){const{scrollXLoad}=reactData;const{elemStore,inWheelScroll,lastScrollTop,inHeaderScroll,inBodyScroll,inFooterScroll}=internalData;if(inHeaderScroll||inBodyScroll||inFooterScroll){return;}if(inWheelScroll){return;}const headerScrollElem=getRefElem(elemStore['main-header-scroll']);const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const footerScrollElem=getRefElem(elemStore['main-footer-scroll']);const yHandleEl=refScrollYHandleElem.value;const wrapperEl=evnt.currentTarget;const{scrollLeft}=wrapperEl;const yBodyEl=yHandleEl||bodyScrollElem;let scrollTop=0;if(yBodyEl){scrollTop=yBodyEl.scrollTop;}const isRollX=true;const isRollY=scrollTop!==lastScrollTop;internalData.inVirtualScroll=true;setScrollLeft(bodyScrollElem,scrollLeft);setScrollLeft(headerScrollElem,scrollLeft);setScrollLeft(footerScrollElem,scrollLeft);if(scrollXLoad){$xeTable.triggerScrollXEvent(evnt);}$xeTable.handleScrollEvent(evnt,isRollY,isRollX,scrollTop,scrollLeft,{type:'table',fixed:''});},triggerVirtualScrollYEvent(evnt){const{scrollYLoad}=reactData;const{elemStore,inWheelScroll,lastScrollLeft,inHeaderScroll,inBodyScroll,inFooterScroll}=internalData;if(inHeaderScroll||inBodyScroll||inFooterScroll){return;}if(inWheelScroll){return;}const leftScrollElem=getRefElem(elemStore['left-body-scroll']);const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const rightScrollElem=getRefElem(elemStore['right-body-scroll']);const rowExpandEl=refRowExpandElem.value;const xHandleEl=refScrollXHandleElem.value;const wrapperEl=evnt.currentTarget;const{scrollTop}=wrapperEl;const xBodyEl=xHandleEl||bodyScrollElem;let scrollLeft=0;if(xBodyEl){scrollLeft=xBodyEl.scrollLeft;}const isRollX=scrollLeft!==lastScrollLeft;const isRollY=true;internalData.inVirtualScroll=true;setScrollTop(bodyScrollElem,scrollTop);setScrollTop(leftScrollElem,scrollTop);setScrollTop(rightScrollElem,scrollTop);setScrollTop(rowExpandEl,scrollTop);if(scrollYLoad){$xeTable.triggerScrollYEvent(evnt);}$xeTable.handleScrollEvent(evnt,isRollY,isRollX,scrollTop,scrollLeft,{type:'table',fixed:''});},/**
             * 对于树形结构中，可以直接滚动到指定深层节点中
             * 对于某些特定的场景可能会用到，比如定位到某一节点
             * @param {Row} row 行对象
             */scrollToTreeRow(row){const{treeConfig}=props;const{isRowGroupStatus}=reactData;const{tableFullData}=internalData;const rests=[];if(treeConfig||isRowGroupStatus){const rowGroupOpts=computeRowGroupOpts.value;const treeOpts=computeTreeOpts.value;const childrenField=treeOpts.children||treeOpts.childrenField;const matchObj=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullData,item=>$xeTable.eqRow(item,row),{children:isRowGroupStatus?rowGroupOpts.mapChildrenField:childrenField});if(matchObj){const nodes=matchObj.nodes;nodes.forEach((row,index)=>{if(index<nodes.length-1&&!$xeTable.isTreeExpandByRow(row)){rests.push($xeTable.setTreeExpand(row,true));}});}}return Promise.all(rests).then(()=>rowToVisible($xeTable,row));},updateScrollYStatus,// 更新横向 X 可视渲染上下剩余空间大小
updateScrollXSpace(){const{scrollXLoad,overflowX,scrollXWidth}=reactData;const{visibleColumn,scrollXStore,elemStore,fullColumnIdData}=internalData;const mouseOpts=computeMouseOpts.value;const tableBody=refTableBody.value;const tableBodyElem=tableBody?tableBody.$el:null;if(tableBodyElem){const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const bodyTableElem=getRefElem(elemStore['main-body-table']);const headerTableElem=getRefElem(elemStore['main-header-table']);const footerTableElem=getRefElem(elemStore['main-footer-table']);let xSpaceLeft=0;const firstColumn=visibleColumn[scrollXStore.startIndex];if(firstColumn){const colRest=fullColumnIdData[firstColumn.id]||{};xSpaceLeft=colRest.oLeft;}let clientWidth=0;if(bodyScrollElem){clientWidth=bodyScrollElem.clientWidth;}// 虚拟渲染
let isScrollXBig=false;let ySpaceWidth=scrollXWidth;if(scrollXWidth>maxXWidth){// 触右
if(bodyScrollElem&&bodyTableElem&&bodyScrollElem.scrollLeft+clientWidth>=maxXWidth){xSpaceLeft=maxXWidth-bodyTableElem.clientWidth;}else{xSpaceLeft=(maxXWidth-clientWidth)*(xSpaceLeft/(scrollXWidth-clientWidth));}ySpaceWidth=maxXWidth;isScrollXBig=true;}if(!(scrollXLoad&&overflowX)){xSpaceLeft=0;}if(headerTableElem){headerTableElem.style.transform=headerTableElem.getAttribute('xvm')?`translate(${xSpaceLeft}px, 0px)`:'';}if(bodyTableElem){bodyTableElem.style.transform=`translate(${xSpaceLeft}px, ${reactData.scrollYTop||0}px)`;}if(footerTableElem){footerTableElem.style.transform=footerTableElem.getAttribute('xvm')?`translate(${xSpaceLeft}px, 0px)`:'';}const containerList=['main'];containerList.forEach(name=>{const layoutList=['header','body','footer'];layoutList.forEach(layout=>{const xSpaceElem=getRefElem(elemStore[`${name}-${layout}-xSpace`]);if(xSpaceElem){xSpaceElem.style.width=scrollXLoad?`${ySpaceWidth}px`:'';}});});reactData.scrollXLeft=xSpaceLeft;reactData.scrollXWidth=ySpaceWidth;reactData.isScrollXBig=isScrollXBig;const scrollXSpaceEl=refScrollXSpaceElem.value;if(scrollXSpaceEl){scrollXSpaceEl.style.width=`${ySpaceWidth}px`;}if(isScrollXBig&&mouseOpts.area){errLog('vxe.error.notProp',['mouse-config.area']);}calcScrollbar();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{updateStyle();});}},// 更新纵向 Y 可视渲染上下剩余空间大小
updateScrollYSpace(){const{isAllOverflow,overflowY,scrollYLoad,expandColumn}=reactData;const{scrollYStore,elemStore,isResizeCellHeight,afterFullData,fullAllDataRowIdData,rowExpandedMaps}=internalData;const{startIndex}=scrollYStore;const mouseOpts=computeMouseOpts.value;const expandOpts=computeExpandOpts.value;const rowOpts=computeRowOpts.value;const cellOpts=computeCellOpts.value;const defaultRowHeight=computeDefaultRowHeight.value;const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const bodyTableElem=getRefElem(elemStore['main-body-table']);const leftBodyTableElem=getRefElem(elemStore['left-body-table']);const rightbodyTableElem=getRefElem(elemStore['right-body-table']);const containerList=['main','left','right'];let ySpaceTop=0;let scrollYHeight=0;let isScrollYBig=false;if(scrollYLoad){const isCustomCellHeight=isResizeCellHeight||cellOpts.height||rowOpts.height;if(!isCustomCellHeight&&!expandColumn&&isAllOverflow){scrollYHeight=afterFullData.length*defaultRowHeight;if(scrollYHeight>maxYHeight){isScrollYBig=true;}ySpaceTop=Math.max(0,startIndex*defaultRowHeight);}else{const firstRow=afterFullData[startIndex];let rowid=getRowid($xeTable,firstRow);let rowRest=fullAllDataRowIdData[rowid]||{};ySpaceTop=rowRest.oTop||0;const lastRow=afterFullData[afterFullData.length-1];rowid=getRowid($xeTable,lastRow);rowRest=fullAllDataRowIdData[rowid]||{};scrollYHeight=(rowRest.oTop||0)+(rowRest.resizeHeight||cellOpts.height||rowOpts.height||rowRest.height||defaultRowHeight);// 是否展开行
if(expandColumn&&rowExpandedMaps[rowid]){scrollYHeight+=rowRest.expandHeight||expandOpts.height||0;}if(scrollYHeight>maxYHeight){isScrollYBig=true;}}}else{if(bodyTableElem){scrollYHeight=bodyTableElem.clientHeight;}}let clientHeight=0;if(bodyScrollElem){clientHeight=bodyScrollElem.clientHeight;}// 虚拟渲染
let ySpaceHeight=scrollYHeight;let scrollYTop=ySpaceTop;if(isScrollYBig){// 触底
if(bodyScrollElem&&bodyTableElem&&bodyScrollElem.scrollTop+clientHeight>=maxYHeight){scrollYTop=maxYHeight-bodyTableElem.clientHeight;}else{scrollYTop=(maxYHeight-clientHeight)*(ySpaceTop/(scrollYHeight-clientHeight));}ySpaceHeight=maxYHeight;}if(!(scrollYLoad&&overflowY)){scrollYTop=0;}if(leftBodyTableElem){leftBodyTableElem.style.transform=`translate(0px, ${scrollYTop}px)`;}if(bodyTableElem){bodyTableElem.style.transform=`translate(${reactData.scrollXLeft||0}px, ${scrollYTop}px)`;}if(rightbodyTableElem){rightbodyTableElem.style.transform=`translate(0px, ${scrollYTop}px)`;}containerList.forEach(name=>{const layoutList=['header','body','footer'];layoutList.forEach(layout=>{const ySpaceElem=getRefElem(elemStore[`${name}-${layout}-ySpace`]);if(ySpaceElem){ySpaceElem.style.height=ySpaceHeight?`${ySpaceHeight}px`:'';}});});const scrollYSpaceEl=refScrollYSpaceElem.value;if(scrollYSpaceEl){scrollYSpaceEl.style.height=ySpaceHeight?`${ySpaceHeight}px`:'';}const rowExpandYSpaceEl=refRowExpandYSpaceElem.value;if(rowExpandYSpaceEl){rowExpandYSpaceEl.style.height=ySpaceHeight?`${ySpaceHeight}px`:'';}reactData.scrollYTop=scrollYTop;reactData.scrollYHeight=scrollYHeight;reactData.isScrollYBig=isScrollYBig;if(isScrollYBig&&mouseOpts.area){errLog('vxe.error.notProp',['mouse-config.area']);}calcScrollbar();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{updateStyle();});},updateScrollXData(){const{isAllOverflow}=reactData;handleTableColumn();$xeTable.updateScrollXSpace();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{handleTableColumn();$xeTable.updateScrollXSpace();if(!isAllOverflow){$xeTable.updateScrollYSpace();}});},updateScrollYData(){$xeTable.handleTableData();$xeTable.updateScrollYSpace();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{$xeTable.handleTableData();$xeTable.updateScrollYSpace();});},/**
             * 处理固定列的显示状态
             */checkScrolling(){const{elemStore}=internalData;const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const leftContainerElem=refLeftContainer.value;const rightContainerElem=refRightContainer.value;const xHandleEl=refScrollXHandleElem.value;const bodtTargetEl=xHandleEl||bodyScrollElem;if(bodtTargetEl){if(leftContainerElem){if(bodtTargetEl.scrollLeft>0){addClass(leftContainerElem,'scrolling--middle');}else{removeClass(leftContainerElem,'scrolling--middle');}}if(rightContainerElem){if(bodtTargetEl.clientWidth<bodtTargetEl.scrollWidth-Math.ceil(bodtTargetEl.scrollLeft)){addClass(rightContainerElem,'scrolling--middle');}else{removeClass(rightContainerElem,'scrolling--middle');}}}},updateZindex(){if(props.zIndex){internalData.tZindex=props.zIndex;}else if(internalData.tZindex<getLastZIndex()){internalData.tZindex=nextZIndex();}},handleCheckedCheckboxRow,/**
             * 行 hover 事件
             */triggerHoverEvent(evnt,{row}){tablePrivateMethods.setHoverRow(row);},setHoverRow(row){const rowid=getRowid($xeTable,row);const el=refElem.value;tablePrivateMethods.clearHoverRow();if(el){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll(`.vxe-body--row[rowid="${rowid}"]`),elem=>addClass(elem,'row--hover'));}internalData.hoverRow=row;},clearHoverRow(){const el=refElem.value;if(el){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll('.vxe-body--row.row--hover'),elem=>removeClass(elem,'row--hover'));}internalData.hoverRow=null;},/**
             * 已废弃，被 getCellElement 替换
             * @deprecated
             */getCell(row,column){return tableMethods.getCellElement(row,column);},findRowIndexOf(list,row){return row?external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(list,item=>$xeTable.eqRow(item,row)):-1;},eqRow(row1,row2){if(row1&&row2){if(row1===row2){return true;}return getRowid($xeTable,row1)===getRowid($xeTable,row2);}return false;}};// 检测对应模块是否安装
'openExport,openPrint,exportData,openImport,importData,saveFile,readFile,importByFile,print'.split(',').forEach(name=>{$xeTable[name]=function(){errLog('vxe.error.reqModule',['VxeTableExportModule']);};});'clearValidate,fullValidate,validate'.split(',').forEach(name=>{$xeTable[name]=function(){errLog('vxe.error.reqModule',['VxeTableValidatorModule']);};});Object.assign($xeTable,tableMethods,tablePrivateMethods);/**
         * 渲染浮固定列
         * 分别渲染左边固定列和右边固定列
         * 如果宽度足够情况下，则不需要渲染固定列
         * @param {String} fixedType 固定列类型
         */const renderFixed=fixedType=>{const{showHeader,showFooter}=props;const{tableData,tableColumn,tableGroupColumn,columnStore,footerTableData}=reactData;const isFixedLeft=fixedType==='left';const fixedColumn=isFixedLeft?columnStore.leftList:columnStore.rightList;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:isFixedLeft?refLeftContainer:refRightContainer,class:`vxe-table--fixed-${fixedType}-wrapper`},[showHeader?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(header,{ref:isFixedLeft?refTableLeftHeader:refTableRightHeader,fixedType,tableData,tableColumn,tableGroupColumn,fixedColumn}):table_renderEmptyElement($xeTable),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(body,{ref:isFixedLeft?refTableLeftBody:refTableRightBody,fixedType,tableData,tableColumn,fixedColumn}),showFooter?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(footer,{ref:isFixedLeft?refTableLeftFooter:refTableRightFooter,footerTableData,tableColumn,fixedColumn,fixedType}):table_renderEmptyElement($xeTable)]);};const renderEmptyBody=()=>{const emptyOpts=computeEmptyOpts.value;const params={$table:$xeTable};if(slots.empty){return slots.empty(params);}else{const compConf=emptyOpts.name?table_renderer.get(emptyOpts.name):null;const rtEmptyView=compConf?compConf.renderTableEmpty||compConf.renderTableEmptyView||compConf.renderEmpty:null;if(rtEmptyView){return getSlotVNs(rtEmptyView(emptyOpts,params));}}return getFuncText(props.emptyText)||table_getI18n('vxe.table.emptyText');};const renderDragTipContents=()=>{const{dragConfig}=props;const{dragRow,dragCol,dragTipText}=reactData;const columnDragOpts=computeColumnDragOpts.value;const rowDragOpts=computeRowDragOpts.value;const rowDragSlots=rowDragOpts.slots||{};const rTipSlot=rowDragSlots.tip||(dragConfig&&dragConfig.slots?dragConfig.slots.rowTip:null);const columnDragSlots=columnDragOpts.slots||{};const cTipSlot=columnDragSlots.tip;if(dragRow&&rTipSlot){return callSlot(rTipSlot,{row:dragRow});}if(dragCol&&cTipSlot){return callSlot(cTipSlot,{column:dragCol});}return[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span',dragTipText)];};const renderDragTip=()=>{const{dragRow,dragCol}=reactData;const rowOpts=computeRowOpts.value;const columnOpts=computeColumnOpts.value;const rowDragOpts=computeRowDragOpts.value;const columnDragOpts=computeColumnDragOpts.value;if(rowOpts.drag||columnOpts.drag){return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--drag-wrapper'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refDragRowLineElem,class:['vxe-table--drag-row-line',{'is--guides':rowDragOpts.showGuidesStatus}]}),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refDragColLineElem,class:['vxe-table--drag-col-line',{'is--guides':columnDragOpts.showGuidesStatus}]}),dragRow&&rowDragOpts.showDragTip||dragCol&&columnDragOpts.showDragTip?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refDragTipElem,class:'vxe-table--drag-sort-tip'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--drag-sort-tip-wrapper'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--drag-sort-tip-status'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span',{class:['vxe-table--drag-sort-tip-normal-status',dragRow?table_getIcon().TABLE_DRAG_STATUS_ROW:table_getIcon().TABLE_DRAG_STATUS_COLUMN]}),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span',{class:['vxe-table--drag-sort-tip-sub-status',table_getIcon().TABLE_DRAG_STATUS_SUB_ROW]}),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span',{class:['vxe-table--drag-sort-tip-disabled-status',table_getIcon().TABLE_DRAG_DISABLED]})]),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--drag-sort-tip-content'},renderDragTipContents())])]):table_renderEmptyElement($xeTable)]);}return table_renderEmptyElement($xeTable);};const renderRowExpandedVNs=()=>{const{treeConfig}=props;const{expandColumn,isRowGroupStatus}=reactData;const tableRowExpandedList=computeTableRowExpandedList.value;const expandOpts=computeExpandOpts.value;const{mode}=expandOpts;if(mode!=='fixed'){return table_renderEmptyElement($xeTable);}const expandVNs=[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{key:'repY',ref:refRowExpandYSpaceElem})];if(expandColumn){const{handleGetRowId}=createHandleGetRowId($xeTable);tableRowExpandedList.forEach(row=>{const expandOpts=computeExpandOpts.value;const{height:expandHeight,padding,indent}=expandOpts;const{fullAllDataRowIdData,fullColumnIdData}=internalData;const treeOpts=computeTreeOpts.value;const{transform,seqMode}=treeOpts;const cellStyle={};const rowid=handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid];const colid=expandColumn.id;const colRest=fullColumnIdData[colid]||{};let rowLevel=0;let seq=-1;let _rowIndex=-1;let rowIndex=-1;let $rowIndex=-1;if(rowRest){rowLevel=rowRest.level;if(isRowGroupStatus||treeConfig&&transform&&seqMode==='increasing'){seq=rowRest._index+1;}else{seq=rowRest.seq;}rowIndex=rowRest.index;$rowIndex=rowRest.$index;_rowIndex=rowRest._index;}if(expandHeight){cellStyle.height=`${expandHeight}px`;}if(isRowGroupStatus||treeConfig){cellStyle.paddingLeft=`${rowLevel*(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(indent)?indent:treeOpts.indent)+30}px`;}let columnIndex=-1;let $columnIndex=-1;let _columnIndex=-1;if(colRest){columnIndex=colRest.index;$columnIndex=colRest.$index;_columnIndex=colRest._index;}const expandParams={$grid:$xeGrid,$table:$xeTable,seq,column:expandColumn,columnIndex,$columnIndex,_columnIndex,fixed:'',type:'body',level:rowLevel,rowid,row,rowIndex,$rowIndex,_rowIndex,isHidden:false,isEdit:false,visibleData:[],data:[],items:[]};expandVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{key:rowid,class:['vxe-body--row-expanded-cell',{'is--padding':padding,'is--ellipsis':expandHeight}],rowid,style:cellStyle},expandColumn.renderData(expandParams)));});}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refRowExpandElem,class:'vxe-table--row-expanded-wrapper'},expandVNs);};const renderScrollX=()=>{return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{key:'vsx',ref:refScrollXVirtualElem,class:'vxe-table--scroll-x-virtual'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollXLeftCornerElem,class:'vxe-table--scroll-x-left-corner'}),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollXWrapperElem,class:'vxe-table--scroll-x-wrapper'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollXHandleElem,class:'vxe-table--scroll-x-handle',onScroll:$xeTable.triggerVirtualScrollXEvent},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollXSpaceElem,class:'vxe-table--scroll-x-space'})])]),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollXRightCornerElem,class:'vxe-table--scroll-x-right-corner'})]);};const renderScrollY=()=>{return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollYVirtualElem,class:'vxe-table--scroll-y-virtual'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollYTopCornerElem,class:'vxe-table--scroll-y-top-corner'}),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollYWrapperElem,class:'vxe-table--scroll-y-wrapper'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollYHandleElem,class:'vxe-table--scroll-y-handle',onScroll:$xeTable.triggerVirtualScrollYEvent},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollYSpaceElem,class:'vxe-table--scroll-y-space'})])]),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollYBottomCornerElem,class:'vxe-table--scroll-y-bottom-corner'})]);};const renderViewport=()=>{const{showHeader,showFooter}=props;const{overflowX,tableData,tableColumn,tableGroupColumn,footerTableData,columnStore}=reactData;const{leftList,rightList}=columnStore;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refTableViewportElem,class:'vxe-table--viewport-wrapper'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--main-wrapper'},[/**
                     * 表头
                     */showHeader?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(header,{ref:refTableHeader,tableData,tableColumn,tableGroupColumn}):table_renderEmptyElement($xeTable),/**
                     * 表体
                     */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(body,{ref:refTableBody,tableData,tableColumn}),/**
                     * 表尾
                     */showFooter?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(footer,{ref:refTableFooter,footerTableData,tableColumn}):table_renderEmptyElement($xeTable)]),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--fixed-wrapper'},[leftList&&leftList.length&&overflowX?renderFixed('left'):table_renderEmptyElement($xeTable),rightList&&rightList.length&&overflowX?renderFixed('right'):table_renderEmptyElement($xeTable)]),renderRowExpandedVNs()]);};const renderBody=()=>{const scrollbarYToLeft=computeScrollbarYToLeft.value;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--layout-wrapper'},scrollbarYToLeft?[renderScrollY(),renderViewport()]:[renderViewport(),renderScrollY()]);};const renderVN=()=>{const{loading,stripe,showHeader,height,treeConfig,mouseConfig,showFooter,highlightCell,highlightHoverRow,highlightHoverColumn,editConfig,editRules}=props;const{isGroup,overflowX,overflowY,scrollXLoad,scrollYLoad,tableData,initStore,isRowGroupStatus,columnStore,filterStore,customStore}=reactData;const{leftList,rightList}=columnStore;const loadingSlot=slots.loading;const tableTipConfig=computeTableTipConfig.value;const validTipConfig=computeValidTipConfig.value;const validOpts=computeValidOpts.value;const checkboxOpts=computeCheckboxOpts.value;const treeOpts=computeTreeOpts.value;const rowOpts=computeRowOpts.value;const columnOpts=computeColumnOpts.value;const vSize=computeSize.value;const tableBorder=computeTableBorder.value;const mouseOpts=computeMouseOpts.value;const areaOpts=computeAreaOpts.value;const loadingOpts=computeLoadingOpts.value;const isMenu=computeIsMenu.value;const currLoading=reactData.isColLoading||reactData.isRowLoading||loading;const resizableOpts=computeResizableOpts.value;const isArea=mouseConfig&&mouseOpts.area;const columnDragOpts=computeColumnDragOpts.value;const scrollbarXToTop=computeScrollbarXToTop.value;const scrollbarYToLeft=computeScrollbarYToLeft.value;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refElem,class:['vxe-table','vxe-table--render-default',`tid_${xID}`,`border--${tableBorder}`,`sx-pos--${scrollbarXToTop?'top':'bottom'}`,`sy-pos--${scrollbarYToLeft?'left':'right'}`,{[`size--${vSize}`]:vSize,[`valid-msg--${validOpts.msgMode}`]:!!editRules,'vxe-editable':!!editConfig,'old-cell-valid':editRules&&table_getConfig().cellVaildMode==='obsolete','cell--highlight':highlightCell,'cell--selected':mouseConfig&&mouseOpts.selected,'cell--area':isArea,'header-cell--area':isArea&&areaOpts.selectCellByHeader,'body-cell--area':isArea&&areaOpts.selectCellByBody,'row--highlight':rowOpts.isHover||highlightHoverRow,'column--highlight':columnOpts.isHover||highlightHoverColumn,'checkbox--range':checkboxOpts.range,'col--drag-cell':columnOpts.drag&&columnDragOpts.trigger==='cell','is--header':showHeader,'is--footer':showFooter,'is--group':isGroup,'is-row-group':isRowGroupStatus,'is--tree-line':treeConfig&&(treeOpts.showLine||treeOpts.line),'is--fixed-left':leftList.length,'is--fixed-right':rightList.length,'is--animat':!!props.animat,'is--round':props.round,'is--stripe':!treeConfig&&stripe,'is--loading':currLoading,'is--empty':!currLoading&&!tableData.length,'is--scroll-y':overflowY,'is--scroll-x':overflowX,'is--virtual-x':scrollXLoad,'is--virtual-y':scrollYLoad}],spellcheck:false,onKeydown:keydownEvent},[/**
                 * 隐藏列
                 */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table-slots'},slots.default?slots.default({}):[]),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refVarElem,class:'vxe-table-vars'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table-var-default'}),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table-var-medium'}),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table-var-small'}),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table-var-mini'})]),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{key:'tw',class:'vxe-table--render-wrapper'},scrollbarXToTop?[renderScrollX(),renderBody()]:[renderBody(),renderScrollX()]),/**
                 * 空数据
                 */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{key:'tn',ref:refEmptyPlaceholder,class:'vxe-table--empty-placeholder'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--empty-content'},renderEmptyBody())]),/**
                 * 边框线
                 */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{key:'tl',class:'vxe-table--border-line'}),/**
                 * 列宽线
                 */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{key:'tcl',ref:refColResizeBar,class:'vxe-table--resizable-col-bar'},resizableOpts.showDragTip?[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--resizable-number-tip'})]:[]),/**
                 * 行高线
                 */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{key:'trl',ref:refRowResizeBar,class:'vxe-table--resizable-row-bar'},resizableOpts.showDragTip?[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--resizable-number-tip'})]:[]),/**
                 * 加载中
                 */VxeUILoadingComponent?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUILoadingComponent,{key:'lg',class:'vxe-table--loading',modelValue:currLoading,icon:loadingOpts.icon,text:loadingOpts.text},loadingSlot?{default:()=>callSlot(loadingSlot,{$table:$xeTable,$grid:$xeGrid,loading:currLoading})}:{}):loadingSlot?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:['vxe-loading--custom-wrapper',{'is--visible':currLoading}]},callSlot(loadingSlot,{$table:$xeTable,$grid:$xeGrid,loading:currLoading})):table_renderEmptyElement($xeTable),/**
                 * 自定义列
                 */initStore.custom?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(panel,{key:'cs',ref:refTableCustom,customStore}):table_renderEmptyElement($xeTable),/**
                 * 筛选
                 */initStore.filter?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(filter_panel,{key:'tf',ref:refTableFilter,filterStore}):table_renderEmptyElement($xeTable),/**
                 * 导入
                 */initStore.import&&props.importConfig?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(import_panel,{key:'it',defaultOptions:reactData.importParams,storeData:reactData.importStore}):table_renderEmptyElement($xeTable),/**
                 * 导出
                 */initStore.export&&(props.exportConfig||props.printConfig)?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(export_panel,{key:'et',defaultOptions:reactData.exportParams,storeData:reactData.exportStore}):table_renderEmptyElement($xeTable),/**
                 * 快捷菜单
                 */isMenu?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(menu_panel,{key:'tm',ref:refTableMenu}):table_renderEmptyElement($xeTable),/**
                 * 拖拽排序提示
                 */renderDragTip(),/**
                 * 提示相关
                 */VxeUITooltipComponent?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{},[/**
                         * 通用提示
                         */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUITooltipComponent,{key:'ctp',ref:refCommTooltip,isArrow:false,enterable:false}),/**
                          * 工具提示
                          */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUITooltipComponent,{key:'btp',ref:refTooltip,theme:tableTipConfig.theme,enterable:tableTipConfig.enterable,enterDelay:tableTipConfig.enterDelay,leaveDelay:tableTipConfig.leaveDelay,useHTML:tableTipConfig.useHTML}),/**
                          * 校验提示
                          */props.editRules&&validOpts.showMessage&&(validOpts.message==='default'?!height:validOpts.message==='tooltip')?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUITooltipComponent,{key:'vtp',ref:refValidTooltip,class:[{'old-cell-valid':editRules&&table_getConfig().cellVaildMode==='obsolete'},'vxe-table--valid-error'],theme:validTipConfig.theme,enterable:validTipConfig.enterable,enterDelay:validTipConfig.enterDelay,leaveDelay:validTipConfig.leaveDelay}):table_renderEmptyElement($xeTable)]):table_renderEmptyElement($xeTable)]);};const dataFlag=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.data?props.data.length:-1,()=>{dataFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.data,()=>{dataFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(dataFlag,()=>{const{initStatus}=internalData;const value=props.data||[];if(value&&value.length>=50000){warnLog('vxe.error.errLargeData',['loadData(data), reloadData(data)']);}loadTableData(value,false).then(()=>{const{scrollXLoad,scrollYLoad,expandColumn}=reactData;const expandOpts=computeExpandOpts.value;internalData.inited=true;internalData.initStatus=true;if(!initStatus){handleLoadDefaults();}// const checkboxOpts = computeCheckboxOpts.value
// const checkboxColumn = internalData.tableFullColumn.find(column => column.type === 'checkbox')
// if (checkboxColumn && internalData.tableFullData.length > 300 && !checkboxOpts.checkField) {
//   warnLog('vxe.error.checkProp', ['checkbox-config.checkField'])
// }
if((scrollXLoad||scrollYLoad)&&expandColumn&&expandOpts.mode!=='fixed'){warnLog('vxe.error.scrollErrProp',['column.type=expand']);}return tableMethods.recalculate();});});const staticColumnFlag=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>reactData.staticColumns.length,()=>{staticColumnFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>reactData.staticColumns,()=>{staticColumnFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(staticColumnFlag,()=>{handleColumn(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(reactData.staticColumns));});const tableColumnFlag=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>reactData.tableColumn.length,()=>{tableColumnFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>reactData.tableColumn,()=>{tableColumnFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(tableColumnFlag,()=>{tablePrivateMethods.analyColumnWidth();});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>reactData.upDataFlag,()=>{(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{tableMethods.updateData();});});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>reactData.reColumnFlag,()=>{(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{tableMethods.refreshColumn();});});const reScrollFlag=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeSize,()=>{reScrollFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.showHeader,()=>{reScrollFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.showFooter,()=>{reScrollFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>reactData.overflowX,()=>{reScrollFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>reactData.overflowY,()=>{reScrollFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(reScrollFlag,()=>{(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{tableMethods.recalculate(true).then(()=>tableMethods.refreshScroll());});});const reLayoutFlag=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.height,()=>{reLayoutFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.maxHeight,()=>{reLayoutFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeScrollbarXToTop,()=>{reLayoutFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeScrollbarYToLeft,()=>{reLayoutFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>core_.VxeUI.getLanguage(),()=>{reLayoutFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(reLayoutFlag,()=>{(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>tableMethods.recalculate(true));});const footFlag=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.footerData?props.footerData.length:-1,()=>{footFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.footerData,()=>{footFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(footFlag,()=>{tableMethods.updateFooter();});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.syncResize,value=>{if(value){handleUpdateResize();(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{handleUpdateResize();setTimeout(()=>handleUpdateResize());});}});const mergeCellFlag=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.mergeCells?props.mergeCells.length:-1,()=>{mergeCellFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.mergeCells,()=>{mergeCellFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(mergeCellFlag,()=>{tableMethods.clearMergeCells();(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{if(props.mergeCells){tableMethods.setMergeCells(props.mergeCells);}});});const mergeFooterItemFlag=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.mergeFooterItems?props.mergeFooterItems.length:-1,()=>{mergeFooterItemFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.mergeFooterItems,()=>{mergeFooterItemFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(mergeFooterItemFlag,()=>{tableMethods.clearMergeFooterItems();(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{if(props.mergeFooterItems){tableMethods.setMergeFooterItems(props.mergeFooterItems);}});});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeRowGroupFields,val=>{handleUpdateRowGroup(val);});if($xeTabs){(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>$xeTabs?$xeTabs.reactData.resizeFlag:null,()=>{handleGlobalResizeEvent();});}table_hooks.forEach(options=>{const{setupTable}=options;if(setupTable){const hookRest=setupTable($xeTable);if(hookRest&&external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(hookRest)){Object.assign($xeTable,hookRest);}}});tablePrivateMethods.preventEvent(null,'created',{$table:$xeTable});let resizeObserver;(0,external_commonjs_vue_commonjs2_vue_root_Vue_.onActivated)(()=>{tableMethods.recalculate().then(()=>tableMethods.refreshScroll());tablePrivateMethods.preventEvent(null,'activated',{$table:$xeTable});});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.onDeactivated)(()=>{internalData.isActivated=false;tablePrivateMethods.preventEvent(null,'deactivated',{$table:$xeTable});});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(()=>{const columnOpts=computeColumnOpts.value;const rowOpts=computeRowOpts.value;const customOpts=computeCustomOpts.value;const rowGroupOpts=computeRowGroupOpts.value;const{groupFields}=rowGroupOpts;if(columnOpts.drag||rowOpts.drag||customOpts.allowSort){initTpImg();}handleUpdateRowGroup(groupFields);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{const{data,exportConfig,importConfig,treeConfig,showOverflow,highlightCurrentRow,highlightCurrentColumn}=props;const{scrollXStore,scrollYStore}=internalData;const editOpts=computeEditOpts.value;const treeOpts=computeTreeOpts.value;const radioOpts=computeRadioOpts.value;const checkboxOpts=computeCheckboxOpts.value;const expandOpts=computeExpandOpts.value;const rowOpts=computeRowOpts.value;const customOpts=computeCustomOpts.value;const mouseOpts=computeMouseOpts.value;const exportOpts=computeExportOpts.value;const importOpts=computeImportOpts.value;const currentRowOpts=computeCurrentRowOpts.value;const currentColumnOpts=computeCurrentColumnOpts.value;const keyboardOpts=computeKeyboardOpts.value;if(props.rowId){warnLog('vxe.error.delProp',['row-id','row-config.keyField']);}if(props.rowKey){warnLog('vxe.error.delProp',['row-key','row-config.useKey']);}if(props.columnKey){warnLog('vxe.error.delProp',['column-id','column-config.useKey']);}if(!(props.rowId||rowOpts.keyField)&&(checkboxOpts.reserve||checkboxOpts.checkRowKeys||radioOpts.reserve||radioOpts.checkRowKey||expandOpts.expandRowKeys||treeOpts.expandRowKeys)){warnLog('vxe.error.reqProp',['row-config.keyField']);}if(props.editConfig&&(editOpts.showStatus||editOpts.showUpdateStatus||editOpts.showInsertStatus)&&!props.keepSource){warnLog('vxe.error.reqProp',['keep-source']);}if(treeConfig&&(treeOpts.showLine||treeOpts.line)&&(!(props.rowKey||rowOpts.useKey)||!showOverflow)){warnLog('vxe.error.reqProp',['row-config.useKey | show-overflow']);}if(treeConfig&&!treeOpts.transform&&props.stripe){warnLog('vxe.error.noTree',['stripe']);}if(props.showFooter&&!(props.footerMethod||props.footerData)){warnLog('vxe.error.reqProp',['footer-data | footer-method']);}if(rowOpts.height){warnLog('vxe.error.delProp',['row-config.height','cell-config.height']);}if(props.highlightCurrentRow){warnLog('vxe.error.delProp',['highlight-current-row','row-config.isCurrent']);}if(props.highlightHoverRow){warnLog('vxe.error.delProp',['highlight-hover-row','row-config.isHover']);}if(props.highlightCurrentColumn){warnLog('vxe.error.delProp',['highlight-current-column','column-config.isCurrent']);}if(props.highlightHoverColumn){warnLog('vxe.error.delProp',['highlight-hover-column','column-config.isHover']);}if(props.resizable){warnLog('vxe.error.delProp',['resizable','column-config.resizable']);}// if (props.scrollY) {
//   warnLog('vxe.error.delProp', ['scroll-y', 'virtual-y-config'])
// }
// if (props.scrollX) {
//   warnLog('vxe.error.delProp', ['scroll-x', 'virtual-x-config'])
// }
// 检查导入导出类型，如果自定义导入导出方法，则不校验类型
if(importConfig&&importOpts.types&&!importOpts.importMethod&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includeArrays(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(importOpts._typeMaps),importOpts.types)){warnLog('vxe.error.errProp',[`export-config.types=${importOpts.types.join(',')}`,importOpts.types.filter(type=>external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(importOpts._typeMaps),type)).join(',')||external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(importOpts._typeMaps).join(',')]);}if(exportConfig&&exportOpts.types&&!exportOpts.exportMethod&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includeArrays(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(exportOpts._typeMaps),exportOpts.types)){warnLog('vxe.error.errProp',[`export-config.types=${exportOpts.types.join(',')}`,exportOpts.types.filter(type=>external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(exportOpts._typeMaps),type)).join(',')||external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(exportOpts._typeMaps).join(',')]);}if(!props.id){if((props.customConfig?isEnableConf(customOpts):customOpts.enabled)&&customOpts.storage){errLog('vxe.error.reqProp',['id']);}}if(props.treeConfig&&checkboxOpts.range){errLog('vxe.error.noTree',['checkbox-config.range']);}if(rowOpts.height&&!props.showOverflow){warnLog('vxe.error.notProp',['table.show-overflow']);}if(!$xeTable.triggerCellAreaMousedownEvent){if(props.areaConfig){warnLog('vxe.error.notProp',['area-config']);}if(props.clipConfig){warnLog('vxe.error.notProp',['clip-config']);}if(props.fnrConfig){warnLog('vxe.error.notProp',['fnr-config']);}if(mouseOpts.area){errLog('vxe.error.notProp',['mouse-config.area']);return;}}if(treeConfig&&rowOpts.drag&&!treeOpts.transform){errLog('vxe.error.notSupportProp',['column-config.drag','tree-config.transform=false','tree-config.transform=true']);}if(props.dragConfig){warnLog('vxe.error.delProp',['drag-config','row-drag-config']);}if(props.treeConfig&&treeOpts.children){warnLog('vxe.error.delProp',['tree-config.children','tree-config.childrenField']);}if(props.treeConfig&&treeOpts.line){warnLog('vxe.error.delProp',['tree-config.line','tree-config.showLine']);}if(mouseOpts.area&&mouseOpts.selected){warnLog('vxe.error.errConflicts',['mouse-config.area','mouse-config.selected']);}if(mouseOpts.area&&props.treeConfig&&!treeOpts.transform){errLog('vxe.error.noTree',['mouse-config.area']);}if(props.editConfig&&editOpts.activeMethod){warnLog('vxe.error.delProp',['edit-config.activeMethod','edit-config.beforeEditMethod']);}if(props.treeConfig&&checkboxOpts.isShiftKey){errLog('vxe.error.errConflicts',['tree-config','checkbox-config.isShiftKey']);}if(checkboxOpts.halfField){warnLog('vxe.error.delProp',['checkbox-config.halfField','checkbox-config.indeterminateField']);}if(rowOpts.currentMethod){warnLog('vxe.error.delProp',['row-config.currentMethod','current-row-config.beforeSelectMethod']);}if(columnOpts.currentMethod){warnLog('vxe.error.delProp',['row-config.currentMethod','current-column-config.beforeSelectMethod']);}if((rowOpts.isCurrent||highlightCurrentRow)&&props.keyboardConfig&&keyboardOpts.isArrow&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(currentRowOpts.isFollowSelected)){warnLog('vxe.error.notConflictProp',['row-config.isCurrent','current-row-config.isFollowSelected']);}if((columnOpts.isCurrent||highlightCurrentColumn)&&props.keyboardConfig&&keyboardOpts.isArrow&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(currentColumnOpts.isFollowSelected)){warnLog('vxe.error.notConflictProp',['column-config.isCurrent','current-column-config.isFollowSelected']);}// 如果不支持虚拟滚动
// if (props.spanMethod) {
//   if (virtualXOpts.enabled) {
//     warnLog('vxe.error.notConflictProp', ['span-method', 'virtual-x-config.enabled=false'])
//   }
//   if (virtualYOpts.enabled) {
//     warnLog('vxe.error.notConflictProp', ['span-method', 'virtual-y-config.enabled=false'])
//   }
// }
// if (props.footerSpanMethod) {
//   if (virtualXOpts.enabled) {
//     warnLog('vxe.error.notConflictProp', ['footer-span-method', 'virtual-x-config.enabled=false'])
//   }
// }
// 检查是否有安装需要的模块
if(props.editConfig&&!$xeTable.insert){errLog('vxe.error.reqModule',['Edit']);}if(props.editRules&&!$xeTable.validate){errLog('vxe.error.reqModule',['Validator']);}if((checkboxOpts.range||props.keyboardConfig||props.mouseConfig)&&!$xeTable.handleCellMousedownEvent){errLog('vxe.error.reqModule',['Keyboard']);}if((props.printConfig||props.importConfig||props.exportConfig)&&!$xeTable.exportData){errLog('vxe.error.reqModule',['Export']);}Object.assign(scrollYStore,{startIndex:0,endIndex:0,visibleSize:0});Object.assign(scrollXStore,{startIndex:0,endIndex:0,visibleSize:0});loadTableData(data||[],true).then(()=>{if(data&&data.length){internalData.inited=true;internalData.initStatus=true;handleLoadDefaults();}handleInitDefaults();updateStyle();});if(props.autoResize){const el=refElem.value;const parentEl=tablePrivateMethods.getParentElem();resizeObserver=table_globalResize.create(()=>{if(props.autoResize){tableMethods.recalculate(true);}});if(el){resizeObserver.observe(el);}if(parentEl){resizeObserver.observe(parentEl);}}});const tableViewportEl=refTableViewportElem.value;if(tableViewportEl){tableViewportEl.addEventListener('wheel',$xeTable.triggerBodyWheelEvent,{passive:false});}table_globalEvents.on($xeTable,'paste',handleGlobalPasteEvent);table_globalEvents.on($xeTable,'copy',handleGlobalCopyEvent);table_globalEvents.on($xeTable,'cut',handleGlobalCutEvent);table_globalEvents.on($xeTable,'mousedown',handleGlobalMousedownEvent);table_globalEvents.on($xeTable,'blur',handleGlobalBlurEvent);table_globalEvents.on($xeTable,'mousewheel',handleGlobalMousewheelEvent);table_globalEvents.on($xeTable,'keydown',handleGlobalKeydownEvent);table_globalEvents.on($xeTable,'resize',handleGlobalResizeEvent);table_globalEvents.on($xeTable,'contextmenu',$xeTable.handleGlobalContextmenuEvent);tablePrivateMethods.preventEvent(null,'mounted',{$table:$xeTable});});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(()=>{const tableViewportEl=refTableViewportElem.value;if(tableViewportEl){tableViewportEl.removeEventListener('wheel',$xeTable.triggerBodyWheelEvent);}internalData.cvCacheMaps={};internalData.prevDragRow=null;internalData.prevDragCol=null;if(resizeObserver){resizeObserver.disconnect();}tableMethods.closeFilter();if($xeTable.closeMenu){$xeTable.closeMenu();}tablePrivateMethods.preventEvent(null,'beforeUnmount',{$table:$xeTable});});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(()=>{table_globalEvents.off($xeTable,'paste');table_globalEvents.off($xeTable,'copy');table_globalEvents.off($xeTable,'cut');table_globalEvents.off($xeTable,'mousedown');table_globalEvents.off($xeTable,'blur');table_globalEvents.off($xeTable,'mousewheel');table_globalEvents.off($xeTable,'keydown');table_globalEvents.off($xeTable,'resize');table_globalEvents.off($xeTable,'contextmenu');tablePrivateMethods.preventEvent(null,'unmounted',{$table:$xeTable});});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{if(props.loading){if(!VxeUILoadingComponent&&!slots.loading){errLog('vxe.error.reqComp',['vxe-loading']);}}if(props.showOverflow===true||props.showOverflow==='tooltip'||props.showHeaderOverflow===true||props.showHeaderOverflow==='tooltip'||props.showFooterOverflow===true||props.showFooterOverflow==='tooltip'||props.tooltipConfig||props.editRules){if(!VxeUITooltipComponent){errLog('vxe.error.reqComp',['vxe-tooltip']);}}});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeColgroup',null);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeTable',$xeTable);$xeTable.renderVN=renderVN;return $xeTable;},render(){return this.renderVN();}}));
;// ./packages/toolbar/src/toolbar.ts









const {
  getConfig: toolbar_getConfig,
  getIcon: toolbar_getIcon,
  getI18n: toolbar_getI18n,
  renderer: toolbar_renderer,
  commands: toolbar_commands,
  createEvent: toolbar_createEvent,
  useFns: toolbar_useFns
} = core_.VxeUI;
/* harmony default export */ var toolbar = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeToolbar',
  props: {
    loading: Boolean,
    refresh: [Boolean, Object],
    import: [Boolean, Object],
    export: [Boolean, Object],
    print: [Boolean, Object],
    zoom: [Boolean, Object],
    custom: [Boolean, Object],
    buttons: {
      type: Array,
      default: () => toolbar_getConfig().toolbar.buttons
    },
    tools: {
      type: Array,
      default: () => toolbar_getConfig().toolbar.tools
    },
    perfect: {
      type: Boolean,
      default: () => toolbar_getConfig().toolbar.perfect
    },
    size: {
      type: String,
      default: () => toolbar_getConfig().toolbar.size || toolbar_getConfig().size
    },
    className: [String, Function]
  },
  emits: ['button-click', 'tool-click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    // 使用已安装的组件，如果未安装则不渲染
    const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
    const {
      computeSize
    } = toolbar_useFns.useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      isRefresh: false,
      connectFlag: 0,
      columns: []
    });
    const internalData = {
      connectTable: null
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeToolbar = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let toolbarMethods = {};
    const $xeGrid = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeGrid', null);
    const computeRefreshOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(toolbar_getConfig().toolbar.refresh, true), props.refresh);
    });
    const computeImportOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(toolbar_getConfig().toolbar.import, true), props.import);
    });
    const computeExportOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(toolbar_getConfig().toolbar.export, true), props.export);
    });
    const computePrintOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(toolbar_getConfig().toolbar.print, true), props.print);
    });
    const computeZoomOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(toolbar_getConfig().toolbar.zoom, true), props.zoom);
    });
    const computeCustomOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(toolbar_getConfig().toolbar.custom, true), props.custom);
    });
    const computeTableCustomOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      if (reactData.connectFlag || $table) {
        if ($table) {
          const {
            computeCustomOpts
          } = $table.getComputeMaps();
          return computeCustomOpts.value;
        }
      }
      return {
        trigger: ''
      };
    });
    const computeTrigger = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const tableCustomOpts = computeTableCustomOpts.value;
      return tableCustomOpts.trigger;
    });
    const checkTable = () => {
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      if ($table) {
        return true;
      }
      errLog('vxe.error.barUnableLink');
    };
    const handleClickSettingEvent = ({
      $event
    }) => {
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      if ($table) {
        if ($table.triggerCustomEvent) {
          $table.triggerCustomEvent($event);
        } else {
          errLog('vxe.error.reqModule', ['VxeTableCustomModule']);
        }
      }
    };
    const handleMouseenterSettingEvent = ({
      $event
    }) => {
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      if ($table) {
        $table.customOpenEvent($event);
      } else {
        errLog('vxe.error.reqModule', ['VxeTableCustomModule']);
      }
    };
    const handleMouseleaveSettingEvent = ({
      $event
    }) => {
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      if ($table) {
        const {
          customStore
        } = $table.reactData;
        customStore.activeBtn = false;
        setTimeout(() => {
          if (!customStore.activeBtn && !customStore.activeWrapper) {
            $table.customCloseEvent($event);
          }
        }, 350);
      }
    };
    const refreshEvent = ({
      $event
    }) => {
      const {
        isRefresh
      } = reactData;
      const refreshOpts = computeRefreshOpts.value;
      if (!isRefresh) {
        const queryMethod = refreshOpts.queryMethod || refreshOpts.query;
        if (queryMethod) {
          reactData.isRefresh = true;
          try {
            Promise.resolve(queryMethod({})).catch(e => e).then(() => {
              reactData.isRefresh = false;
            });
          } catch (e) {
            reactData.isRefresh = false;
          }
        } else if ($xeGrid) {
          reactData.isRefresh = true;
          $xeGrid.triggerToolbarCommitEvent({
            code: refreshOpts.code || 'reload'
          }, $event).catch(e => e).then(() => {
            reactData.isRefresh = false;
          });
        }
      }
    };
    const zoomEvent = ({
      $event
    }) => {
      if ($xeGrid) {
        $xeGrid.triggerZoomEvent($event);
      }
    };
    const btnEvent = (evnt, item) => {
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      const {
        code
      } = item;
      if (code) {
        if ($xeGrid) {
          $xeGrid.triggerToolbarBtnEvent(item, evnt);
        } else {
          const gCommandOpts = toolbar_commands.get(code);
          const params = {
            code,
            button: item,
            $table: $table,
            $grid: $xeGrid,
            $event: evnt
          };
          if (gCommandOpts) {
            const tCommandMethod = gCommandOpts.tableCommandMethod || gCommandOpts.commandMethod;
            if (tCommandMethod) {
              tCommandMethod(params);
            } else {
              errLog('vxe.error.notCommands', [code]);
            }
          }
          $xeToolbar.dispatchEvent('button-click', params, evnt);
        }
      }
    };
    const tolEvent = (evnt, item) => {
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      const {
        code
      } = item;
      if (code) {
        if ($xeGrid) {
          $xeGrid.triggerToolbarTolEvent(item, evnt);
        } else {
          const gCommandOpts = toolbar_commands.get(code);
          const params = {
            code,
            tool: item,
            $table: $table,
            $grid: $xeGrid,
            $event: evnt
          };
          if (gCommandOpts) {
            const tCommandMethod = gCommandOpts.tableCommandMethod || gCommandOpts.commandMethod;
            if (tCommandMethod) {
              tCommandMethod(params);
            } else {
              errLog('vxe.error.notCommands', [code]);
            }
          }
          $xeToolbar.dispatchEvent('tool-click', params, evnt);
        }
      }
    };
    const importEvent = () => {
      if (checkTable()) {
        const {
          connectTable
        } = internalData;
        const $table = connectTable;
        if ($table) {
          $table.openImport();
        }
      }
    };
    const exportEvent = () => {
      if (checkTable()) {
        const {
          connectTable
        } = internalData;
        const $table = connectTable;
        if ($table) {
          $table.openExport();
        }
      }
    };
    const printEvent = () => {
      if (checkTable()) {
        const {
          connectTable
        } = internalData;
        const $table = connectTable;
        if ($table) {
          $table.openPrint();
        }
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, toolbar_createEvent(evnt, {
        $toolbar: $xeToolbar
      }, params));
    };
    toolbarMethods = {
      dispatchEvent,
      syncUpdate(params) {
        internalData.connectTable = params.$table;
        reactData.columns = params.collectColumn;
        reactData.connectFlag++;
      }
    };
    Object.assign($xeToolbar, toolbarMethods);
    const renderDropdowns = (item, isBtn) => {
      const {
        dropdowns
      } = item;
      const downVNs = [];
      if (dropdowns) {
        return dropdowns.map((child, index) => {
          if (child.visible === false) {
            return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
          }
          return VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            key: index,
            disabled: child.disabled,
            loading: child.loading,
            type: child.type,
            mode: child.mode,
            icon: child.icon,
            circle: child.circle,
            round: child.round,
            status: child.status,
            content: child.name,
            title: child.title,
            routerLink: child.routerLink,
            permissionCode: child.permissionCode,
            prefixTooltip: child.prefixTooltip,
            suffixTooltip: child.suffixTooltip,
            onClick: ({
              $event
            }) => isBtn ? btnEvent($event, child) : tolEvent($event, child)
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
        });
      }
      return downVNs;
    };
    /**
     * 渲染按钮
     */
    const renderLeftBtns = () => {
      const {
        buttons
      } = props;
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      const buttonPrefixSlot = slots.buttonPrefix || slots['button-prefix'];
      const buttonSuffixSlot = slots.buttonSuffix || slots['button-suffix'];
      const btnVNs = [];
      if (buttonPrefixSlot) {
        btnVNs.push(...getSlotVNs(buttonPrefixSlot({
          buttons: buttons || [],
          $grid: $xeGrid,
          $table: $table
        })));
      }
      if (buttons) {
        buttons.forEach((item, index) => {
          const {
            dropdowns,
            buttonRender
          } = item;
          if (item.visible !== false) {
            const compConf = buttonRender ? toolbar_renderer.get(buttonRender.name) : null;
            if (buttonRender && compConf && compConf.renderToolbarButton) {
              const toolbarButtonClassName = compConf.toolbarButtonClassName;
              const params = {
                $grid: $xeGrid,
                $table: $table,
                button: item
              };
              btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
                key: `br${item.code || index}`,
                class: ['vxe-button--item', toolbarButtonClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(toolbarButtonClassName) ? toolbarButtonClassName(params) : toolbarButtonClassName : '']
              }, getSlotVNs(compConf.renderToolbarButton(buttonRender, params))));
            } else {
              if (VxeUIButtonComponent) {
                btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
                  key: `bd${item.code || index}`,
                  disabled: item.disabled,
                  loading: item.loading,
                  type: item.type,
                  mode: item.mode,
                  icon: item.icon,
                  circle: item.circle,
                  round: item.round,
                  status: item.status,
                  content: item.name,
                  title: item.title,
                  routerLink: item.routerLink,
                  permissionCode: item.permissionCode,
                  prefixTooltip: item.prefixTooltip,
                  suffixTooltip: item.suffixTooltip,
                  destroyOnClose: item.destroyOnClose,
                  placement: item.placement,
                  transfer: item.transfer,
                  onClick: ({
                    $event
                  }) => btnEvent($event, item)
                }, dropdowns && dropdowns.length ? {
                  dropdowns: () => renderDropdowns(item, true)
                } : {}));
              }
            }
          }
        });
      }
      if (buttonSuffixSlot) {
        btnVNs.push(...getSlotVNs(buttonSuffixSlot({
          buttons: buttons || [],
          $grid: $xeGrid,
          $table: $table
        })));
      }
      return btnVNs;
    };
    /**
     * 渲染右侧工具
     */
    const renderRightTools = () => {
      const {
        tools
      } = props;
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      const toolPrefixSlot = slots.toolPrefix || slots['tool-prefix'];
      const toolSuffixSlot = slots.toolSuffix || slots['tool-suffix'];
      const btnVNs = [];
      if (toolPrefixSlot) {
        btnVNs.push(...getSlotVNs(toolPrefixSlot({
          tools: tools || [],
          $grid: $xeGrid,
          $table: $table
        })));
      }
      if (tools) {
        tools.forEach((item, tIndex) => {
          const {
            dropdowns,
            toolRender
          } = item;
          if (item.visible !== false) {
            const rdName = toolRender ? toolRender.name : null;
            const compConf = toolRender ? toolbar_renderer.get(rdName) : null;
            if (toolRender && compConf && compConf.renderToolbarTool) {
              const toolbarToolClassName = compConf.toolbarToolClassName;
              const params = {
                $grid: $xeGrid,
                $table: $table,
                tool: item
              };
              btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
                key: rdName,
                class: ['vxe-tool--item', toolbarToolClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(toolbarToolClassName) ? toolbarToolClassName(params) : toolbarToolClassName : '']
              }, getSlotVNs(compConf.renderToolbarTool(toolRender, params))));
            } else {
              if (VxeUIButtonComponent) {
                btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
                  key: tIndex,
                  disabled: item.disabled,
                  loading: item.loading,
                  type: item.type,
                  mode: item.mode,
                  icon: item.icon,
                  circle: item.circle,
                  round: item.round,
                  status: item.status,
                  content: item.name,
                  title: item.title,
                  routerLink: item.routerLink,
                  permissionCode: item.permissionCode,
                  prefixTooltip: item.prefixTooltip,
                  suffixTooltip: item.suffixTooltip,
                  destroyOnClose: item.destroyOnClose,
                  placement: item.placement,
                  transfer: item.transfer,
                  onClick: ({
                    $event
                  }) => tolEvent($event, item)
                }, dropdowns && dropdowns.length ? {
                  dropdowns: () => renderDropdowns(item, false)
                } : {}));
              }
            }
          }
        });
      }
      if (toolSuffixSlot) {
        btnVNs.push(...getSlotVNs(toolSuffixSlot({
          tools: tools || [],
          $grid: $xeGrid,
          $table: $table
        })));
      }
      return btnVNs;
    };
    const renderToolImport = () => {
      const importOpts = computeImportOpts.value;
      return VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
        key: 'import',
        circle: true,
        icon: importOpts.icon || toolbar_getIcon().TOOLBAR_TOOLS_IMPORT,
        title: toolbar_getI18n('vxe.toolbar.import'),
        onClick: importEvent
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderToolExport = () => {
      const exportOpts = computeExportOpts.value;
      return VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
        key: 'export',
        circle: true,
        icon: exportOpts.icon || toolbar_getIcon().TOOLBAR_TOOLS_EXPORT,
        title: toolbar_getI18n('vxe.toolbar.export'),
        onClick: exportEvent
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderToolPrint = () => {
      const printOpts = computePrintOpts.value;
      return VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
        key: 'print',
        circle: true,
        icon: printOpts.icon || toolbar_getIcon().TOOLBAR_TOOLS_PRINT,
        title: toolbar_getI18n('vxe.toolbar.print'),
        onClick: printEvent
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderToolRefresh = () => {
      const refreshOpts = computeRefreshOpts.value;
      return VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
        key: 'refresh',
        circle: true,
        icon: reactData.isRefresh ? refreshOpts.iconLoading || toolbar_getIcon().TOOLBAR_TOOLS_REFRESH_LOADING : refreshOpts.icon || toolbar_getIcon().TOOLBAR_TOOLS_REFRESH,
        title: toolbar_getI18n('vxe.toolbar.refresh'),
        onClick: refreshEvent
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderToolZoom = () => {
      const zoomOpts = computeZoomOpts.value;
      return $xeGrid && VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
        key: 'zoom',
        circle: true,
        icon: $xeGrid.isMaximized() ? zoomOpts.iconOut || toolbar_getIcon().TOOLBAR_TOOLS_MINIMIZE : zoomOpts.iconIn || toolbar_getIcon().TOOLBAR_TOOLS_FULLSCREEN,
        title: toolbar_getI18n(`vxe.toolbar.zoom${$xeGrid.isMaximized() ? 'Out' : 'In'}`),
        onClick: zoomEvent
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderToolCustom = () => {
      const customOpts = computeCustomOpts.value;
      const btnTrigger = computeTrigger.value;
      const customBtnOns = {};
      if (btnTrigger === 'manual') {
        // 手动触发
      } else if (btnTrigger === 'hover') {
        // hover 触发
        customBtnOns.onMouseenter = handleMouseenterSettingEvent;
        customBtnOns.onMouseleave = handleMouseleaveSettingEvent;
      } else {
        // 点击触发
        customBtnOns.onClick = handleClickSettingEvent;
      }
      return VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
        key: 'custom',
        circle: true,
        icon: customOpts.icon || toolbar_getIcon().TOOLBAR_TOOLS_CUSTOM,
        title: toolbar_getI18n('vxe.toolbar.custom'),
        className: 'vxe-toolbar-custom-target',
        ...customBtnOns
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderVN = () => {
      const {
        perfect,
        loading,
        refresh,
        zoom,
        custom,
        className
      } = props;
      const {
        connectTable
      } = internalData;
      const vSize = computeSize.value;
      const toolsSlot = slots.tools;
      const buttonsSlot = slots.buttons;
      const $table = connectTable;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-toolbar', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $toolbar: $xeToolbar
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--perfect': perfect,
          'is--loading': loading
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-buttons--wrapper'
      }, buttonsSlot ? buttonsSlot({
        $grid: $xeGrid,
        $table: $table
      }) : renderLeftBtns()), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tools--wrapper'
      }, toolsSlot ? toolsSlot({
        $grid: $xeGrid,
        $table: $table
      }) : renderRightTools()), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tools--operate'
      }, [props.import ? renderToolImport() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), props.export ? renderToolExport() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), props.print ? renderToolPrint() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), refresh ? renderToolRefresh() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), zoom && $xeGrid ? renderToolZoom() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), custom ? renderToolCustom() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])]);
    };
    $xeToolbar.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      const {
        refresh
      } = props;
      const refreshOpts = computeRefreshOpts.value;
      const queryMethod = refreshOpts.queryMethod || refreshOpts.query;
      if (refresh && !$xeGrid && !queryMethod) {
        warnLog('vxe.error.notFunc', ['queryMethod']);
      }
      const customOpts = computeCustomOpts.value;
      if (customOpts.isFooter) {
        warnLog('vxe.error.delProp', ['toolbar.custom.isFooter', 'table.custom-config.showFooter']);
      }
      if (customOpts.showFooter) {
        warnLog('vxe.error.delProp', ['toolbar.custom.showFooter', 'table.custom-config.showFooter']);
      }
      if (customOpts.immediate) {
        warnLog('vxe.error.delProp', ['toolbar.custom.immediate', 'table.custom-config.immediate']);
      }
      if (customOpts.trigger) {
        warnLog('vxe.error.delProp', ['toolbar.custom.trigger', 'table.custom-config.trigger']);
      }
      if (props.refresh || props.import || props.export || props.print || props.zoom) {
        if (!VxeUIButtonComponent) {
          errLog('vxe.error.reqComp', ['vxe-button']);
        }
      }
    });
    return $xeToolbar;
  },
  render() {
    return this.renderVN();
  }
}));
;// ./packages/grid/src/grid.ts
















const {
  getConfig: grid_getConfig,
  getI18n: grid_getI18n,
  commands: grid_commands,
  hooks: grid_hooks,
  useFns: grid_useFns,
  createEvent: grid_createEvent,
  globalEvents: grid_globalEvents,
  GLOBAL_EVENT_KEYS: grid_GLOBAL_EVENT_KEYS,
  renderEmptyElement: grid_renderEmptyElement
} = core_.VxeUI;
const tableComponentPropKeys = Object.keys(src_props);
const tableComponentMethodKeys = ['clearAll', 'syncData', 'updateData', 'loadData', 'reloadData', 'reloadRow', 'loadColumn', 'reloadColumn', 'getRowNode', 'getColumnNode', 'getRowIndex', 'getVTRowIndex', 'getVMRowIndex', 'getColumnIndex', 'getVTColumnIndex', 'getVMColumnIndex', 'setRow', 'createData', 'createRow', 'revertData', 'clearData', 'isRemoveByRow', 'isInsertByRow', 'isUpdateByRow', 'getColumns', 'getColumnById', 'getColumnByField', 'getTableColumn', 'getFullColumns', 'getData', 'getCheckboxRecords', 'getParentRow', 'getTreeParentRow', 'getRowSeq', 'getRowById', 'getRowid', 'getTableData', 'getFullData', 'setColumnFixed', 'clearColumnFixed', 'setColumnWidth', 'getColumnWidth', 'setRowHeightConf', 'getRowHeightConf', 'setRowHeight', 'getRowHeight', 'hideColumn', 'showColumn', 'resetColumn', 'refreshColumn', 'refreshScroll', 'recalculate', 'closeTooltip', 'isAllCheckboxChecked', 'isAllCheckboxIndeterminate', 'getCheckboxIndeterminateRecords', 'setCheckboxRow', 'setCheckboxRowKey', 'isCheckedByCheckboxRow', 'isCheckedByCheckboxRowKey', 'isIndeterminateByCheckboxRow', 'isIndeterminateByCheckboxRowKey', 'toggleCheckboxRow', 'setAllCheckboxRow', 'getRadioReserveRecord', 'clearRadioReserve', 'getCheckboxReserveRecords', 'clearCheckboxReserve', 'toggleAllCheckboxRow', 'clearCheckboxRow', 'setCurrentRow', 'isCheckedByRadioRow', 'isCheckedByRadioRowKey', 'setRadioRow', 'setRadioRowKey', 'clearCurrentRow', 'clearRadioRow', 'getCurrentRecord', 'getRadioRecord', 'getCurrentColumn', 'setCurrentColumn', 'clearCurrentColumn', 'setPendingRow', 'togglePendingRow', 'hasPendingByRow', 'isPendingByRow', 'getPendingRecords', 'clearPendingRow', 'sort', 'setSort', 'clearSort', 'isSort', 'getSortColumns', 'closeFilter', 'isFilter', 'isActiveFilterByColumn', 'isRowExpandLoaded', 'clearRowExpandLoaded', 'reloadRowExpand', 'reloadRowExpand', 'toggleRowExpand', 'setAllRowExpand', 'setRowExpand', 'isExpandByRow', 'isRowExpandByRow', 'clearRowExpand', 'clearRowExpandReserve', 'getRowExpandRecords', 'getTreeExpandRecords', 'isTreeExpandLoaded', 'clearTreeExpandLoaded', 'reloadTreeExpand', 'reloadTreeChilds', 'toggleTreeExpand', 'setAllTreeExpand', 'setTreeExpand', 'isTreeExpandByRow', 'clearTreeExpand', 'clearTreeExpandReserve', 'getScroll', 'scrollTo', 'scrollToRow', 'scrollToColumn', 'clearScroll', 'updateFooter', 'updateStatus', 'setMergeCells', 'removeInsertRow', 'removeMergeCells', 'getMergeCells', 'clearMergeCells', 'setMergeFooterItems', 'removeMergeFooterItems', 'getMergeFooterItems', 'clearMergeFooterItems', 'getCustomStoreData', 'setRowGroupExpand', 'setAllRowGroupExpand', 'clearRowGroupExpand', 'isRowGroupExpandByRow', 'isRowGroupRecord', 'setRowGroups', 'clearRowGroups', 'openTooltip', 'moveColumnTo', 'moveRowTo', 'getCellLabel', 'getCellElement', 'focus', 'blur', 'connect'];
const gridComponentEmits = [...emits, 'page-change', 'form-submit', 'form-submit-invalid', 'form-reset', 'form-collapse', 'form-toggle-collapse', 'proxy-query', 'proxy-delete', 'proxy-save', 'toolbar-button-click', 'toolbar-tool-click', 'zoom'];
/* harmony default export */ var grid = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeGrid',
  props: {
    ...src_props,
    layouts: Array,
    columns: Array,
    pagerConfig: Object,
    proxyConfig: Object,
    toolbarConfig: Object,
    formConfig: Object,
    zoomConfig: Object,
    size: {
      type: String,
      default: () => grid_getConfig().grid.size || grid_getConfig().size
    }
  },
  emits: gridComponentEmits,
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    // 使用已安装的组件，如果未安装则不渲染
    const VxeUIFormComponent = core_.VxeUI.getComponent('VxeForm');
    const VxeUIPagerComponent = core_.VxeUI.getComponent('VxePager');
    const defaultLayouts = [['Form'], ['Toolbar', 'Top', 'Table', 'Bottom', 'Pager']];
    const {
      computeSize
    } = grid_useFns.useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      tableLoading: false,
      proxyInited: false,
      isZMax: false,
      tableData: [],
      filterData: [],
      formData: {},
      sortData: [],
      tZindex: 0,
      tablePage: {
        total: 0,
        pageSize: grid_getConfig().pager?.pageSize || 10,
        currentPage: 1
      }
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refToolbar = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPager = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refFormWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refToolbarWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTopWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBottomWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPagerWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const extendTableMethods = methodKeys => {
      const funcs = {};
      methodKeys.forEach(name => {
        funcs[name] = (...args) => {
          const $xeTable = refTable.value;
          if ($xeTable && $xeTable[name]) {
            return $xeTable[name](...args);
          }
        };
      });
      return funcs;
    };
    const gridExtendTableMethods = extendTableMethods(tableComponentMethodKeys);
    tableComponentMethodKeys.forEach(name => {
      gridExtendTableMethods[name] = (...args) => {
        const $xeTable = refTable.value;
        if ($xeTable && $xeTable[name]) {
          return $xeTable && $xeTable[name](...args);
        }
      };
    });
    const computeProxyOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(grid_getConfig().grid.proxyConfig, true), props.proxyConfig);
    });
    const computeIsRespMsg = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const proxyOpts = computeProxyOpts.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(proxyOpts.message) ? proxyOpts.message : proxyOpts.showResponseMsg;
    });
    const computeIsActiveMsg = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const proxyOpts = computeProxyOpts.value;
      return proxyOpts.showActiveMsg;
    });
    const computePagerOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, grid_getConfig().grid.pagerConfig, props.pagerConfig);
    });
    const computeFormOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, grid_getConfig().grid.formConfig, props.formConfig);
    });
    const computeToolbarOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, grid_getConfig().grid.toolbarConfig, props.toolbarConfig);
    });
    const computeZoomOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, grid_getConfig().grid.zoomConfig, props.zoomConfig);
    });
    const computeStyles = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        height,
        maxHeight
      } = props;
      const {
        isZMax,
        tZindex
      } = reactData;
      const stys = {};
      if (isZMax) {
        stys.zIndex = tZindex;
      } else {
        if (height) {
          stys.height = height === 'auto' || height === '100%' ? '100%' : toCssUnit(height);
        }
        if (maxHeight) {
          stys.maxHeight = maxHeight === 'auto' || maxHeight === '100%' ? '100%' : toCssUnit(maxHeight);
        }
      }
      return stys;
    });
    const computeTableExtendProps = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const rest = {};
      const gridProps = props;
      tableComponentPropKeys.forEach(key => {
        rest[key] = gridProps[key];
      });
      return rest;
    });
    const computeTableProps = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        seqConfig,
        pagerConfig,
        loading,
        editConfig,
        proxyConfig
      } = props;
      const {
        isZMax,
        tableLoading,
        tablePage
      } = reactData;
      const tableExtendProps = computeTableExtendProps.value;
      const proxyOpts = computeProxyOpts.value;
      const pagerOpts = computePagerOpts.value;
      const tProps = Object.assign({}, tableExtendProps);
      if (isZMax) {
        if (tableExtendProps.maxHeight) {
          tProps.maxHeight = '100%';
        } else {
          tProps.height = '100%';
        }
      }
      if (proxyConfig && isEnableConf(proxyOpts)) {
        tProps.loading = loading || tableLoading;
        if (pagerConfig && proxyOpts.seq && isEnableConf(pagerOpts)) {
          tProps.seqConfig = Object.assign({}, seqConfig, {
            startIndex: (tablePage.currentPage - 1) * tablePage.pageSize
          });
        }
      }
      if (editConfig) {
        tProps.editConfig = Object.assign({}, editConfig);
      }
      return tProps;
    });
    const computeCurrLayoutConf = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        layouts
      } = props;
      let confs = [];
      if (layouts && layouts.length) {
        confs = layouts;
      } else {
        confs = grid_getConfig().grid.layouts || defaultLayouts;
      }
      let headKeys = [];
      let bodyKeys = [];
      let footKeys = [];
      if (confs.length) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(confs[0])) {
          headKeys = confs[0];
          bodyKeys = confs[1] || [];
          footKeys = confs[2] || [];
        } else {
          bodyKeys = confs;
        }
      }
      return {
        headKeys,
        bodyKeys,
        footKeys
      };
    });
    const computePageConfFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const pagerOpts = computePagerOpts.value;
      return `${pagerOpts.currentPage}${pagerOpts.pageSize}`;
    });
    const refMaps = {
      refElem,
      refTable,
      refForm,
      refToolbar,
      refPager
    };
    const computeMaps = {
      computeProxyOpts,
      computePagerOpts,
      computeFormOpts,
      computeToolbarOpts,
      computeZoomOpts
    };
    const $xeGrid = {
      xID,
      props: props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const initToolbar = () => {
      const toolbarOpts = computeToolbarOpts.value;
      if (props.toolbarConfig && isEnableConf(toolbarOpts)) {
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const $xeTable = refTable.value;
          const $xeToolbar = refToolbar.value;
          if ($xeTable && $xeToolbar) {
            $xeTable.connect($xeToolbar);
          }
        });
      }
    };
    const getFormData = () => {
      const {
        proxyConfig
      } = props;
      const {
        formData
      } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      return proxyConfig && isEnableConf(proxyOpts) && proxyOpts.form ? formData : formOpts.data;
    };
    const initPages = () => {
      const {
        tablePage
      } = reactData;
      const {
        pagerConfig
      } = props;
      const pagerOpts = computePagerOpts.value;
      const {
        currentPage,
        pageSize
      } = pagerOpts;
      if (pagerConfig && isEnableConf(pagerOpts)) {
        if (currentPage) {
          tablePage.currentPage = currentPage;
        }
        if (pageSize) {
          tablePage.pageSize = pageSize;
        }
      }
    };
    const triggerPendingEvent = code => {
      const isActiveMsg = computeIsActiveMsg.value;
      const $xeTable = refTable.value;
      const selectRecords = $xeTable.getCheckboxRecords();
      if (selectRecords.length) {
        $xeTable.togglePendingRow(selectRecords);
        gridExtendTableMethods.clearCheckboxRow();
      } else {
        if (isActiveMsg) {
          if (core_.VxeUI.modal) {
            core_.VxeUI.modal.message({
              id: code,
              content: grid_getI18n('vxe.grid.selectOneRecord'),
              status: 'warning'
            });
          }
        }
      }
    };
    const getRespMsg = (rest, defaultMsg) => {
      const proxyOpts = computeProxyOpts.value;
      const resConfigs = proxyOpts.response || proxyOpts.props || {};
      const messageProp = resConfigs.message;
      let msg;
      if (rest && messageProp) {
        msg = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(messageProp) ? messageProp({
          data: rest,
          $grid: $xeGrid
        }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, messageProp);
      }
      return msg || grid_getI18n(defaultMsg);
    };
    const handleDeleteRow = (code, alertKey, callback) => {
      const isActiveMsg = computeIsActiveMsg.value;
      const selectRecords = gridExtendTableMethods.getCheckboxRecords();
      if (isActiveMsg) {
        if (selectRecords.length) {
          if (core_.VxeUI.modal) {
            return core_.VxeUI.modal.confirm({
              id: `cfm_${code}`,
              content: grid_getI18n(alertKey),
              escClosable: true
            }).then(type => {
              if (type === 'confirm') {
                return callback();
              }
            });
          }
        } else {
          if (core_.VxeUI.modal) {
            core_.VxeUI.modal.message({
              id: `msg_${code}`,
              content: grid_getI18n('vxe.grid.selectOneRecord'),
              status: 'warning'
            });
          }
        }
      } else {
        if (selectRecords.length) {
          callback();
        }
      }
      return Promise.resolve();
    };
    const pageChangeEvent = params => {
      const {
        proxyConfig
      } = props;
      const {
        tablePage
      } = reactData;
      const {
        $event,
        currentPage,
        pageSize
      } = params;
      const proxyOpts = computeProxyOpts.value;
      tablePage.currentPage = currentPage;
      tablePage.pageSize = pageSize;
      $xeGrid.dispatchEvent('page-change', params, $event);
      if (proxyConfig && isEnableConf(proxyOpts)) {
        $xeGrid.commitProxy('query').then(rest => {
          $xeGrid.dispatchEvent('proxy-query', rest, $event);
        });
      }
    };
    const sortChangeEvent = params => {
      const $xeTable = refTable.value;
      const {
        proxyConfig
      } = props;
      const {
        computeSortOpts
      } = $xeTable.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      const sortOpts = computeSortOpts.value;
      // 如果是服务端排序
      if (sortOpts.remote) {
        reactData.sortData = params.sortList;
        if (proxyConfig && isEnableConf(proxyOpts)) {
          reactData.tablePage.currentPage = 1;
          gridMethods.commitProxy('query').then(rest => {
            gridMethods.dispatchEvent('proxy-query', rest, params.$event);
          });
        }
      }
      gridMethods.dispatchEvent('sort-change', params, params.$event);
    };
    const filterChangeEvent = params => {
      const $xeTable = refTable.value;
      const {
        proxyConfig
      } = props;
      const {
        computeFilterOpts
      } = $xeTable.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      const filterOpts = computeFilterOpts.value;
      // 如果是服务端过滤
      if (filterOpts.remote) {
        reactData.filterData = params.filterList;
        if (proxyConfig && isEnableConf(proxyOpts)) {
          reactData.tablePage.currentPage = 1;
          gridMethods.commitProxy('query').then(rest => {
            gridMethods.dispatchEvent('proxy-query', rest, params.$event);
          });
        }
      }
      gridMethods.dispatchEvent('filter-change', params, params.$event);
    };
    const submitFormEvent = params => {
      const {
        proxyConfig
      } = props;
      const proxyOpts = computeProxyOpts.value;
      if (reactData.tableLoading) {
        return;
      }
      if (proxyConfig && isEnableConf(proxyOpts)) {
        gridMethods.commitProxy('reload').then(rest => {
          gridMethods.dispatchEvent('proxy-query', {
            ...rest,
            isReload: true
          }, params.$event);
        });
      }
      gridMethods.dispatchEvent('form-submit', params, params.$event);
    };
    const resetFormEvent = params => {
      const {
        proxyConfig
      } = props;
      const {
        $event
      } = params;
      const proxyOpts = computeProxyOpts.value;
      const $xeTable = refTable.value;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        $xeTable.clearScroll();
        gridMethods.commitProxy('reload').then(rest => {
          gridMethods.dispatchEvent('proxy-query', {
            ...rest,
            isReload: true
          }, $event);
        });
      }
      gridMethods.dispatchEvent('form-reset', params, $event);
    };
    const submitInvalidEvent = params => {
      gridMethods.dispatchEvent('form-submit-invalid', params, params.$event);
    };
    const collapseEvent = params => {
      const {
        $event
      } = params;
      gridMethods.dispatchEvent('form-toggle-collapse', params, $event);
      gridMethods.dispatchEvent('form-collapse', params, $event);
    };
    const handleZoom = isMax => {
      const {
        isZMax
      } = reactData;
      if (isMax ? !isZMax : isZMax) {
        reactData.isZMax = !isZMax;
        if (reactData.tZindex < getLastZIndex()) {
          reactData.tZindex = nextZIndex();
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => gridExtendTableMethods.recalculate(true)).then(() => {
        setTimeout(() => gridExtendTableMethods.recalculate(true), 15);
        return reactData.isZMax;
      });
    };
    const getFuncSlot = (optSlots, slotKey) => {
      const funcSlot = optSlots[slotKey];
      if (funcSlot) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(funcSlot)) {
          if (slots[funcSlot]) {
            return slots[funcSlot];
          } else {
            errLog('vxe.error.notSlot', [funcSlot]);
          }
        } else {
          return funcSlot;
        }
      }
      return null;
    };
    const getConfigSlot = slotConfigs => {
      const slotConf = {};
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectMap(slotConfigs, (slotFunc, slotKey) => {
        if (slotFunc) {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
            if (slots[slotFunc]) {
              slotConf[slotKey] = slots[slotFunc];
            } else {
              errLog('vxe.error.notSlot', [slotFunc]);
            }
          } else {
            slotConf[slotKey] = slotFunc;
          }
        }
      });
      return slotConf;
    };
    /**
     * 渲染表单
     */
    const renderForm = () => {
      const {
        formConfig,
        proxyConfig
      } = props;
      const {
        formData
      } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      if (formConfig && isEnableConf(formOpts) || slots.form) {
        let slotVNs = [];
        if (slots.form) {
          slotVNs = slots.form({
            $grid: $xeGrid
          });
        } else {
          if (formOpts.items) {
            const formSlots = {};
            if (!formOpts.inited) {
              formOpts.inited = true;
              const beforeItem = proxyOpts.beforeItem;
              if (proxyOpts && beforeItem) {
                formOpts.items.forEach(item => {
                  beforeItem({
                    $grid: $xeGrid,
                    item
                  });
                });
              }
            }
            // 处理插槽
            formOpts.items.forEach(item => {
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(item.slots, func => {
                if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(func)) {
                  if (slots[func]) {
                    formSlots[func] = slots[func];
                  }
                }
              });
            });
            if (VxeUIFormComponent) {
              slotVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIFormComponent, {
                ref: refForm,
                ...Object.assign({}, formOpts, {
                  data: proxyConfig && isEnableConf(proxyOpts) && proxyOpts.form ? formData : formOpts.data
                }),
                onSubmit: submitFormEvent,
                onReset: resetFormEvent,
                onSubmitInvalid: submitInvalidEvent,
                onCollapse: collapseEvent
              }, formSlots));
            }
          }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refFormWrapper,
          key: 'form',
          class: 'vxe-grid--form-wrapper'
        }, slotVNs);
      }
      return grid_renderEmptyElement($xeGrid);
    };
    /**
     * 渲染工具栏
     */
    const renderToolbar = () => {
      const {
        toolbarConfig
      } = props;
      const toolbarOpts = computeToolbarOpts.value;
      if (toolbarConfig && isEnableConf(toolbarOpts) || slots.toolbar) {
        let slotVNs = [];
        if (slots.toolbar) {
          slotVNs = slots.toolbar({
            $grid: $xeGrid
          });
        } else {
          const toolbarOptSlots = toolbarOpts.slots;
          let buttonsSlot;
          let toolsSlot;
          const toolbarSlots = {};
          if (toolbarOptSlots) {
            buttonsSlot = getFuncSlot(toolbarOptSlots, 'buttons');
            toolsSlot = getFuncSlot(toolbarOptSlots, 'tools');
            if (buttonsSlot) {
              toolbarSlots.buttons = buttonsSlot;
            }
            if (toolsSlot) {
              toolbarSlots.tools = toolsSlot;
            }
          }
          slotVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(toolbar, {
            ref: refToolbar,
            ...toolbarOpts,
            slots: undefined
          }, toolbarSlots));
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refToolbarWrapper,
          key: 'toolbar',
          class: 'vxe-grid--toolbar-wrapper'
        }, slotVNs);
      }
      return grid_renderEmptyElement($xeGrid);
    };
    /**
     * 渲染表格顶部区域
     */
    const renderTop = () => {
      if (slots.top) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refTopWrapper,
          key: 'top',
          class: 'vxe-grid--top-wrapper'
        }, slots.top({
          $grid: $xeGrid
        }));
      }
      return grid_renderEmptyElement($xeGrid);
    };
    const renderTableLeft = () => {
      const leftSlot = slots.left;
      if (leftSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-grid--left-wrapper'
        }, leftSlot({
          $grid: $xeGrid
        }));
      }
      return grid_renderEmptyElement($xeGrid);
    };
    const renderTableRight = () => {
      const rightSlot = slots.right;
      if (rightSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-grid--right-wrapper'
        }, rightSlot({
          $grid: $xeGrid
        }));
      }
      return grid_renderEmptyElement($xeGrid);
    };
    /**
     * 渲染表格
     */
    const renderTable = () => {
      const {
        proxyConfig
      } = props;
      const tableProps = computeTableProps.value;
      const proxyOpts = computeProxyOpts.value;
      const tableOns = Object.assign({}, tableCompEvents);
      const emptySlot = slots.empty;
      const loadingSlot = slots.loading;
      const rowDragIconSlot = slots.rowDragIcon || slots['row-drag-icon'];
      const columnDragIconSlot = slots.columnDragIcon || slots['column-drag-icon'];
      if (proxyConfig && isEnableConf(proxyOpts)) {
        if (proxyOpts.sort) {
          tableOns.onSortChange = sortChangeEvent;
        }
        if (proxyOpts.filter) {
          tableOns.onFilterChange = filterChangeEvent;
        }
      }
      const slotObj = {};
      if (emptySlot) {
        slotObj.empty = emptySlot;
      }
      if (loadingSlot) {
        slotObj.loading = loadingSlot;
      }
      if (rowDragIconSlot) {
        slotObj.rowDragIcon = rowDragIconSlot;
      }
      if (columnDragIconSlot) {
        slotObj.columnDragIcon = columnDragIconSlot;
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-grid--table-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(table, {
        ref: refTable,
        ...tableProps,
        ...tableOns
      }, slotObj)]);
    };
    /**
     * 渲染表格底部区域
     */
    const renderBottom = () => {
      if (slots.bottom) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refBottomWrapper,
          key: 'bottom',
          class: 'vxe-grid--bottom-wrapper'
        }, slots.bottom({
          $grid: $xeGrid
        }));
      }
      return grid_renderEmptyElement($xeGrid);
    };
    /**
     * 渲染分页
     */
    const renderPager = () => {
      const {
        proxyConfig,
        pagerConfig
      } = props;
      const proxyOpts = computeProxyOpts.value;
      const pagerOpts = computePagerOpts.value;
      const pagerSlot = slots.pager;
      if (pagerConfig && isEnableConf(pagerOpts) || slots.pager) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refPagerWrapper,
          key: 'pager',
          class: 'vxe-grid--pager-wrapper'
        }, pagerSlot ? pagerSlot({
          $grid: $xeGrid
        }) : [VxeUIPagerComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIPagerComponent, {
          ref: refPager,
          ...pagerOpts,
          ...(proxyConfig && isEnableConf(proxyOpts) ? reactData.tablePage : {}),
          onPageChange: pageChangeEvent
        }, getConfigSlot(pagerOpts.slots)) : grid_renderEmptyElement($xeGrid)]);
      }
      return grid_renderEmptyElement($xeGrid);
    };
    const renderChildLayout = layoutKeys => {
      const childVNs = [];
      layoutKeys.forEach(key => {
        switch (key) {
          case 'Form':
            childVNs.push(renderForm());
            break;
          case 'Toolbar':
            childVNs.push(renderToolbar());
            break;
          case 'Top':
            childVNs.push(renderTop());
            break;
          case 'Table':
            childVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
              key: 'table',
              class: 'vxe-grid--table-container'
            }, [renderTableLeft(), renderTable(), renderTableRight()]));
            break;
          case 'Bottom':
            childVNs.push(renderBottom());
            break;
          case 'Pager':
            childVNs.push(renderPager());
            break;
          default:
            errLog('vxe.error.notProp', [`layouts -> ${key}`]);
            break;
        }
      });
      return childVNs;
    };
    const renderLayout = () => {
      const currLayoutConf = computeCurrLayoutConf.value;
      const {
        headKeys,
        bodyKeys,
        footKeys
      } = currLayoutConf;
      const asideLeftSlot = slots.asideLeft || slots['aside-left'];
      const asideRightSlot = slots.asideRight || slots['aside-right'];
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-grid--layout-header-wrapper'
      }, renderChildLayout(headKeys)), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-grid--layout-body-wrapper'
      }, [asideLeftSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-grid--layout-aside-left-wrapper'
      }, asideLeftSlot({})) : grid_renderEmptyElement($xeGrid), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-grid--layout-body-content-wrapper'
      }, renderChildLayout(bodyKeys)), asideRightSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-grid--layout-aside-right-wrapper'
      }, asideRightSlot({})) : grid_renderEmptyElement($xeGrid)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-grid--layout-footer-wrapper'
      }, renderChildLayout(footKeys))];
    };
    const tableCompEvents = {};
    emits.forEach(name => {
      const type = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().camelCase(`on-${name}`);
      tableCompEvents[type] = (...args) => emit(name, ...args);
    });
    const initProxy = () => {
      const {
        proxyConfig,
        formConfig
      } = props;
      const {
        proxyInited
      } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        if (formConfig && isEnableConf(formOpts) && proxyOpts.form && formOpts.items) {
          const fData = {};
          formOpts.items.forEach(item => {
            const {
              field,
              itemRender
            } = item;
            if (field) {
              let itemValue = null;
              if (itemRender) {
                const {
                  defaultValue
                } = itemRender;
                if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(defaultValue)) {
                  itemValue = defaultValue({
                    item
                  });
                } else if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(defaultValue)) {
                  itemValue = defaultValue;
                }
              }
              fData[field] = itemValue;
            }
          });
          reactData.formData = fData;
        }
        if (!proxyInited) {
          reactData.proxyInited = true;
          if (proxyOpts.autoLoad !== false) {
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => gridMethods.commitProxy('_init')).then(rest => {
              gridMethods.dispatchEvent('proxy-query', {
                ...rest,
                isInited: true
              }, new Event('init'));
            });
          }
        }
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const zoomOpts = computeZoomOpts.value;
      const isEsc = grid_globalEvents.hasKey(evnt, grid_GLOBAL_EVENT_KEYS.ESCAPE);
      if (isEsc && reactData.isZMax && zoomOpts.escRestore !== false) {
        gridPrivateMethods.triggerZoomEvent(evnt);
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, grid_createEvent(evnt, {
        $grid: $xeGrid
      }, params));
    };
    const gridMethods = {
      dispatchEvent,
      getEl() {
        return refElem.value;
      },
      /**
       * 提交指令，支持 code 或 button
       * @param {String/Object} code 字符串或对象
       */
      commitProxy(proxyTarget, ...args) {
        const {
          toolbarConfig,
          pagerConfig,
          editRules,
          validConfig
        } = props;
        const {
          tablePage
        } = reactData;
        const isActiveMsg = computeIsActiveMsg.value;
        const isRespMsg = computeIsRespMsg.value;
        const proxyOpts = computeProxyOpts.value;
        const pagerOpts = computePagerOpts.value;
        const toolbarOpts = computeToolbarOpts.value;
        const {
          beforeQuery,
          afterQuery,
          beforeDelete,
          afterDelete,
          beforeSave,
          afterSave,
          ajax = {}
        } = proxyOpts;
        const resConfigs = proxyOpts.response || proxyOpts.props || {};
        const $xeTable = refTable.value;
        const formData = getFormData();
        let button = null;
        let code = null;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(proxyTarget)) {
          const {
            buttons
          } = toolbarOpts;
          const matchObj = toolbarConfig && isEnableConf(toolbarOpts) && buttons ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(buttons, item => item.code === proxyTarget, {
            children: 'dropdowns'
          }) : null;
          button = matchObj ? matchObj.item : null;
          code = proxyTarget;
        } else {
          button = proxyTarget;
          code = button.code;
        }
        const btnParams = button ? button.params : null;
        switch (code) {
          case 'insert':
            return $xeTable.insert({});
          case 'insert_edit':
            return $xeTable.insert({}).then(({
              row
            }) => $xeTable.setEditRow(row));
          // 已废弃
          case 'insert_actived':
            return $xeTable.insert({}).then(({
              row
            }) => $xeTable.setEditRow(row));
          // 已废弃
          case 'mark_cancel':
            triggerPendingEvent(code);
            break;
          case 'remove':
            return handleDeleteRow(code, 'vxe.grid.removeSelectRecord', () => $xeTable.removeCheckboxRow());
          case 'import':
            $xeTable.importData(btnParams);
            break;
          case 'open_import':
            $xeTable.openImport(btnParams);
            break;
          case 'export':
            $xeTable.exportData(btnParams);
            break;
          case 'open_export':
            $xeTable.openExport(btnParams);
            break;
          case 'reset_custom':
            return $xeTable.resetCustom(true);
          case '_init':
          case 'reload':
          case 'query':
            {
              const ajaxMethods = ajax.query;
              const querySuccessMethods = ajax.querySuccess;
              const queryErrorMethods = ajax.queryError;
              if (ajaxMethods) {
                const isInited = code === '_init';
                const isReload = code === 'reload';
                if (!isInited && reactData.tableLoading) {
                  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
                }
                let sortList = [];
                let filterList = [];
                let pageParams = {};
                if (pagerConfig) {
                  if (isInited || isReload) {
                    tablePage.currentPage = 1;
                  }
                  if (isEnableConf(pagerOpts)) {
                    pageParams = {
                      ...tablePage
                    };
                  }
                }
                if (isInited) {
                  let defaultSort = null;
                  if ($xeTable) {
                    const {
                      computeSortOpts
                    } = $xeTable.getComputeMaps();
                    const sortOpts = computeSortOpts.value;
                    defaultSort = sortOpts.defaultSort;
                  }
                  // 如果使用默认排序
                  if (defaultSort) {
                    if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(defaultSort)) {
                      defaultSort = [defaultSort];
                    }
                    sortList = defaultSort.map(item => {
                      return {
                        field: item.field,
                        property: item.field,
                        order: item.order
                      };
                    });
                  }
                  if ($xeTable) {
                    filterList = $xeTable.getCheckedFilters();
                  }
                } else {
                  if ($xeTable) {
                    if (isReload) {
                      $xeTable.clearAll();
                    } else {
                      sortList = $xeTable.getSortColumns();
                      filterList = $xeTable.getCheckedFilters();
                    }
                  }
                }
                const commitParams = {
                  code,
                  button,
                  isInited,
                  isReload,
                  $grid: $xeGrid,
                  page: pageParams,
                  sort: sortList.length ? sortList[0] : {},
                  sorts: sortList,
                  filters: filterList,
                  form: formData,
                  options: ajaxMethods
                };
                reactData.sortData = sortList;
                reactData.filterData = filterList;
                reactData.tableLoading = true;
                return Promise.resolve((beforeQuery || ajaxMethods)(commitParams, ...args)).then(rest => {
                  let tableData = [];
                  reactData.tableLoading = false;
                  if (rest) {
                    if (pagerConfig && isEnableConf(pagerOpts)) {
                      const totalProp = resConfigs.total;
                      const total = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(totalProp) ? totalProp({
                        data: rest,
                        $grid: $xeGrid
                      }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, totalProp || 'page.total')) || 0;
                      tablePage.total = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(total);
                      const resultProp = resConfigs.result;
                      tableData = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(resultProp) ? resultProp({
                        data: rest,
                        $grid: $xeGrid
                      }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, resultProp || 'result')) || [];
                      // 检验当前页码，不能超出当前最大页数
                      const pageCount = Math.max(Math.ceil(total / tablePage.pageSize), 1);
                      if (tablePage.currentPage > pageCount) {
                        tablePage.currentPage = pageCount;
                      }
                    } else {
                      const listProp = resConfigs.list;
                      tableData = (listProp ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(listProp) ? listProp({
                        data: rest,
                        $grid: $xeGrid
                      }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, listProp) : rest) || [];
                    }
                  }
                  if ($xeTable) {
                    $xeTable.loadData(tableData);
                  } else {
                    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
                      if ($xeTable) {
                        $xeTable.loadData(tableData);
                      }
                    });
                  }
                  if (afterQuery) {
                    afterQuery(commitParams, ...args);
                  }
                  if (querySuccessMethods) {
                    querySuccessMethods({
                      ...commitParams,
                      response: rest
                    });
                  }
                  return {
                    status: true
                  };
                }).catch(rest => {
                  reactData.tableLoading = false;
                  if (queryErrorMethods) {
                    queryErrorMethods({
                      ...commitParams,
                      response: rest
                    });
                  }
                  return {
                    status: false
                  };
                });
              } else {
                errLog('vxe.error.notFunc', ['proxy-config.ajax.query']);
              }
              break;
            }
          case 'delete':
            {
              const ajaxMethods = ajax.delete;
              const deleteSuccessMethods = ajax.deleteSuccess;
              const deleteErrorMethods = ajax.deleteError;
              if (ajaxMethods) {
                const selectRecords = gridExtendTableMethods.getCheckboxRecords();
                const removeRecords = selectRecords.filter(row => !$xeTable.isInsertByRow(row));
                const body = {
                  removeRecords
                };
                const commitParams = {
                  $grid: $xeGrid,
                  code,
                  button,
                  body,
                  form: formData,
                  options: ajaxMethods
                };
                if (selectRecords.length) {
                  return handleDeleteRow(code, 'vxe.grid.deleteSelectRecord', () => {
                    if (!removeRecords.length) {
                      return $xeTable.remove(selectRecords);
                    }
                    reactData.tableLoading = true;
                    return Promise.resolve((beforeDelete || ajaxMethods)(commitParams, ...args)).then(rest => {
                      reactData.tableLoading = false;
                      $xeTable.setPendingRow(removeRecords, false);
                      if (isRespMsg) {
                        if (core_.VxeUI.modal) {
                          core_.VxeUI.modal.message({
                            content: getRespMsg(rest, 'vxe.grid.delSuccess'),
                            status: 'success'
                          });
                        }
                      }
                      if (afterDelete) {
                        afterDelete(commitParams, ...args);
                      } else {
                        gridMethods.commitProxy('query');
                      }
                      if (deleteSuccessMethods) {
                        deleteSuccessMethods({
                          ...commitParams,
                          response: rest
                        });
                      }
                      return {
                        status: true
                      };
                    }).catch(rest => {
                      reactData.tableLoading = false;
                      if (isRespMsg) {
                        if (core_.VxeUI.modal) {
                          core_.VxeUI.modal.message({
                            id: code,
                            content: getRespMsg(rest, 'vxe.grid.operError'),
                            status: 'error'
                          });
                        }
                      }
                      if (deleteErrorMethods) {
                        deleteErrorMethods({
                          ...commitParams,
                          response: rest
                        });
                      }
                      return {
                        status: false
                      };
                    });
                  });
                } else {
                  if (isActiveMsg) {
                    if (core_.VxeUI.modal) {
                      core_.VxeUI.modal.message({
                        id: code,
                        content: grid_getI18n('vxe.grid.selectOneRecord'),
                        status: 'warning'
                      });
                    }
                  }
                }
              } else {
                errLog('vxe.error.notFunc', ['proxy-config.ajax.delete']);
              }
              break;
            }
          case 'save':
            {
              const ajaxMethods = ajax.save;
              const saveSuccessMethods = ajax.saveSuccess;
              const saveErrorMethods = ajax.saveError;
              if (ajaxMethods) {
                const body = $xeTable.getRecordset();
                const {
                  insertRecords,
                  removeRecords,
                  updateRecords,
                  pendingRecords
                } = body;
                const commitParams = {
                  $grid: $xeGrid,
                  code,
                  button,
                  body,
                  form: formData,
                  options: ajaxMethods
                };
                // 排除掉新增且标记为删除的数据
                if (insertRecords.length) {
                  body.pendingRecords = pendingRecords.filter(row => $xeTable.findRowIndexOf(insertRecords, row) === -1);
                }
                // 排除已标记为删除的数据
                if (pendingRecords.length) {
                  body.insertRecords = insertRecords.filter(row => $xeTable.findRowIndexOf(pendingRecords, row) === -1);
                }
                let restPromise = Promise.resolve();
                if (editRules) {
                  // 只校验新增和修改的数据
                  restPromise = $xeTable[validConfig && validConfig.msgMode === 'full' ? 'fullValidate' : 'validate'](body.insertRecords.concat(updateRecords));
                }
                return restPromise.then(errMap => {
                  if (errMap) {
                    // 如果校验不通过
                    return;
                  }
                  if (body.insertRecords.length || removeRecords.length || updateRecords.length || body.pendingRecords.length) {
                    reactData.tableLoading = true;
                    return Promise.resolve((beforeSave || ajaxMethods)(commitParams, ...args)).then(rest => {
                      reactData.tableLoading = false;
                      $xeTable.clearPendingRow();
                      if (isRespMsg) {
                        if (core_.VxeUI.modal) {
                          core_.VxeUI.modal.message({
                            content: getRespMsg(rest, 'vxe.grid.saveSuccess'),
                            status: 'success'
                          });
                        }
                      }
                      if (afterSave) {
                        afterSave(commitParams, ...args);
                      } else {
                        gridMethods.commitProxy('query');
                      }
                      if (saveSuccessMethods) {
                        saveSuccessMethods({
                          ...commitParams,
                          response: rest
                        });
                      }
                      return {
                        status: true
                      };
                    }).catch(rest => {
                      reactData.tableLoading = false;
                      if (isRespMsg) {
                        if (core_.VxeUI.modal) {
                          core_.VxeUI.modal.message({
                            id: code,
                            content: getRespMsg(rest, 'vxe.grid.operError'),
                            status: 'error'
                          });
                        }
                      }
                      if (saveErrorMethods) {
                        saveErrorMethods({
                          ...commitParams,
                          response: rest
                        });
                      }
                      return {
                        status: false
                      };
                    });
                  } else {
                    if (isActiveMsg) {
                      if (core_.VxeUI.modal) {
                        core_.VxeUI.modal.message({
                          id: code,
                          content: grid_getI18n('vxe.grid.dataUnchanged'),
                          status: 'info'
                        });
                      }
                    }
                  }
                });
              } else {
                errLog('vxe.error.notFunc', ['proxy-config.ajax.save']);
              }
              break;
            }
          default:
            {
              const gCommandOpts = grid_commands.get(code);
              if (gCommandOpts) {
                const tCommandMethod = gCommandOpts.tableCommandMethod || gCommandOpts.commandMethod;
                if (tCommandMethod) {
                  tCommandMethod({
                    code,
                    button,
                    $grid: $xeGrid,
                    $table: $xeTable
                  }, ...args);
                } else {
                  errLog('vxe.error.notCommands', [code]);
                }
              }
            }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      zoom() {
        if (reactData.isZMax) {
          return gridMethods.revert();
        }
        return gridMethods.maximize();
      },
      isMaximized() {
        return reactData.isZMax;
      },
      maximize() {
        return handleZoom(true);
      },
      revert() {
        return handleZoom();
      },
      getFormData,
      getFormItems(itemIndex) {
        const formOpts = computeFormOpts.value;
        const {
          formConfig
        } = props;
        const {
          items
        } = formOpts;
        const itemList = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(formConfig && isEnableConf(formOpts) && items ? items : [], item => {
          itemList.push(item);
        }, {
          children: 'children'
        });
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(itemIndex) ? itemList : itemList[itemIndex];
      },
      getProxyInfo() {
        const $xeTable = refTable.value;
        if (props.proxyConfig) {
          const {
            sortData
          } = reactData;
          return {
            data: $xeTable ? $xeTable.getFullData() : [],
            filter: reactData.filterData,
            form: getFormData(),
            sort: sortData.length ? sortData[0] : {},
            sorts: sortData,
            pager: reactData.tablePage,
            pendingRecords: $xeTable ? $xeTable.getPendingRecords() : []
          };
        }
        return null;
      }
      // setProxyInfo (options) {
      //   if (props.proxyConfig && options) {
      //     const { pager, form } = options
      //     const proxyOpts = computeProxyOpts.value
      //     if (pager) {
      //       if (pager.currentPage) {
      //         reactData.tablePage.currentPage = Number(pager.currentPage)
      //       }
      //       if (pager.pageSize) {
      //         reactData.tablePage.pageSize = Number(pager.pageSize)
      //       }
      //     }
      //     if (proxyOpts.form && form) {
      //       Object.assign(reactData.formData, form)
      //     }
      //   }
      //   return nextTick()
      // }
    };
    // 检查插槽
    if (true) {
      gridMethods.loadColumn = columns => {
        const $xeTable = refTable.value;
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(columns, column => {
          if (column.slots) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(column.slots, func => {
              if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(func)) {
                if (!slots[func]) {
                  errLog('vxe.error.notSlot', [func]);
                }
              }
            });
          }
        });
        if ($xeTable) {
          return $xeTable.loadColumn(columns);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      };
      gridMethods.reloadColumn = columns => {
        gridExtendTableMethods.clearAll();
        return gridMethods.loadColumn(columns);
      };
    }
    const gridPrivateMethods = {
      extendTableMethods,
      callSlot(slotFunc, params) {
        if (slotFunc) {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
            slotFunc = slots[slotFunc] || null;
          }
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
            return getSlotVNs(slotFunc(params));
          }
        }
        return [];
      },
      /**
       * 获取需要排除的高度
       */
      getExcludeHeight() {
        const {
          isZMax
        } = reactData;
        const el = refElem.value;
        if (el) {
          const formWrapper = refFormWrapper.value;
          const toolbarWrapper = refToolbarWrapper.value;
          const topWrapper = refTopWrapper.value;
          const bottomWrapper = refBottomWrapper.value;
          const pagerWrapper = refPagerWrapper.value;
          const parentEl = el.parentElement;
          const parentPaddingSize = isZMax ? 0 : parentEl ? getPaddingTopBottomSize(parentEl) : 0;
          return parentPaddingSize + getPaddingTopBottomSize(el) + getOffsetHeight(formWrapper) + getOffsetHeight(toolbarWrapper) + getOffsetHeight(topWrapper) + getOffsetHeight(bottomWrapper) + getOffsetHeight(pagerWrapper);
        }
        return 0;
      },
      getParentHeight() {
        const el = refElem.value;
        if (el) {
          const parentEl = el.parentElement;
          return (reactData.isZMax ? getDomNode().visibleHeight : parentEl ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getComputedStyle(parentEl).height) : 0) - gridPrivateMethods.getExcludeHeight();
        }
        return 0;
      },
      triggerToolbarCommitEvent(params, evnt) {
        const {
          code
        } = params;
        return gridMethods.commitProxy(params, evnt).then(rest => {
          if (code && rest && rest.status && ['query', 'reload', 'delete', 'save'].includes(code)) {
            gridMethods.dispatchEvent(code === 'delete' || code === 'save' ? `proxy-${code}` : 'proxy-query', {
              ...rest,
              isReload: code === 'reload'
            }, evnt);
          }
        });
      },
      triggerToolbarBtnEvent(button, evnt) {
        gridPrivateMethods.triggerToolbarCommitEvent(button, evnt);
        gridMethods.dispatchEvent('toolbar-button-click', {
          code: button.code,
          button
        }, evnt);
      },
      triggerToolbarTolEvent(tool, evnt) {
        gridPrivateMethods.triggerToolbarCommitEvent(tool, evnt);
        gridMethods.dispatchEvent('toolbar-tool-click', {
          code: tool.code,
          tool
        }, evnt);
      },
      triggerZoomEvent(evnt) {
        gridMethods.zoom();
        gridMethods.dispatchEvent('zoom', {
          type: reactData.isZMax ? 'max' : 'revert'
        }, evnt);
      }
    };
    Object.assign($xeGrid, gridExtendTableMethods, gridMethods, gridPrivateMethods);
    const columnFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.columns ? props.columns.length : -1, () => {
      columnFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.columns, () => {
      columnFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(columnFlag, () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => $xeGrid.loadColumn(props.columns || []));
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.toolbarConfig, () => {
      initToolbar();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computePageConfFlag, () => {
      initPages();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.proxyConfig, () => {
      initProxy();
    });
    grid_hooks.forEach(options => {
      const {
        setupGrid
      } = options;
      if (setupGrid) {
        const hookRest = setupGrid($xeGrid);
        if (hookRest && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(hookRest)) {
          Object.assign($xeGrid, hookRest);
        }
      }
    });
    initPages();
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          columns
        } = props;
        if (props.formConfig) {
          if (!VxeUIFormComponent) {
            errLog('vxe.error.reqComp', ['vxe-form']);
          }
        }
        if (props.pagerConfig) {
          if (!VxeUIPagerComponent) {
            errLog('vxe.error.reqComp', ['vxe-pager']);
          }
        }
        // const { data, columns, proxyConfig } = props
        // const proxyOpts = computeProxyOpts.value
        // const formOpts = computeFormOpts.value
        // if (isEnableConf(proxyConfig) && (data || (proxyOpts.form && formOpts.data))) {
        //   errLog('vxe.error.errConflicts', ['grid.data', 'grid.proxy-config'])
        // }
        //   if (proxyOpts.props) {
        //     warnLog('vxe.error.delProp', ['proxy-config.props', 'proxy-config.response'])
        //   }
        if (columns && columns.length) {
          $xeGrid.loadColumn(columns);
        }
        initToolbar();
        initProxy();
      });
      grid_globalEvents.on($xeGrid, 'keydown', handleGlobalKeydownEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      grid_globalEvents.off($xeGrid, 'keydown');
    });
    const renderVN = () => {
      const vSize = computeSize.value;
      const styles = computeStyles.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-grid', {
          [`size--${vSize}`]: vSize,
          'is--animat': !!props.animat,
          'is--round': props.round,
          'is--maximize': reactData.isZMax,
          'is--loading': props.loading || reactData.tableLoading
        }],
        style: styles
      }, renderLayout());
    };
    $xeGrid.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeGrid', $xeGrid);
    return $xeGrid;
  },
  render() {
    return this.renderVN();
  }
}));
;// ./packages/grid/index.ts


const VxeGrid = Object.assign({}, grid, {
  install(app) {
    app.component(grid.name, grid);
  }
});
if (core_.VxeUI.dynamicApp) {
  core_.VxeUI.dynamicApp.component(grid.name, grid);
}
core_.VxeUI.component(grid);
const Grid = VxeGrid;
/* harmony default export */ var packages_grid = ((/* unused pure expression or super */ null && (VxeGrid)));
;// ./packages/table/src/use/cell-view.ts


function useCellView(props) {
  const currColumn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const {
      renderParams
    } = props;
    return renderParams.column;
  });
  const currRow = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const {
      renderParams
    } = props;
    return renderParams.row;
  });
  const cellOptions = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const {
      renderOpts
    } = props;
    return renderOpts.props || {};
  });
  const cellModel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)({
    get() {
      const {
        renderParams
      } = props;
      const {
        row,
        column
      } = renderParams;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
    },
    set(value) {
      const {
        renderParams
      } = props;
      const {
        row,
        column
      } = renderParams;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, column.field, value);
    }
  });
  return {
    currColumn,
    currRow,
    cellModel,
    cellOptions
  };
}
;// ./packages/table/src/use/index.ts

;// ./packages/table/module/filter/hook.ts












const {
  renderer: hook_renderer,
  hooks: hook_hooks
} = core_.VxeUI;
const tableFilterMethodKeys = ['openFilter', 'setFilter', 'clearFilter', 'saveFilterPanel', 'resetFilterPanel', 'getCheckedFilters', 'updateFilterOptionStatus'];
hook_hooks.add('tableFilterModule', {
  setupTable($xeTable) {
    const {
      props,
      reactData,
      internalData
    } = $xeTable;
    const {
      refElem,
      refTableFilter
    } = $xeTable.getRefMaps();
    const {
      computeFilterOpts,
      computeMouseOpts
    } = $xeTable.getComputeMaps();
    // 确认筛选
    const handleFilterConfirmFilter = evnt => {
      const {
        filterStore
      } = reactData;
      filterStore.options.forEach(option => {
        option.checked = option._checked;
      });
      $xeTable.confirmFilterEvent(evnt);
    };
    // （单选）筛选发生改变
    const changeRadioOption = (evnt, checked, item) => {
      const {
        filterStore
      } = reactData;
      filterStore.options.forEach(option => {
        option._checked = false;
      });
      item._checked = checked;
      $xeTable.checkFilterOptions();
      handleFilterConfirmFilter(evnt);
    };
    // （多选）筛选发生改变
    const changeMultipleOption = (evnt, checked, item) => {
      item._checked = checked;
      $xeTable.checkFilterOptions();
    };
    /**
     * 重置筛选
     * 当筛选面板中的重置按钮被按下时触发
     * @param {Event} evnt 事件
     */
    const handleFilterResetFilter = evnt => {
      const {
        filterStore
      } = reactData;
      $xeTable.handleClearFilter(filterStore.column);
      $xeTable.confirmFilterEvent(evnt);
    };
    const filterPrivateMethods = {
      checkFilterOptions() {
        const {
          filterStore
        } = reactData;
        filterStore.isAllSelected = filterStore.options.every(item => item._checked);
        filterStore.isIndeterminate = !filterStore.isAllSelected && filterStore.options.some(item => item._checked);
      },
      /**
       * 点击筛选事件
       * 当筛选图标被点击时触发
       * 更新选项是否全部状态
       * 打开筛选面板
       * @param {Event} evnt 事件
       * @param {ColumnInfo} column 列配置
       * @param {Object} params 参数
       */
      triggerFilterEvent(evnt, column, params) {
        const {
          initStore,
          filterStore
        } = reactData;
        const {
          elemStore
        } = internalData;
        if (filterStore.column === column && filterStore.visible) {
          filterStore.visible = false;
        } else {
          const el = refElem.value;
          const {
            scrollTop,
            scrollLeft,
            visibleHeight,
            visibleWidth
          } = getDomNode();
          const filterOpts = computeFilterOpts.value;
          const {
            transfer
          } = filterOpts;
          const tableRect = el.getBoundingClientRect();
          const btnElem = evnt.currentTarget;
          const {
            filters,
            filterMultiple,
            filterRender
          } = column;
          const compConf = isEnableConf(filterRender) ? hook_renderer.get(filterRender.name) : null;
          const frMethod = column.filterRecoverMethod || (compConf ? compConf.tableFilterRecoverMethod || compConf.filterRecoverMethod : null);
          internalData._currFilterParams = params;
          Object.assign(filterStore, {
            multiple: filterMultiple,
            options: filters,
            column,
            style: null
          });
          // 复原状态
          filterStore.options.forEach(option => {
            const {
              _checked,
              checked
            } = option;
            option._checked = checked;
            if (!checked && _checked !== checked) {
              if (frMethod) {
                frMethod({
                  option,
                  column,
                  $table: $xeTable
                });
              }
            }
          });
          this.checkFilterOptions();
          filterStore.visible = true;
          initStore.filter = true;
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            const headerScrollElem = getRefElem(elemStore['main-header-scroll']);
            if (!headerScrollElem) {
              return;
            }
            const tableFilter = refTableFilter.value;
            const filterWrapperElem = tableFilter ? tableFilter.getRefMaps().refElem.value : null;
            if (!filterWrapperElem) {
              return;
            }
            const btnRect = btnElem.getBoundingClientRect();
            const filterHeadElem = filterWrapperElem.querySelector('.vxe-table--filter-header');
            const filterFootElem = filterWrapperElem.querySelector('.vxe-table--filter-footer');
            const filterWidth = filterWrapperElem.offsetWidth;
            const centerWidth = filterWidth / 2;
            let left = 0;
            let top = 0;
            let maxHeight = 0;
            if (transfer) {
              left = btnRect.left - centerWidth + scrollLeft;
              top = btnRect.top + btnElem.clientHeight + scrollTop;
              maxHeight = Math.min(Math.max(tableRect.height, Math.floor(visibleHeight / 2)), Math.max(80, visibleHeight - top - (filterHeadElem ? filterHeadElem.clientHeight : 0) - (filterFootElem ? filterFootElem.clientHeight : 0) - 28));
              if (left < 16) {
                left = 16;
              } else if (left > visibleWidth - filterWidth - 16) {
                left = visibleWidth - filterWidth - 16;
              }
            } else {
              left = btnRect.left - tableRect.left - centerWidth;
              top = btnRect.top - tableRect.top + btnElem.clientHeight;
              maxHeight = Math.max(40, el.clientHeight - top - (filterHeadElem ? filterHeadElem.clientHeight : 0) - (filterFootElem ? filterFootElem.clientHeight : 0) - 14);
              if (left < 1) {
                left = 1;
              } else if (left > el.clientWidth - filterWidth - 1) {
                left = el.clientWidth - filterWidth - 1;
              }
            }
            filterStore.style = {
              top: toCssUnit(top),
              left: toCssUnit(left)
            };
            // 判断面板不能大于表格高度
            filterStore.maxHeight = maxHeight;
          });
        }
        $xeTable.dispatchEvent('filter-visible', {
          column,
          field: column.field,
          property: column.field,
          filterList: $xeTable.getCheckedFilters(),
          visible: filterStore.visible
        }, evnt);
      },
      handleClearFilter(column) {
        if (column) {
          const {
            filters,
            filterRender
          } = column;
          if (filters) {
            const compConf = isEnableConf(filterRender) ? hook_renderer.get(filterRender.name) : null;
            const frMethod = column.filterResetMethod || (compConf ? compConf.tableFilterResetMethod || compConf.filterResetMethod : null);
            filters.forEach(item => {
              item._checked = false;
              item.checked = false;
              if (!frMethod) {
                item.data = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(item.resetValue, true);
              }
            });
            if (frMethod) {
              frMethod({
                options: filters,
                column,
                $table: $xeTable
              });
            }
          }
        }
      },
      handleColumnConfirmFilter(column, evnt) {
        const {
          mouseConfig
        } = props;
        const {
          scrollXLoad: oldScrollXLoad,
          scrollYLoad: oldScrollYLoad
        } = reactData;
        const filterOpts = computeFilterOpts.value;
        const mouseOpts = computeMouseOpts.value;
        const {
          field
        } = column;
        const values = [];
        const datas = [];
        column.filters.forEach(item => {
          if (item.checked) {
            values.push(item.value);
            datas.push(item.data);
          }
        });
        const filterList = $xeTable.getCheckedFilters();
        const params = {
          $table: $xeTable,
          $event: evnt,
          column,
          field,
          property: field,
          values,
          datas,
          filters: filterList,
          filterList
        };
        // 如果是服务端筛选，则跳过本地筛选处理
        if (!filterOpts.remote) {
          $xeTable.handleTableData(true);
          $xeTable.checkSelectionStatus();
        }
        if (mouseConfig && mouseOpts.area && $xeTable.handleFilterEvent) {
          $xeTable.handleFilterEvent(evnt, params);
        }
        if (evnt) {
          $xeTable.dispatchEvent('filter-change', params, evnt);
        }
        $xeTable.closeFilter();
        return $xeTable.updateFooter().then(() => {
          const {
            scrollXLoad,
            scrollYLoad
          } = reactData;
          if (oldScrollXLoad || scrollXLoad || oldScrollYLoad || scrollYLoad) {
            if (oldScrollXLoad || scrollXLoad) {
              $xeTable.updateScrollXSpace();
            }
            if (oldScrollYLoad || scrollYLoad) {
              $xeTable.updateScrollYSpace();
            }
            return $xeTable.refreshScroll();
          }
        }).then(() => {
          $xeTable.updateCellAreas();
          return $xeTable.recalculate(true);
        }).then(() => {
          // 存在滚动行为未结束情况
          setTimeout(() => $xeTable.recalculate(), 50);
        });
      },
      /**
       * 确认筛选
       * 当筛选面板中的确定按钮被按下时触发
       * @param {Event} evnt 事件
       */
      confirmFilterEvent(evnt) {
        const {
          filterStore
        } = reactData;
        const {
          column
        } = filterStore;
        $xeTable.handleColumnConfirmFilter(column, evnt);
      },
      handleFilterChangeRadioOption: changeRadioOption,
      handleFilterChangeMultipleOption: changeMultipleOption,
      // 筛选发生改变
      handleFilterChangeOption(evnt, checked, item) {
        const {
          filterStore
        } = reactData;
        if (filterStore.multiple) {
          changeMultipleOption(evnt, checked, item);
        } else {
          changeRadioOption(evnt, checked, item);
        }
      },
      handleFilterConfirmFilter,
      handleFilterResetFilter
    };
    const filterMethods = {
      /**
       * 手动弹出筛选面板
       * @param column
       */
      openFilter(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column && column.filters) {
          const {
            elemStore
          } = internalData;
          const {
            fixed
          } = column;
          return $xeTable.scrollToColumn(column).then(() => {
            const headerWrapperElem = getRefElem(elemStore[`${fixed || 'main'}-header-wrapper`] || elemStore['main-header-wrapper']);
            if (headerWrapperElem) {
              const filterBtnElem = headerWrapperElem.querySelector(`.vxe-header--column.${column.id} .vxe-cell--filter`);
              triggerEvent(filterBtnElem, 'click');
            }
          });
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 修改筛选条件列表
       * @param {ColumnInfo} fieldOrColumn 列或字段名
       * @param {Array} options 选项
       */
      setFilter(fieldOrColumn, options, isUpdate) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column && column.filters) {
          column.filters = toFilters(options || []);
          if (isUpdate) {
            return $xeTable.handleColumnConfirmFilter(column, new Event('click'));
          }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 清空指定列的筛选条件
       * 如果为空则清空所有列的筛选条件
       * @param {String} fieldOrColumn 列或字段名
       */
      clearFilter(fieldOrColumn) {
        const {
          filterStore
        } = reactData;
        const {
          tableFullColumn
        } = internalData;
        const filterOpts = computeFilterOpts.value;
        let column;
        if (fieldOrColumn) {
          column = handleFieldOrColumn($xeTable, fieldOrColumn);
          if (column) {
            filterPrivateMethods.handleClearFilter(column);
          }
        } else {
          tableFullColumn.forEach(filterPrivateMethods.handleClearFilter);
        }
        if (!fieldOrColumn || column !== filterStore.column) {
          Object.assign(filterStore, {
            isAllSelected: false,
            isIndeterminate: false,
            style: null,
            options: [],
            column: null,
            multiple: false,
            visible: false
          });
        }
        if (!filterOpts.remote) {
          return $xeTable.updateData();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      saveFilterPanel() {
        handleFilterConfirmFilter(null);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      resetFilterPanel() {
        handleFilterResetFilter(null);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      getCheckedFilters() {
        const {
          tableFullColumn
        } = internalData;
        const filterList = [];
        tableFullColumn.forEach(column => {
          const {
            field,
            filters
          } = column;
          const valueList = [];
          const dataList = [];
          if (filters && filters.length) {
            filters.forEach(item => {
              if (item.checked) {
                valueList.push(item.value);
                dataList.push(item.data);
              }
            });
            if (valueList.length) {
              filterList.push({
                column,
                field,
                property: field,
                values: valueList,
                datas: dataList
              });
            }
          }
        });
        return filterList;
      },
      updateFilterOptionStatus(item, checked) {
        item._checked = checked;
        item.checked = checked;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    return {
      ...filterMethods,
      ...filterPrivateMethods
    };
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableFilterMethodKeys);
  }
});
;// ./packages/table/module/menu/hook.ts





const {
  menus: hook_menus,
  hooks: menu_hook_hooks,
  globalEvents: hook_globalEvents,
  GLOBAL_EVENT_KEYS: hook_GLOBAL_EVENT_KEYS
} = core_.VxeUI;
const tableMenuMethodKeys = ['closeMenu'];
menu_hook_hooks.add('tableMenuModule', {
  setupTable($xeTable) {
    const {
      xID,
      props,
      reactData,
      internalData
    } = $xeTable;
    const {
      refElem,
      refTableFilter,
      refTableMenu
    } = $xeTable.getRefMaps();
    const {
      computeMouseOpts,
      computeIsMenu,
      computeMenuOpts
    } = $xeTable.getComputeMaps();
    let menuMethods = {};
    let menuPrivateMethods = {};
    /**
     * 显示快捷菜单
     */
    const handleOpenMenuEvent = (evnt, type, params) => {
      const {
        ctxMenuStore
      } = reactData;
      const isMenu = computeIsMenu.value;
      const menuOpts = computeMenuOpts.value;
      const config = menuOpts[type];
      const visibleMethod = menuOpts.visibleMethod;
      if (config) {
        const {
          options,
          disabled
        } = config;
        if (disabled) {
          evnt.preventDefault();
        } else if (isMenu && options && options.length) {
          params.options = options;
          $xeTable.preventEvent(evnt, 'event.showMenu', params, () => {
            if (!visibleMethod || visibleMethod(params)) {
              evnt.preventDefault();
              $xeTable.updateZindex();
              const {
                scrollTop,
                scrollLeft,
                visibleHeight,
                visibleWidth
              } = getDomNode();
              let top = evnt.clientY + scrollTop;
              let left = evnt.clientX + scrollLeft;
              const handleVisible = () => {
                internalData._currMenuParams = params;
                Object.assign(ctxMenuStore, {
                  visible: true,
                  list: options,
                  selected: null,
                  selectChild: null,
                  showChild: false,
                  style: {
                    zIndex: internalData.tZindex,
                    top: `${top}px`,
                    left: `${left}px`
                  }
                });
                (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
                  const tableMenu = refTableMenu.value;
                  const ctxElem = tableMenu.getRefMaps().refElem.value;
                  const clientHeight = ctxElem.clientHeight;
                  const clientWidth = ctxElem.clientWidth;
                  const {
                    boundingTop,
                    boundingLeft
                  } = getAbsolutePos(ctxElem);
                  const offsetTop = boundingTop + clientHeight - visibleHeight;
                  const offsetLeft = boundingLeft + clientWidth - visibleWidth;
                  if (offsetTop > -10) {
                    ctxMenuStore.style.top = `${Math.max(scrollTop + 2, top - clientHeight - 2)}px`;
                  }
                  if (offsetLeft > -10) {
                    ctxMenuStore.style.left = `${Math.max(scrollLeft + 2, left - clientWidth - 2)}px`;
                  }
                });
              };
              const {
                keyboard,
                row,
                column
              } = params;
              if (keyboard && row && column) {
                $xeTable.scrollToRow(row, column).then(() => {
                  const cell = $xeTable.getCellElement(row, column);
                  if (cell) {
                    const {
                      boundingTop,
                      boundingLeft
                    } = getAbsolutePos(cell);
                    top = boundingTop + scrollTop + Math.floor(cell.offsetHeight / 2);
                    left = boundingLeft + scrollLeft + Math.floor(cell.offsetWidth / 2);
                  }
                  handleVisible();
                });
              } else {
                handleVisible();
              }
            } else {
              menuMethods.closeMenu();
            }
          });
        }
      }
      $xeTable.closeFilter();
    };
    menuMethods = {
      /**
       * 关闭快捷菜单
       */
      closeMenu() {
        Object.assign(reactData.ctxMenuStore, {
          visible: false,
          selected: null,
          selectChild: null,
          showChild: false
        });
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    menuPrivateMethods = {
      /**
       * 处理菜单的移动
       */
      moveCtxMenu(evnt, ctxMenuStore, property, hasOper, operRest, menuList) {
        let selectItem;
        const selectIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(menuList, item => ctxMenuStore[property] === item);
        if (hasOper) {
          if (operRest && hasChildrenList(ctxMenuStore.selected)) {
            ctxMenuStore.showChild = true;
          } else {
            ctxMenuStore.showChild = false;
            ctxMenuStore.selectChild = null;
          }
        } else if (hook_globalEvents.hasKey(evnt, hook_GLOBAL_EVENT_KEYS.ARROW_UP)) {
          for (let len = selectIndex - 1; len >= 0; len--) {
            if (menuList[len].visible !== false) {
              selectItem = menuList[len];
              break;
            }
          }
          ctxMenuStore[property] = selectItem || menuList[menuList.length - 1];
        } else if (hook_globalEvents.hasKey(evnt, hook_GLOBAL_EVENT_KEYS.ARROW_DOWN)) {
          for (let index = selectIndex + 1; index < menuList.length; index++) {
            if (menuList[index].visible !== false) {
              selectItem = menuList[index];
              break;
            }
          }
          ctxMenuStore[property] = selectItem || menuList[0];
        } else if (ctxMenuStore[property] && (hook_globalEvents.hasKey(evnt, hook_GLOBAL_EVENT_KEYS.ENTER) || hook_globalEvents.hasKey(evnt, hook_GLOBAL_EVENT_KEYS.SPACEBAR))) {
          $xeTable.ctxMenuLinkEvent(evnt, ctxMenuStore[property]);
        }
      },
      handleOpenMenuEvent,
      /**
       * 快捷菜单事件处理
       */
      handleGlobalContextmenuEvent(evnt) {
        const {
          mouseConfig,
          menuConfig
        } = props;
        const {
          editStore,
          ctxMenuStore
        } = reactData;
        const {
          visibleColumn
        } = internalData;
        const tableFilter = refTableFilter.value;
        const tableMenu = refTableMenu.value;
        const mouseOpts = computeMouseOpts.value;
        const menuOpts = computeMenuOpts.value;
        const el = refElem.value;
        const {
          selected
        } = editStore;
        const layoutList = ['header', 'body', 'footer'];
        if (isEnableConf(menuConfig)) {
          if (ctxMenuStore.visible && tableMenu && getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) {
            evnt.preventDefault();
            return;
          }
          if (internalData._keyCtx) {
            const type = 'body';
            const params = {
              type,
              $table: $xeTable,
              keyboard: true,
              columns: visibleColumn.slice(0),
              $event: evnt
            };
            // 如果开启单元格区域
            if (mouseConfig && mouseOpts.area) {
              const activeArea = $xeTable.getActiveCellArea();
              if (activeArea && activeArea.row && activeArea.column) {
                params.row = activeArea.row;
                params.column = activeArea.column;
                handleOpenMenuEvent(evnt, type, params);
                return;
              }
            } else if (mouseConfig && mouseOpts.selected) {
              // 如果启用键盘导航且已选中单元格
              if (selected.row && selected.column) {
                params.row = selected.row;
                params.column = selected.column;
                handleOpenMenuEvent(evnt, type, params);
                return;
              }
            }
          }
          // 分别匹配表尾、内容、表尾的快捷菜单
          for (let index = 0; index < layoutList.length; index++) {
            const layout = layoutList[index];
            const columnTargetNode = getEventTargetNode(evnt, el, `vxe-${layout}--column`, target => {
              // target=td|th，直接向上找 table 去匹配即可
              return target.parentNode.parentNode.parentNode.getAttribute('xid') === xID;
            });
            const params = {
              type: layout,
              $table: $xeTable,
              columns: visibleColumn.slice(0),
              $event: evnt
            };
            if (columnTargetNode.flag) {
              const cell = columnTargetNode.targetElem;
              const columnNodeRest = $xeTable.getColumnNode(cell);
              const column = columnNodeRest ? columnNodeRest.item : null;
              let typePrefix = `${layout}-`;
              if (column) {
                Object.assign(params, {
                  column,
                  columnIndex: $xeTable.getColumnIndex(column),
                  cell
                });
              }
              if (layout === 'body') {
                const rowNodeRest = $xeTable.getRowNode(cell.parentNode);
                const row = rowNodeRest ? rowNodeRest.item : null;
                typePrefix = '';
                if (row) {
                  params.row = row;
                  params.rowIndex = $xeTable.getRowIndex(row);
                }
              }
              const eventType = `${typePrefix}cell-menu`;
              handleOpenMenuEvent(evnt, layout, params);
              $xeTable.dispatchEvent(eventType, params, evnt);
              return;
            } else if (getEventTargetNode(evnt, el, `vxe-table--${layout}-wrapper`, target => target.getAttribute('xid') === xID).flag) {
              if (menuOpts.trigger === 'cell') {
                evnt.preventDefault();
              } else {
                handleOpenMenuEvent(evnt, layout, params);
              }
              return;
            }
          }
        }
        if (tableFilter && !getEventTargetNode(evnt, tableFilter.getRefMaps().refElem.value).flag) {
          $xeTable.closeFilter();
        }
        menuMethods.closeMenu();
      },
      ctxMenuMouseoverEvent(evnt, item, child) {
        const menuElem = evnt.currentTarget;
        const {
          ctxMenuStore
        } = reactData;
        evnt.preventDefault();
        evnt.stopPropagation();
        ctxMenuStore.selected = item;
        ctxMenuStore.selectChild = child;
        if (!child) {
          ctxMenuStore.showChild = hasChildrenList(item);
          if (ctxMenuStore.showChild) {
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              const childWrapperElem = menuElem.nextElementSibling;
              if (childWrapperElem) {
                const {
                  boundingTop,
                  boundingLeft,
                  visibleHeight,
                  visibleWidth
                } = getAbsolutePos(menuElem);
                const posTop = boundingTop + menuElem.offsetHeight;
                const posLeft = boundingLeft + menuElem.offsetWidth;
                let left = '';
                let right = '';
                // 是否超出右侧
                if (posLeft + childWrapperElem.offsetWidth > visibleWidth - 10) {
                  left = 'auto';
                  right = `${menuElem.offsetWidth}px`;
                }
                // 是否超出底部
                let top = '';
                let bottom = '';
                if (posTop + childWrapperElem.offsetHeight > visibleHeight - 10) {
                  top = 'auto';
                  bottom = '0';
                }
                childWrapperElem.style.left = left;
                childWrapperElem.style.right = right;
                childWrapperElem.style.top = top;
                childWrapperElem.style.bottom = bottom;
              }
            });
          }
        }
      },
      ctxMenuMouseoutEvent(evnt, item) {
        const {
          ctxMenuStore
        } = reactData;
        if (!item.children) {
          ctxMenuStore.selected = null;
        }
        ctxMenuStore.selectChild = null;
      },
      /**
       * 快捷菜单点击事件
       */
      ctxMenuLinkEvent(evnt, menu) {
        const $xeGrid = $xeTable.xeGrid;
        // 如果一级菜单有配置 code 则允许点击，否则不能点击
        if (!menu.disabled && (menu.code || !menu.children || !menu.children.length)) {
          const gMenuOpts = hook_menus.get(menu.code);
          const params = Object.assign({}, internalData._currMenuParams, {
            menu,
            $table: $xeTable,
            $grid: $xeGrid,
            $event: evnt
          });
          const tmMethod = gMenuOpts ? gMenuOpts.tableMenuMethod || gMenuOpts.menuMethod : null;
          if (tmMethod) {
            tmMethod(params, evnt);
          }
          $xeTable.dispatchEvent('menu-click', params, evnt);
          menuMethods.closeMenu();
        }
      }
    };
    return {
      ...menuMethods,
      ...menuPrivateMethods
    };
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableMenuMethodKeys);
  }
});
;// ./packages/table/module/edit/hook.ts














const {
  getConfig: hook_getConfig,
  renderer: edit_hook_renderer,
  hooks: edit_hook_hooks,
  getI18n: hook_getI18n
} = core_.VxeUI;
const tableEditMethodKeys = ['insert', 'insertAt', 'insertNextAt', 'insertChild', 'insertChildAt', 'insertChildNextAt', 'remove', 'removeCheckboxRow', 'removeRadioRow', 'removeCurrentRow', 'getRecordset', 'getInsertRecords', 'getRemoveRecords', 'getUpdateRecords', 'getEditRecord', 'getActiveRecord', 'getSelectedCell', 'clearEdit', 'clearActived', 'clearSelected', 'isEditByRow', 'isActiveByRow', 'setEditRow', 'setActiveRow', 'setEditCell', 'setActiveCell', 'setSelectCell'];
edit_hook_hooks.add('tableEditModule', {
  setupTable($xeTable) {
    const {
      props,
      reactData,
      internalData
    } = $xeTable;
    const {
      refElem
    } = $xeTable.getRefMaps();
    const {
      computeMouseOpts,
      computeEditOpts,
      computeCheckboxOpts,
      computeTreeOpts,
      computeValidOpts
    } = $xeTable.getComputeMaps();
    const browseObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().browse();
    let editMethods = {};
    let editPrivateMethods = {};
    const getEditColumnModel = (row, column) => {
      const {
        model,
        editRender
      } = column;
      if (editRender) {
        model.value = getCellValue(row, column);
        model.update = false;
      }
    };
    const setEditColumnModel = (row, column) => {
      const {
        model,
        editRender
      } = column;
      if (editRender && model.update) {
        setCellValue(row, column, model.value);
        model.update = false;
        model.value = null;
      }
    };
    const removeCellSelectedClass = () => {
      const el = refElem.value;
      if (el) {
        const cell = el.querySelector('.col--selected');
        if (cell) {
          removeClass(cell, 'col--selected');
        }
      }
    };
    const syncActivedCell = () => {
      const {
        editStore,
        tableColumn
      } = reactData;
      const editOpts = computeEditOpts.value;
      const {
        actived
      } = editStore;
      const {
        row,
        column
      } = actived;
      if (row || column) {
        if (editOpts.mode === 'row') {
          tableColumn.forEach(column => setEditColumnModel(row, column));
        } else {
          setEditColumnModel(row, column);
        }
      }
    };
    const insertTreeRow = (newRecords, isAppend) => {
      const {
        tableFullTreeData,
        afterFullData,
        fullDataRowIdData,
        fullAllDataRowIdData
      } = internalData;
      const treeOpts = computeTreeOpts.value;
      const {
        rowField,
        parentField,
        mapChildrenField
      } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const funcName = isAppend ? 'push' : 'unshift';
      newRecords.forEach(item => {
        const parentRowId = item[parentField];
        const rowid = getRowid($xeTable, item);
        const matchObj = parentRowId ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData, item => parentRowId === item[rowField], {
          children: mapChildrenField
        }) : null;
        if (matchObj) {
          const {
            item: parentRow
          } = matchObj;
          const parentRest = fullAllDataRowIdData[getRowid($xeTable, parentRow)];
          const parentLevel = parentRest ? parentRest.level : 0;
          let parentChilds = parentRow[childrenField];
          let mapChilds = parentRow[mapChildrenField];
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(parentChilds)) {
            parentChilds = parentRow[childrenField] = [];
          }
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(mapChilds)) {
            mapChilds = parentRow[childrenField] = [];
          }
          parentChilds[funcName](item);
          mapChilds[funcName](item);
          const rest = {
            row: item,
            rowid,
            seq: -1,
            index: -1,
            _index: -1,
            $index: -1,
            treeIndex: -1,
            items: parentChilds,
            parent: parentRow,
            level: parentLevel + 1,
            height: 0,
            resizeHeight: 0,
            oTop: 0,
            expandHeight: 0
          };
          fullDataRowIdData[rowid] = rest;
          fullAllDataRowIdData[rowid] = rest;
        } else {
          if (true) {
            if (parentRowId) {
              warnLog('vxe.error.unableInsert');
            }
          }
          afterFullData[funcName](item);
          tableFullTreeData[funcName](item);
          const rest = {
            row: item,
            rowid,
            seq: -1,
            index: -1,
            _index: -1,
            $index: -1,
            treeIndex: -1,
            items: tableFullTreeData,
            parent: null,
            level: 0,
            height: 0,
            resizeHeight: 0,
            oTop: 0,
            expandHeight: 0
          };
          fullDataRowIdData[rowid] = rest;
          fullAllDataRowIdData[rowid] = rest;
        }
      });
    };
    const handleInsertRowAt = (records, targetRow, isInsertNextRow) => {
      const {
        treeConfig
      } = props;
      const {
        tableFullTreeData,
        afterFullData,
        mergeBodyList,
        tableFullData,
        fullDataRowIdData,
        fullAllDataRowIdData,
        insertRowMaps
      } = internalData;
      const treeOpts = computeTreeOpts.value;
      const {
        transform,
        rowField,
        mapChildrenField
      } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(records)) {
        records = [records];
      }
      const newRecords = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)($xeTable.defineField(records.map(record => Object.assign(treeConfig && transform ? {
        [mapChildrenField]: [],
        [childrenField]: []
      } : {}, record))));
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(targetRow)) {
        // 如果为虚拟树
        if (treeConfig && transform) {
          insertTreeRow(newRecords, false);
        } else {
          newRecords.forEach(item => {
            const rowid = getRowid($xeTable, item);
            const rest = {
              row: item,
              rowid,
              seq: -1,
              index: -1,
              _index: -1,
              $index: -1,
              treeIndex: -1,
              items: afterFullData,
              parent: null,
              level: 0,
              height: 0,
              resizeHeight: 0,
              oTop: 0,
              expandHeight: 0
            };
            fullDataRowIdData[rowid] = rest;
            fullAllDataRowIdData[rowid] = rest;
            afterFullData.unshift(item);
            tableFullData.unshift(item);
          });
          // 刷新单元格合并
          mergeBodyList.forEach(mergeItem => {
            const {
              row: mergeRowIndex
            } = mergeItem;
            if (mergeRowIndex > 0) {
              mergeItem.row = mergeRowIndex + newRecords.length;
            }
          });
        }
      } else {
        if (targetRow === -1) {
          // 如果为虚拟树
          if (treeConfig && transform) {
            insertTreeRow(newRecords, true);
          } else {
            newRecords.forEach(item => {
              const rowid = getRowid($xeTable, item);
              const rest = {
                row: item,
                rowid,
                seq: -1,
                index: -1,
                _index: -1,
                treeIndex: -1,
                $index: -1,
                items: afterFullData,
                parent: null,
                level: 0,
                height: 0,
                resizeHeight: 0,
                oTop: 0,
                expandHeight: 0
              };
              fullDataRowIdData[rowid] = rest;
              fullAllDataRowIdData[rowid] = rest;
              afterFullData.push(item);
              tableFullData.push(item);
            });
            // 刷新单元格合并
            mergeBodyList.forEach(mergeItem => {
              const {
                row: mergeRowIndex,
                rowspan: mergeRowspan
              } = mergeItem;
              if (mergeRowIndex + mergeRowspan > afterFullData.length) {
                mergeItem.rowspan = mergeRowspan + newRecords.length;
              }
            });
          }
        } else {
          // 如果为虚拟树
          if (treeConfig && transform) {
            const matchMapObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData, item => targetRow[rowField] === item[rowField], {
              children: mapChildrenField
            });
            if (matchMapObj) {
              const {
                parent: parentRow
              } = matchMapObj;
              const parentMapChilds = parentRow ? parentRow[mapChildrenField] : tableFullTreeData;
              const parentRest = fullAllDataRowIdData[getRowid($xeTable, parentRow)];
              const parentLevel = parentRest ? parentRest.level : 0;
              newRecords.forEach((item, i) => {
                const rowid = getRowid($xeTable, item);
                if (true) {
                  if (item[treeOpts.parentField]) {
                    if (parentRow && item[treeOpts.parentField] !== parentRow[rowField]) {
                      errLog('vxe.error.errProp', [`${treeOpts.parentField}=${item[treeOpts.parentField]}`, `${treeOpts.parentField}=${parentRow[rowField]}`]);
                    }
                  }
                }
                if (parentRow) {
                  item[treeOpts.parentField] = parentRow[rowField];
                }
                let targetIndex = matchMapObj.index + i;
                if (isInsertNextRow) {
                  targetIndex = targetIndex + 1;
                }
                parentMapChilds.splice(targetIndex, 0, item);
                const rest = {
                  row: item,
                  rowid,
                  seq: -1,
                  index: -1,
                  _index: -1,
                  $index: -1,
                  treeIndex: -1,
                  items: parentMapChilds,
                  parent: parentRow,
                  level: parentLevel + 1,
                  height: 0,
                  resizeHeight: 0,
                  oTop: 0,
                  expandHeight: 0
                };
                fullDataRowIdData[rowid] = rest;
                fullAllDataRowIdData[rowid] = rest;
              });
              // 源
              if (parentRow) {
                const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData, item => targetRow[rowField] === item[rowField], {
                  children: childrenField
                });
                if (matchObj) {
                  const parentChilds = matchObj.items;
                  let targetIndex = matchObj.index;
                  if (isInsertNextRow) {
                    targetIndex = targetIndex + 1;
                  }
                  parentChilds.splice(targetIndex, 0, ...newRecords);
                }
              }
            } else {
              if (true) {
                warnLog('vxe.error.unableInsert');
              }
              insertTreeRow(newRecords, true);
            }
          } else {
            if (treeConfig) {
              throw new Error(hook_getI18n('vxe.error.noTree', ['insert']));
            }
            let afIndex = -1;
            // 如果是可视索引
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(targetRow)) {
              if (targetRow < afterFullData.length) {
                afIndex = targetRow;
              }
            } else {
              afIndex = $xeTable.findRowIndexOf(afterFullData, targetRow);
            }
            // 如果是插入指定行的下一行
            if (isInsertNextRow) {
              afIndex = Math.min(afterFullData.length, afIndex + 1);
            }
            if (afIndex === -1) {
              throw new Error(hook_getI18n('vxe.error.unableInsert'));
            }
            afterFullData.splice(afIndex, 0, ...newRecords);
            const tfIndex = $xeTable.findRowIndexOf(tableFullData, targetRow);
            if (tfIndex > -1) {
              tableFullData.splice(tfIndex + (isInsertNextRow ? 1 : 0), 0, ...newRecords);
            } else {
              tableFullData.push(...newRecords);
            }
            // 刷新单元格合并
            mergeBodyList.forEach(mergeItem => {
              const {
                row: mergeRowIndex,
                rowspan: mergeRowspan
              } = mergeItem;
              if (mergeRowIndex > afIndex) {
                mergeItem.row = mergeRowIndex + newRecords.length;
              } else if (mergeRowIndex + mergeRowspan > afIndex) {
                mergeItem.rowspan = mergeRowspan + newRecords.length;
              }
            });
          }
        }
      }
      newRecords.forEach(newRow => {
        const rowid = getRowid($xeTable, newRow);
        insertRowMaps[rowid] = newRow;
      });
      reactData.insertRowFlag++;
      $xeTable.cacheRowMap(false);
      $xeTable.updateScrollYStatus();
      $xeTable.handleTableData(treeConfig && transform);
      if (!(treeConfig && transform)) {
        $xeTable.updateAfterDataIndex();
      }
      $xeTable.updateFooter();
      $xeTable.handleUpdateBodyMerge();
      $xeTable.checkSelectionStatus();
      if (reactData.scrollYLoad) {
        $xeTable.updateScrollYSpace();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        $xeTable.updateCellAreas();
        return $xeTable.recalculate();
      }).then(() => {
        return {
          row: newRecords.length ? newRecords[newRecords.length - 1] : null,
          rows: newRecords
        };
      });
    };
    const handleInsertChildRowAt = (records, parentRow, targetRow, isInsertNextRow) => {
      const {
        treeConfig
      } = props;
      const treeOpts = computeTreeOpts.value;
      const {
        transform,
        rowField,
        parentField
      } = treeOpts;
      if (treeConfig && transform) {
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(records)) {
          records = [records];
        }
        return handleInsertRowAt(records.map(item => Object.assign({}, item, {
          [parentField]: parentRow[rowField]
        })), targetRow, isInsertNextRow);
      } else {
        errLog('vxe.error.errProp', ['tree-config.transform=false', 'tree-config.transform=true']);
      }
      return Promise.resolve({
        row: null,
        rows: []
      });
    };
    const handleClearEdit = (evnt, targetRow) => {
      const {
        editStore
      } = reactData;
      const {
        actived,
        focused
      } = editStore;
      const {
        row,
        column
      } = actived;
      const validOpts = computeValidOpts.value;
      if (row || column) {
        if (targetRow && getRowid($xeTable, targetRow) !== getRowid($xeTable, row)) {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
        syncActivedCell();
        actived.args = null;
        actived.row = null;
        actived.column = null;
        $xeTable.updateFooter();
        $xeTable.dispatchEvent('edit-closed', {
          row,
          rowIndex: $xeTable.getRowIndex(row),
          $rowIndex: $xeTable.getVMRowIndex(row),
          column,
          columnIndex: $xeTable.getColumnIndex(column),
          $columnIndex: $xeTable.getVMColumnIndex(column)
        }, evnt || null);
      }
      focused.row = null;
      focused.column = null;
      if (validOpts.autoClear) {
        if (validOpts.msgMode !== 'full' || hook_getConfig().cellVaildMode === 'obsolete') {
          if ($xeTable.clearValidate) {
            return $xeTable.clearValidate();
          }
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => $xeTable.updateCellAreas());
    };
    const handleEditActive = (params, evnt, isFocus, isPos) => {
      const $xeGrid = $xeTable.xeGrid;
      const {
        editConfig,
        mouseConfig
      } = props;
      const {
        editStore,
        tableColumn
      } = reactData;
      const editOpts = computeEditOpts.value;
      const {
        mode
      } = editOpts;
      const {
        actived,
        focused
      } = editStore;
      const {
        row,
        column
      } = params;
      const {
        editRender
      } = column;
      const cell = params.cell || $xeTable.getCellElement(row, column);
      const beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;
      params.cell = cell;
      if (cell && isEnableConf(editConfig) && isEnableConf(editRender)) {
        // 激活编辑
        if (!$xeTable.isPendingByRow(row)) {
          if (actived.row !== row || (mode === 'cell' ? actived.column !== column : false)) {
            // 判断是否禁用编辑
            let type = 'edit-disabled';
            if (!beforeEditMethod || beforeEditMethod({
              ...params,
              $table: $xeTable,
              $grid: $xeGrid
            })) {
              if (mouseConfig) {
                $xeTable.clearSelected();
                if ($xeTable.clearCellAreas) {
                  $xeTable.clearCellAreas();
                  $xeTable.clearCopyCellArea();
                }
              }
              $xeTable.closeTooltip();
              if (actived.column) {
                handleClearEdit(evnt);
              }
              type = 'edit-activated';
              column.renderHeight = cell.offsetHeight;
              actived.args = params;
              actived.row = row;
              actived.column = column;
              if (mode === 'row') {
                tableColumn.forEach(column => getEditColumnModel(row, column));
              } else {
                getEditColumnModel(row, column);
              }
              const afterEditMethod = editOpts.afterEditMethod;
              (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
                if (isFocus) {
                  $xeTable.handleFocus(params, evnt);
                }
                if (afterEditMethod) {
                  afterEditMethod({
                    ...params,
                    $table: $xeTable,
                    $grid: $xeGrid
                  });
                }
              });
            }
            $xeTable.dispatchEvent(type, {
              row,
              rowIndex: $xeTable.getRowIndex(row),
              $rowIndex: $xeTable.getVMRowIndex(row),
              column,
              columnIndex: $xeTable.getColumnIndex(column),
              $columnIndex: $xeTable.getVMColumnIndex(column)
            }, evnt);
            // v4已废弃
            if (type === 'edit-activated') {
              $xeTable.dispatchEvent('edit-actived', {
                row,
                rowIndex: $xeTable.getRowIndex(row),
                $rowIndex: $xeTable.getVMRowIndex(row),
                column,
                columnIndex: $xeTable.getColumnIndex(column),
                $columnIndex: $xeTable.getVMColumnIndex(column)
              }, evnt);
            }
          } else {
            const {
              column: oldColumn
            } = actived;
            if (mouseConfig) {
              $xeTable.clearSelected();
              if ($xeTable.clearCellAreas) {
                $xeTable.clearCellAreas();
                $xeTable.clearCopyCellArea();
              }
            }
            if (oldColumn !== column) {
              const {
                model: oldModel
              } = oldColumn;
              if (oldModel.update) {
                setCellValue(row, oldColumn, oldModel.value);
              }
              if ($xeTable.clearValidate) {
                $xeTable.clearValidate(row, column);
              }
            }
            column.renderHeight = cell.offsetHeight;
            actived.args = params;
            actived.column = column;
            if (isPos) {
              setTimeout(() => {
                $xeTable.handleFocus(params, evnt);
              });
            }
          }
          focused.column = null;
          focused.row = null;
          $xeTable.focus();
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const handleEditCell = (row, fieldOrColumn, isPos) => {
      const {
        editConfig
      } = props;
      const column = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
      if (row && column && isEnableConf(editConfig) && isEnableConf(column.editRender)) {
        return Promise.resolve(isPos ? $xeTable.scrollToRow(row, column) : null).then(() => {
          const cell = $xeTable.getCellElement(row, column);
          if (cell) {
            handleEditActive({
              row,
              rowIndex: $xeTable.getRowIndex(row),
              column,
              columnIndex: $xeTable.getColumnIndex(column),
              cell,
              $table: $xeTable
            }, null, isPos, isPos);
            internalData._lastCallTime = Date.now();
          }
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    editMethods = {
      /**
       * 往表格中插入临时数据
       *
       * @param {*} records
       */
      insert(records) {
        return handleInsertRowAt(records, null);
      },
      /**
       * 往表格指定行中插入临时数据
       * 如果 row 为空则从插入到顶部，如果为树结构，则插入到目标节点顶部
       * 如果 row 为 -1 则从插入到底部，如果为树结构，则插入到目标节点底部
       * 如果 row 为有效行则插入到该行的位置，如果为树结构，则有插入到效的目标节点该行的位置
       * @param {Object/Array} records 新的数据
       * @param {Row} targetRow 指定行
       */
      insertAt(records, targetRow) {
        return handleInsertRowAt(records, targetRow);
      },
      insertNextAt(records, targetRow) {
        return handleInsertRowAt(records, targetRow, true);
      },
      insertChild(records, parentRow) {
        return handleInsertChildRowAt(records, parentRow, null);
      },
      insertChildAt(records, parentRow, targetRow) {
        return handleInsertChildRowAt(records, parentRow, targetRow);
      },
      insertChildNextAt(records, parentRow, targetRow) {
        return handleInsertChildRowAt(records, parentRow, targetRow, true);
      },
      /**
       * 删除指定行数据
       * 如果传 row 则删除一行
       * 如果传 rows 则删除多行
       * 如果为空则删除所有
       */
      remove(rows) {
        const {
          treeConfig
        } = props;
        const {
          editStore
        } = reactData;
        const {
          tableFullTreeData,
          selectCheckboxMaps,
          afterFullData,
          mergeBodyList,
          tableFullData,
          pendingRowMaps,
          insertRowMaps,
          removeRowMaps
        } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const treeOpts = computeTreeOpts.value;
        const {
          transform,
          mapChildrenField
        } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const {
          actived
        } = editStore;
        const {
          checkField
        } = checkboxOpts;
        let delList = [];
        if (!rows) {
          rows = tableFullData;
        } else if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
          rows = [rows];
        }
        // 如果是新增，则保存记录
        rows.forEach(row => {
          if (!$xeTable.isInsertByRow(row)) {
            const rowid = getRowid($xeTable, row);
            removeRowMaps[rowid] = row;
          }
        });
        // 如果绑定了多选属性，则更新状态
        if (!checkField) {
          rows.forEach(row => {
            const rowid = getRowid($xeTable, row);
            if (selectCheckboxMaps[rowid]) {
              delete selectCheckboxMaps[rowid];
            }
          });
          reactData.updateCheckboxFlag++;
        }
        // 从数据源中移除
        if (tableFullData === rows) {
          rows = delList = tableFullData.slice(0);
          internalData.tableFullData = [];
          internalData.afterFullData = [];
          $xeTable.clearMergeCells();
        } else {
          // 如果为虚拟树
          if (treeConfig && transform) {
            rows.forEach(row => {
              const rowid = getRowid($xeTable, row);
              const matchMapObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData, item => rowid === getRowid($xeTable, item), {
                children: mapChildrenField
              });
              if (matchMapObj) {
                const rItems = matchMapObj.items.splice(matchMapObj.index, 1);
                delList.push(rItems[0]);
              }
              const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData, item => rowid === getRowid($xeTable, item), {
                children: childrenField
              });
              if (matchObj) {
                matchObj.items.splice(matchObj.index, 1);
              }
              const afIndex = $xeTable.findRowIndexOf(afterFullData, row);
              if (afIndex > -1) {
                afterFullData.splice(afIndex, 1);
              }
            });
          } else {
            rows.forEach(row => {
              const tfIndex = $xeTable.findRowIndexOf(tableFullData, row);
              if (tfIndex > -1) {
                const rItems = tableFullData.splice(tfIndex, 1);
                delList.push(rItems[0]);
              }
              const afIndex = $xeTable.findRowIndexOf(afterFullData, row);
              if (afIndex > -1) {
                // 刷新单元格合并
                mergeBodyList.forEach(mergeItem => {
                  const {
                    row: mergeRowIndex,
                    rowspan: mergeRowspan
                  } = mergeItem;
                  if (mergeRowIndex > afIndex) {
                    mergeItem.row = mergeRowIndex - 1;
                  } else if (mergeRowIndex + mergeRowspan > afIndex) {
                    mergeItem.rowspan = mergeRowspan - 1;
                  }
                });
                afterFullData.splice(afIndex, 1);
              }
            });
          }
        }
        // 如果当前行被激活编辑，则清除激活状态
        if (actived.row && $xeTable.findRowIndexOf(rows, actived.row) > -1) {
          editMethods.clearEdit();
        }
        // 从新增中移除已删除的数据
        rows.forEach(row => {
          const rowid = getRowid($xeTable, row);
          if (insertRowMaps[rowid]) {
            delete insertRowMaps[rowid];
          }
          if (pendingRowMaps[rowid]) {
            delete pendingRowMaps[rowid];
          }
        });
        reactData.removeRowFlag++;
        reactData.insertRowFlag++;
        reactData.pendingRowFlag++;
        $xeTable.cacheRowMap(false);
        $xeTable.handleTableData(treeConfig && transform);
        $xeTable.updateFooter();
        $xeTable.handleUpdateBodyMerge();
        if (!(treeConfig && transform)) {
          $xeTable.updateAfterDataIndex();
        }
        $xeTable.checkSelectionStatus();
        if (reactData.scrollYLoad) {
          $xeTable.updateScrollYSpace();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
          $xeTable.updateCellAreas();
          return $xeTable.recalculate();
        }).then(() => {
          return {
            row: delList.length ? delList[delList.length - 1] : null,
            rows: delList
          };
        });
      },
      /**
       * 删除复选框选中的数据
       */
      removeCheckboxRow() {
        return editMethods.remove($xeTable.getCheckboxRecords()).then(params => {
          $xeTable.clearCheckboxRow();
          return params;
        });
      },
      /**
       * 删除单选框选中的数据
       */
      removeRadioRow() {
        const radioRecord = $xeTable.getRadioRecord();
        return editMethods.remove(radioRecord || []).then(params => {
          $xeTable.clearRadioRow();
          return params;
        });
      },
      /**
       * 删除当前行选中的数据
       */
      removeCurrentRow() {
        const currentRecord = $xeTable.getCurrentRecord();
        return editMethods.remove(currentRecord || []).then(params => {
          $xeTable.clearCurrentRow();
          return params;
        });
      },
      /**
       * 获取表格数据集，包含新增、删除、修改、标记
       */
      getRecordset() {
        const removeRecords = editMethods.getRemoveRecords();
        const pendingRecords = $xeTable.getPendingRecords();
        const delRecords = removeRecords.concat(pendingRecords);
        // 如果已经被删除，则无需放到更新数组
        const updateRecords = editMethods.getUpdateRecords().filter(row => {
          return !delRecords.some(item => $xeTable.eqRow(item, row));
        });
        return {
          insertRecords: editMethods.getInsertRecords(),
          removeRecords,
          updateRecords,
          pendingRecords
        };
      },
      /**
       * 获取新增的临时数据
       */
      getInsertRecords() {
        const {
          fullAllDataRowIdData,
          insertRowMaps
        } = internalData;
        const insertRecords = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(insertRowMaps, (row, rowid) => {
          if (fullAllDataRowIdData[rowid]) {
            insertRecords.push(row);
          }
        });
        return insertRecords;
      },
      /**
       * 获取已删除的数据
       */
      getRemoveRecords() {
        const {
          removeRowMaps
        } = internalData;
        const removeRecords = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(removeRowMaps, row => {
          removeRecords.push(row);
        });
        return removeRecords;
      },
      /**
       * 获取更新数据
       * 只精准匹配 row 的更改
       * 如果是树表格，子节点更改状态不会影响父节点的更新状态
       */
      getUpdateRecords() {
        const {
          keepSource,
          treeConfig
        } = props;
        const {
          tableFullData
        } = internalData;
        const treeOpts = computeTreeOpts.value;
        if (keepSource) {
          syncActivedCell();
          if (treeConfig) {
            return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().filterTree(tableFullData, row => $xeTable.isUpdateByRow(row), treeOpts);
          }
          return tableFullData.filter(row => $xeTable.isUpdateByRow(row));
        }
        return [];
      },
      getActiveRecord() {
        if (true) {
          warnLog('vxe.error.delFunc', ['getActiveRecord', 'getEditRecord']);
        }
        return $xeTable.getEditRecord();
      },
      getEditRecord() {
        const {
          editStore
        } = reactData;
        const {
          afterFullData
        } = internalData;
        const el = refElem.value;
        const {
          args,
          row
        } = editStore.actived;
        if (args && $xeTable.findRowIndexOf(afterFullData, row) > -1 && el.querySelectorAll('.vxe-body--column.col--active').length) {
          return Object.assign({}, args);
        }
        return null;
      },
      /**
       * 获取选中的单元格
       */
      getSelectedCell() {
        const {
          editStore
        } = reactData;
        const {
          args,
          column
        } = editStore.selected;
        if (args && column) {
          return Object.assign({}, args);
        }
        return null;
      },
      clearActived(row) {
        // 即将废弃
        if (true) {
          warnLog('vxe.error.delFunc', ['clearActived', 'clearEdit']);
        }
        return $xeTable.clearEdit(row);
      },
      /**
       * 清除激活的编辑
       */
      clearEdit(row) {
        return handleClearEdit(null, row);
      },
      /**
       * 清除所选中源状态
       */
      clearSelected() {
        const {
          editStore
        } = reactData;
        const {
          selected
        } = editStore;
        selected.row = null;
        selected.column = null;
        removeCellSelectedClass();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      isActiveByRow(row) {
        if (true) {
          warnLog('vxe.error.delFunc', ['isActiveByRow', 'isEditByRow']);
        }
        // 即将废弃
        return $xeTable.isEditByRow(row);
      },
      /**
       * 判断行是否为激活编辑状态
       * @param {Row} row 行对象
       */
      isEditByRow(row) {
        const {
          editStore
        } = reactData;
        return editStore.actived.row === row;
      },
      setActiveRow(row) {
        if (true) {
          warnLog('vxe.error.delFunc', ['setActiveRow', 'setEditRow']);
        }
        // 即将废弃
        return editMethods.setEditRow(row);
      },
      /**
       * 激活行编辑
       */
      setEditRow(row, fieldOrColumn) {
        const {
          visibleColumn
        } = internalData;
        let column = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(visibleColumn, column => isEnableConf(column.editRender));
        let isPos = false;
        if (fieldOrColumn) {
          isPos = true;
          if (fieldOrColumn !== true) {
            column = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
          }
        }
        return handleEditCell(row, column, isPos);
      },
      setActiveCell(row, fieldOrColumn) {
        if (true) {
          warnLog('vxe.error.delFunc', ['setActiveCell', 'setEditCell']);
        }
        // 即将废弃
        return editMethods.setEditCell(row, fieldOrColumn);
      },
      /**
       * 激活单元格编辑
       */
      setEditCell(row, fieldOrColumn) {
        return handleEditCell(row, fieldOrColumn, true);
      },
      /**
       * 只对 trigger=dblclick 有效，选中单元格
       */
      setSelectCell(row, fieldOrColumn) {
        const {
          tableData
        } = reactData;
        const editOpts = computeEditOpts.value;
        const column = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
        if (row && column && editOpts.trigger !== 'manual') {
          const rowIndex = $xeTable.findRowIndexOf(tableData, row);
          if (rowIndex > -1 && column) {
            const cell = $xeTable.getCellElement(row, column);
            const params = {
              row,
              rowIndex,
              column,
              columnIndex: $xeTable.getColumnIndex(column),
              cell
            };
            $xeTable.handleSelected(params, {});
          }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    editPrivateMethods = {
      /**
       * 处理激活编辑
       */
      handleEdit(params, evnt) {
        return handleEditActive(params, evnt, true, true);
      },
      /**
       * @deprecated
       */
      handleActived(params, evnt) {
        return editPrivateMethods.handleEdit(params, evnt);
      },
      /**
       * 处理取消编辑
       * @param evnt
       * @returns
       */
      handleClearEdit,
      /**
       * 处理聚焦
       */
      handleFocus(params) {
        const {
          row,
          column,
          cell
        } = params;
        const {
          editRender
        } = column;
        const editOpts = computeEditOpts.value;
        if (isEnableConf(editRender)) {
          const compRender = edit_hook_renderer.get(editRender.name);
          let autoFocus = editRender.autofocus || editRender.autoFocus;
          let autoSelect = editRender.autoSelect || editRender.autoselect;
          let inputElem;
          // 是否启用聚焦
          if (editOpts.autoFocus) {
            if (!autoFocus && compRender) {
              autoFocus = compRender.tableAutoFocus || compRender.tableAutofocus || compRender.autofocus;
            }
            if (!autoSelect && compRender) {
              autoSelect = compRender.tableAutoSelect || compRender.autoselect;
            }
            // 如果指定了聚焦 class
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(autoFocus)) {
              inputElem = autoFocus(params);
            } else if (autoFocus) {
              if (autoFocus === true) {
                // 自动匹配模式，会自动匹配第一个可输入元素
                inputElem = cell.querySelector('input,textarea');
              } else {
                inputElem = cell.querySelector(autoFocus);
              }
              if (inputElem) {
                inputElem.focus();
              }
            }
          }
          if (inputElem) {
            if (autoSelect) {
              inputElem.select();
            } else {
              // 保持一致行为，光标移到末端
              if (browseObj.msie) {
                const textRange = inputElem.createTextRange();
                textRange.collapse(false);
                textRange.select();
              }
            }
          } else {
            // 是否自动定位
            if (editOpts.autoPos) {
              if (!column.fixed) {
                // 显示到可视区中
                $xeTable.scrollToRow(row, column);
              }
            }
          }
        }
      },
      /**
       * 处理选中源
       */
      handleSelected(params, evnt) {
        const {
          mouseConfig
        } = props;
        const {
          editStore
        } = reactData;
        const mouseOpts = computeMouseOpts.value;
        const editOpts = computeEditOpts.value;
        const {
          actived,
          selected
        } = editStore;
        const {
          row,
          column
        } = params;
        const isMouseSelected = mouseConfig && mouseOpts.selected;
        const selectMethod = () => {
          if (isMouseSelected && (selected.row !== row || selected.column !== column)) {
            if (actived.row !== row || (editOpts.mode === 'cell' ? actived.column !== column : false)) {
              handleClearEdit(evnt);
              $xeTable.clearSelected();
              if ($xeTable.clearCellAreas) {
                $xeTable.clearCellAreas();
                $xeTable.clearCopyCellArea();
              }
              selected.args = params;
              selected.row = row;
              selected.column = column;
              if (isMouseSelected) {
                editPrivateMethods.addCellSelectedClass();
              }
              $xeTable.focus();
              if (evnt) {
                $xeTable.dispatchEvent('cell-selected', params, evnt);
              }
            }
          }
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        };
        return selectMethod();
      },
      addCellSelectedClass() {
        const {
          editStore
        } = reactData;
        const {
          selected
        } = editStore;
        const {
          row,
          column
        } = selected;
        removeCellSelectedClass();
        if (row && column) {
          const cell = $xeTable.getCellElement(row, column);
          if (cell) {
            addClass(cell, 'col--selected');
          }
        }
      }
    };
    return {
      ...editMethods,
      ...editPrivateMethods
    };
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableEditMethodKeys);
  }
});
;// ./packages/table/module/export/util.ts
// 默认导出或打印的 HTML 样式
const defaultHtmlStyle = 'body{margin:0;padding: 0 1px;color:#333333;font-size:14px;font-family:"Microsoft YaHei",微软雅黑,"MicrosoftJhengHei",华文细黑,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type="checkbox"]{margin:0}.vxe-table input[type="checkbox"],.vxe-table input[type="radio"],.vxe-table input[type="checkbox"]+span,.vxe-table input[type="radio"]+span{vertical-align:middle;padding-left:0.4em}';
function getExportBlobByContent(content, options) {
  return new Blob([content], {
    type: `text/${options.type};charset=utf-8;`
  });
}
function createHtmlPage(opts, content) {
  const {
    style
  } = opts;
  return ['<!DOCTYPE html><html>', '<head>', '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">', `<title>${opts.sheetName}</title>`, '<style media="print">.vxe-page-break-before{page-break-before:always;}.vxe-page-break-after{page-break-after:always;}</style>', `<style>${defaultHtmlStyle}</style>`, style ? `<style>${style}</style>` : '', '</head>', `<body>${content}</body>`, '</html>'].join('');
}
;// ./packages/table/module/export/hook.ts















const {
  getI18n: export_hook_getI18n,
  hooks: export_hook_hooks,
  renderer: export_hook_renderer
} = core_.VxeUI;
let htmlCellElem;
const csvBOM = '\ufeff';
const enterSymbol = '\r\n';
function defaultFilterExportColumn(column) {
  return column.field || ['seq', 'checkbox', 'radio'].indexOf(column.type) > -1;
}
const getConvertColumns = columns => {
  const result = [];
  columns.forEach(column => {
    if (column.childNodes && column.childNodes.length) {
      result.push(column);
      result.push(...getConvertColumns(column.childNodes));
    } else {
      result.push(column);
    }
  });
  return result;
};
const convertToRows = originColumns => {
  let maxLevel = 1;
  const traverse = (column, parent) => {
    if (parent) {
      column._level = parent._level + 1;
      if (maxLevel < column._level) {
        maxLevel = column._level;
      }
    }
    if (column.childNodes && column.childNodes.length) {
      let colSpan = 0;
      column.childNodes.forEach(subColumn => {
        traverse(subColumn, column);
        colSpan += subColumn._colSpan;
      });
      column._colSpan = colSpan;
    } else {
      column._colSpan = 1;
    }
  };
  originColumns.forEach(column => {
    column._level = 1;
    traverse(column);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getConvertColumns(originColumns);
  allColumns.forEach(column => {
    if (column.childNodes && column.childNodes.length) {
      column._rowSpan = 1;
    } else {
      column._rowSpan = maxLevel - column._level + 1;
    }
    rows[column._level - 1].push(column);
  });
  return rows;
};
function toTableBorder(border) {
  if (border === true) {
    return 'full';
  }
  if (border) {
    return border;
  }
  return 'default';
}
function getBooleanValue(cellValue) {
  return cellValue === 'TRUE' || cellValue === 'true' || cellValue === true;
}
function getFooterData($xeTable, opts, footerTableData) {
  const {
    footerFilterMethod
  } = opts;
  return footerFilterMethod ? footerTableData.filter((items, index) => footerFilterMethod({
    $table: $xeTable,
    items,
    $rowIndex: index
  })) : footerTableData;
}
function getCsvCellTypeLabel(column, cellValue) {
  if (cellValue) {
    if (column.type === 'seq') {
      return `\t${cellValue}`;
    }
    switch (column.cellType) {
      case 'string':
        if (!isNaN(cellValue)) {
          return `\t${cellValue}`;
        }
        break;
      case 'number':
        break;
      default:
        if (cellValue.length >= 12 && !isNaN(cellValue)) {
          return `\t${cellValue}`;
        }
        break;
    }
  }
  return cellValue;
}
function toTxtCellLabel(val) {
  if (/[",\s\n]/.test(val)) {
    return `"${val.replace(/"/g, '""')}"`;
  }
  return val;
}
function getElementsByTagName(elem, qualifiedName) {
  return elem.getElementsByTagName(qualifiedName);
}
function getTxtCellKey(now) {
  return `#${now}@${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId()}`;
}
function replaceTxtCell(cell, vMaps) {
  return cell.replace(/#\d+@\d+/g, key => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().hasOwnProp(vMaps, key) ? vMaps[key] : key);
}
function getTxtCellValue(val, vMaps) {
  const rest = replaceTxtCell(val, vMaps);
  return rest.replace(/^"+$/g, qVal => '"'.repeat(Math.ceil(qVal.length / 2)));
}
function toExportField(tableConf, field) {
  const {
    fieldMaps,
    titleMaps
  } = tableConf;
  // title 转 field
  if (!fieldMaps[field]) {
    const teCol = titleMaps[field];
    if (teCol && teCol.field) {
      field = teCol.field;
    }
  }
  return field;
}
function parseCsvAndTxt(tableConf, content, cellSeparator) {
  const list = content.split(enterSymbol);
  const rows = [];
  let fields = [];
  if (list.length) {
    const vMaps = {};
    const now = Date.now();
    list.forEach(rVal => {
      if (rVal) {
        const item = {};
        rVal = rVal.replace(/("")|(\n)/g, (text, dVal) => {
          const key = getTxtCellKey(now);
          vMaps[key] = dVal ? '"' : '\n';
          return key;
        }).replace(/"(.*?)"/g, (text, cVal) => {
          const key = getTxtCellKey(now);
          vMaps[key] = replaceTxtCell(cVal, vMaps);
          return key;
        });
        const cells = rVal.split(cellSeparator);
        if (!fields.length) {
          fields = cells.map(val => toExportField(tableConf, getTxtCellValue(val.trim(), vMaps)));
        } else {
          cells.forEach((val, colIndex) => {
            if (colIndex < fields.length) {
              item[fields[colIndex]] = getTxtCellValue(val.trim(), vMaps);
            }
          });
          rows.push(item);
        }
      }
    });
  }
  return {
    fields,
    rows
  };
}
function parseCsv(tableConf, content) {
  return parseCsvAndTxt(tableConf, content, ',');
}
function parseTxt(tableConf, content) {
  return parseCsvAndTxt(tableConf, content, '\t');
}
function parseHTML(tableConf, content) {
  const domParser = new DOMParser();
  const xmlDoc = domParser.parseFromString(content, 'text/html');
  const bodyNodes = getElementsByTagName(xmlDoc, 'body');
  const rows = [];
  const fields = [];
  if (bodyNodes.length) {
    const tableNodes = getElementsByTagName(bodyNodes[0], 'table');
    if (tableNodes.length) {
      const theadNodes = getElementsByTagName(tableNodes[0], 'thead');
      if (theadNodes.length) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(getElementsByTagName(theadNodes[0], 'tr'), rowNode => {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(getElementsByTagName(rowNode, 'th'), cellNode => {
            fields.push(toExportField(tableConf, cellNode.textContent || ''));
          });
        });
        const tbodyNodes = getElementsByTagName(tableNodes[0], 'tbody');
        if (tbodyNodes.length) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(getElementsByTagName(tbodyNodes[0], 'tr'), rowNode => {
            const item = {};
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(getElementsByTagName(rowNode, 'td'), (cellNode, colIndex) => {
              if (fields[colIndex]) {
                item[fields[colIndex]] = cellNode.textContent || '';
              }
            });
            rows.push(item);
          });
        }
      }
    }
  }
  return {
    fields,
    rows
  };
}
function parseXML(tableConf, content) {
  const domParser = new DOMParser();
  const xmlDoc = domParser.parseFromString(content, 'application/xml');
  const sheetNodes = getElementsByTagName(xmlDoc, 'Worksheet');
  const rows = [];
  const fields = [];
  if (sheetNodes.length) {
    const tableNodes = getElementsByTagName(sheetNodes[0], 'Table');
    if (tableNodes.length) {
      const rowNodes = getElementsByTagName(tableNodes[0], 'Row');
      if (rowNodes.length) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(getElementsByTagName(rowNodes[0], 'Cell'), cellNode => {
          fields.push(toExportField(tableConf, cellNode.textContent || ''));
        });
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(rowNodes, (rowNode, index) => {
          if (index) {
            const item = {};
            const cellNodes = getElementsByTagName(rowNode, 'Cell');
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(cellNodes, (cellNode, colIndex) => {
              if (fields[colIndex]) {
                item[fields[colIndex]] = cellNode.textContent;
              }
            });
            rows.push(item);
          }
        });
      }
    }
  }
  return {
    fields,
    rows
  };
}
function clearColumnConvert(columns) {
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(columns, column => {
    delete column._level;
    delete column._colSpan;
    delete column._rowSpan;
    delete column._children;
    delete column.childNodes;
  }, {
    children: 'children'
  });
}
const tableExportMethodKeys = ['exportData', 'importByFile', 'importData', 'saveFile', 'readFile', 'print', 'getPrintHtml', 'openImport', 'closeImport', 'openExport', 'closeExport', 'openPrint', 'closePrint'];
export_hook_hooks.add('tableExportModule', {
  setupTable($xeTable) {
    const {
      props,
      reactData,
      internalData
    } = $xeTable;
    const {
      computeTreeOpts,
      computePrintOpts,
      computeExportOpts,
      computeImportOpts,
      computeCustomOpts,
      computeSeqOpts,
      computeRadioOpts,
      computeCheckboxOpts,
      computeColumnOpts
    } = $xeTable.getComputeMaps();
    const $xeGrid = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeGrid', null);
    const hasTreeChildren = row => {
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      return row[childrenField] && row[childrenField].length;
    };
    const getSeq = (cellValue, row, $rowIndex, column, $columnIndex) => {
      const seqOpts = computeSeqOpts.value;
      const seqMethod = seqOpts.seqMethod || column.seqMethod;
      if (seqMethod) {
        return seqMethod({
          $table: $xeTable,
          row,
          rowIndex: $xeTable.getRowIndex(row),
          $rowIndex,
          column,
          columnIndex: $xeTable.getColumnIndex(column),
          $columnIndex
        });
      }
      return cellValue;
    };
    function getHeaderTitle(opts, column) {
      const columnOpts = computeColumnOpts.value;
      const headExportMethod = column.headerExportMethod || columnOpts.headerExportMethod;
      return headExportMethod ? headExportMethod({
        column,
        options: opts,
        $table: $xeTable
      }) : (opts.isTitle ? column.getTitle() : column.field) || '';
    }
    const toBooleanValue = cellValue => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(cellValue) ? cellValue ? 'TRUE' : 'FALSE' : cellValue;
    };
    const toStringValue = cellValue => {
      return eqEmptyValue(cellValue) ? '' : `${cellValue}`;
    };
    const getBodyLabelData = (opts, columns, datas) => {
      const {
        isAllExpand,
        mode
      } = opts;
      const {
        treeConfig
      } = props;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const treeOpts = computeTreeOpts.value;
      const columnOpts = computeColumnOpts.value;
      if (!htmlCellElem) {
        htmlCellElem = document.createElement('div');
      }
      if (treeConfig) {
        const childrenField = treeOpts.children || treeOpts.childrenField;
        // 如果是树表格只允许导出数据源
        const rest = [];
        const expandMaps = new Map();
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(datas, (item, $rowIndex, items, path, parent, nodes) => {
          const row = item._row || item;
          const parentRow = parent && parent._row ? parent._row : parent;
          if (isAllExpand || !parentRow || expandMaps.has(parentRow) && $xeTable.isTreeExpandByRow(parentRow)) {
            const hasRowChild = hasTreeChildren(row);
            const item = {
              _row: row,
              _level: nodes.length - 1,
              _hasChild: hasRowChild,
              _expand: hasRowChild && $xeTable.isTreeExpandByRow(row)
            };
            columns.forEach((column, $columnIndex) => {
              let cellValue = '';
              const renderOpts = column.editRender || column.cellRender;
              let bodyExportMethod = column.exportMethod || columnOpts.exportMethod;
              if (!bodyExportMethod && renderOpts && renderOpts.name) {
                const compConf = export_hook_renderer.get(renderOpts.name);
                if (compConf) {
                  bodyExportMethod = compConf.tableExportMethod || compConf.exportMethod;
                }
              }
              if (!bodyExportMethod) {
                bodyExportMethod = columnOpts.exportMethod;
              }
              if (bodyExportMethod) {
                cellValue = bodyExportMethod({
                  $table: $xeTable,
                  row,
                  column,
                  options: opts
                });
              } else {
                switch (column.type) {
                  case 'seq':
                    {
                      const seqVal = path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : '.').join('');
                      cellValue = mode === 'all' ? seqVal : getSeq(seqVal, row, $rowIndex, column, $columnIndex);
                      break;
                    }
                  case 'checkbox':
                    cellValue = toBooleanValue($xeTable.isCheckedByCheckboxRow(row));
                    item._checkboxLabel = checkboxOpts.labelField ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkboxOpts.labelField) : '';
                    item._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({
                      $table: $xeTable,
                      row
                    });
                    break;
                  case 'radio':
                    cellValue = toBooleanValue($xeTable.isCheckedByRadioRow(row));
                    item._radioLabel = radioOpts.labelField ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, radioOpts.labelField) : '';
                    item._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({
                      $table: $xeTable,
                      row
                    });
                    break;
                  default:
                    if (opts.original) {
                      cellValue = getCellValue(row, column);
                    } else {
                      cellValue = $xeTable.getCellLabel(row, column);
                      if (column.type === 'html') {
                        htmlCellElem.innerHTML = cellValue;
                        cellValue = htmlCellElem.innerText.trim();
                      } else {
                        const cell = $xeTable.getCellElement(row, column);
                        if (cell && !hasClass(cell, 'is--progress')) {
                          cellValue = cell.innerText.trim();
                        }
                      }
                    }
                }
              }
              item[column.id] = toStringValue(cellValue);
            });
            expandMaps.set(row, 1);
            rest.push(Object.assign(item, row));
          }
        }, {
          children: childrenField
        });
        return rest;
      }
      return datas.map((row, $rowIndex) => {
        const item = {
          _row: row
        };
        columns.forEach((column, $columnIndex) => {
          let cellValue = '';
          const renderOpts = column.editRender || column.cellRender;
          let bodyExportMethod = column.exportMethod || columnOpts.exportMethod;
          if (!bodyExportMethod && renderOpts && renderOpts.name) {
            const compConf = export_hook_renderer.get(renderOpts.name);
            if (compConf) {
              bodyExportMethod = compConf.tableExportMethod || compConf.exportMethod;
            }
          }
          if (bodyExportMethod) {
            cellValue = bodyExportMethod({
              $table: $xeTable,
              row,
              column,
              options: opts
            });
          } else {
            switch (column.type) {
              case 'seq':
                {
                  const seqValue = $rowIndex + 1;
                  cellValue = mode === 'all' ? seqValue : getSeq(seqValue, row, $rowIndex, column, $columnIndex);
                  break;
                }
              case 'checkbox':
                cellValue = toBooleanValue($xeTable.isCheckedByCheckboxRow(row));
                item._checkboxLabel = checkboxOpts.labelField ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkboxOpts.labelField) : '';
                item._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({
                  $table: $xeTable,
                  row
                });
                break;
              case 'radio':
                cellValue = toBooleanValue($xeTable.isCheckedByRadioRow(row));
                item._radioLabel = radioOpts.labelField ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, radioOpts.labelField) : '';
                item._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({
                  $table: $xeTable,
                  row
                });
                break;
              default:
                if (opts.original) {
                  cellValue = getCellValue(row, column);
                } else {
                  cellValue = $xeTable.getCellLabel(row, column);
                  if (column.type === 'html') {
                    htmlCellElem.innerHTML = cellValue;
                    cellValue = htmlCellElem.innerText.trim();
                  } else {
                    const cell = $xeTable.getCellElement(row, column);
                    if (cell && !hasClass(cell, 'is--progress')) {
                      cellValue = cell.innerText.trim();
                    }
                  }
                }
            }
          }
          item[column.id] = toStringValue(cellValue);
        });
        return item;
      });
    };
    const getExportData = opts => {
      const {
        columns,
        dataFilterMethod
      } = opts;
      let datas = opts.data;
      if (dataFilterMethod) {
        datas = datas.filter((row, index) => dataFilterMethod({
          $table: $xeTable,
          row,
          $rowIndex: index
        }));
      }
      return getBodyLabelData(opts, columns, datas);
    };
    const getFooterCellValue = (opts, row, column) => {
      const columnOpts = computeColumnOpts.value;
      const renderOpts = column.editRender || column.cellRender;
      let footLabelMethod = column.footerExportMethod;
      if (!footLabelMethod && renderOpts && renderOpts.name) {
        const compConf = export_hook_renderer.get(renderOpts.name);
        if (compConf) {
          footLabelMethod = compConf.tableFooterExportMethod || compConf.footerExportMethod;
        }
      }
      if (!footLabelMethod) {
        footLabelMethod = columnOpts.footerExportMethod;
      }
      const _columnIndex = $xeTable.getVTColumnIndex(column);
      if (footLabelMethod) {
        return footLabelMethod({
          $table: $xeTable,
          items: row,
          itemIndex: _columnIndex,
          row,
          _columnIndex,
          column,
          options: opts
        });
      }
      // 兼容老模式
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(row)) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(row[_columnIndex]);
      }
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
    };
    const toCsv = ($xeTable, opts, columns, datas) => {
      let content = csvBOM;
      if (opts.isHeader) {
        content += columns.map(column => toTxtCellLabel(getHeaderTitle(opts, column))).join(',') + enterSymbol;
      }
      datas.forEach(row => {
        content += columns.map(column => toTxtCellLabel(getCsvCellTypeLabel(column, row[column.id]))).join(',') + enterSymbol;
      });
      if (opts.isFooter) {
        const {
          footerTableData
        } = reactData;
        const footers = getFooterData($xeTable, opts, footerTableData);
        footers.forEach(row => {
          content += columns.map(column => toTxtCellLabel(getFooterCellValue(opts, row, column))).join(',') + enterSymbol;
        });
      }
      return content;
    };
    const toTxt = ($xeTable, opts, columns, datas) => {
      let content = '';
      if (opts.isHeader) {
        content += columns.map(column => toTxtCellLabel(getHeaderTitle(opts, column))).join('\t') + enterSymbol;
      }
      datas.forEach(row => {
        content += columns.map(column => toTxtCellLabel(row[column.id])).join('\t') + enterSymbol;
      });
      if (opts.isFooter) {
        const {
          footerTableData
        } = reactData;
        const footers = getFooterData($xeTable, opts, footerTableData);
        footers.forEach(row => {
          content += columns.map(column => toTxtCellLabel(getFooterCellValue(opts, row, column))).join('\t') + enterSymbol;
        });
      }
      return content;
    };
    const hasEllipsis = (column, property, allColumnOverflow) => {
      const columnOverflow = column[property];
      const headOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(columnOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(columnOverflow) ? allColumnOverflow : columnOverflow;
      const showEllipsis = headOverflow === 'ellipsis';
      const showTitle = headOverflow === 'title';
      const showTooltip = headOverflow === true || headOverflow === 'tooltip';
      let isEllipsis = showTitle || showTooltip || showEllipsis;
      // 虚拟滚动不支持动态高度
      const {
        scrollXLoad,
        scrollYLoad
      } = reactData;
      if ((scrollXLoad || scrollYLoad) && !isEllipsis) {
        isEllipsis = true;
      }
      return isEllipsis;
    };
    const toHtml = (opts, columns, datas) => {
      const {
        id,
        border,
        treeConfig,
        headerAlign: allHeaderAlign,
        align: allAlign,
        footerAlign: allFooterAlign,
        showOverflow: allColumnOverflow,
        showHeaderOverflow: allColumnHeaderOverflow
      } = props;
      const {
        isAllSelected,
        isIndeterminate
      } = reactData;
      const {
        mergeBodyCellMaps
      } = internalData;
      const treeOpts = computeTreeOpts.value;
      const {
        print: isPrint,
        isHeader,
        isFooter,
        isColgroup,
        isMerge,
        colgroups,
        original
      } = opts;
      const allCls = 'check-all';
      const clss = ['vxe-table', `border--${toTableBorder(border)}`, isPrint ? 'is--print' : '', isHeader ? 'is--header' : ''].filter(cls => cls);
      const tables = [`<table class="${clss.join(' ')}" border="0" cellspacing="0" cellpadding="0">`, `<colgroup>${columns.map(column => `<col style="width:${column.renderWidth}px">`).join('')}</colgroup>`];
      if (isHeader) {
        tables.push('<thead>');
        if (isColgroup && !original) {
          colgroups.forEach(cols => {
            tables.push(`<tr>${cols.map(column => {
              const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;
              const classNames = hasEllipsis(column, 'showHeaderOverflow', allColumnHeaderOverflow) ? ['col--ellipsis'] : [];
              const cellTitle = getHeaderTitle(opts, column);
              let childWidth = 0;
              let countChild = 0;
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], item => {
                if (!item.childNodes || !column.childNodes.length) {
                  countChild++;
                }
                childWidth += item.renderWidth;
              }, {
                children: 'childNodes'
              });
              const cellWidth = childWidth - countChild;
              if (headAlign) {
                classNames.push(`col--${headAlign}`);
              }
              if (column.type === 'checkbox') {
                return `<th class="${classNames.join(' ')}" colspan="${column._colSpan}" rowspan="${column._rowSpan}"><div ${isPrint ? '' : `style="width: ${cellWidth}px"`}><input type="checkbox" class="${allCls}" ${isAllSelected ? 'checked' : ''}><span>${cellTitle}</span></div></th>`;
              }
              return `<th class="${classNames.join(' ')}" colspan="${column._colSpan}" rowspan="${column._rowSpan}" title="${cellTitle}"><div ${isPrint ? '' : `style="width: ${cellWidth}px"`}><span>${formatText(cellTitle, true)}</span></div></th>`;
            }).join('')}</tr>`);
          });
        } else {
          tables.push(`<tr>${columns.map(column => {
            const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;
            const classNames = hasEllipsis(column, 'showHeaderOverflow', allColumnHeaderOverflow) ? ['col--ellipsis'] : [];
            const cellTitle = getHeaderTitle(opts, column);
            if (headAlign) {
              classNames.push(`col--${headAlign}`);
            }
            if (column.type === 'checkbox') {
              return `<th class="${classNames.join(' ')}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><input type="checkbox" class="${allCls}" ${isAllSelected ? 'checked' : ''}><span>${cellTitle}</span></div></th>`;
            }
            return `<th class="${classNames.join(' ')}" title="${cellTitle}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><span>${formatText(cellTitle, true)}</span></div></th>`;
          }).join('')}</tr>`);
        }
        tables.push('</thead>');
      }
      if (datas.length) {
        tables.push('<tbody>');
        if (treeConfig) {
          datas.forEach(item => {
            tables.push('<tr>' + columns.map(column => {
              const colid = column.id;
              const cellAlign = column.align || allAlign;
              const classNames = hasEllipsis(column, 'showOverflow', allColumnOverflow) ? ['col--ellipsis'] : [];
              const cellValue = item[colid];
              if (cellAlign) {
                classNames.push(`col--${cellAlign}`);
              }
              if (column.treeNode) {
                let treeIcon = '';
                if (item._hasChild) {
                  treeIcon = `<i class="${item._expand ? 'vxe-table--tree-fold-icon' : 'vxe-table--tree-unfold-icon'}"></i>`;
                }
                classNames.push('vxe-table--tree-node');
                if (column.type === 'radio') {
                  return `<td class="${classNames.join(' ')}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell"><input type="radio" name="radio_${id}" ${item._radioDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._radioLabel}</span></div></div></div></td>`;
                } else if (column.type === 'checkbox') {
                  return `<td class="${classNames.join(' ')}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell"><input type="checkbox" ${item._checkboxDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._checkboxLabel}</span></div></div></div></td>`;
                }
                return `<td class="${classNames.join(' ')}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell">${cellValue}</div></div></div></td>`;
              }
              if (column.type === 'radio') {
                return `<td class="${classNames.join(' ')}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><input type="radio" name="radio_${id}" ${item._radioDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._radioLabel}</span></div></td>`;
              } else if (column.type === 'checkbox') {
                return `<td class="${classNames.join(' ')}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><input type="checkbox" ${item._checkboxDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._checkboxLabel}</span></div></td>`;
              }
              return `<td class="${classNames.join(' ')}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join('') + '</tr>');
          });
        } else {
          datas.forEach(item => {
            tables.push('<tr>' + columns.map(column => {
              const cellAlign = column.align || allAlign;
              const classNames = hasEllipsis(column, 'showOverflow', allColumnOverflow) ? ['col--ellipsis'] : [];
              const cellValue = item[column.id];
              let rowSpan = 1;
              let colSpan = 1;
              if (isMerge) {
                const _rowIndex = $xeTable.getVTRowIndex(item._row);
                const _columnIndex = $xeTable.getVTColumnIndex(column);
                const spanRest = mergeBodyCellMaps[`${_rowIndex}:${_columnIndex}`];
                if (spanRest) {
                  const {
                    rowspan,
                    colspan
                  } = spanRest;
                  if (!rowspan || !colspan) {
                    return '';
                  }
                  if (rowspan > 1) {
                    rowSpan = rowspan;
                  }
                  if (colspan > 1) {
                    colSpan = colspan;
                  }
                }
              }
              if (cellAlign) {
                classNames.push(`col--${cellAlign}`);
              }
              if (column.type === 'radio') {
                return `<td class="${classNames.join(' ')}" rowspan="${rowSpan}" colspan="${colSpan}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><input type="radio" name="radio_${id}" ${item._radioDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._radioLabel}</span></div></td>`;
              } else if (column.type === 'checkbox') {
                return `<td class="${classNames.join(' ')}" rowspan="${rowSpan}" colspan="${colSpan}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><input type="checkbox" ${item._checkboxDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._checkboxLabel}</span></div></td>`;
              }
              return `<td class="${classNames.join(' ')}" rowspan="${rowSpan}" colspan="${colSpan}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join('') + '</tr>');
          });
        }
        tables.push('</tbody>');
      }
      if (isFooter) {
        const {
          footerTableData
        } = reactData;
        const footers = getFooterData($xeTable, opts, footerTableData);
        if (footers.length) {
          tables.push('<tfoot>');
          footers.forEach(row => {
            tables.push(`<tr>${columns.map(column => {
              const footAlign = column.footerAlign || column.align || allFooterAlign || allAlign;
              const classNames = hasEllipsis(column, 'showOverflow', allColumnOverflow) ? ['col--ellipsis'] : [];
              const cellValue = getFooterCellValue(opts, row, column);
              if (footAlign) {
                classNames.push(`col--${footAlign}`);
              }
              return `<td class="${classNames.join(' ')}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join('')}</tr>`);
          });
          tables.push('</tfoot>');
        }
      }
      // 是否半选状态
      const script = !isAllSelected && isIndeterminate ? `<script>(function(){var a=document.querySelector(".${allCls}");if(a){a.indeterminate=true}})()</script>` : '';
      tables.push('</table>', script);
      return isPrint ? tables.join('') : createHtmlPage(opts, tables.join(''));
    };
    const toXML = (opts, columns, datas) => {
      let xml = ['<?xml version="1.0"?>', '<?mso-application progid="Excel.Sheet"?>', '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" xmlns:html="http://www.w3.org/TR/REC-html40">', '<DocumentProperties xmlns="urn:schemas-microsoft-com:office:office">', '<Version>16.00</Version>', '</DocumentProperties>', '<ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel">', '<WindowHeight>7920</WindowHeight>', '<WindowWidth>21570</WindowWidth>', '<WindowTopX>32767</WindowTopX>', '<WindowTopY>32767</WindowTopY>', '<ProtectStructure>False</ProtectStructure>', '<ProtectWindows>False</ProtectWindows>', '</ExcelWorkbook>', `<Worksheet ss:Name="${opts.sheetName}">`, '<Table>', columns.map(column => `<Column ss:Width="${column.renderWidth}"/>`).join('')].join('');
      if (opts.isHeader) {
        xml += `<Row>${columns.map(column => `<Cell><Data ss:Type="String">${getHeaderTitle(opts, column)}</Data></Cell>`).join('')}</Row>`;
      }
      datas.forEach(row => {
        xml += '<Row>' + columns.map(column => `<Cell><Data ss:Type="String">${row[column.id]}</Data></Cell>`).join('') + '</Row>';
      });
      if (opts.isFooter) {
        const {
          footerTableData
        } = reactData;
        const footers = getFooterData($xeTable, opts, footerTableData);
        footers.forEach(row => {
          xml += `<Row>${columns.map(column => `<Cell><Data ss:Type="String">${getFooterCellValue(opts, row, column)}</Data></Cell>`).join('')}</Row>`;
        });
      }
      return `${xml}</Table></Worksheet></Workbook>`;
    };
    const getContent = ($xeTable, opts, columns, datas) => {
      if (columns.length) {
        switch (opts.type) {
          case 'csv':
            return toCsv($xeTable, opts, columns, datas);
          case 'txt':
            return toTxt($xeTable, opts, columns, datas);
          case 'html':
            return toHtml(opts, columns, datas);
          case 'xml':
            return toXML(opts, columns, datas);
        }
      }
      return '';
    };
    const downloadFile = (opts, content) => {
      const {
        filename,
        type,
        download
      } = opts;
      if (!download) {
        const blob = getExportBlobByContent(content, opts);
        return Promise.resolve({
          type,
          content,
          blob
        });
      }
      if (core_.VxeUI.saveFile) {
        core_.VxeUI.saveFile({
          filename,
          type,
          content
        }).then(() => {
          if (opts.message !== false) {
            if (core_.VxeUI.modal) {
              core_.VxeUI.modal.message({
                content: export_hook_getI18n('vxe.table.expSuccess'),
                status: 'success'
              });
            }
          }
        });
      }
    };
    const handleExport = opts => {
      const {
        remote,
        columns,
        colgroups,
        exportMethod,
        afterExportMethod
      } = opts;
      return new Promise(resolve => {
        if (remote) {
          const params = {
            options: opts,
            $table: $xeTable,
            $grid: $xeGrid
          };
          resolve(exportMethod ? exportMethod(params) : params);
        } else {
          const datas = getExportData(opts);
          resolve($xeTable.preventEvent(null, 'event.export', {
            options: opts,
            columns,
            colgroups,
            datas
          }, () => {
            return downloadFile(opts, getContent($xeTable, opts, columns, datas));
          }));
        }
      }).then(params => {
        clearColumnConvert(columns);
        if (!opts.print) {
          if (afterExportMethod) {
            afterExportMethod({
              status: true,
              options: opts,
              $table: $xeTable,
              $grid: $xeGrid
            });
          }
        }
        return Object.assign({
          status: true
        }, params);
      }).catch(() => {
        clearColumnConvert(columns);
        if (!opts.print) {
          if (afterExportMethod) {
            afterExportMethod({
              status: false,
              options: opts,
              $table: $xeTable,
              $grid: $xeGrid
            });
          }
        }
        const params = {
          status: false
        };
        return Promise.reject(params);
      });
    };
    const handleImport = (content, opts) => {
      const {
        tableFullColumn,
        _importResolve,
        _importReject
      } = internalData;
      let rest = {
        fields: [],
        rows: []
      };
      const tableFieldMaps = {};
      const tableTitleMaps = {};
      tableFullColumn.forEach(column => {
        const field = column.field;
        const title = column.getTitle();
        if (field) {
          tableFieldMaps[field] = column;
        }
        if (title) {
          tableTitleMaps[column.getTitle()] = column;
        }
      });
      const tableConf = {
        fieldMaps: tableFieldMaps,
        titleMaps: tableTitleMaps
      };
      switch (opts.type) {
        case 'csv':
          rest = parseCsv(tableConf, content);
          break;
        case 'txt':
          rest = parseTxt(tableConf, content);
          break;
        case 'html':
          rest = parseHTML(tableConf, content);
          break;
        case 'xml':
          rest = parseXML(tableConf, content);
          break;
      }
      const {
        fields,
        rows
      } = rest;
      const status = fields.some(field => tableFieldMaps[field] || tableTitleMaps[field]);
      if (status) {
        $xeTable.createData(rows).then(data => {
          let loadRest;
          if (opts.mode === 'insert' || opts.mode === 'insertBottom') {
            loadRest = $xeTable.insertAt(data, -1);
          }
          if (opts.mode === 'insertTop') {
            loadRest = $xeTable.insert(data);
          } else {
            loadRest = $xeTable.reloadData(data);
          }
          if (opts.message !== false) {
            if (core_.VxeUI.modal) {
              core_.VxeUI.modal.message({
                content: export_hook_getI18n('vxe.table.impSuccess', [rows.length]),
                status: 'success'
              });
            }
          }
          return loadRest.then(() => {
            if (_importResolve) {
              _importResolve({
                status: true
              });
            }
          });
        });
      } else if (opts.message !== false) {
        if (core_.VxeUI.modal) {
          core_.VxeUI.modal.message({
            content: export_hook_getI18n('vxe.error.impFields'),
            status: 'error'
          });
        }
        if (_importReject) {
          _importReject({
            status: false
          });
        }
      }
    };
    const handleFileImport = (file, opts) => {
      const {
        importMethod,
        afterImportMethod
      } = opts;
      const {
        type,
        filename
      } = parseFile(file);
      const importOpts = computeImportOpts.value;
      // 检查类型，如果为自定义导出，则不需要校验类型
      if (!importMethod && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(importOpts._typeMaps), type)) {
        if (opts.message !== false) {
          if (core_.VxeUI.modal) {
            core_.VxeUI.modal.message({
              content: export_hook_getI18n('vxe.error.notType', [type]),
              status: 'error'
            });
          }
        }
        const params = {
          status: false
        };
        return Promise.reject(params);
      }
      const rest = new Promise((resolve, reject) => {
        const _importResolve = params => {
          resolve(params);
          internalData._importResolve = null;
          internalData._importReject = null;
        };
        const _importReject = params => {
          reject(params);
          internalData._importResolve = null;
          internalData._importReject = null;
        };
        internalData._importResolve = _importResolve;
        internalData._importReject = _importReject;
        if (window.FileReader) {
          const options = Object.assign({
            mode: 'insertTop'
          }, opts, {
            type,
            filename
          });
          if (options.remote) {
            if (importMethod) {
              Promise.resolve(importMethod({
                file,
                options,
                $table: $xeTable
              })).then(() => {
                _importResolve({
                  status: true
                });
              }).catch(() => {
                _importResolve({
                  status: true
                });
              });
            } else {
              _importResolve({
                status: true
              });
            }
          } else {
            const {
              tableFullColumn
            } = internalData;
            $xeTable.preventEvent(null, 'event.import', {
              file,
              options,
              columns: tableFullColumn
            }, () => {
              const reader = new FileReader();
              reader.onerror = () => {
                errLog('vxe.error.notType', [type]);
                _importReject({
                  status: false
                });
              };
              reader.onload = e => {
                handleImport(e.target.result, options);
              };
              reader.readAsText(file, options.encoding || 'UTF-8');
            });
          }
        } else {
          // 不支持的浏览器
          errLog('vxe.error.notExp');
          _importResolve({
            status: true
          });
        }
      });
      return rest.then(() => {
        if (afterImportMethod) {
          afterImportMethod({
            status: true,
            options: opts,
            $table: $xeTable
          });
        }
      }).catch(e => {
        if (afterImportMethod) {
          afterImportMethod({
            status: false,
            options: opts,
            $table: $xeTable
          });
        }
        return Promise.reject(e);
      });
    };
    const handleFilterColumns = (exportOpts, column, columns) => {
      return columns.some(item => {
        if (isColumnInfo(item)) {
          return column.id === item.id;
        } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
          return column.field === item;
        } else {
          const colid = item.id || item.colId;
          const type = item.type;
          const field = item.field;
          if (colid) {
            return column.id === colid;
          } else if (field && type) {
            return column.field === field && column.type === type;
          } else if (field) {
            return column.field === field;
          } else if (type) {
            return column.type === type;
          }
        }
        return false;
      });
    };
    const handleFilterFields = (exportOpts, column, includeFields, excludeFields) => {
      if (excludeFields) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(excludeFields, column.field)) {
          return false;
        }
      }
      if (includeFields) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(includeFields, column.field)) {
          return true;
        }
        return false;
      }
      return exportOpts.original ? column.field : defaultFilterExportColumn(column);
    };
    const handleExportAndPrint = (options, isPrint) => {
      const {
        treeConfig,
        showHeader,
        showFooter
      } = props;
      const {
        initStore,
        isGroup,
        footerTableData,
        exportStore,
        exportParams
      } = reactData;
      const {
        collectColumn,
        mergeBodyList,
        mergeFooterList
      } = internalData;
      const exportOpts = computeExportOpts.value;
      const hasTree = treeConfig;
      const customOpts = computeCustomOpts.value;
      const selectRecords = $xeTable.getCheckboxRecords();
      const proxyOpts = $xeGrid ? $xeGrid.getComputeMaps().computeProxyOpts.value : {};
      const hasFooter = !!footerTableData.length;
      const hasMerge = !!(mergeBodyList.length || mergeFooterList.length);
      const defOpts = Object.assign({
        message: true,
        isHeader: showHeader,
        isTitle: showHeader,
        isFooter: showFooter,
        isColgroup: isGroup,
        isMerge: hasMerge,
        useStyle: true,
        current: 'current',
        modes: (proxyOpts.ajax && proxyOpts.ajax.queryAll ? ['all'] : []).concat(['current', 'selected', 'empty'])
      }, options);
      const types = defOpts.types || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(exportOpts._typeMaps);
      const modes = defOpts.modes || [];
      const checkMethod = customOpts.checkMethod;
      const exportColumns = collectColumn.slice(0);
      const {
        columns,
        excludeFields,
        includeFields
      } = defOpts;
      // 处理类型
      const typeList = types.map(value => {
        return {
          value,
          label: export_hook_getI18n(`vxe.export.types.${value}`)
        };
      });
      const modeList = modes.map(item => {
        if (item && item.value) {
          return {
            value: item.value,
            label: item.label || item.value
          };
        }
        return {
          value: item,
          label: export_hook_getI18n(`vxe.export.modes.${item}`)
        };
      });
      // 默认选中
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(exportColumns, (column, index, items, path, parent) => {
        const isColGroup = column.children && column.children.length;
        let isChecked = false;
        if (columns && columns.length) {
          isChecked = handleFilterColumns(defOpts, column, columns);
        } else if (excludeFields || includeFields) {
          isChecked = handleFilterFields(defOpts, column, includeFields, excludeFields);
        } else {
          isChecked = column.visible && (isColGroup || defaultFilterExportColumn(column));
        }
        column.checked = isChecked;
        column.halfChecked = false;
        column.disabled = parent && parent.disabled || (checkMethod ? !checkMethod({
          $table: $xeTable,
          column
        }) : false);
      });
      // 更新条件
      Object.assign(exportStore, {
        columns: exportColumns,
        typeList,
        modeList,
        hasFooter,
        hasMerge,
        hasTree,
        isPrint,
        hasColgroup: isGroup,
        visible: true
      });
      // 默认参数
      Object.assign(exportParams, {
        mode: selectRecords.length ? 'selected' : 'current'
      }, defOpts);
      const {
        filename,
        sheetName,
        mode,
        type
      } = exportParams;
      if (filename) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(filename)) {
          exportParams.filename = filename({
            options: defOpts,
            $table: $xeTable,
            $grid: $xeGrid
          });
        } else {
          exportParams.filename = `${filename}`;
        }
      }
      if (sheetName) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(sheetName)) {
          exportParams.sheetName = sheetName({
            options: defOpts,
            $table: $xeTable,
            $grid: $xeGrid
          });
        } else {
          exportParams.sheetName = `${sheetName}`;
        }
      }
      if (!modeList.some(item => item.value === mode)) {
        exportParams.mode = modeList[0].value;
      }
      if (!typeList.some(item => item.value === type)) {
        exportParams.type = typeList[0].value;
      }
      initStore.export = true;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const handleCloseExport = () => {
      if (core_.VxeUI.modal) {
        return core_.VxeUI.modal.close('VXE_EXPORT_MODAL');
      }
      return Promise.resolve();
    };
    const exportMethods = {
      /**
       * 导出文件，支持 csv/html/xml/txt
       * 如果是树表格，则默认是导出所有节点
       * 如果是启用了虚拟滚动，则只能导出数据源，可以配合 dataFilterMethod 函数转换数据
       * @param {Object} options 参数
       */
      exportData(options) {
        const {
          treeConfig,
          showHeader,
          showFooter
        } = props;
        const {
          isGroup
        } = reactData;
        const {
          tableFullColumn,
          afterFullData,
          collectColumn,
          mergeBodyList,
          mergeFooterList
        } = internalData;
        const exportOpts = computeExportOpts.value;
        const treeOpts = computeTreeOpts.value;
        const proxyOpts = $xeGrid ? $xeGrid.getComputeMaps().computeProxyOpts.value : {};
        const hasMerge = !!(mergeBodyList.length || mergeFooterList.length);
        const opts = Object.assign({
          message: true,
          isHeader: showHeader,
          isTitle: showHeader,
          isFooter: showFooter,
          isColgroup: isGroup,
          isMerge: hasMerge,
          useStyle: true,
          current: 'current',
          modes: (proxyOpts.ajax && proxyOpts.ajax.queryAll ? ['all'] : []).concat(['current', 'selected', 'empty']),
          download: true,
          type: 'csv'
          // filename: '',
          // sheetName: '',
          // original: false,
          // isAllExpand: false,
          // data: null,
          // remote: false,
          // dataFilterMethod: null,
          // footerFilterMethod: null,
          // exportMethod: null,
          // columnFilterMethod: null,
          // beforeExportMethod: null,
          // afterExportMethod: null
        }, exportOpts, options);
        let {
          filename,
          sheetName,
          type,
          mode,
          columns,
          original,
          columnFilterMethod,
          beforeExportMethod,
          includeFields,
          excludeFields
        } = opts;
        let groups = [];
        const selectRecords = $xeTable.getCheckboxRecords();
        if (!mode) {
          mode = selectRecords.length ? 'selected' : 'current';
        }
        const customCols = columns && columns.length ? columns : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(collectColumn, column => {
          const isColGroup = column.children && column.children.length;
          let isChecked = false;
          if (columns && columns.length) {
            isChecked = handleFilterColumns(opts, column, columns);
          } else if (excludeFields || includeFields) {
            isChecked = handleFilterFields(opts, column, includeFields, excludeFields);
          } else {
            isChecked = column.visible && (isColGroup || defaultFilterExportColumn(column));
          }
          return isChecked;
        }, {
          children: 'children',
          mapChildren: 'childNodes',
          original: true
        });
        const handleOptions = Object.assign({}, opts, {
          filename: '',
          sheetName: ''
        });
        // 如果设置源数据，则默认导出设置了字段的列
        if (!customCols && !columnFilterMethod) {
          handleOptions.columnFilterMethod = ({
            column
          }) => {
            if (excludeFields) {
              if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(excludeFields, column.field)) {
                return false;
              }
            }
            if (includeFields) {
              if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(includeFields, column.field)) {
                return true;
              }
              return false;
            }
            return original ? column.field : defaultFilterExportColumn(column);
          };
        }
        if (customCols) {
          handleOptions._isCustomColumn = true;
          groups = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().mapTree(customCols, item => {
            let targetColumn;
            if (item) {
              if (isColumnInfo(item)) {
                targetColumn = item;
              } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
                targetColumn = $xeTable.getColumnByField(item);
              } else {
                const colid = item.id || item.colId;
                const type = item.type;
                const field = item.field;
                if (colid) {
                  targetColumn = $xeTable.getColumnById(colid);
                } else if (field && type) {
                  targetColumn = tableFullColumn.find(column => column.field === field && column.type === type);
                } else if (field) {
                  targetColumn = $xeTable.getColumnByField(field);
                } else if (type) {
                  targetColumn = tableFullColumn.find(column => column.type === type);
                }
              }
              return targetColumn || {};
            }
          }, {
            children: 'childNodes',
            mapChildren: '_children'
          }), (column, index) => isColumnInfo(column) && (!columnFilterMethod || columnFilterMethod({
            $table: $xeTable,
            column: column,
            $columnIndex: index
          })), {
            children: '_children',
            mapChildren: 'childNodes',
            original: true
          });
        } else {
          groups = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(isGroup ? collectColumn : tableFullColumn, (column, index) => column.visible && (!columnFilterMethod || columnFilterMethod({
            $table: $xeTable,
            column,
            $columnIndex: index
          })), {
            children: 'children',
            mapChildren: 'childNodes',
            original: true
          });
        }
        // 获取所有列
        const cols = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(groups, column => {
          const isColGroup = column.children && column.children.length;
          if (!isColGroup) {
            cols.push(column);
          }
        }, {
          children: 'childNodes'
        });
        // 构建分组层级
        handleOptions.columns = cols;
        handleOptions.colgroups = convertToRows(groups);
        if (filename) {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(filename)) {
            handleOptions.filename = filename({
              options: opts,
              $table: $xeTable,
              $grid: $xeGrid
            });
          } else {
            handleOptions.filename = `${filename}`;
          }
        }
        if (!handleOptions.filename) {
          handleOptions.filename = export_hook_getI18n(handleOptions.original ? 'vxe.table.expOriginFilename' : 'vxe.table.expFilename', [external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(Date.now(), 'yyyyMMddHHmmss')]);
        }
        if (sheetName) {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(sheetName)) {
            handleOptions.sheetName = sheetName({
              options: opts,
              $table: $xeTable,
              $grid: $xeGrid
            });
          } else {
            handleOptions.sheetName = `${sheetName}`;
          }
        }
        if (!handleOptions.sheetName) {
          handleOptions.sheetName = document.title || '';
        }
        // 检查类型，如果为自定义导出，则不需要校验类型
        if (!handleOptions.exportMethod && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(exportOpts._typeMaps), type)) {
          errLog('vxe.error.notType', [type]);
          if (true) {
            if (['xlsx', 'pdf'].includes(type)) {
              warnLog('vxe.error.reqPlugin', [4, 'plugin-export-xlsx']);
            }
          }
          const params = {
            status: false
          };
          return Promise.reject(params);
        }
        if (!handleOptions.print) {
          if (beforeExportMethod) {
            beforeExportMethod({
              options: handleOptions,
              $table: $xeTable,
              $grid: $xeGrid
            });
          }
        }
        if (!handleOptions.data) {
          handleOptions.data = [];
          if (mode === 'selected') {
            if (['html', 'pdf'].indexOf(type) > -1 && treeConfig) {
              handleOptions.data = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree($xeTable.getTableData().fullData, item => $xeTable.findRowIndexOf(selectRecords, item) > -1, Object.assign({}, treeOpts, {
                data: '_row'
              }));
            } else {
              handleOptions.data = selectRecords;
            }
          } else if (mode === 'all') {
            if (true) {
              if (!$xeGrid) {
                warnLog('vxe.error.errProp', ['all', 'mode=current,selected']);
              }
            }
            if ($xeGrid && !handleOptions.remote) {
              const gridReactData = $xeGrid.reactData;
              const {
                computeProxyOpts
              } = $xeGrid.getComputeMaps();
              const proxyOpts = computeProxyOpts.value;
              const {
                sortData
              } = gridReactData;
              const {
                beforeQueryAll,
                afterQueryAll,
                ajax = {}
              } = proxyOpts;
              const resConfigs = proxyOpts.response || proxyOpts.props || {};
              const ajaxMethods = ajax.queryAll;
              const queryAllSuccessMethods = ajax.queryAllSuccess;
              const queryAllErrorMethods = ajax.queryAllError;
              if (true) {
                if (!ajaxMethods) {
                  warnLog('vxe.error.notFunc', ['proxy-config.ajax.queryAll']);
                }
              }
              if (ajaxMethods) {
                const params = {
                  $table: $xeTable,
                  $grid: $xeGrid,
                  sort: sortData.length ? sortData[0] : {},
                  sorts: sortData,
                  filters: gridReactData.filterData,
                  form: gridReactData.formData,
                  options: handleOptions
                };
                return Promise.resolve((beforeQueryAll || ajaxMethods)(params)).then(rest => {
                  const listProp = resConfigs.list;
                  handleOptions.data = (listProp ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(listProp) ? listProp({
                    data: rest,
                    $grid: $xeGrid
                  }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, listProp) : rest) || [];
                  if (afterQueryAll) {
                    afterQueryAll(params);
                  }
                  if (queryAllSuccessMethods) {
                    queryAllSuccessMethods({
                      ...params,
                      response: rest
                    });
                  }
                  return handleExport(handleOptions);
                }).catch(rest => {
                  if (queryAllErrorMethods) {
                    queryAllErrorMethods({
                      ...params,
                      response: rest
                    });
                  }
                });
              }
            }
          }
          if (mode === 'current') {
            handleOptions.data = afterFullData;
          }
        }
        return handleExport(handleOptions);
      },
      importByFile(file, options) {
        const opts = Object.assign({}, options);
        const {
          beforeImportMethod
        } = opts;
        if (beforeImportMethod) {
          beforeImportMethod({
            options: opts,
            $table: $xeTable
          });
        }
        return handleFileImport(file, opts);
      },
      importData(options) {
        const importOpts = computeImportOpts.value;
        const opts = Object.assign({
          types: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(importOpts._typeMaps)
          // beforeImportMethod: null,
          // afterImportMethod: null
        }, importOpts, options);
        const {
          beforeImportMethod,
          afterImportMethod
        } = opts;
        if (beforeImportMethod) {
          beforeImportMethod({
            options: opts,
            $table: $xeTable
          });
        }
        return core_.VxeUI.readFile(opts).catch(e => {
          if (afterImportMethod) {
            afterImportMethod({
              status: false,
              options: opts,
              $table: $xeTable
            });
          }
          return Promise.reject(e);
        }).then(params => {
          const {
            file
          } = params;
          return handleFileImport(file, opts);
        });
      },
      saveFile(options) {
        return core_.VxeUI.saveFile(options);
      },
      readFile(options) {
        return core_.VxeUI.readFile(options);
      },
      print(options) {
        const printOpts = computePrintOpts.value;
        const opts = Object.assign({
          original: false
          // beforePrintMethod
        }, printOpts, options, {
          type: 'html',
          download: false,
          remote: false,
          print: true
        });
        const {
          sheetName
        } = opts;
        let printTitle = '';
        if (sheetName) {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(sheetName)) {
            printTitle = sheetName({
              options: opts,
              $table: $xeTable,
              $grid: $xeGrid
            });
          } else {
            printTitle = `${sheetName}`;
          }
        }
        if (!printTitle) {
          printTitle = document.title || '';
        }
        const beforePrintMethod = opts.beforePrintMethod;
        const tableHtml = opts.html || opts.content;
        return new Promise((resolve, reject) => {
          if (core_.VxeUI.print) {
            if (tableHtml) {
              resolve(core_.VxeUI.print({
                title: printTitle,
                html: tableHtml,
                customStyle: opts.style,
                beforeMethod: beforePrintMethod ? ({
                  html
                }) => {
                  return beforePrintMethod({
                    html,
                    content: html,
                    options: opts,
                    $table: $xeTable
                  });
                } : undefined
              }));
            } else {
              resolve(exportMethods.exportData(opts).then(({
                content
              }) => {
                return core_.VxeUI.print({
                  title: printTitle,
                  html: content,
                  customStyle: opts.style,
                  beforeMethod: beforePrintMethod ? ({
                    html
                  }) => {
                    return beforePrintMethod({
                      html,
                      content: html,
                      options: opts,
                      $table: $xeTable
                    });
                  } : undefined
                });
              }));
            }
          } else {
            const e = {
              status: false
            };
            reject(e);
          }
        });
      },
      getPrintHtml(options) {
        const printOpts = computePrintOpts.value;
        const opts = Object.assign({
          original: false
          // beforePrintMethod
        }, printOpts, options, {
          type: 'html',
          download: false,
          remote: false,
          print: true
        });
        return $xeTable.exportData(opts).then(({
          content
        }) => {
          return {
            html: content
          };
        });
      },
      closeImport() {
        if (core_.VxeUI.modal) {
          return core_.VxeUI.modal.close('VXE_IMPORT_MODAL');
        }
        return Promise.resolve();
      },
      openImport(options) {
        const {
          treeConfig,
          importConfig
        } = props;
        const {
          initStore,
          importStore,
          importParams
        } = reactData;
        const importOpts = computeImportOpts.value;
        const defOpts = Object.assign({
          mode: 'insertTop',
          message: true,
          types: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(importOpts._typeMaps),
          modes: ['insertTop', 'covering']
        }, importOpts, options);
        const types = defOpts.types || [];
        const modes = defOpts.modes || [];
        const isTree = !!treeConfig;
        if (isTree) {
          if (defOpts.message) {
            if (core_.VxeUI.modal) {
              core_.VxeUI.modal.message({
                content: export_hook_getI18n('vxe.error.treeNotImp'),
                status: 'error'
              });
            }
          }
          return;
        }
        if (!importConfig) {
          errLog('vxe.error.reqProp', ['import-config']);
        }
        // 处理类型
        const typeList = types.map(value => {
          return {
            value,
            label: export_hook_getI18n(`vxe.export.types.${value}`)
          };
        });
        const modeList = modes.map(item => {
          if (item && item.value) {
            return {
              value: item.value,
              label: item.label || item.value
            };
          }
          return {
            value: item,
            label: export_hook_getI18n(`vxe.import.modes.${item}`)
          };
        });
        Object.assign(importStore, {
          file: null,
          type: '',
          filename: '',
          modeList,
          typeList,
          visible: true
        });
        Object.assign(importParams, defOpts);
        if (!modeList.some(item => item.value === importParams.mode)) {
          importParams.mode = modeList[0].value;
        }
        initStore.import = true;
      },
      closeExport: handleCloseExport,
      openExport(options) {
        const exportOpts = computeExportOpts.value;
        const defOpts = Object.assign({
          message: true,
          types: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(exportOpts._typeMaps)
        }, exportOpts, options);
        if (!props.exportConfig) {
          errLog('vxe.error.reqProp', ['export-config']);
        }
        handleExportAndPrint(defOpts);
      },
      closePrint: handleCloseExport,
      openPrint(options) {
        const printOpts = computePrintOpts.value;
        const defOpts = Object.assign({
          message: true
        }, printOpts, options);
        if (!props.printConfig) {
          errLog('vxe.error.reqProp', ['print-config']);
        }
        handleExportAndPrint(defOpts, true);
      }
    };
    return exportMethods;
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableExportMethodKeys);
  }
});
;// ./packages/table/module/keyboard/hook.ts







const {
  hooks: keyboard_hook_hooks
} = core_.VxeUI;
const browseObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().browse();
function getTargetOffset(target, container) {
  let offsetTop = 0;
  let offsetLeft = 0;
  const triggerCheckboxLabel = !browseObj.firefox && hasClass(target, 'vxe-checkbox--label');
  if (triggerCheckboxLabel) {
    const checkboxLabelStyle = getComputedStyle(target);
    offsetTop -= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(checkboxLabelStyle.paddingTop);
    offsetLeft -= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(checkboxLabelStyle.paddingLeft);
  }
  while (target && target !== container) {
    offsetTop += target.offsetTop;
    offsetLeft += target.offsetLeft;
    target = target.offsetParent;
    if (triggerCheckboxLabel) {
      const checkboxStyle = getComputedStyle(target);
      offsetTop -= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(checkboxStyle.paddingTop);
      offsetLeft -= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(checkboxStyle.paddingLeft);
    }
  }
  return {
    offsetTop,
    offsetLeft
  };
}
keyboard_hook_hooks.add('tableKeyboardModule', {
  setupTable($xeTable) {
    const {
      props,
      reactData,
      internalData
    } = $xeTable;
    const {
      refElem
    } = $xeTable.getRefMaps();
    const {
      computeEditOpts,
      computeCheckboxOpts,
      computeMouseOpts,
      computeTreeOpts,
      computeRowOpts,
      computeColumnOpts,
      computeCellOpts,
      computeDefaultRowHeight,
      computeCurrentRowOpts,
      computeCurrentColumnOpts
    } = $xeTable.getComputeMaps();
    function getCheckboxRangeRows(evnt, params, targetTrElem, trRect, offsetClientTop, moveRange) {
      const {
        showOverflow
      } = props;
      const {
        fullAllDataRowIdData,
        isResizeCellHeight
      } = internalData;
      const rowOpts = computeRowOpts.value;
      const cellOpts = computeCellOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const {
        row
      } = params;
      let countHeight = 0;
      let rangeRows = [];
      let moveSize = 0;
      const isDown = moveRange > 0;
      const {
        scrollYLoad
      } = reactData;
      const {
        afterFullData
      } = internalData;
      if (isDown) {
        moveSize = offsetClientTop + moveRange;
      } else {
        moveSize = trRect.height - offsetClientTop + Math.abs(moveRange);
      }
      if (scrollYLoad) {
        const _rowIndex = $xeTable.getVTRowIndex(row);
        const isCustomCellHeight = isResizeCellHeight || cellOpts.height || rowOpts.height;
        if (!isCustomCellHeight && showOverflow) {
          if (isDown) {
            rangeRows = afterFullData.slice(_rowIndex, _rowIndex + Math.ceil(moveSize / defaultRowHeight));
          } else {
            rangeRows = afterFullData.slice(_rowIndex - Math.floor(moveSize / defaultRowHeight), _rowIndex + 1);
          }
        } else {
          if (isDown) {
            for (let i = _rowIndex; i < afterFullData.length; i++) {
              const item = afterFullData[i];
              const rowid = $xeTable.getRowid(item);
              const rowRest = fullAllDataRowIdData[rowid] || {};
              countHeight += rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
              rangeRows.push(item);
              if (countHeight > moveSize) {
                return rangeRows;
              }
            }
          } else {
            for (let len = _rowIndex; len >= 0; len--) {
              const item = afterFullData[len];
              const rowid = $xeTable.getRowid(item);
              const rowRest = fullAllDataRowIdData[rowid] || {};
              countHeight += rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
              rangeRows.push(item);
              if (countHeight > moveSize) {
                return rangeRows;
              }
            }
          }
        }
      } else {
        const siblingProp = isDown ? 'next' : 'previous';
        while (targetTrElem && countHeight < moveSize) {
          const rowNodeRest = $xeTable.getRowNode(targetTrElem);
          if (rowNodeRest) {
            rangeRows.push(rowNodeRest.item);
            countHeight += targetTrElem.offsetHeight;
            targetTrElem = targetTrElem[`${siblingProp}ElementSibling`];
          }
        }
      }
      return rangeRows;
    }
    const handleCheckboxRangeEvent = (evnt, params) => {
      const {
        elemStore
      } = internalData;
      const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
      const leftScrollElem = getRefElem(elemStore['left-body-scroll']);
      const rightScrollElem = getRefElem(elemStore['right-body-scroll']);
      const {
        column,
        cell
      } = params;
      if (column.type === 'checkbox') {
        let bodyWrapperElem = bodyScrollElem;
        if (leftScrollElem && column.fixed === 'left') {
          bodyWrapperElem = leftScrollElem;
        } else if (rightScrollElem && column.fixed === 'right') {
          bodyWrapperElem = rightScrollElem;
        }
        if (!bodyWrapperElem) {
          return;
        }
        const el = refElem.value;
        const disX = evnt.clientX;
        const disY = evnt.clientY;
        const checkboxRangeElem = bodyWrapperElem.querySelector('.vxe-table--checkbox-range');
        const trElem = cell.parentElement;
        const selectRecords = $xeTable.getCheckboxRecords();
        let lastRangeRows = [];
        const marginSize = 1;
        const offsetRest = getTargetOffset(evnt.target, bodyWrapperElem);
        const startTop = offsetRest.offsetTop + evnt.offsetY;
        const startLeft = offsetRest.offsetLeft + evnt.offsetX;
        const startScrollTop = bodyWrapperElem.scrollTop;
        const rowHeight = trElem.offsetHeight;
        const trRect = trElem.getBoundingClientRect();
        const offsetClientTop = disY - trRect.y;
        let mouseScrollTimeout = null;
        let isMouseScrollDown = false;
        let mouseScrollSpaceSize = 1;
        const triggerEvent = (type, evnt) => {
          $xeTable.dispatchEvent(`checkbox-range-${type}`, {
            records: $xeTable.getCheckboxRecords(),
            reserves: $xeTable.getCheckboxReserveRecords()
          }, evnt);
        };
        const handleChecked = evnt => {
          const {
            clientX,
            clientY
          } = evnt;
          const offsetLeft = clientX - disX;
          const offsetTop = clientY - disY + (bodyWrapperElem.scrollTop - startScrollTop);
          let rangeHeight = Math.abs(offsetTop);
          let rangeWidth = Math.abs(offsetLeft);
          let rangeTop = startTop;
          let rangeLeft = startLeft;
          if (offsetTop < marginSize) {
            // 向上
            rangeTop += offsetTop;
            if (rangeTop < marginSize) {
              rangeTop = marginSize;
              rangeHeight = startTop;
            }
          } else {
            // 向下
            rangeHeight = Math.min(rangeHeight, bodyWrapperElem.scrollHeight - startTop - marginSize);
          }
          if (offsetLeft < marginSize) {
            // 向左
            rangeLeft += offsetLeft;
            if (rangeWidth > startLeft) {
              rangeLeft = marginSize;
              rangeWidth = startLeft;
            }
          } else {
            // 向右
            rangeWidth = Math.min(rangeWidth, bodyWrapperElem.clientWidth - startLeft - marginSize);
          }
          checkboxRangeElem.style.height = `${rangeHeight}px`;
          checkboxRangeElem.style.width = `${rangeWidth}px`;
          checkboxRangeElem.style.left = `${rangeLeft}px`;
          checkboxRangeElem.style.top = `${rangeTop}px`;
          checkboxRangeElem.style.display = 'block';
          const rangeRows = getCheckboxRangeRows(evnt, params, trElem, trRect, offsetClientTop, offsetTop < marginSize ? -rangeHeight : rangeHeight);
          // 至少滑动 10px 才能有效匹配
          if (rangeHeight > 10 && rangeRows.length !== lastRangeRows.length) {
            const isControlKey = hasControlKey(evnt);
            lastRangeRows = rangeRows;
            if (isControlKey) {
              rangeRows.forEach(row => {
                $xeTable.handleBatchSelectRows([row], selectRecords.indexOf(row) === -1);
              });
            } else {
              $xeTable.setAllCheckboxRow(false);
              $xeTable.handleCheckedCheckboxRow(rangeRows, true, false);
            }
            triggerEvent('change', evnt);
          }
        };
        // 停止鼠标滚动
        const stopMouseScroll = () => {
          clearTimeout(mouseScrollTimeout);
          mouseScrollTimeout = null;
        };
        // 开始鼠标滚动
        const startMouseScroll = evnt => {
          stopMouseScroll();
          mouseScrollTimeout = setTimeout(() => {
            if (mouseScrollTimeout) {
              const {
                scrollLeft,
                scrollTop,
                clientHeight,
                scrollHeight
              } = bodyWrapperElem;
              const topSize = Math.ceil(mouseScrollSpaceSize * 50 / rowHeight);
              if (isMouseScrollDown) {
                if (scrollTop + clientHeight < scrollHeight) {
                  $xeTable.scrollTo(scrollLeft, scrollTop + topSize);
                  startMouseScroll(evnt);
                  handleChecked(evnt);
                } else {
                  stopMouseScroll();
                }
              } else {
                if (scrollTop) {
                  $xeTable.scrollTo(scrollLeft, scrollTop - topSize);
                  startMouseScroll(evnt);
                  handleChecked(evnt);
                } else {
                  stopMouseScroll();
                }
              }
            }
          }, 50);
        };
        addClass(el, 'drag--range');
        document.onmousemove = evnt => {
          evnt.preventDefault();
          evnt.stopPropagation();
          const {
            clientY
          } = evnt;
          const {
            boundingTop
          } = getAbsolutePos(bodyWrapperElem);
          // 如果超过可视区，触发滚动
          if (clientY < boundingTop) {
            isMouseScrollDown = false;
            mouseScrollSpaceSize = boundingTop - clientY;
            if (!mouseScrollTimeout) {
              startMouseScroll(evnt);
            }
          } else if (clientY > boundingTop + bodyWrapperElem.clientHeight) {
            isMouseScrollDown = true;
            mouseScrollSpaceSize = clientY - boundingTop - bodyWrapperElem.clientHeight;
            if (!mouseScrollTimeout) {
              startMouseScroll(evnt);
            }
          } else if (mouseScrollTimeout) {
            stopMouseScroll();
          }
          handleChecked(evnt);
        };
        document.onmouseup = evnt => {
          stopMouseScroll();
          removeClass(el, 'drag--range');
          checkboxRangeElem.removeAttribute('style');
          document.onmousemove = null;
          document.onmouseup = null;
          triggerEvent('end', evnt);
        };
        triggerEvent('start', evnt);
      }
    };
    const handleCellMousedownEvent = (evnt, params) => {
      const {
        editConfig,
        checkboxConfig,
        mouseConfig
      } = props;
      const checkboxOpts = computeCheckboxOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const editOpts = computeEditOpts.value;
      if (mouseConfig && mouseOpts.area && $xeTable.triggerCellAreaMousedownEvent) {
        return $xeTable.triggerCellAreaMousedownEvent(evnt, params);
      } else {
        if (checkboxConfig && checkboxOpts.range) {
          handleCheckboxRangeEvent(evnt, params);
        }
        if (mouseConfig && mouseOpts.selected) {
          if (!editConfig || editOpts.mode === 'cell') {
            $xeTable.handleSelected(params, evnt);
          }
        }
      }
    };
    const handleMoveSelected = (evnt, args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow) => {
      const {
        afterFullData,
        visibleColumn
      } = internalData;
      const params = Object.assign({}, args);
      const _rowIndex = $xeTable.getVTRowIndex(params.row);
      const _columnIndex = $xeTable.getVTColumnIndex(params.column);
      evnt.preventDefault();
      if (isUpArrow && _rowIndex > 0) {
        // 移动到上一行
        params.rowIndex = _rowIndex - 1;
        params.row = afterFullData[params.rowIndex];
      } else if (isDwArrow && _rowIndex < afterFullData.length - 1) {
        // 移动到下一行
        params.rowIndex = _rowIndex + 1;
        params.row = afterFullData[params.rowIndex];
      } else if (isLeftArrow && _columnIndex) {
        // 移动到左侧单元格
        params.columnIndex = _columnIndex - 1;
        params.column = visibleColumn[params.columnIndex];
      } else if (isRightArrow && _columnIndex < visibleColumn.length - 1) {
        // 移动到右侧单元格
        params.columnIndex = _columnIndex + 1;
        params.column = visibleColumn[params.columnIndex];
      }
      $xeTable.scrollToRow(params.row, params.column).then(() => {
        params.cell = $xeTable.getCellElement(params.row, params.column);
        $xeTable.handleSelected(params, evnt);
      });
      return params;
    };
    const keyboardMethods = {
      // 处理 Tab 键移动
      moveTabSelected(args, isLeft, evnt) {
        const {
          editConfig
        } = props;
        const {
          afterFullData,
          visibleColumn
        } = internalData;
        const editOpts = computeEditOpts.value;
        const rowOpts = computeRowOpts.value;
        const currentRowOpts = computeCurrentRowOpts.value;
        const columnOpts = computeColumnOpts.value;
        const currentColumnOpts = computeCurrentColumnOpts.value;
        let targetRow;
        let targetRowIndex;
        let targetColumnIndex;
        const params = Object.assign({}, args);
        const _rowIndex = $xeTable.getVTRowIndex(params.row);
        const _columnIndex = $xeTable.getVTColumnIndex(params.column);
        evnt.preventDefault();
        if (isLeft) {
          // 向左
          if (_columnIndex <= 0) {
            // 如果已经是第一列，则移动到上一行
            if (_rowIndex > 0) {
              targetRowIndex = _rowIndex - 1;
              targetRow = afterFullData[targetRowIndex];
              targetColumnIndex = visibleColumn.length - 1;
            }
          } else {
            targetColumnIndex = _columnIndex - 1;
          }
        } else {
          if (_columnIndex >= visibleColumn.length - 1) {
            // 如果已经是第一列，则移动到上一行
            if (_rowIndex < afterFullData.length - 1) {
              targetRowIndex = _rowIndex + 1;
              targetRow = afterFullData[targetRowIndex];
              targetColumnIndex = 0;
            }
          } else {
            targetColumnIndex = _columnIndex + 1;
          }
        }
        const targetColumn = visibleColumn[targetColumnIndex];
        if (targetColumn) {
          if (targetRow) {
            params.rowIndex = targetRowIndex;
            params.row = targetRow;
          } else {
            params.rowIndex = _rowIndex;
          }
          params.columnIndex = targetColumnIndex;
          params.column = targetColumn;
          params.cell = $xeTable.getCellElement(params.row, params.column);
          if (rowOpts.isCurrent && currentRowOpts.isFollowSelected) {
            $xeTable.triggerCurrentRowEvent(evnt, params);
          }
          if (columnOpts.isCurrent && currentColumnOpts.isFollowSelected) {
            $xeTable.triggerCurrentColumnEvent(evnt, params);
          }
          if (editConfig) {
            if (editOpts.trigger === 'click' || editOpts.trigger === 'dblclick') {
              if (editOpts.mode === 'row') {
                $xeTable.handleEdit(params, evnt);
              } else {
                $xeTable.scrollToRow(params.row, params.column).then(() => {
                  $xeTable.handleSelected(params, evnt);
                });
              }
            }
          } else {
            $xeTable.scrollToRow(params.row, params.column).then(() => {
              $xeTable.handleSelected(params, evnt);
            });
          }
        }
      },
      // 处理当前行方向键移动
      moveCurrentRow(isUpArrow, isDwArrow, evnt) {
        const {
          treeConfig
        } = props;
        const {
          currentRow
        } = reactData;
        const {
          afterFullData
        } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let targetRow;
        if (currentRow) {
          if (treeConfig) {
            const {
              index,
              items
            } = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(afterFullData, item => item === currentRow, {
              children: childrenField
            });
            if (isUpArrow && index > 0) {
              targetRow = items[index - 1];
            } else if (isDwArrow && index < items.length - 1) {
              targetRow = items[index + 1];
            }
          } else {
            const _rowIndex = $xeTable.getVTRowIndex(currentRow);
            if (isUpArrow && _rowIndex > 0) {
              targetRow = afterFullData[_rowIndex - 1];
            } else if (isDwArrow && _rowIndex < afterFullData.length - 1) {
              targetRow = afterFullData[_rowIndex + 1];
            }
          }
        } else {
          targetRow = afterFullData[0];
        }
        if (targetRow) {
          evnt.preventDefault();
          const params = {
            $table: $xeTable,
            row: targetRow,
            rowIndex: $xeTable.getRowIndex(targetRow),
            $rowIndex: $xeTable.getVMRowIndex(targetRow)
          };
          $xeTable.scrollToRow(targetRow).then(() => $xeTable.triggerCurrentRowEvent(evnt, params));
        }
      },
      // 处理当前列方向键移动
      moveCurrentColumn(isLeftArrow, isRightArrow, evnt) {
        const {
          currentColumn
        } = reactData;
        const {
          visibleColumn
        } = internalData;
        let targetCol = null;
        if (currentColumn) {
          const _columnIndex = $xeTable.getVTColumnIndex(currentColumn);
          if (isLeftArrow && _columnIndex > 0) {
            targetCol = visibleColumn[_columnIndex - 1];
          } else if (isRightArrow && _columnIndex < visibleColumn.length - 1) {
            targetCol = visibleColumn[_columnIndex + 1];
          }
        } else {
          targetCol = visibleColumn[0];
        }
        if (targetCol) {
          evnt.preventDefault();
          const params = {
            $table: $xeTable,
            column: targetCol,
            columnIndex: $xeTable.getColumnIndex(targetCol),
            $columnIndex: $xeTable.getVMColumnIndex(targetCol)
          };
          $xeTable.scrollToColumn(targetCol).then(() => $xeTable.triggerCurrentColumnEvent(evnt, params));
        }
      },
      // 处理可编辑方向键移动
      moveArrowSelected(args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt) {
        const {
          highlightCurrentRow,
          highlightCurrentColumn
        } = props;
        const rowOpts = computeRowOpts.value;
        const currentRowOpts = computeCurrentRowOpts.value;
        const columnOpts = computeColumnOpts.value;
        const currentColumnOpts = computeCurrentColumnOpts.value;
        const params = handleMoveSelected(evnt, args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow);
        if (rowOpts.isCurrent || highlightCurrentRow) {
          if (currentRowOpts.isFollowSelected) {
            $xeTable.triggerCurrentRowEvent(evnt, params);
          } else {
            // 当前行按键上下移动
            if ((isUpArrow || isDwArrow) && (rowOpts.isCurrent || highlightCurrentRow)) {
              $xeTable.moveCurrentRow(isUpArrow, isDwArrow, evnt);
            }
          }
        }
        if (columnOpts.isCurrent || highlightCurrentColumn) {
          if (currentColumnOpts.isFollowSelected) {
            $xeTable.triggerCurrentColumnEvent(evnt, params);
          } else {
            // 当前行按键左右移动
            if ((isLeftArrow || isRightArrow) && (columnOpts.isCurrent || highlightCurrentColumn)) {
              $xeTable.moveCurrentColumn(isLeftArrow, isRightArrow, evnt);
            }
          }
        }
      },
      moveEnterSelected(args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt) {
        const {
          highlightCurrentRow,
          highlightCurrentColumn
        } = props;
        const rowOpts = computeRowOpts.value;
        const currentRowOpts = computeCurrentRowOpts.value;
        const columnOpts = computeColumnOpts.value;
        const currentColumnOpts = computeCurrentColumnOpts.value;
        const params = handleMoveSelected(evnt, args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow);
        if ((rowOpts.isCurrent || highlightCurrentRow) && currentRowOpts.isFollowSelected) {
          $xeTable.triggerCurrentRowEvent(evnt, params);
        }
        if ((columnOpts.isCurrent || highlightCurrentColumn) && currentColumnOpts.isFollowSelected) {
          $xeTable.triggerCurrentColumnEvent(evnt, params);
        }
      },
      // 已废弃，待删除
      moveSelected(args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt) {
        handleMoveSelected(evnt, args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow);
      },
      handleCellMousedownEvent
    };
    return keyboardMethods;
  }
});
;// ./packages/table/module/validator/hook.ts












const {
  getConfig: validator_hook_getConfig,
  validators: hook_validators,
  hooks: validator_hook_hooks
} = core_.VxeUI;
/**
 * 校验规则
 */
class Rule {
  constructor(rule) {
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.max,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  /**
   * 获取校验不通过的消息
   * 支持国际化翻译
   */
  get content() {
    return getFuncText(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
}
const tableValidatorMethodKeys = ['fullValidate', 'validate', 'fullValidateField', 'validateField', 'clearValidate'];
validator_hook_hooks.add('tableValidatorModule', {
  setupTable($xeTable) {
    const {
      props,
      reactData,
      internalData
    } = $xeTable;
    const {
      refValidTooltip
    } = $xeTable.getRefMaps();
    const {
      computeValidOpts,
      computeTreeOpts,
      computeEditOpts
    } = $xeTable.getComputeMaps();
    let validatorMethods = {};
    let validatorPrivateMethods = {};
    let validRuleErr;
    /**
     * 聚焦到校验通过的单元格并弹出校验错误提示
     */
    const handleValidError = params => {
      return new Promise(resolve => {
        const validOpts = computeValidOpts.value;
        if (validOpts.autoPos === false) {
          $xeTable.dispatchEvent('valid-error', params, null);
          resolve();
        } else {
          $xeTable.handleEdit(params, {
            type: 'valid-error',
            trigger: 'call'
          }).then(() => {
            resolve(validatorPrivateMethods.showValidTooltip(params));
          });
        }
      });
    };
    const handleErrMsgMode = validErrMaps => {
      const validOpts = computeValidOpts.value;
      if (validOpts.msgMode === 'single') {
        const keys = Object.keys(validErrMaps);
        const resMaps = {};
        if (keys.length) {
          const firstKey = keys[0];
          resMaps[firstKey] = validErrMaps[firstKey];
        }
        return resMaps;
      }
      return validErrMaps;
    };
    /**
     * 对表格数据进行校验
     * 如果不指定数据，则默认只校验临时变动的数据，例如新增或修改
     * 如果传 true 则校验当前表格数据
     * 如果传 row 指定行记录，则只验证传入的行
     * 如果传 rows 为多行记录，则只验证传入的行
     * 如果只传 callback 否则默认验证整个表格数据
     * 返回 Promise 对象，或者使用回调方式
     */
    const beginValidate = (rows, cols, cb, isFull) => {
      const validRest = {};
      const {
        editRules,
        treeConfig
      } = props;
      const {
        afterFullData,
        pendingRowMaps,
        removeRowMaps
      } = internalData;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const validOpts = computeValidOpts.value;
      let validList;
      if (rows === true) {
        validList = afterFullData;
      } else if (rows) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(rows)) {
          cb = rows;
        } else {
          validList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows) ? rows : [rows];
        }
      }
      if (!validList) {
        if ($xeTable.getInsertRecords) {
          validList = $xeTable.getInsertRecords().concat($xeTable.getUpdateRecords());
        } else {
          validList = [];
        }
      }
      const rowValidErrs = [];
      internalData._lastCallTime = Date.now();
      validRuleErr = false; // 如果为快速校验，当存在某列校验不通过时将终止执行
      validatorMethods.clearValidate();
      const validErrMaps = {};
      if (editRules) {
        const columns = cols && cols.length ? cols : $xeTable.getColumns();
        const handleVaild = row => {
          const rowid = getRowid($xeTable, row);
          // 是否删除
          if (removeRowMaps[rowid]) {
            return;
          }
          // 是否标记删除
          if (pendingRowMaps[rowid]) {
            return;
          }
          if (isFull || !validRuleErr) {
            const colVailds = [];
            columns.forEach(column => {
              const field = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(column) ? column : column.field;
              if ((isFull || !validRuleErr) && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().has(editRules, field)) {
                colVailds.push(validatorPrivateMethods.validCellRules('all', row, column).catch(({
                  rule,
                  rules
                }) => {
                  const rest = {
                    rule,
                    rules,
                    rowIndex: $xeTable.getRowIndex(row),
                    row,
                    columnIndex: $xeTable.getColumnIndex(column),
                    column,
                    field,
                    $table: $xeTable
                  };
                  if (!validRest[field]) {
                    validRest[field] = [];
                  }
                  validErrMaps[`${getRowid($xeTable, row)}:${column.id}`] = {
                    column,
                    row,
                    rule,
                    content: rule.content
                  };
                  validRest[field].push(rest);
                  if (!isFull) {
                    validRuleErr = true;
                    return Promise.reject(rest);
                  }
                }));
              }
            });
            rowValidErrs.push(Promise.all(colVailds));
          }
        };
        if (treeConfig) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(validList, handleVaild, {
            children: childrenField
          });
        } else {
          validList.forEach(handleVaild);
        }
        return Promise.all(rowValidErrs).then(() => {
          const ruleProps = Object.keys(validRest);
          reactData.validErrorMaps = handleErrMsgMode(validErrMaps);
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
            if (ruleProps.length) {
              return Promise.reject(validRest[ruleProps[0]][0]);
            }
            if (cb) {
              cb();
            }
          });
        }).catch(firstErrParams => {
          return new Promise((resolve, reject) => {
            const finish = () => {
              (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
                if (cb) {
                  cb(validRest);
                  resolve();
                } else {
                  if (validator_hook_getConfig().validToReject === 'obsolete') {
                    // 已废弃，校验失败将不会执行catch
                    reject(validRest);
                  } else {
                    resolve(validRest);
                  }
                }
              });
            };
            const posAndFinish = () => {
              firstErrParams.cell = $xeTable.getCellElement(firstErrParams.row, firstErrParams.column);
              scrollToView(firstErrParams.cell);
              handleValidError(firstErrParams).then(finish);
            };
            /**
             * 当校验不通过时
             * 将表格滚动到可视区
             * 由于提示信息至少需要占一行，定位向上偏移一行
             */
            if (validOpts.autoPos === false) {
              finish();
            } else {
              const row = firstErrParams.row;
              const column = firstErrParams.column;
              $xeTable.scrollToRow(row, column).then(posAndFinish);
            }
          });
        });
      } else {
        reactData.validErrorMaps = {};
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        if (cb) {
          cb();
        }
      });
    };
    validatorMethods = {
      /**
       * 完整校验行，和 validate 的区别就是会给有效数据中的每一行进行校验
       */
      fullValidate(rows, cb) {
        if (true) {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(cb)) {
            warnLog('vxe.error.notValidators', ['fullValidate(rows, callback)', 'fullValidate(rows)']);
          }
        }
        return beginValidate(rows, null, cb, true);
      },
      /**
       * 快速校验行，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）
       */
      validate(rows, cb) {
        return beginValidate(rows, null, cb);
      },
      /**
       * 完整校验单元格，和 validateField 的区别就是会给有效数据中的每一行进行校验
       */
      fullValidateField(rows, fieldOrColumn) {
        const colList = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn) ? fieldOrColumn : fieldOrColumn ? [fieldOrColumn] : []).map(column => handleFieldOrColumn($xeTable, column));
        if (colList.length) {
          return beginValidate(rows, colList, null, true);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 快速校验单元格，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）
       */
      validateField(rows, fieldOrColumn) {
        const colList = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn) ? fieldOrColumn : fieldOrColumn ? [fieldOrColumn] : []).map(column => handleFieldOrColumn($xeTable, column));
        if (colList.length) {
          return beginValidate(rows, colList, null);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      clearValidate(rows, fieldOrColumn) {
        const {
          validErrorMaps
        } = reactData;
        const validTip = refValidTooltip.value;
        const validOpts = computeValidOpts.value;
        const rowList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows) ? rows : rows ? [rows] : [];
        const colList = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn) ? fieldOrColumn : fieldOrColumn ? [fieldOrColumn] : []).map(column => handleFieldOrColumn($xeTable, column));
        let validErrMaps = {};
        if (validTip && validTip.reactData.visible) {
          validTip.close();
        }
        // 如果是单个提示模式
        if (validOpts.msgMode === 'single') {
          reactData.validErrorMaps = {};
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
        if (rowList.length && colList.length) {
          validErrMaps = Object.assign({}, validErrorMaps);
          rowList.forEach(row => {
            colList.forEach(column => {
              const validKey = `${getRowid($xeTable, row)}:${column.id}`;
              if (validErrMaps[validKey]) {
                delete validErrMaps[validKey];
              }
            });
          });
        } else if (rowList.length) {
          const rowIdList = rowList.map(row => `${getRowid($xeTable, row)}`);
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(validErrorMaps, (item, key) => {
            if (rowIdList.indexOf(key.split(':')[0]) > -1) {
              validErrMaps[key] = item;
            }
          });
        } else if (colList.length) {
          const colidList = colList.map(column => `${column.id}`);
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(validErrorMaps, (item, key) => {
            if (colidList.indexOf(key.split(':')[1]) > -1) {
              validErrMaps[key] = item;
            }
          });
        }
        reactData.validErrorMaps = validErrMaps;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    const validErrorRuleValue = (rule, val) => {
      const {
        type,
        min,
        max,
        pattern
      } = rule;
      const isNumType = type === 'number';
      const numVal = isNumType ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(val) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getSize(val);
      // 判断数值
      if (isNumType && isNaN(val)) {
        return true;
      }
      // 如果存在 min，判断最小值
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(min) && numVal < external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(min)) {
        return true;
      }
      // 如果存在 max，判断最大值
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(max) && numVal > external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max)) {
        return true;
      }
      // 如果存在 pattern，正则校验
      if (pattern && !(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
        return true;
      }
      return false;
    };
    validatorPrivateMethods = {
      /**
       * 校验数据
       * 按表格行、列顺序依次校验（同步或异步）
       * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列
       * 如果校验失败则，触发回调或者Promise<不通过列的错误消息>
       * 如果是传回调方式这返回一个校验不通过列的错误消息
       *
       * rule 配置：
       *  required=Boolean 是否必填
       *  min=Number 最小长度
       *  max=Number 最大长度
       *  validator=Function({ cellValue, rule, rules, row, column, rowIndex, columnIndex }) 自定义校验，接收一个 Promise
       *  trigger=blur|change 触发方式（除非特殊场景，否则默认为空就行）
       */
      validCellRules(validType, row, column, val) {
        const $xeGrid = $xeTable.xeGrid;
        const {
          editRules
        } = props;
        const {
          field
        } = column;
        const errorRules = [];
        const syncValidList = [];
        if (field && editRules) {
          const rules = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(editRules, field);
          if (rules) {
            const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(val) ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, field) : val;
            rules.forEach(rule => {
              const {
                type,
                trigger,
                required,
                validator
              } = rule;
              if (validType === 'all' || !trigger || validType === trigger) {
                if (validator) {
                  const validParams = {
                    cellValue,
                    rule,
                    rules,
                    row,
                    rowIndex: $xeTable.getRowIndex(row),
                    column,
                    columnIndex: $xeTable.getColumnIndex(column),
                    field: column.field,
                    $table: $xeTable,
                    $grid: $xeGrid
                  };
                  let customValid;
                  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(validator)) {
                    const gvItem = hook_validators.get(validator);
                    if (gvItem) {
                      const tcvMethod = gvItem.tableCellValidatorMethod || gvItem.cellValidatorMethod;
                      if (tcvMethod) {
                        customValid = tcvMethod(validParams);
                      } else {
                        if (true) {
                          warnLog('vxe.error.notValidators', [validator]);
                        }
                      }
                    } else {
                      errLog('vxe.error.notValidators', [validator]);
                    }
                  } else {
                    customValid = validator(validParams);
                  }
                  if (customValid) {
                    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isError(customValid)) {
                      validRuleErr = true;
                      errorRules.push(new Rule({
                        type: 'custom',
                        trigger,
                        content: customValid.message,
                        rule: new Rule(rule)
                      }));
                    } else if (customValid.catch) {
                      // 如果为异步校验（注：异步校验是并发无序的）
                      syncValidList.push(customValid.catch(e => {
                        validRuleErr = true;
                        errorRules.push(new Rule({
                          type: 'custom',
                          trigger,
                          content: e && e.message ? e.message : rule.content || rule.message,
                          rule: new Rule(rule)
                        }));
                      }));
                    }
                  }
                } else {
                  const isArrType = type === 'array';
                  const isArrVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(cellValue);
                  let hasEmpty = true;
                  if (isArrType || isArrVal) {
                    hasEmpty = !isArrVal || !cellValue.length;
                  } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(cellValue)) {
                    hasEmpty = eqEmptyValue(cellValue.trim());
                  } else {
                    hasEmpty = eqEmptyValue(cellValue);
                  }
                  if (required ? hasEmpty || validErrorRuleValue(rule, cellValue) : !hasEmpty && validErrorRuleValue(rule, cellValue)) {
                    validRuleErr = true;
                    errorRules.push(new Rule(rule));
                  }
                }
              }
            });
          }
        }
        return Promise.all(syncValidList).then(() => {
          if (errorRules.length) {
            const rest = {
              rules: errorRules,
              rule: errorRules[0]
            };
            return Promise.reject(rest);
          }
        });
      },
      hasCellRules(type, row, column) {
        const {
          editRules
        } = props;
        const {
          field
        } = column;
        if (field && editRules) {
          const rules = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(editRules, field);
          return rules && !!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(rules, rule => type === 'all' || !rule.trigger || type === rule.trigger);
        }
        return false;
      },
      /**
       * 触发校验
       */
      triggerValidate(type) {
        const {
          editConfig,
          editRules
        } = props;
        const {
          editStore
        } = reactData;
        const {
          actived
        } = editStore;
        const editOpts = computeEditOpts.value;
        const validOpts = computeValidOpts.value;
        // 检查清除校验消息
        if (editRules && validOpts.msgMode === 'single') {
          reactData.validErrorMaps = {};
        }
        // 校验单元格
        if (editConfig && editRules && actived.row) {
          const {
            row,
            column,
            cell
          } = actived.args;
          if (validatorPrivateMethods.hasCellRules(type, row, column)) {
            return validatorPrivateMethods.validCellRules(type, row, column).then(() => {
              if (editOpts.mode === 'row') {
                validatorMethods.clearValidate(row, column);
              }
            }).catch(({
              rule
            }) => {
              // 如果校验不通过与触发方式一致，则聚焦提示错误，否则跳过并不作任何处理
              if (!rule.trigger || type === rule.trigger) {
                const rest = {
                  rule,
                  row,
                  column,
                  cell
                };
                validatorPrivateMethods.showValidTooltip(rest);
                return Promise.reject(rest);
              }
              return Promise.resolve();
            });
          }
        }
        return Promise.resolve();
      },
      /**
       * 弹出校验错误提示
       */
      showValidTooltip(params) {
        const {
          height
        } = props;
        const {
          tableData,
          validStore,
          validErrorMaps
        } = reactData;
        const {
          rule,
          row,
          column,
          cell
        } = params;
        const validOpts = computeValidOpts.value;
        const validTip = refValidTooltip.value;
        const content = rule.content;
        validStore.visible = true;
        if (validOpts.msgMode === 'single') {
          reactData.validErrorMaps = {
            [`${getRowid($xeTable, row)}:${column.id}`]: {
              column,
              row,
              rule,
              content
            }
          };
        } else {
          reactData.validErrorMaps = Object.assign({}, validErrorMaps, {
            [`${getRowid($xeTable, row)}:${column.id}`]: {
              column,
              row,
              rule,
              content
            }
          });
        }
        $xeTable.dispatchEvent('valid-error', params, null);
        if (validTip) {
          if (validTip && (validOpts.message === 'tooltip' || validOpts.message === 'default' && !height && tableData.length < 2)) {
            return validTip.open(cell, content);
          }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    return {
      ...validatorMethods,
      ...validatorPrivateMethods
    };
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableValidatorMethodKeys);
  }
});
;// ./packages/table/module/custom/hook.ts






const tableCustomMethodKeys = ['openCustom', 'closeCustom', 'saveCustom', 'cancelCustom', 'resetCustom', 'toggleCustomAllCheckbox', 'setCustomAllCheckbox'];
core_.VxeUI.hooks.add('tableCustomModule', {
  setupTable($xeTable) {
    const {
      reactData,
      internalData
    } = $xeTable;
    const {
      computeCustomOpts
    } = $xeTable.getComputeMaps();
    const {
      refElem
    } = $xeTable.getRefMaps();
    const $xeGrid = $xeTable.xeGrid;
    const calcMaxHeight = () => {
      const {
        customStore
      } = reactData;
      const el = refElem.value;
      // 判断面板不能大于表格高度
      let tableHeight = 0;
      if (el) {
        tableHeight = el.clientHeight - 28;
      }
      customStore.maxHeight = Math.max(88, tableHeight);
    };
    const openCustom = () => {
      const {
        initStore,
        customStore
      } = reactData;
      customStore.visible = true;
      initStore.custom = true;
      handleUpdateCustomColumn();
      checkCustomStatus();
      calcMaxHeight();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => calcMaxHeight());
    };
    const handleUpdateCustomColumn = () => {
      const {
        customStore
      } = reactData;
      const {
        collectColumn
      } = internalData;
      if (customStore.visible) {
        const sortMaps = {};
        const fixedMaps = {};
        const visibleMaps = {};
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn, column => {
          const colid = column.getKey();
          column.renderFixed = column.fixed;
          column.renderVisible = column.visible;
          column.renderResizeWidth = column.renderWidth;
          sortMaps[colid] = column.renderSortNumber;
          fixedMaps[colid] = column.fixed;
          visibleMaps[colid] = column.visible;
        });
        customStore.oldSortMaps = sortMaps;
        customStore.oldFixedMaps = fixedMaps;
        customStore.oldVisibleMaps = visibleMaps;
        reactData.customColumnList = collectColumn.slice(0);
      }
    };
    const closeCustom = () => {
      const {
        customStore
      } = reactData;
      const customOpts = computeCustomOpts.value;
      if (customStore.visible) {
        customStore.visible = false;
        if (!customOpts.immediate) {
          $xeTable.handleCustom();
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const saveCustom = () => {
      const {
        customColumnList
      } = reactData;
      const customOpts = computeCustomOpts.value;
      const {
        allowVisible,
        allowSort,
        allowFixed,
        allowResizable
      } = customOpts;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(customColumnList, (column, index, items, path, parentColumn) => {
        if (parentColumn) {
          // 更新子列信息
          column.fixed = parentColumn.fixed;
        } else {
          if (allowSort) {
            const sortIndex = index + 1;
            column.renderSortNumber = sortIndex;
          }
          if (allowFixed) {
            column.fixed = column.renderFixed;
          }
        }
        if (allowResizable) {
          if (column.renderVisible && (!column.children || column.children.length)) {
            if (column.renderResizeWidth !== column.renderWidth) {
              column.resizeWidth = column.renderResizeWidth;
              column.renderWidth = column.renderResizeWidth;
            }
          }
        }
        if (allowVisible) {
          column.visible = column.renderVisible;
        }
      });
      reactData.isCustomStatus = true;
      reactData.isDragColMove = true;
      setTimeout(() => {
        reactData.isDragColMove = false;
      }, 1000);
      return $xeTable.saveCustomStore('confirm');
    };
    const cancelCustom = () => {
      const {
        customColumnList,
        customStore
      } = reactData;
      const {
        oldSortMaps,
        oldFixedMaps,
        oldVisibleMaps
      } = customStore;
      const customOpts = computeCustomOpts.value;
      const {
        allowVisible,
        allowSort,
        allowFixed,
        allowResizable
      } = customOpts;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(customColumnList, column => {
        const colid = column.getKey();
        const visible = !!oldVisibleMaps[colid];
        const fixed = oldFixedMaps[colid] || '';
        if (allowVisible) {
          column.renderVisible = visible;
          column.visible = visible;
        }
        if (allowFixed) {
          column.renderFixed = fixed;
          column.fixed = fixed;
        }
        if (allowSort) {
          column.renderSortNumber = oldSortMaps[colid] || 0;
        }
        if (allowResizable) {
          column.renderResizeWidth = column.renderWidth;
        }
      }, {
        children: 'children'
      });
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const setCustomAllCheckbox = checked => {
      const {
        customStore
      } = reactData;
      const {
        customColumnList
      } = reactData;
      const customOpts = computeCustomOpts.value;
      const {
        checkMethod,
        visibleMethod
      } = customOpts;
      const isAll = !!checked;
      if (customOpts.immediate) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(customColumnList, column => {
          if (visibleMethod && !visibleMethod({
            $table: $xeTable,
            column
          })) {
            return;
          }
          if (checkMethod && !checkMethod({
            $table: $xeTable,
            column
          })) {
            return;
          }
          column.visible = isAll;
          column.renderVisible = isAll;
          column.halfVisible = false;
        });
        customStore.isAll = isAll;
        reactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore('update:visible');
      } else {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(customColumnList, column => {
          if (visibleMethod && !visibleMethod({
            $table: $xeTable,
            column
          })) {
            return;
          }
          if (checkMethod && !checkMethod({
            $table: $xeTable,
            column
          })) {
            return;
          }
          column.renderVisible = isAll;
          column.halfVisible = false;
        });
        customStore.isAll = isAll;
      }
      $xeTable.checkCustomStatus();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const customMethods = {
      openCustom,
      closeCustom,
      saveCustom,
      cancelCustom,
      resetCustom(options) {
        const {
          collectColumn
        } = internalData;
        const customOpts = computeCustomOpts.value;
        const {
          checkMethod
        } = customOpts;
        const opts = Object.assign({
          visible: true,
          resizable: options === true,
          fixed: options === true,
          sort: options === true
        }, options);
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn, column => {
          if (opts.resizable) {
            column.resizeWidth = 0;
          }
          if (opts.fixed) {
            column.fixed = column.defaultFixed;
          }
          if (opts.sort) {
            column.renderSortNumber = column.sortNumber;
          }
          if (!checkMethod || checkMethod({
            $table: $xeTable,
            column
          })) {
            column.visible = column.defaultVisible;
          }
          column.renderResizeWidth = column.renderWidth;
        });
        reactData.isCustomStatus = false;
        $xeTable.saveCustomStore('reset');
        return $xeTable.handleCustom();
      },
      toggleCustomAllCheckbox() {
        const {
          customStore
        } = reactData;
        const isAll = !customStore.isAll;
        return setCustomAllCheckbox(isAll);
      },
      setCustomAllCheckbox
    };
    const checkCustomStatus = () => {
      const {
        customStore
      } = reactData;
      const {
        collectColumn
      } = internalData;
      const customOpts = computeCustomOpts.value;
      const {
        checkMethod
      } = customOpts;
      customStore.isAll = collectColumn.every(column => (checkMethod ? !checkMethod({
        $table: $xeTable,
        column
      }) : false) || column.renderVisible);
      customStore.isIndeterminate = !customStore.isAll && collectColumn.some(column => (!checkMethod || checkMethod({
        $table: $xeTable,
        column
      })) && (column.renderVisible || column.halfVisible));
    };
    const emitCustomEvent = (type, evnt) => {
      const comp = $xeGrid || $xeTable;
      comp.dispatchEvent('custom', {
        type
      }, evnt);
    };
    const customPrivateMethods = {
      checkCustomStatus,
      emitCustomEvent,
      triggerCustomEvent(evnt) {
        const reactData = $xeTable.reactData;
        const {
          customStore
        } = reactData;
        if (customStore.visible) {
          closeCustom();
          emitCustomEvent('close', evnt);
        } else {
          customStore.btnEl = evnt.target;
          openCustom();
          emitCustomEvent('open', evnt);
        }
      },
      customOpenEvent(evnt) {
        const reactData = $xeTable.reactData;
        const {
          customStore
        } = reactData;
        if (!customStore.visible) {
          customStore.activeBtn = true;
          customStore.btnEl = evnt.target;
          $xeTable.openCustom();
          $xeTable.emitCustomEvent('open', evnt);
        }
      },
      customCloseEvent(evnt) {
        const reactData = $xeTable.reactData;
        const {
          customStore
        } = reactData;
        if (customStore.visible) {
          customStore.activeBtn = false;
          $xeTable.closeCustom();
          $xeTable.emitCustomEvent('close', evnt);
        }
      },
      handleUpdateCustomColumn
    };
    return {
      ...customMethods,
      ...customPrivateMethods
    };
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableCustomMethodKeys);
  }
});
;// ./packages/table/render/index.ts










const {
  getConfig: render_getConfig,
  renderer: render_renderer,
  getI18n: render_getI18n,
  getComponent
} = core_.VxeUI;
const componentDefaultModelProp = 'modelValue';
const defaultCompProps = {};
function handleDefaultValue(value, defaultVal, initVal) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(value) ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(defaultVal) ? initVal : defaultVal : value;
}
function parseDate(value, props) {
  return value && props.valueFormat ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(value, props.valueFormat) : value;
}
function getFormatDate(value, props, defaultFormat) {
  const {
    dateConfig = {}
  } = props;
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(parseDate(value, props), dateConfig.labelFormat || defaultFormat);
}
function getLabelFormatDate(value, props) {
  return getFormatDate(value, props, render_getI18n(`vxe.input.date.labelFormat.${props.type || 'date'}`));
}
/**
 * 已废弃
 * @deprecated
 */
function getOldComponentName(name) {
  return `vxe-${name.replace('$', '')}`;
}
function getDefaultComponent({
  name
}) {
  return getComponent(name);
}
/**
 * 已废弃
 * @deprecated
 */
function getOldComponent({
  name
}) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(getOldComponentName(name));
}
function handleConfirmFilter(params, checked, option) {
  const {
    $panel
  } = params;
  $panel.changeOption({}, checked, option);
}
function getNativeAttrs(renderOpts) {
  let {
    name,
    attrs
  } = renderOpts;
  if (name === 'input') {
    attrs = Object.assign({
      type: 'text'
    }, attrs);
  }
  return attrs;
}
function getInputImmediateModel(renderOpts) {
  const {
    name,
    immediate,
    props
  } = renderOpts;
  if (!immediate) {
    if (name === 'VxeInput' || name === '$input') {
      const {
        type
      } = props || {};
      return !(!type || type === 'text' || type === 'number' || type === 'integer' || type === 'float');
    }
    if (name === 'input' || name === 'textarea' || name === '$textarea') {
      return false;
    }
    return true;
  }
  return immediate;
}
function getCellEditProps(renderOpts, params, value, defaultProps) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign({
    immediate: getInputImmediateModel(renderOpts)
  }, defaultCompProps, defaultProps, renderOpts.props, {
    [componentDefaultModelProp]: value
  });
}
function getCellEditFilterProps(renderOpts, params, value, defaultProps) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign({}, defaultCompProps, defaultProps, renderOpts.props, {
    [componentDefaultModelProp]: value
  });
}
function isImmediateCell(renderOpts, params) {
  return params.$type === 'cell' || getInputImmediateModel(renderOpts);
}
function getCellLabelVNs(renderOpts, params, cellLabel, opts) {
  const {
    placeholder
  } = renderOpts;
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: ['vxe-cell--label', opts ? opts.class : '']
  }, placeholder && isEmptyValue(cellLabel) ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-cell--placeholder'
  }, formatText(getFuncText(placeholder), 1))] : formatText(cellLabel, 1))];
}
/**
 * 原生事件处理
 * @param renderOpts
 * @param params
 * @param modelFunc
 * @param changeFunc
 */
function getNativeElementOns(renderOpts, params, eFns) {
  const {
    events
  } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const {
    model: modelFunc,
    change: changeFunc,
    blur: blurFunc
  } = eFns || {};
  const isSameEvent = changeEvent === modelEvent;
  const ons = {};
  if (events) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(events, (func, key) => {
      ons[getOnName(key)] = function (...args) {
        func(params, ...args);
      };
    });
  }
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function (targetEvnt) {
      modelFunc(targetEvnt);
      if (isSameEvent && changeFunc) {
        changeFunc(targetEvnt);
      }
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (!isSameEvent && changeFunc) {
    ons[getOnName(changeEvent)] = function (evnt) {
      changeFunc(evnt);
      if (events && events[changeEvent]) {
        events[changeEvent](params, evnt);
      }
    };
  }
  if (blurFunc) {
    ons[getOnName(blurEvent)] = function (evnt) {
      blurFunc(evnt);
      if (events && events[blurEvent]) {
        events[blurEvent](params, evnt);
      }
    };
  }
  return ons;
}
const blurEvent = 'blur';
/**
 * 组件事件处理
 * @param renderOpts
 * @param params
 * @param modelFunc
 * @param changeFunc
 */
function getComponentOns(renderOpts, params, eFns) {
  const {
    events
  } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const {
    model: modelFunc,
    change: changeFunc,
    blur: blurFunc
  } = eFns || {};
  const ons = {};
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(events, (func, key) => {
    ons[getOnName(key)] = function (...args) {
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(func)) {
        errLog('vxe.error.errFunc', [func]);
      }
      func(params, ...args);
    };
  });
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function (targetEvnt) {
      modelFunc(targetEvnt);
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (changeFunc) {
    ons[getOnName(changeEvent)] = function (...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  if (blurFunc) {
    ons[getOnName(blurEvent)] = function (...args) {
      blurFunc(...args);
      if (events && events[blurEvent]) {
        events[blurEvent](params, ...args);
      }
    };
  }
  return ons;
}
function getEditOns(renderOpts, params) {
  const {
    $table,
    row,
    column
  } = params;
  const {
    name
  } = renderOpts;
  const {
    model
  } = column;
  const isImmediate = isImmediateCell(renderOpts, params);
  return getComponentOns(renderOpts, params, {
    model(cellValue) {
      // 处理 model 值双向绑定
      model.update = true;
      model.value = cellValue;
      if (isImmediate) {
        setCellValue(row, column, cellValue);
      }
    },
    change(eventParams) {
      // 处理 change 事件相关逻辑
      if (!isImmediate && name && ['VxeInput', 'VxeNumberInput', 'VxeTextarea', '$input', '$textarea'].includes(name)) {
        const cellValue = eventParams.value;
        model.update = true;
        model.value = cellValue;
        $table.updateStatus(params, cellValue);
      } else {
        $table.updateStatus(params);
      }
    },
    blur() {
      if (isImmediate) {
        $table.handleCellRuleUpdateStatus('blur', params);
      } else {
        $table.handleCellRuleUpdateStatus('blur', params, model.value);
      }
    }
  });
}
function getFilterOns(renderOpts, params, option) {
  return getComponentOns(renderOpts, params, {
    model(value) {
      // 处理 model 值双向绑定
      option.data = value;
    },
    change() {
      handleConfirmFilter(params, !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(option.data), option);
    },
    blur() {
      handleConfirmFilter(params, !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(option.data), option);
    }
  });
}
function getNativeEditOns(renderOpts, params) {
  const {
    $table,
    row,
    column
  } = params;
  const {
    model
  } = column;
  return getNativeElementOns(renderOpts, params, {
    model(evnt) {
      // 处理 model 值双向绑定
      const targetEl = evnt.target;
      if (targetEl) {
        const cellValue = targetEl.value;
        if (isImmediateCell(renderOpts, params)) {
          setCellValue(row, column, cellValue);
        } else {
          model.update = true;
          model.value = cellValue;
        }
      }
    },
    change(evnt) {
      // 处理 change 事件相关逻辑
      const targetEl = evnt.target;
      if (targetEl) {
        const cellValue = targetEl.value;
        $table.updateStatus(params, cellValue);
      }
    },
    blur(evnt) {
      const targetEl = evnt.target;
      if (targetEl) {
        const cellValue = targetEl.value;
        $table.updateStatus(params, cellValue);
      }
    }
  });
}
function getNativeFilterOns(renderOpts, params, option) {
  return getNativeElementOns(renderOpts, params, {
    model(evnt) {
      // 处理 model 值双向绑定
      const targetEl = evnt.target;
      if (targetEl) {
        option.data = targetEl.value;
      }
    },
    change() {
      handleConfirmFilter(params, !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(option.data), option);
    },
    blur() {
      handleConfirmFilter(params, !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(option.data), option);
    }
  });
}
/**
 * 单元格可编辑渲染-原生的标签
 * input、textarea、select
 */
function nativeEditRender(renderOpts, params) {
  const {
    row,
    column
  } = params;
  const {
    name
  } = renderOpts;
  const cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row, column) : column.model.value;
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(name, {
    class: `vxe-default-${name}`,
    ...getNativeAttrs(renderOpts),
    value: cellValue,
    ...getNativeEditOns(renderOpts, params)
  })];
}
function buttonCellRender(renderOpts, params) {
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getCellEditProps(renderOpts, params, null),
    ...getComponentOns(renderOpts, params)
  })];
}
function defaultEditRender(renderOpts, params) {
  const {
    row,
    column
  } = params;
  const cellValue = getCellValue(row, column);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getCellEditProps(renderOpts, params, cellValue),
    ...getEditOns(renderOpts, params)
  })];
}
function checkboxEditRender(renderOpts, params) {
  const {
    row,
    column
  } = params;
  const cellValue = getCellValue(row, column);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getCellEditProps(renderOpts, params, cellValue),
    ...getEditOns(renderOpts, params)
  })];
}
function radioAndCheckboxGroupEditRender(renderOpts, params) {
  const {
    options
  } = renderOpts;
  const {
    row,
    column
  } = params;
  const cellValue = getCellValue(row, column);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    options,
    ...getCellEditProps(renderOpts, params, cellValue),
    ...getEditOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldEditRender(renderOpts, params) {
  const {
    row,
    column
  } = params;
  const cellValue = getCellValue(row, column);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getOldComponent(renderOpts), {
    ...getCellEditProps(renderOpts, params, cellValue),
    ...getEditOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldButtonEditRender(renderOpts, params) {
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getComponent('vxe-button'), {
    ...getCellEditProps(renderOpts, params, null),
    ...getComponentOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldButtonsEditRender(renderOpts, params) {
  return renderOpts.children.map(childRenderOpts => oldButtonEditRender(childRenderOpts, params)[0]);
}
function renderNativeOptgroups(renderOpts, params, renderOptionsMethods) {
  const {
    optionGroups,
    optionGroupProps = {}
  } = renderOpts;
  const groupOptions = optionGroupProps.options || 'options';
  const groupLabel = optionGroupProps.label || 'label';
  return optionGroups.map((group, gIndex) => {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('optgroup', {
      key: gIndex,
      label: group[groupLabel]
    }, renderOptionsMethods(group[groupOptions], renderOpts, params));
  });
}
/**
 * 渲染原生的 option 标签
 */
function renderNativeOptions(options, renderOpts, params) {
  const {
    optionProps = {}
  } = renderOpts;
  const {
    row,
    column
  } = params;
  const labelProp = optionProps.label || 'label';
  const valueProp = optionProps.value || 'value';
  const disabledProp = optionProps.disabled || 'disabled';
  const cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row, column) : column.model.value;
  return options.map((option, oIndex) => {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('option', {
      key: oIndex,
      value: option[valueProp],
      disabled: option[disabledProp],
      /* eslint-disable eqeqeq */
      selected: option[valueProp] == cellValue
    }, option[labelProp]);
  });
}
function nativeFilterRender(renderOpts, params) {
  const {
    column
  } = params;
  const {
    name
  } = renderOpts;
  const attrs = getNativeAttrs(renderOpts);
  return column.filters.map((option, oIndex) => {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(name, {
      key: oIndex,
      class: `vxe-default-${name}`,
      ...attrs,
      value: option.data,
      ...getNativeFilterOns(renderOpts, params, option)
    });
  });
}
function defaultFilterRender(renderOpts, params) {
  const {
    column
  } = params;
  return column.filters.map((option, oIndex) => {
    const optionValue = option.data;
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
      key: oIndex,
      ...getCellEditFilterProps(renderOpts, renderOpts, optionValue),
      ...getFilterOns(renderOpts, params, option)
    });
  });
}
/**
 * 已废弃
 * @deprecated
 */
function oldFilterRender(renderOpts, params) {
  const {
    column
  } = params;
  return column.filters.map((option, oIndex) => {
    const optionValue = option.data;
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getOldComponent(renderOpts), {
      key: oIndex,
      ...getCellEditFilterProps(renderOpts, renderOpts, optionValue),
      ...getFilterOns(renderOpts, params, option)
    });
  });
}
function handleFilterMethod({
  option,
  row,
  column
}) {
  const {
    data
  } = option;
  const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
  /* eslint-disable eqeqeq */
  return cellValue == data;
}
function handleInputFilterMethod({
  option,
  row,
  column
}) {
  const {
    data
  } = option;
  const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
  /* eslint-disable eqeqeq */
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(cellValue).indexOf(data) > -1;
}
function nativeSelectEditRender(renderOpts, params) {
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('select', {
    class: 'vxe-default-select',
    ...getNativeAttrs(renderOpts),
    ...getNativeEditOns(renderOpts, params)
  }, renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeOptions) : renderNativeOptions(renderOpts.options, renderOpts, params))];
}
function defaultSelectEditRender(renderOpts, params) {
  const {
    row,
    column
  } = params;
  const {
    options,
    optionProps,
    optionGroups,
    optionGroupProps
  } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getCellEditProps(renderOpts, params, cellValue, {
      options,
      optionProps,
      optionGroups,
      optionGroupProps
    }),
    ...getEditOns(renderOpts, params)
  })];
}
function defaultTableOrTreeSelectEditRender(renderOpts, params) {
  const {
    row,
    column
  } = params;
  const {
    options,
    optionProps
  } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getCellEditProps(renderOpts, params, cellValue, {
      options,
      optionProps
    }),
    ...getEditOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldSelectEditRender(renderOpts, params) {
  const {
    row,
    column
  } = params;
  const {
    options,
    optionProps,
    optionGroups,
    optionGroupProps
  } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getOldComponent(renderOpts), {
    ...getCellEditProps(renderOpts, params, cellValue, {
      options,
      optionProps,
      optionGroups,
      optionGroupProps
    }),
    ...getEditOns(renderOpts, params)
  })];
}
function getSelectCellValue(renderOpts, {
  row,
  column
}) {
  const {
    options,
    optionGroups,
    optionProps = {},
    optionGroupProps = {}
  } = renderOpts;
  const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
  let selectItem;
  const labelProp = optionProps.label || 'label';
  const valueProp = optionProps.value || 'value';
  if (!(cellValue === null || cellValue === undefined)) {
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().map(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(cellValue) ? cellValue : [cellValue], optionGroups ? value => {
      const groupOptions = optionGroupProps.options || 'options';
      for (let index = 0; index < optionGroups.length; index++) {
        /* eslint-disable eqeqeq */
        selectItem = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(optionGroups[index][groupOptions], item => item[valueProp] == value);
        if (selectItem) {
          break;
        }
      }
      return selectItem ? selectItem[labelProp] : value;
    } : value => {
      /* eslint-disable eqeqeq */
      selectItem = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(options, item => item[valueProp] == value);
      return selectItem ? selectItem[labelProp] : value;
    }).join(', ');
  }
  return '';
}
function handleExportSelectMethod(params) {
  const {
    row,
    column,
    options
  } = params;
  return options.original ? getCellValue(row, column) : getSelectCellValue(column.editRender || column.cellRender, params);
}
function getTreeSelectCellValue(renderOpts, {
  row,
  column
}) {
  const {
    options,
    optionProps = {}
  } = renderOpts;
  const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
  const labelProp = optionProps.label || 'label';
  const valueProp = optionProps.value || 'value';
  const childrenProp = optionProps.children || 'children';
  if (!(cellValue === null || cellValue === undefined)) {
    const keyMaps = {};
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(options, item => {
      keyMaps[external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(item, valueProp)] = item;
    }, {
      children: childrenProp
    });
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().map(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(cellValue) ? cellValue : [cellValue], value => {
      const item = keyMaps[value];
      return item ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(item, labelProp) : item;
    }).join(', ');
  }
  return '';
}
function handleExportTreeSelectMethod(params) {
  const {
    row,
    column,
    options
  } = params;
  return options.original ? getCellValue(row, column) : getTreeSelectCellValue(column.editRender || column.cellRender, params);
}
function handleNumberCell(renderOpts, params) {
  const {
    props = {},
    showNegativeStatus
  } = renderOpts;
  const {
    row,
    column
  } = params;
  const {
    type
  } = props;
  let cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
  let isNegative = false;
  if (!isEmptyValue(cellValue)) {
    const numberInputConfig = render_getConfig().numberInput || {};
    if (type === 'float') {
      const autoFill = handleDefaultValue(props.autoFill, numberInputConfig.autoFill, true);
      const digits = handleDefaultValue(props.digits, numberInputConfig.digits, 1);
      cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(cellValue, digits), digits);
      if (!autoFill) {
        cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellValue);
      }
      if (showNegativeStatus) {
        if (cellValue < 0) {
          isNegative = true;
        }
      }
    } else if (type === 'amount') {
      const autoFill = handleDefaultValue(props.autoFill, numberInputConfig.autoFill, true);
      const digits = handleDefaultValue(props.digits, numberInputConfig.digits, 2);
      const showCurrency = handleDefaultValue(props.showCurrency, numberInputConfig.showCurrency, false);
      cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellValue);
      if (showNegativeStatus) {
        if (cellValue < 0) {
          isNegative = true;
        }
      }
      cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().commafy(cellValue, {
        digits
      });
      if (!autoFill) {
        const [iStr, dStr] = cellValue.split('.');
        if (dStr) {
          const dRest = dStr.replace(/0+$/, '');
          cellValue = dRest ? [iStr, '.', dRest].join('') : iStr;
        }
      }
      if (showCurrency) {
        cellValue = `${props.currencySymbol || numberInputConfig.currencySymbol || render_getI18n('vxe.numberInput.currencySymbol') || ''}${cellValue}`;
      }
    } else {
      if (showNegativeStatus) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellValue) < 0) {
          isNegative = true;
        }
      }
    }
  }
  return getCellLabelVNs(renderOpts, params, cellValue, isNegative ? {
    class: 'is--negative'
  } : {});
}
/**
 * 表格 - 渲染器
 */
render_renderer.mixin({
  input: {
    tableAutoFocus: 'input',
    renderTableEdit: nativeEditRender,
    renderTableDefault: nativeEditRender,
    renderTableFilter: nativeFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  textarea: {
    tableAutoFocus: 'textarea',
    renderTableEdit: nativeEditRender
  },
  select: {
    renderTableEdit: nativeSelectEditRender,
    renderTableDefault: nativeSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderTableFilter(renderOpts, params) {
      const {
        column
      } = params;
      return column.filters.map((option, oIndex) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('select', {
          key: oIndex,
          class: 'vxe-default-select',
          ...getNativeAttrs(renderOpts),
          ...getNativeFilterOns(renderOpts, params, option)
        }, renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeOptions) : renderNativeOptions(renderOpts.options, renderOpts, params));
      });
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  VxeInput: {
    tableAutoFocus: 'input',
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      const {
        props = {}
      } = renderOpts;
      const {
        row,
        column
      } = params;
      const inputConfig = render_getConfig().input || {};
      const digits = props.digits || inputConfig.digits || 2;
      let cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      if (cellValue) {
        switch (props.type) {
          case 'date':
          case 'week':
          case 'month':
          case 'quarter':
          case 'year':
            cellValue = getLabelFormatDate(cellValue, props);
            break;
          case 'float':
            cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(cellValue, digits), digits);
            break;
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderTableDefault: defaultEditRender,
    renderTableFilter: defaultFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  FormatNumberInput: {
    renderTableDefault: handleNumberCell,
    tableFilterDefaultMethod: handleInputFilterMethod,
    tableExportMethod(params) {
      const {
        row,
        column
      } = params;
      const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      return cellValue;
    }
  },
  VxeNumberInput: {
    tableAutoFocus: 'input',
    renderTableEdit: defaultEditRender,
    renderTableCell: handleNumberCell,
    renderTableFooter(renderOpts, params) {
      const {
        props = {}
      } = renderOpts;
      const {
        row,
        column,
        _columnIndex
      } = params;
      const {
        type
      } = props;
      // 兼容老模式
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(row) ? row[_columnIndex] : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(itemValue)) {
        const numberInputConfig = render_getConfig().numberInput || {};
        if (type === 'float') {
          const autoFill = handleDefaultValue(props.autoFill, numberInputConfig.autoFill, true);
          const digits = handleDefaultValue(props.digits, numberInputConfig.digits, 1);
          let amountLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(itemValue, digits), digits);
          if (!autoFill) {
            amountLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(amountLabel);
          }
          return amountLabel;
        } else if (type === 'amount') {
          const autoFill = handleDefaultValue(props.autoFill, numberInputConfig.autoFill, true);
          const digits = handleDefaultValue(props.digits, numberInputConfig.digits, 2);
          const showCurrency = handleDefaultValue(props.showCurrency, numberInputConfig.showCurrency, false);
          let amountLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().commafy(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(itemValue), {
            digits
          });
          if (!autoFill) {
            const [iStr, dStr] = amountLabel.split('.');
            if (dStr) {
              const dRest = dStr.replace(/0+$/, '');
              amountLabel = dRest ? [iStr, '.', dRest].join('') : iStr;
            }
          }
          if (showCurrency) {
            amountLabel = `${props.currencySymbol || numberInputConfig.currencySymbol || render_getI18n('vxe.numberInput.currencySymbol') || ''}${amountLabel}`;
          }
          return amountLabel;
        }
      }
      return getFuncText(itemValue, 1);
    },
    renderTableDefault: defaultEditRender,
    renderTableFilter: defaultFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod,
    tableExportMethod(params) {
      const {
        row,
        column
      } = params;
      const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      return cellValue;
    }
  },
  VxeDatePicker: {
    tableAutoFocus: 'input',
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      const {
        props = {}
      } = renderOpts;
      const {
        row,
        column
      } = params;
      let cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      if (cellValue) {
        if (props.type !== 'time') {
          cellValue = getLabelFormatDate(cellValue, props);
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderTableDefault: defaultEditRender,
    renderTableFilter: defaultFilterRender,
    tableFilterDefaultMethod: handleFilterMethod
  },
  VxeTextarea: {
    tableAutoFocus: 'textarea',
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      const {
        row,
        column
      } = params;
      const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      return getCellLabelVNs(renderOpts, params, cellValue);
    }
  },
  VxeButton: {
    renderTableDefault: buttonCellRender
  },
  VxeButtonGroup: {
    renderTableDefault(renderOpts, params) {
      const {
        options
      } = renderOpts;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        options,
        ...getCellEditProps(renderOpts, params, null),
        ...getComponentOns(renderOpts, params)
      })];
    }
  },
  VxeSelect: {
    tableAutoFocus: 'input',
    renderTableEdit: defaultSelectEditRender,
    renderTableDefault: defaultSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderTableFilter(renderOpts, params) {
      const {
        column
      } = params;
      const {
        options,
        optionProps,
        optionGroups,
        optionGroupProps
      } = renderOpts;
      return column.filters.map((option, oIndex) => {
        const optionValue = option.data;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
          key: oIndex,
          ...getCellEditFilterProps(renderOpts, params, optionValue, {
            options,
            optionProps,
            optionGroups,
            optionGroupProps
          }),
          ...getFilterOns(renderOpts, params, option)
        });
      });
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  /**
   * 已废弃，被 FormatSelect 替换
   * @deprecated
   */
  formatOption: {
    renderTableDefault(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    }
  },
  FormatSelect: {
    renderTableDefault(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  VxeTreeSelect: {
    tableAutoFocus: 'input',
    renderTableEdit: defaultTableOrTreeSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    },
    tableExportMethod: handleExportTreeSelectMethod
  },
  /**
   * 已废弃，被 FormatTreeSelect 替换
   * @deprecated
   */
  formatTree: {
    renderTableDefault(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    }
  },
  FormatTreeSelect: {
    renderTableDefault(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    },
    tableExportMethod: handleExportTreeSelectMethod
  },
  VxeTableSelect: {
    tableAutoFocus: 'input',
    renderTableEdit: defaultTableOrTreeSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    },
    tableExportMethod: handleExportTreeSelectMethod
  },
  VxeColorPicker: {
    tableAutoFocus: 'input',
    renderTableEdit(renderOpts, params) {
      const {
        row,
        column
      } = params;
      const {
        options
      } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...getCellEditProps(renderOpts, params, cellValue, {
          colors: options
        }),
        ...getEditOns(renderOpts, params)
      })];
    },
    renderTableCell(renderOpts, params) {
      const {
        row,
        column
      } = params;
      const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-color-picker--readonly'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--readonly-color',
        style: {
          backgroundColor: cellValue
        }
      })]);
    }
  },
  VxeIconPicker: {
    tableAutoFocus: 'input',
    renderTableEdit(renderOpts, params) {
      const {
        row,
        column
      } = params;
      const {
        options
      } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...getCellEditProps(renderOpts, params, cellValue, {
          icons: options
        }),
        ...getEditOns(renderOpts, params)
      })];
    },
    renderTableCell(renderOpts, params) {
      const {
        row,
        column
      } = params;
      const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: cellValue
      });
    }
  },
  VxeRadioGroup: {
    renderTableDefault: radioAndCheckboxGroupEditRender
  },
  VxeCheckbox: {
    renderTableDefault: checkboxEditRender
  },
  VxeCheckboxGroup: {
    renderTableDefault: radioAndCheckboxGroupEditRender
  },
  VxeSwitch: {
    tableAutoFocus: 'button',
    renderTableEdit: defaultEditRender,
    renderTableDefault: defaultEditRender
  },
  VxeUpload: {
    renderTableEdit: defaultEditRender,
    renderTableCell: defaultEditRender,
    renderTableDefault: defaultEditRender
  },
  VxeImage: {
    renderTableDefault(renderOpts, params) {
      const {
        row,
        column
      } = params;
      const {
        props
      } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...props,
        src: cellValue,
        ...getEditOns(renderOpts, params)
      })];
    }
  },
  VxeImageGroup: {
    renderTableDefault(renderOpts, params) {
      const {
        row,
        column
      } = params;
      const {
        props
      } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...props,
        urlList: cellValue,
        ...getEditOns(renderOpts, params)
      })];
    }
  },
  VxeTextEllipsis: {
    renderTableDefault(renderOpts, params) {
      const {
        row,
        column
      } = params;
      const {
        props
      } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...props,
        content: cellValue,
        ...getEditOns(renderOpts, params)
      })];
    }
  },
  VxeRate: {
    renderTableDefault: defaultEditRender
  },
  VxeSlider: {
    renderTableDefault: defaultEditRender
  },
  // 以下已废弃
  $input: {
    tableAutoFocus: '.vxe-input--inner',
    renderTableEdit: oldEditRender,
    renderTableCell(renderOpts, params) {
      const {
        props = {}
      } = renderOpts;
      const {
        row,
        column
      } = params;
      const digits = props.digits || render_getConfig().input?.digits || 2;
      let cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      if (cellValue) {
        switch (props.type) {
          case 'date':
          case 'week':
          case 'month':
          case 'year':
            cellValue = getLabelFormatDate(cellValue, props);
            break;
          case 'float':
            cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(cellValue, digits), digits);
            break;
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderTableDefault: oldEditRender,
    renderTableFilter: oldFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  $textarea: {
    tableAutoFocus: '.vxe-textarea--inner'
  },
  $button: {
    renderTableDefault: oldButtonEditRender
  },
  $buttons: {
    renderTableDefault: oldButtonsEditRender
  },
  $select: {
    tableAutoFocus: '.vxe-input--inner',
    renderTableEdit: oldSelectEditRender,
    renderTableDefault: oldSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderTableFilter(renderOpts, params) {
      const {
        column
      } = params;
      const {
        options,
        optionProps,
        optionGroups,
        optionGroupProps
      } = renderOpts;
      return column.filters.map((option, oIndex) => {
        const optionValue = option.data;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getOldComponent(renderOpts), {
          key: oIndex,
          ...getCellEditFilterProps(renderOpts, params, optionValue, {
            options,
            optionProps,
            optionGroups,
            optionGroupProps
          }),
          ...getFilterOns(renderOpts, params, option)
        });
      });
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  $radio: {
    tableAutoFocus: '.vxe-radio--input'
  },
  $checkbox: {
    tableAutoFocus: '.vxe-checkbox--input'
  },
  $switch: {
    tableAutoFocus: '.vxe-switch--button',
    renderTableEdit: oldEditRender,
    renderTableDefault: oldEditRender
  }
  // 以上已废弃
});
;// ./packages/table/index.ts











const VxeTable = Object.assign({}, table, {
  install(app) {
    app.component(table.name, table);
  }
});
const tableHandle = {
  useCellView: useCellView
};
if (core_.VxeUI.dynamicApp) {
  core_.VxeUI.dynamicApp.component(table.name, table);
}
core_.VxeUI.component(table);
core_.VxeUI.tableHandle = tableHandle;
const Table = VxeTable;
/* harmony default export */ var packages_table = ((/* unused pure expression or super */ null && (VxeTable)));
;// ./packages/toolbar/index.ts


const VxeToolbar = Object.assign({}, toolbar, {
  install(app) {
    app.component(toolbar.name, toolbar);
  }
});
if (core_.VxeUI.dynamicApp) {
  core_.VxeUI.dynamicApp.component(toolbar.name, toolbar);
}
core_.VxeUI.component(toolbar);
const Toolbar = VxeToolbar;
/* harmony default export */ var packages_toolbar = ((/* unused pure expression or super */ null && (VxeToolbar)));
;// ./packages/locale/lang/zh-CN.ts
/* harmony default export */ var zh_CN = ({
  vxe: {
    base: {
      pleaseInput: '请输入',
      pleaseSelect: '请选择',
      comma: '，',
      fullStop: '。'
    },
    loading: {
      text: '加载中...'
    },
    error: {
      downErr: '下载失败',
      errLargeData: '当绑定的数据量过大时，应该请使用 {0}，否则可能会出现卡顿',
      groupFixed: '如果使用分组表头，冻结列必须按组设置',
      groupMouseRange: '分组表头与 "{0}" 不能同时使用，这可能会出现错误',
      groupTag: '分组列头应该使用 "{0}" 而不是 "{1}"，这可能会出现错误',
      scrollErrProp: '启用虚拟滚动后不支持该参数 "{0}"',
      errConflicts: '参数 "{0}" 与 "{1}" 有冲突',
      notSupportProp: '当启用参数 "{0}" 时不支持 "{1}"，应该为 "{2}"，否则将会出现错误',
      notConflictProp: '当使用 "{0}" 时，应该设置 "{1}"，否则可能会存在功能冲突',
      unableInsert: '无法插入到指定位置，请检查参数是否正确',
      useErr: '安装 "{0}" 模块时发生错误，可能顺序不正确，依赖的模块需要在 Table 之前安装',
      barUnableLink: '工具栏无法关联表格',
      expandContent: '展开行的插槽应该是 "content"，请检查是否正确',
      reqComp: '缺少 "{0}" 组件，请检查是否正确安装。 https://vxeui.com/#/start/useGlobal',
      reqModule: '缺少 "{0}" 模块',
      reqProp: '缺少必要的 "{0}" 参数，这可能会导致出现错误',
      emptyProp: '参数 "{0}" 不允许为空',
      errProp: '不支持的参数 "{0}"，可能为 "{1}"',
      colRepet: 'column.{0}="{1}" 重复了，这可能会导致某些功能无法使用',
      notFunc: '方法 "{0}" 不存在',
      errFunc: '参数 "{0}" 不是一个方法',
      notValidators: '全局校验 "{0}" 不存在',
      notFormats: '全局格式化 "{0}" 不存在',
      notCommands: '全局指令 "{0}" 不存在',
      notSlot: '插槽 "{0}" 不存在',
      noTree: '树结构不支持 "{0}"',
      notProp: '不支持的参数 "{0}"',
      checkProp: '当数据量过大时可能会导致复选框卡顿，建议设置参数 "{0}" 提升渲染速度',
      coverProp: '"{0}" 的参数 "{1}" 重复定义，这可能会出现错误',
      uniField: '字段名 "{0}" 重复定义，这可能会出现错误',
      repeatKey: '主键重复 {0}="{1}"，这可能会出现错误',
      delFunc: '方法 "{0}" 已废弃，请使用 "{1}"',
      delProp: '参数 "{0}" 已废弃，请使用 "{1}"',
      delEvent: '事件 "{0}" 已废弃，请使用 "{1}"',
      removeProp: '参数 "{0}" 已废弃，不建议使用，这可能会导致出现错误',
      errFormat: '全局的格式化内容应该使用 "VXETable.formats" 定义，挂载 "formatter={0}" 的方式已不建议使用',
      notType: '不支持的文件类型 "{0}"',
      notExp: '该浏览器不支持导入/导出功能',
      impFields: '导入失败，请检查字段名和数据格式是否正确',
      treeNotImp: '树表格不支持导入',
      treeCrossDrag: '只能拖拽第一层级',
      treeDragChild: '父级不能拖拽到自己的子级中',
      reqPlugin: '扩展插件未安装 "{1}" https://vxeui.com/other{0}/#/{1}/install',
      errMaxRow: '超过支持的最大数据量 {0} 行，这可能会导致出现错误'
    },
    table: {
      emptyText: '暂无数据',
      allTitle: '全选/取消',
      seqTitle: '序号',
      actionTitle: '操作',
      confirmFilter: '筛选',
      resetFilter: '重置',
      allFilter: '全部',
      sortAsc: '升序：最低到最高',
      sortDesc: '降序：最高到最低',
      filter: '对所选的列启用筛选',
      impSuccess: '成功导入 {0} 条记录',
      expLoading: '正在导出中',
      expSuccess: '导出成功',
      expError: '导出失败',
      expFilename: '导出_{0}',
      expOriginFilename: '导出_源_{0}',
      customTitle: '列设置',
      customAll: '全部',
      customConfirm: '确认',
      customClose: '关闭',
      customCancel: '取消',
      customRestore: '恢复默认',
      maxFixedCol: '最大冻结列的数量不能超过 {0} 个',
      dragTip: '移动：{0}',
      resizeColTip: '宽：{0} 像素',
      resizeRowTip: '高：{0} 像素',
      rowGroupContentTotal: '{0}（{1}）'
    },
    grid: {
      selectOneRecord: '请至少选择一条记录！',
      deleteSelectRecord: '您确定要删除所选记录吗？',
      removeSelectRecord: '您确定要移除所选记录吗？',
      dataUnchanged: '数据未改动！',
      delSuccess: '成功删除所选记录！',
      saveSuccess: '保存成功！',
      operError: '发生错误，操作失败！'
    },
    select: {
      search: '搜索',
      loadingText: '加载中',
      emptyText: '暂无数据'
    },
    pager: {
      goto: '前往',
      gotoTitle: '页数',
      pagesize: '{0}条/页',
      total: '共 {0} 条记录',
      pageClassifier: '页',
      homePage: '首页',
      homePageTitle: '首页',
      prevPage: '上一页',
      prevPageTitle: '上一页',
      nextPage: '下一页',
      nextPageTitle: '下一页',
      prevJump: '向上跳页',
      prevJumpTitle: '向上跳页',
      nextJump: '向下跳页',
      nextJumpTitle: '向下跳页',
      endPage: '末页',
      endPageTitle: '末页'
    },
    alert: {
      title: '系统提示'
    },
    button: {
      confirm: '确认',
      cancel: '取消',
      clear: '清除'
    },
    filter: {
      search: '搜索'
    },
    custom: {
      cstmTitle: '列设置',
      cstmRestore: '恢复默认',
      cstmCancel: '取消',
      cstmConfirm: '确定',
      cstmConfirmRestore: '请确认是否恢复成默认列配置？',
      cstmDragTarget: '移动：{0}',
      setting: {
        colSort: '排序',
        sortHelpTip: '点击并拖动图标可以调整列的排序',
        colTitle: '列标题',
        colResizable: '列宽（像素）',
        colVisible: '是否显示',
        colFixed: '冻结列',
        colFixedMax: '冻结列（最多 {0} 列）',
        fixedLeft: '左侧',
        fixedUnset: '不设置',
        fixedRight: '右侧'
      }
    },
    import: {
      modes: {
        covering: '覆盖方式（直接覆盖表格数据）',
        insert: '底部追加（在表格的底部追加新数据）',
        insertTop: '顶部追加（在表格的顶部追加新数据）',
        insertBottom: '底部追加（在表格的底部追加新数据）'
      },
      impTitle: '导入数据',
      impFile: '文件名',
      impSelect: '选择文件',
      impType: '文件类型',
      impOpts: '参数设置',
      impMode: '导入模式',
      impConfirm: '导入',
      impCancel: '取消'
    },
    export: {
      types: {
        csv: 'CSV (逗号分隔)(*.csv)',
        html: '网页(*.html)',
        xml: 'XML 数据(*.xml)',
        txt: '文本文件(制表符分隔)(*.txt)',
        xls: 'Excel 97-2003 工作簿(*.xls)',
        xlsx: 'Excel 工作簿(*.xlsx)',
        pdf: 'PDF (*.pdf)'
      },
      modes: {
        empty: '空数据',
        current: '当前数据（当前页的数据）',
        selected: '选中数据（当前页选中的数据）',
        all: '全量数据（包括所有分页的数据）'
      },
      printTitle: '打印数据',
      expTitle: '导出数据',
      expName: '文件名',
      expNamePlaceholder: '请输入文件名',
      expSheetName: '标题',
      expSheetNamePlaceholder: '请输入标题',
      expType: '保存类型',
      expMode: '选择数据',
      expCurrentColumn: '全部字段',
      expColumn: '选择字段',
      expOpts: '参数设置',
      expOptHeader: '表头',
      expHeaderTitle: '是否需要表头',
      expOptFooter: '表尾',
      expFooterTitle: '是否需要表尾',
      expOptColgroup: '分组表头',
      expOptTitle: '列标题',
      expTitleTitle: '是否为列标题，否则显示为列的字段名',
      expColgroupTitle: '如果存在，则支持带有分组结构的表头',
      expOptMerge: '合并',
      expMergeTitle: '如果存在，则支持带有合并结构的单元格',
      expOptAllExpand: '展开树',
      expAllExpandTitle: '如果存在，则支持将带有层级结构的数据全部展开',
      expOptUseStyle: '样式',
      expUseStyleTitle: '如果存在，则支持带样式的单元格',
      expOptOriginal: '源数据',
      expOriginalTitle: '如果为源数据，则支持导入到表格中',
      expPrint: '打印',
      expConfirm: '导出',
      expCancel: '取消'
    },
    modal: {
      errTitle: '错误提示',
      zoomMin: '最小化',
      zoomIn: '最大化',
      zoomOut: '还原',
      close: '关闭',
      miniMaxSize: '最小化窗口的数量不能超过 {0} 个',
      footPropErr: 'show-footer 仅用于启用表尾，需配合 show-confirm-button | show-cancel-button | 插槽使用'
    },
    drawer: {
      close: '关闭'
    },
    form: {
      folding: '收起',
      unfolding: '展开'
    },
    toolbar: {
      import: '导入',
      export: '导出',
      print: '打印',
      refresh: '刷新',
      zoomIn: '全屏',
      zoomOut: '还原',
      custom: '列设置',
      customAll: '全部',
      customConfirm: '确认',
      customRestore: '重置',
      fixedLeft: '冻结在左侧',
      fixedRight: '冻结在右侧',
      cancelFixed: '取消冻结列'
    },
    datePicker: {
      yearTitle: '{0} 年'
    },
    input: {
      date: {
        m1: '01 月',
        m2: '02 月',
        m3: '03 月',
        m4: '04 月',
        m5: '05 月',
        m6: '06 月',
        m7: '07 月',
        m8: '08 月',
        m9: '09 月',
        m10: '10 月',
        m11: '11 月',
        m12: '12 月',
        quarterLabel: '{0} 年',
        monthLabel: '{0} 年',
        dayLabel: '{0} 年 {1}',
        labelFormat: {
          date: 'yyyy-MM-dd',
          time: 'HH:mm:ss',
          datetime: 'yyyy-MM-dd HH:mm:ss',
          week: 'yyyy 年第 WW 周',
          month: 'yyyy-MM',
          quarter: 'yyyy 年第 q 季度',
          year: 'yyyy'
        },
        weeks: {
          w: '周',
          w0: '周日',
          w1: '周一',
          w2: '周二',
          w3: '周三',
          w4: '周四',
          w5: '周五',
          w6: '周六'
        },
        months: {
          m0: '一月',
          m1: '二月',
          m2: '三月',
          m3: '四月',
          m4: '五月',
          m5: '六月',
          m6: '七月',
          m7: '八月',
          m8: '九月',
          m9: '十月',
          m10: '十一月',
          m11: '十二月'
        },
        quarters: {
          q1: '第一季度',
          q2: '第二季度',
          q3: '第三季度',
          q4: '第四季度'
        }
      }
    },
    numberInput: {
      currencySymbol: '¥'
    },
    imagePreview: {
      popupTitle: '预览',
      operBtn: {
        zoomOut: '缩小',
        zoomIn: '放大',
        pctFull: '等比例缩放',
        pct11: '显示原始尺寸',
        rotateLeft: '向左旋转',
        rotateRight: '向右旋转',
        print: '点击打印图片',
        download: '点击下载图片'
      }
    },
    upload: {
      fileBtnText: '点击或拖拽上传',
      imgBtnText: '点击或拖拽上传',
      dragPlaceholder: '请把文件拖放到这个区域即可上传',
      imgSizeHint: '单张{0}',
      imgCountHint: '最多{0}张',
      fileTypeHint: '支持 {0} 文件类型',
      fileSizeHint: '单个文件大小不超过{0}',
      fileCountHint: '最多可上传{0}个文件',
      uploadTypeErr: '文件类型不匹配！',
      overCountErr: '最多只能选择{0}个文件！',
      overCountExtraErr: '已超出最大数量{0}个，超出的{1}个文件将被忽略！',
      overSizeErr: '文件大小最大不能超过{0}！',
      reUpload: '重新上传',
      uploadProgress: '上传中 {0}%',
      uploadErr: '上传失败',
      uploadSuccess: '上传成功',
      moreBtnText: '更多（{0}）',
      viewItemTitle: '点击查看',
      morePopup: {
        readTitle: '查看列表',
        imageTitle: '上传图片',
        fileTitle: '上传文件'
      }
    },
    empty: {
      defText: '暂无数据'
    },
    colorPicker: {
      clear: '清除',
      confirm: '确认',
      copySuccess: '已复制到剪贴板：{0}'
    },
    formDesign: {
      formName: '表单名称',
      defFormTitle: '未命名的表单',
      widgetPropTab: '控件属性',
      widgetFormTab: '表单属性',
      error: {
        wdFormUni: '该类型的控件在表单中只允许添加一个',
        wdSubUni: '该类型的控件在子表中只允许添加一个'
      },
      styleSetting: {
        btn: '样式设置',
        title: '表单的样式设置',
        layoutTitle: '控件布局',
        verticalLayout: '上下布局',
        horizontalLayout: '横向布局',
        styleTitle: '标题样式',
        boldTitle: '标题加粗',
        fontBold: '加粗',
        fontNormal: '常规',
        colonTitle: '显示冒号',
        colonVisible: '显示',
        colonHidden: '隐藏',
        alignTitle: '对齐方式',
        widthTitle: '标题宽度',
        alignLeft: '居左',
        alignRight: '居右',
        unitPx: '像素',
        unitPct: '百分比'
      },
      widget: {
        group: {
          base: '基础控件',
          layout: '布局控件',
          system: '系统控件',
          module: '模块控件',
          chart: '图表控件',
          advanced: '高级控件'
        },
        copyTitle: '副本_{0}',
        component: {
          input: '输入框',
          textarea: '文本域',
          select: '下拉选择',
          row: '一行多列',
          title: '标题',
          text: '文本',
          subtable: '子表',
          VxeSwitch: '是/否',
          VxeInput: '输入框',
          VxeNumberInput: '数字',
          VxeDatePicker: '日期',
          VxeTextarea: '文本域',
          VxeSelect: '下拉选择',
          VxeTreeSelect: '树形选择',
          VxeRadioGroup: '单选框',
          VxeCheckboxGroup: '复选框',
          VxeUploadFile: '文件',
          VxeUploadImage: '图片',
          VxeRate: '评分',
          VxeSlider: '滑块'
        }
      },
      widgetProp: {
        name: '控件名称',
        placeholder: '提示语',
        required: '必填校验',
        multiple: '允许多选',
        displaySetting: {
          name: '显示设置',
          pc: '电脑端',
          mobile: '手机端',
          visible: '显示',
          hidden: '隐藏'
        },
        dataSource: {
          name: '数据源',
          defValue: '选项{0}',
          addOption: '添加选项',
          batchEditOption: '批量编辑',
          batchEditTip: '每行对应一个选项，支持从表格、Excel、WPS 中直接复制粘贴。',
          batchEditSubTip: '每行对应一个选项，如果是分组，子项可以是空格或制表键开头，支持从表格、Excel、WPS 中直接复制粘贴。',
          buildOption: '生成选项'
        },
        rowProp: {
          colSize: '列数',
          col2: '两列',
          col3: '三列',
          col4: '四列',
          col6: '六列',
          layout: '布局'
        },
        textProp: {
          name: '内容',
          alignTitle: '对齐方式',
          alignLeft: '居左',
          alignCenter: '居中',
          alignRight: '居右',
          colorTitle: '字体颜色',
          sizeTitle: '字体大小',
          boldTitle: '字体加粗',
          fontNormal: '常规',
          fontBold: '加粗'
        },
        subtableProp: {
          seqTitle: '序号',
          showSeq: '显示序号',
          showCheckbox: '允许多选',
          errSubDrag: '子表不支持该控件，请使用其他控件',
          colPlace: '将控件拖拽进来'
        },
        uploadProp: {
          limitFileCount: '文件数量限制',
          limitFileSize: '文件大小限制',
          multiFile: '允许上传多个文件',
          limitImgCount: '图片数量限制',
          limitImgSize: '图片大小限制',
          multiImg: '允许上传多张图片'
        }
      }
    },
    listDesign: {
      fieldSettingTab: '字段设置',
      listSettingTab: '参数设置',
      searchTitle: '查询条件',
      listTitle: '列表字段',
      searchField: '查询字段',
      listField: '列表字段',
      activeBtn: {
        ActionButtonUpdate: '编辑',
        ActionButtonDelete: '删除'
      },
      search: {
        addBtn: '编辑',
        emptyText: '未配置查询条件',
        editPopupTitle: '编辑查询字段'
      },
      searchPopup: {
        colTitle: '标题',
        saveBtn: '保存'
      }
    },
    text: {
      copySuccess: '已复制到剪贴板',
      copyError: '当前环境不支持该操作'
    },
    countdown: {
      formats: {
        yyyy: '年',
        MM: '月',
        dd: '天',
        HH: '时',
        mm: '分',
        ss: '秒'
      }
    },
    plugins: {
      extendCellArea: {
        area: {
          mergeErr: '无法对合并单元格进行该操作',
          multiErr: '无法对多重选择区域进行该操作',
          selectErr: '无法操作指定区域的单元格',
          extendErr: '如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同',
          pasteMultiErr: '无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作',
          cpInvalidErr: '该操作无法进行，您选择的区域中存在被禁止的列（{0}）'
        },
        fnr: {
          title: '查找和替换',
          findLabel: '查找',
          replaceLabel: '替换',
          findTitle: '查找内容：',
          replaceTitle: '替换为：',
          tabs: {
            find: '查找',
            replace: '替换'
          },
          filter: {
            re: '正则表达式',
            whole: '全词匹配',
            sensitive: '区分大小写'
          },
          btns: {
            findNext: '查找下一个',
            findAll: '查找全部',
            replace: '替换',
            replaceAll: '替换全部',
            cancel: '取消'
          },
          header: {
            seq: '#',
            cell: '单元格',
            value: '值'
          },
          body: {
            row: '行：{0}',
            col: '列：{0}'
          },
          empty: '(空值)',
          reError: '无效的正则表达式',
          recordCount: '已找到 {0} 个单元格',
          notCell: '找不到匹配的单元格',
          replaceSuccess: '成功替换 {0} 个单元格'
        }
      },
      filterComplexInput: {
        menus: {
          fixedColumn: '冻结列',
          fixedGroup: '冻结分组',
          cancelFixed: '取消冻结',
          fixedLeft: '冻结左侧',
          fixedRight: '冻结右侧'
        },
        cases: {
          equal: '等于',
          gt: '大于',
          lt: '小于',
          begin: '开头是',
          endin: '结尾是',
          include: '包含',
          isSensitive: '区分大小写'
        }
      },
      filterCombination: {
        menus: {
          sort: '排序',
          clearSort: '清除排序',
          sortAsc: '升序',
          sortDesc: '降序',
          fixedColumn: '冻结列',
          fixedGroup: '冻结分组',
          cancelFixed: '取消冻结',
          fixedLeft: '冻结左侧',
          fixedRight: '冻结右侧',
          clearFilter: '清除筛选',
          textOption: '文本筛选',
          numberOption: '数值筛选'
        },
        popup: {
          title: '自定义筛选的方式',
          currColumnTitle: '当前列：',
          and: '与',
          or: '或',
          describeHtml: '可用 ? 代表单个字符<br/>用 * 代表任意多个字符'
        },
        cases: {
          equal: '等于',
          unequal: '不等于',
          gt: '大于',
          ge: '大于或等于',
          lt: '小于',
          le: '小于或等于',
          begin: '开头是',
          notbegin: '开头不是',
          endin: '结尾是',
          notendin: '结尾不是',
          include: '包含',
          exclude: '不包含',
          between: '介于',
          custom: '自定义筛选',
          insensitive: '不区分大小写',
          isSensitive: '区分大小写'
        },
        empty: '(空白)',
        notData: '无匹配项'
      }
    },
    pro: {
      area: {
        mergeErr: '无法对合并单元格进行该操作',
        multiErr: '无法对多重选择区域进行该操作',
        extendErr: '如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同',
        pasteMultiErr: '无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作'
      },
      fnr: {
        title: '查找和替换',
        findLabel: '查找',
        replaceLabel: '替换',
        findTitle: '查找内容：',
        replaceTitle: '替换为：',
        tabs: {
          find: '查找',
          replace: '替换'
        },
        filter: {
          re: '正则表达式',
          whole: '全词匹配',
          sensitive: '区分大小写'
        },
        btns: {
          findNext: '查找下一个',
          findAll: '查找全部',
          replace: '替换',
          replaceAll: '替换全部',
          cancel: '取消'
        },
        header: {
          seq: '#',
          cell: '单元格',
          value: '值'
        },
        empty: '(空值)',
        reError: '无效的正则表达式',
        recordCount: '已找到 {0} 个单元格',
        notCell: '找不到匹配的单元格',
        replaceSuccess: '成功替换 {0} 个单元格'
      }
    },
    renderer: {
      search: '搜索',
      cases: {
        equal: '等于',
        unequal: '不等于',
        gt: '大于',
        ge: '大于或等于',
        lt: '小于',
        le: '小于或等于',
        begin: '开头是',
        notbegin: '开头不是',
        endin: '结尾是',
        notendin: '结尾不是',
        include: '包含',
        exclude: '不包含',
        between: '介于',
        custom: '自定义筛选',
        insensitive: '不区分大小写',
        isSensitive: '区分大小写'
      },
      combination: {
        menus: {
          sort: '排序',
          clearSort: '清除排序',
          sortAsc: '升序',
          sortDesc: '降序',
          fixedColumn: '冻结列',
          fixedGroup: '冻结分组',
          cancelFixed: '取消冻结',
          fixedLeft: '冻结到左侧',
          fixedRight: '冻结到右侧',
          clearFilter: '清除筛选',
          textOption: '文本筛选',
          numberOption: '数值筛选'
        },
        popup: {
          title: '自定义筛选的方式',
          currColumnTitle: '当前列：',
          and: '与',
          or: '或',
          describeHtml: '可用 ? 代表单个字符<br/>用 * 代表任意多个字符'
        },
        empty: '(空白)',
        notData: '无匹配项'
      }
    }
  }
});
;// ./packages/components.ts









const components = [VxeColumn, VxeColgroup, VxeGrid, VxeTable, VxeToolbar];
// 默认安装
function install(app, options) {
  core_.VxeUI.setConfig(options);
  components.forEach(component => component.install(app));
}
// 保留兼容老版本
if (!core_.VxeUI.hasLanguage('zh-CN')) {
  const defaultLanguage = 'zh-CN';
  core_.VxeUI.setI18n(defaultLanguage, zh_CN);
  core_.VxeUI.setLanguage(defaultLanguage);
}
core_.VxeUI.setTheme('light');

// Components





;// ./index.ts


if (typeof window !== 'undefined' && window.Vue) {
  if (!window.VXETable) {
    window.VXETable = components_namespaceObject;
  }
}

/* harmony default export */ var index = (components_namespaceObject);
;// ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = (index);


/******/ 	return __webpack_exports__;
/******/ })()
;
});