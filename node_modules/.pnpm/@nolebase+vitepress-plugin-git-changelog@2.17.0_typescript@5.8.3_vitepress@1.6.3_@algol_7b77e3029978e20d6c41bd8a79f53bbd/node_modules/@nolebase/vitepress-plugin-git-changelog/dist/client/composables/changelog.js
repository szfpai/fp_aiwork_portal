"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useChangelog = useChangelog;
var _virtualNolebaseGitChangelog = _interopRequireDefault(require("virtual:nolebase-git-changelog"));
var _vitepress = require("vitepress");
var _vue = require("vue");
var _utils = require("../utils");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function useChangelog() {
  const {
    page
  } = (0, _vitepress.useData)();
  const gitChangelog = (0, _vue.ref)(_virtualNolebaseGitChangelog.default);
  if (!gitChangelog.value) gitChangelog.value = {
    commits: [],
    authors: []
  };
  const _commits = (0, _vue.computed)(() => {
    const currentPath = (0, _vue.toValue)(page.value.filePath);
    const allCommits = gitChangelog.value.commits;
    const commits2 = allCommits.filter(c => c.paths.includes(currentPath)) || [];
    return commits2.sort((a, b) => b.date_timestamp - a.date_timestamp).filter((commit, index) => {
      if (commit.tag && (!commits2[index + 1] || commits2[index + 1]?.tag)) return false;
      return true;
    });
  });
  const authors = (0, _vue.computed)(() => {
    const uniq = /* @__PURE__ */new Map();
    const authorsFromFrontMatter = (0, _utils.isStringArray)(page.value.frontmatter.authors) ? page.value.frontmatter.authors : [];
    [..._commits.value.map(c => c.authors), ...authorsFromFrontMatter].flat().map(name => {
      if (!uniq.has(name)) {
        uniq.set(name, {
          name,
          commitsCount: 1
        });
        return true;
      } else {
        uniq.get(name).commitsCount++;
        return false;
      }
    });
    return Array.from(uniq.values()).sort((a, b) => b.commitsCount - a.commitsCount).map(a => {
      return {
        ...a,
        ...(gitChangelog.value.authors.find(item => item.name === a.name) ?? {
          // a avatarUrl fallback for authors in frontmatter
          avatarUrl: `https://gravatar.com/avatar/${a.name}?d=retro`
        })
      };
    });
  });
  const commits = (0, _vue.computed)(() => {
    return _commits.value.map(_c => {
      return {
        ..._c,
        authors: _c.authors.map(_a => {
          return authors.value.find(v => v.name === _a);
        })
      };
    });
  });
  const update = data => {
    gitChangelog.value = data;
  };
  const useHmr = () => {
    if (import.meta.hot) {
      import.meta.hot.send("nolebase-git-changelog:client-mounted", {
        page: {
          filePath: page.value.filePath
        }
      });
      import.meta.hot.on("nolebase-git-changelog:updated", data => {
        if (!data || typeof data !== "object") return;
        if (data) update(data);
      });
      import.meta.hot.accept("virtual:nolebase-git-changelog", newModule => {
        if (!newModule) return;
        if (!("default" in newModule)) return;
        if (!newModule.default || typeof newModule.default !== "object") return;
        if (newModule.default) update(newModule.default);
      });
    }
  };
  return {
    commits,
    authors,
    useHmr
  };
}