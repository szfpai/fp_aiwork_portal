{"version":3,"sources":["../src/map.ts"],"names":[],"mappings":"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","file":"map.js","sourcesContent":["import {\r\n  baseUrl,\r\n  rebase,\r\n  isPlain,\r\n  isURL,\r\n  getCommonBase,\r\n  resolve,\r\n  sameOrigin,\r\n} from \"./url.js\";\r\nimport { alphabetize } from \"./alphabetize.js\";\r\n\r\nlet crypto;\r\n\r\nexport interface IImportMap {\r\n  imports?: Record<string, string>;\r\n  scopes?: {\r\n    [scope: string]: Record<string, string>;\r\n  };\r\n  integrity?: {\r\n    [url: string]: string\r\n  }\r\n}\r\n\r\nexport class ImportMap implements IImportMap {\r\n  imports: Record<string, string> = Object.create(null);\r\n  scopes: Record<string, Record<string, string>> = Object.create(null);\r\n  integrity: Record<string, string> = Object.create(null);\r\n\r\n  /**\r\n   * The absolute URL of the import map, for determining relative resolutions\r\n   * When using file:/// URLs this allows relative modules to be co-located\r\n   */\r\n  mapUrl: URL;\r\n  /**\r\n   * The URL to use for root-level resolutions in the import map\r\n   * If null, root resolutions are not resolved and instead left as-is\r\n   *\r\n   * By default, rootUrl is null unless the mapUrl is an http or https URL,\r\n   * in which case it is taken to be the root of the mapUrl.\r\n   */\r\n  rootUrl: URL | null;\r\n\r\n  /**\r\n   * Create a new import map instance\r\n   *\r\n   * @param opts import map options, can be an optional bag of { map?, mapUrl?, rootUrl? } or just a direct mapUrl\r\n   */\r\n  constructor(\r\n    opts:\r\n      | {\r\n          map?: IImportMap;\r\n          mapUrl?: string | URL;\r\n          rootUrl?: string | URL | null;\r\n        }\r\n      | string\r\n      | URL\r\n  ) {\r\n    let {\r\n      map,\r\n      mapUrl = baseUrl,\r\n      rootUrl,\r\n    } = opts instanceof URL ||\r\n    typeof opts === \"string\" ||\r\n    typeof opts === \"undefined\"\r\n      ? { mapUrl: opts, map: undefined, rootUrl: undefined }\r\n      : opts;\r\n    if (typeof mapUrl === \"string\") mapUrl = new URL(mapUrl);\r\n    this.mapUrl = mapUrl;\r\n    if (\r\n      rootUrl === undefined &&\r\n      (this.mapUrl.protocol === \"http:\" || this.mapUrl.protocol === \"https:\")\r\n    )\r\n      rootUrl = new URL(\"/\", this.mapUrl);\r\n    else if (typeof rootUrl === \"string\") rootUrl = new URL(rootUrl);\r\n    this.rootUrl = rootUrl || null;\r\n    if (map) this.extend(map);\r\n  }\r\n\r\n  /**\r\n   * Clones the import map\r\n   * @returns Cloned import map\r\n   */\r\n  clone() {\r\n    return new ImportMap({ mapUrl: this.mapUrl, rootUrl: this.rootUrl }).extend(\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Extends the import map mappings\r\n   * @param map Import map to extend with\r\n   * @param overrideScopes Set to true to have scopes be replacing instead of extending\r\n   * @returns ImportMap for chaining\r\n   */\r\n  extend(map: IImportMap, overrideScopes = false) {\r\n    Object.assign(this.imports, map.imports);\r\n    if (overrideScopes) {\r\n      Object.assign(this.scopes, map.scopes);\r\n    } else if (map.scopes) {\r\n      for (const scope of Object.keys(map.scopes))\r\n        Object.assign(\r\n          (this.scopes[scope] = this.scopes[scope] || Object.create(null)),\r\n          map.scopes[scope]\r\n        );\r\n    }\r\n    Object.assign(this.integrity, map.integrity);\r\n    this.rebase();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Performs an alphanumerical sort on the import map imports and scopes\r\n   * @returns ImportMap for chaining\r\n   */\r\n  sort() {\r\n    this.imports = alphabetize(this.imports);\r\n    this.scopes = alphabetize(this.scopes);\r\n    for (const scope of Object.keys(this.scopes))\r\n      this.scopes[scope] = alphabetize(this.scopes[scope]);\r\n    this.integrity = alphabetize(this.integrity);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set a specific entry in the import map\r\n   *\r\n   * @param name Specifier to set\r\n   * @param target Target of the map\r\n   * @param parent Optional parent scope\r\n   * @returns ImportMap for chaining\r\n   */\r\n  set(name: string, target: string, parent?: string) {\r\n    if (!parent) {\r\n      this.imports[name] = target;\r\n    } else {\r\n      this.scopes[parent] = this.scopes[parent] || Object.create(null);\r\n      this.scopes[parent][name] = target;\r\n    }\r\n    return this;\r\n  }\r\n  /**\r\n   * @param target URL target\r\n   * @param integrity Integrity\r\n   */\r\n  setIntegrity(target: string, integrity: string) {\r\n    this.integrity[target] = integrity;\r\n    const targetRebased = rebase(target, this.mapUrl, this.rootUrl);\r\n    if (targetRebased !== target && this.integrity[targetRebased])\r\n      delete this.integrity[targetRebased];\r\n    if (targetRebased.startsWith('./') && target !== targetRebased.slice(2) && this.integrity[targetRebased.slice(2)])\r\n      delete this.integrity[targetRebased.slice(2)];\r\n  }\r\n  /**\r\n   * @param target URL target\r\n   * @param integrity Integrity\r\n   */\r\n  getIntegrity(target: string, integrity: string) {\r\n    const targetResolved = resolve(target, this.mapUrl, this.rootUrl);\r\n    if (this.integrity[targetResolved]) return this.integrity[targetResolved];\r\n    const targetRebased = rebase(targetResolved, this.mapUrl, this.rootUrl);\r\n    if (this.integrity[targetRebased]) return this.integrity[targetRebased];\r\n    if (this.integrity[targetRebased.slice(2)]) return this.integrity[targetRebased.slice(2)];\r\n  }\r\n\r\n  /**\r\n   * Bulk replace URLs in the import map\r\n   * Provide a URL ending in \"/\" to perform path replacements\r\n   *\r\n   * @param url {String} The URL to replace\r\n   * @param newUrl {String} The URL to replace it with\r\n   * @returns ImportMap for chaining\r\n   */\r\n  replace(url: string, newUrl: string) {\r\n    const replaceSubpaths = url.endsWith(\"/\");\r\n    if (!isURL(url)) throw new Error(\"URL remapping only supports URLs\");\r\n    const newRelPkgUrl = rebase(newUrl, this.mapUrl, this.rootUrl);\r\n    if (this.imports[url]) {\r\n      this.imports[newRelPkgUrl] = this.imports[url];\r\n      delete this.imports[url];\r\n    }\r\n    if (replaceSubpaths) {\r\n      for (const impt of Object.keys(this.imports)) {\r\n        const target = this.imports[impt];\r\n        if (target.startsWith(url)) {\r\n          this.imports[impt] = newRelPkgUrl + target.slice(url.length);\r\n        }\r\n      }\r\n    }\r\n    for (const scope of Object.keys(this.scopes)) {\r\n      const scopeImports = this.scopes[scope];\r\n      const scopeUrl = resolve(scope, this.mapUrl, this.rootUrl);\r\n      if ((replaceSubpaths && scopeUrl.startsWith(url)) || scopeUrl === url) {\r\n        const newScope = newRelPkgUrl + scopeUrl.slice(url.length);\r\n        delete this.scopes[scope];\r\n        this.scopes[newScope] = scopeImports;\r\n      }\r\n      for (const impt of Object.keys(scopeImports)) {\r\n        const target = scopeImports[impt];\r\n        if ((replaceSubpaths && target.startsWith(url)) || target === url)\r\n          scopeImports[impt] = newRelPkgUrl + target.slice(url.length);\r\n      }\r\n    }\r\n    if (this.integrity[url]) {\r\n      this.integrity[newRelPkgUrl] = this.integrity[url];\r\n      delete this.integrity[url];\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Groups subpath mappings into path mappings when multiple exact subpaths\r\n   * exist under the same path.\r\n   *\r\n   * For two mappings like { \"base/a.js\": \"/a.js\", \"base/b.js\": \"/b.js\" },\r\n   * these will be replaced with a single path mapping { \"base/\": \"/\" }.\r\n   * Groupings are done throughout all import scopes individually.\r\n   *\r\n   * @returns ImportMap for chaining\r\n   */\r\n  combineSubpaths() {\r\n    // iterate possible bases and submappings, grouping bases greedily\r\n    const combineSubpathMappings = (mappings: Record<string, string>) => {\r\n      let outMappings: Record<string, string> = Object.create(null);\r\n      for (let impt of Object.keys(mappings)) {\r\n        const target = mappings[impt];\r\n        // Check if this import is already handled by an existing path mapping\r\n        // If so, either merge with it or continue on\r\n        let mapMatch;\r\n        if (isPlain(impt)) {\r\n          mapMatch = getMapMatch(impt, outMappings);\r\n        } else {\r\n          mapMatch =\r\n            getMapMatch(\r\n              (impt = rebase(impt, this.mapUrl, this.rootUrl)),\r\n              outMappings\r\n            ) ||\r\n            (this.rootUrl &&\r\n              getMapMatch(\r\n                (impt = rebase(impt, this.mapUrl, null)),\r\n                outMappings\r\n              )) ||\r\n            undefined;\r\n        }\r\n        if (\r\n          mapMatch &&\r\n          impt.slice(mapMatch.length) ===\r\n            resolve(target, this.mapUrl, this.rootUrl).slice(\r\n              resolve(outMappings[mapMatch], this.mapUrl, this.rootUrl).length\r\n            )\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        let newbase = false;\r\n        const targetParts = mappings[impt].split(\"/\");\r\n        const imptParts = impt.split(\"/\");\r\n        for (let j = imptParts.length - 1; j > 0; j--) {\r\n          const subpath = imptParts.slice(j).join(\"/\");\r\n          const subpathTarget = targetParts\r\n            .slice(targetParts.length - (imptParts.length - j))\r\n            .join(\"/\");\r\n          if (subpath !== subpathTarget) {\r\n            outMappings[impt] = mappings[impt];\r\n            break;\r\n          }\r\n          const base = imptParts.slice(0, j).join(\"/\") + \"/\";\r\n          if (outMappings[base]) continue;\r\n          const baseTarget =\r\n            targetParts\r\n              .slice(0, targetParts.length - (imptParts.length - j))\r\n              .join(\"/\") + \"/\";\r\n\r\n          // Dedupe existing mappings against the new base to remove them\r\n          // And if we dont dedupe against anything then dont perform this basing\r\n          for (let impt of Object.keys(outMappings)) {\r\n            const target = outMappings[impt];\r\n            let matches = false;\r\n            if (isPlain(impt)) {\r\n              matches = impt.startsWith(base);\r\n            } else {\r\n              matches =\r\n                (impt = rebase(impt, this.mapUrl, this.rootUrl)).startsWith(\r\n                  base\r\n                ) ||\r\n                (impt = rebase(impt, this.mapUrl, this.rootUrl)).startsWith(\r\n                  base\r\n                );\r\n            }\r\n            if (\r\n              matches &&\r\n              impt.slice(base.length) ===\r\n                resolve(target, this.mapUrl, this.rootUrl).slice(\r\n                  resolve(baseTarget, this.mapUrl, this.rootUrl).length\r\n                )\r\n            ) {\r\n              newbase = true;\r\n              delete outMappings[impt];\r\n            }\r\n          }\r\n\r\n          if (newbase) {\r\n            outMappings[base] = baseTarget;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (!newbase) outMappings[impt] = target;\r\n      }\r\n      return outMappings;\r\n    };\r\n\r\n    // Only applies for scopes since \"imports\" are generally treated as\r\n    // an authoritative entry point list\r\n    for (const scope of Object.keys(this.scopes)) {\r\n      this.scopes[scope] = combineSubpathMappings(this.scopes[scope]);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Groups the import map scopes to shared URLs to reduce duplicate mappings.\r\n   *\r\n   * For two given scopes, \"https://site.com/x/\" and \"https://site.com/y/\",\r\n   * a single scope will be constructed for \"https://site.com/\" including\r\n   * their shared mappings, only retaining the scopes if they have differences.\r\n   *\r\n   * In the case where the scope is on the same origin as the mapUrl, the grouped\r\n   * scope is determined based on determining the common baseline over all local scopes\r\n   *\r\n   * @returns ImportMap for chaining\r\n   */\r\n  flatten() {\r\n    // First, determine the common base for the local mappings if any\r\n    let localScopemapUrl: string | null = null;\r\n    for (const scope of Object.keys(this.scopes)) {\r\n      const resolvedScope = resolve(scope, this.mapUrl, this.rootUrl);\r\n      if (isURL(resolvedScope)) {\r\n        const scopeUrl = new URL(resolvedScope);\r\n        if (sameOrigin(scopeUrl, this.mapUrl)) {\r\n          if (!localScopemapUrl) localScopemapUrl = scopeUrl.href;\r\n          else\r\n            localScopemapUrl = getCommonBase(scopeUrl.href, localScopemapUrl);\r\n        }\r\n      } else {\r\n        if (!localScopemapUrl) localScopemapUrl = resolvedScope;\r\n        else localScopemapUrl = getCommonBase(resolvedScope, localScopemapUrl);\r\n      }\r\n    }\r\n\r\n    // for each scope, update its mappings to be in the shared base where possible\r\n    const relativeLocalScopemapUrl = localScopemapUrl\r\n      ? rebase(localScopemapUrl, this.mapUrl, this.rootUrl)\r\n      : null;\r\n    for (const scope of Object.keys(this.scopes)) {\r\n      const scopeImports = this.scopes[scope];\r\n\r\n      let scopemapUrl: string;\r\n      const resolvedScope = resolve(scope, this.mapUrl, this.rootUrl);\r\n      if (isURL(resolvedScope)) {\r\n        const scopeUrl = new URL(resolvedScope);\r\n        if (sameOrigin(scopeUrl, this.mapUrl)) {\r\n          scopemapUrl = relativeLocalScopemapUrl;\r\n        } else {\r\n          scopemapUrl =\r\n            scopeUrl.protocol +\r\n            \"//\" +\r\n            scopeUrl.hostname +\r\n            (scopeUrl.port ? \":\" + scopeUrl.port : \"\") +\r\n            \"/\";\r\n        }\r\n      } else {\r\n        scopemapUrl = relativeLocalScopemapUrl;\r\n      }\r\n\r\n      let scopeBase: Record<string, string> | null =\r\n        this.scopes[scopemapUrl] || Object.create(null);\r\n      if (scopeBase === scopeImports) scopeBase = null;\r\n\r\n      let flattenedAll = true;\r\n      for (const name of Object.keys(scopeImports)) {\r\n        const target = scopeImports[name];\r\n        if (\r\n          this.imports[name] &&\r\n          resolve(this.imports[name], this.mapUrl, this.rootUrl) ===\r\n            resolve(target, this.mapUrl, this.rootUrl)\r\n        ) {\r\n          delete scopeImports[name];\r\n        } else if (\r\n          scopeBase &&\r\n          (!scopeBase[name] ||\r\n            resolve(scopeBase[name], this.mapUrl, this.rootUrl) ===\r\n              resolve(target, this.mapUrl, this.rootUrl))\r\n        ) {\r\n          scopeBase[name] = rebase(target, this.mapUrl, this.rootUrl);\r\n          delete scopeImports[name];\r\n          this.scopes[<string>scopemapUrl] = alphabetize(scopeBase);\r\n        } else {\r\n          flattenedAll = false;\r\n        }\r\n      }\r\n      if (flattenedAll) delete this.scopes[scope];\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Rebase the entire import map to a new mapUrl and rootUrl\r\n   *\r\n   * If the rootUrl is not provided, it will remain null if it was\r\n   * already set to null.\r\n   *\r\n   * Otherwise, just like the constructor options, the rootUrl\r\n   * will default to the mapUrl base if it is an http: or https:\r\n   * scheme URL, and null otherwise keeping absolute URLs entirely\r\n   * in-tact.\r\n   *\r\n   * @param mapUrl The new map URL to use\r\n   * @param rootUrl The new root URL to use\r\n   * @returns ImportMap for chaining\r\n   */\r\n  rebase(mapUrl: URL | string = this.mapUrl, rootUrl?: URL | string | null) {\r\n    if (typeof mapUrl === \"string\") mapUrl = new URL(mapUrl);\r\n    if (rootUrl === undefined) {\r\n      if (mapUrl.href === this.mapUrl.href) rootUrl = this.rootUrl;\r\n      else\r\n        rootUrl =\r\n          this.rootUrl === null ||\r\n          (mapUrl.protocol !== \"https:\" && mapUrl.protocol !== \"http:\")\r\n            ? null\r\n            : new URL(\"/\", mapUrl);\r\n    } else if (typeof rootUrl === \"string\") rootUrl = new URL(rootUrl);\r\n    let changedImportProps = false;\r\n    for (const impt of Object.keys(this.imports)) {\r\n      const target = this.imports[impt];\r\n      this.imports[impt] = rebase(\r\n        resolve(target, this.mapUrl, this.rootUrl),\r\n        mapUrl,\r\n        rootUrl\r\n      );\r\n      if (!isPlain(impt)) {\r\n        const newImpt = rebase(\r\n          resolve(impt, this.mapUrl, this.rootUrl),\r\n          mapUrl,\r\n          rootUrl\r\n        );\r\n        if (newImpt !== impt) {\r\n          changedImportProps = true;\r\n          this.imports[newImpt] = this.imports[impt];\r\n          delete this.imports[impt];\r\n        }\r\n      }\r\n    }\r\n    if (changedImportProps) this.imports = alphabetize(this.imports);\r\n    let changedScopeProps = false;\r\n    for (const scope of Object.keys(this.scopes)) {\r\n      const scopeImports = this.scopes[scope];\r\n      let changedScopeImportProps = false;\r\n      for (const impt of Object.keys(scopeImports)) {\r\n        const target = scopeImports[impt];\r\n        scopeImports[impt] = rebase(\r\n          resolve(target, this.mapUrl, this.rootUrl),\r\n          mapUrl,\r\n          rootUrl\r\n        );\r\n        if (!isPlain(impt)) {\r\n          const newName = rebase(\r\n            resolve(impt, this.mapUrl, this.rootUrl),\r\n            mapUrl,\r\n            rootUrl\r\n          );\r\n          if (newName !== impt) {\r\n            changedScopeImportProps = true;\r\n            scopeImports[newName] = scopeImports[impt];\r\n            delete scopeImports[impt];\r\n          }\r\n        }\r\n      }\r\n      if (changedScopeImportProps)\r\n        this.scopes[scope] = alphabetize(scopeImports);\r\n      const newScope = rebase(\r\n        resolve(scope, this.mapUrl, this.rootUrl),\r\n        mapUrl,\r\n        rootUrl\r\n      );\r\n      if (scope !== newScope) {\r\n        changedScopeProps = true;\r\n        delete this.scopes[scope];\r\n        this.scopes[newScope] = scopeImports;\r\n      }\r\n    }\r\n    if (changedScopeProps) this.scopes = alphabetize(this.scopes);\r\n    let changedIntegrityProps = false;\r\n    for (const target of Object.keys(this.integrity)) {\r\n      const newTarget = rebase(\r\n        resolve(target, this.mapUrl, this.rootUrl),\r\n        mapUrl,\r\n        rootUrl\r\n      );\r\n      if (target !== newTarget) {\r\n        this.integrity[newTarget] = this.integrity[target];\r\n        delete this.integrity[target];\r\n        changedIntegrityProps = true;\r\n      }\r\n    }\r\n    if (changedIntegrityProps) this.integrity = alphabetize(this.integrity);\r\n    this.mapUrl = mapUrl;\r\n    this.rootUrl = rootUrl;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Perform a module resolution against the import map\r\n   *\r\n   * @param specifier Specifier to resolve\r\n   * @param parentUrl Parent URL to resolve against\r\n   * @returns Resolved URL string\r\n   */\r\n  resolve(specifier: string, parentUrl: string | URL = this.mapUrl): string {\r\n    if (typeof parentUrl !== \"string\") parentUrl = parentUrl.toString();\r\n    parentUrl = resolve(parentUrl, this.mapUrl, this.rootUrl);\r\n    let specifierUrl: URL | undefined;\r\n    if (!isPlain(specifier)) {\r\n      specifierUrl = new URL(specifier, parentUrl);\r\n      specifier = specifierUrl.href;\r\n    }\r\n    const scopeMatches = getScopeMatches(\r\n      parentUrl,\r\n      this.scopes,\r\n      this.mapUrl,\r\n      this.rootUrl\r\n    );\r\n    for (const [scope] of scopeMatches) {\r\n      let mapMatch = getMapMatch(specifier, this.scopes[scope]);\r\n      if (!mapMatch && specifierUrl) {\r\n        mapMatch =\r\n          getMapMatch(\r\n            (specifier = rebase(specifier, this.mapUrl, this.rootUrl)),\r\n            this.scopes[scope]\r\n          ) ||\r\n          (this.rootUrl &&\r\n            getMapMatch(\r\n              (specifier = rebase(specifier, this.mapUrl, null)),\r\n              this.scopes[scope]\r\n            )) ||\r\n          undefined;\r\n      }\r\n      if (mapMatch) {\r\n        const target = this.scopes[scope][mapMatch];\r\n        return resolve(\r\n          target + specifier.slice(mapMatch.length),\r\n          this.mapUrl,\r\n          this.rootUrl\r\n        );\r\n      }\r\n    }\r\n    let mapMatch = getMapMatch(specifier, this.imports);\r\n    if (!mapMatch && specifierUrl) {\r\n      mapMatch =\r\n        getMapMatch(\r\n          (specifier = rebase(specifier, this.mapUrl, this.rootUrl)),\r\n          this.imports\r\n        ) ||\r\n        (this.rootUrl &&\r\n          getMapMatch(\r\n            (specifier = rebase(specifier, this.mapUrl, null)),\r\n            this.imports\r\n          )) ||\r\n        undefined;\r\n    }\r\n    if (mapMatch) {\r\n      const target = this.imports[mapMatch];\r\n      return resolve(\r\n        target + specifier.slice(mapMatch.length),\r\n        this.mapUrl,\r\n        this.rootUrl\r\n      );\r\n    }\r\n    if (specifierUrl) return specifierUrl.href;\r\n    throw new Error(`Unable to resolve ${specifier} in ${parentUrl}`);\r\n  }\r\n\r\n  /**\r\n   * Get the import map JSON data\r\n   *\r\n   * @returns Import map data\r\n   */\r\n  toJSON(): IImportMap {\r\n    const obj: any = {};\r\n    if (Object.keys(this.imports).length) obj.imports = this.imports;\r\n    if (Object.keys(this.scopes).length) obj.scopes = this.scopes;\r\n    if (Object.keys(this.integrity).length) obj.integrity = this.integrity;\r\n    return JSON.parse(JSON.stringify(obj));\r\n  }\r\n}\r\n\r\nexport function getScopeMatches(\r\n  parentUrl: string,\r\n  scopes: Record<string, Record<string, string>>,\r\n  mapUrl: URL,\r\n  rootUrl?: URL\r\n): [string, string][] {\r\n  let scopeCandidates = Object.keys(scopes).map((scope) => [\r\n    scope,\r\n    resolve(scope, mapUrl, rootUrl),\r\n  ]);\r\n  scopeCandidates = scopeCandidates.sort(([, matchA], [, matchB]) =>\r\n    matchA.length < matchB.length ? 1 : -1\r\n  );\r\n\r\n  return scopeCandidates.filter(([, scopeUrl]) => {\r\n    return (\r\n      scopeUrl === parentUrl ||\r\n      (scopeUrl.endsWith(\"/\") && parentUrl.startsWith(scopeUrl))\r\n    );\r\n  }) as [string, string][];\r\n}\r\n\r\nexport function getMapMatch<T = any>(\r\n  specifier: string,\r\n  map: Record<string, T>\r\n): string | undefined {\r\n  if (specifier in map) return specifier;\r\n  let curMatch;\r\n  for (const match of Object.keys(map)) {\r\n    const wildcard = match.endsWith(\"*\");\r\n    if (!match.endsWith(\"/\") && !wildcard) continue;\r\n    if (specifier.startsWith(wildcard ? match.slice(0, -1) : match)) {\r\n      if (!curMatch || match.length > curMatch.length) curMatch = match;\r\n    }\r\n  }\r\n  return curMatch;\r\n}\r\n"]}