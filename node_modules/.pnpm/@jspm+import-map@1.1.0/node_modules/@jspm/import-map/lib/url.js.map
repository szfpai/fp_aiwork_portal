{"version":3,"sources":["../src/url.ts"],"names":[],"mappings":"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","file":"url.js","sourcesContent":["declare global {\r\n  // @ts-ignore\r\n  var document: any;\r\n  // @ts-ignore\r\n  var location: any;\r\n  // @ts-ignore\r\n  var process: NodeJS.Process;\r\n}\r\n\r\nexport let baseUrl: URL;\r\n// @ts-ignore\r\nif (typeof Deno !== \"undefined\") {\r\n  // @ts-ignore\r\n  baseUrl = new URL(\"file://\" + Deno.cwd() + \"/\");\r\n} else if (typeof process !== \"undefined\" && process.versions?.node) {\r\n  baseUrl = new URL(\"file://\" + process.cwd() + \"/\");\r\n} else if ((typeof document as any) !== \"undefined\") {\r\n  const baseEl: any | null = document.querySelector(\"base[href]\");\r\n  if (baseEl)\r\n    baseUrl = new URL(baseEl.href + (baseEl.href.endsWith(\"/\") ? \"\" : \"/\"));\r\n  else if (typeof location !== \"undefined\")\r\n    baseUrl = new URL(\"../\", new URL(location.href));\r\n}\r\n\r\nexport function getCommonBase(a: string, b: string): string {\r\n  if (a.startsWith(b)) return b;\r\n  if (b.startsWith(a)) return a;\r\n  const aSegments = a.split(\"/\");\r\n  const bSegments = b.split(\"/\");\r\n  let i = 0;\r\n  while (aSegments[i] === bSegments[i]) i++;\r\n  return aSegments.slice(0, i).join(\"/\") + \"/\";\r\n}\r\n\r\nexport function sameOrigin(url: URL, baseUrl: URL) {\r\n  return (\r\n    url.protocol === baseUrl.protocol &&\r\n    url.host === baseUrl.host &&\r\n    url.port === baseUrl.port &&\r\n    url.username === baseUrl.username &&\r\n    url.password === baseUrl.password\r\n  );\r\n}\r\n\r\nexport function resolve(url: string, mapUrl: URL, rootUrl: URL | null): string {\r\n  if (url.startsWith(\"/\"))\r\n    return rootUrl\r\n      ? new URL(\".\" + url.slice(url[1] === \"/\" ? 1 : 0), rootUrl).href\r\n      : url;\r\n  return new URL(url, mapUrl).href;\r\n}\r\n\r\n/**\r\n * Rebase the given URL to the baseURL and rootURL\r\n * \r\n * @param url URL to rebase\r\n * @param baseUrl Import map baseUrl\r\n *                URLs will be based relative to this path if the same origin as the URL.\r\n * @param rootUrl Optional URL ending in / of the root HTML URL.\r\n *                When provided and possible, will be used as the base of the form '/...'\r\n * @returns relative URL string\r\n */\r\nexport function rebase(url: string, baseUrl: URL, rootUrl: URL | null = null) {\r\n  let resolved;\r\n  if (url.startsWith(\"/\") || url.startsWith(\"//\")) {\r\n    if (rootUrl === null) return url;\r\n    resolved = new URL(url, rootUrl);\r\n  } else {\r\n    resolved = new URL(url, baseUrl);\r\n  }\r\n  if (rootUrl && resolved.href.startsWith(rootUrl.href))\r\n    return resolved.href.slice(rootUrl.href.length - 1);\r\n  if (rootUrl && rootUrl.href.startsWith(resolved.href)) {\r\n    // edge-case\r\n    return \"/\" + relative(resolved, rootUrl);\r\n  }\r\n  if (sameOrigin(resolved, baseUrl)) return relative(resolved, baseUrl);\r\n  return resolved.href;\r\n}\r\n\r\nexport function relative(url: URL, baseUrl: URL) {\r\n  const baseUrlPath = baseUrl.pathname;\r\n  const urlPath = url.pathname;\r\n  const minLen = Math.min(baseUrlPath.length, urlPath.length);\r\n  let sharedBaseIndex = -1;\r\n  for (let i = 0; i < minLen; i++) {\r\n    if (baseUrlPath[i] !== urlPath[i]) break;\r\n    if (urlPath[i] === \"/\") sharedBaseIndex = i;\r\n  }\r\n  const backtracks =\r\n    baseUrlPath.slice(sharedBaseIndex + 1).split(\"/\").length - 1;\r\n  return (\r\n    (backtracks ? \"../\".repeat(backtracks) : \"./\") +\r\n    urlPath.slice(sharedBaseIndex + 1) +\r\n    url.search +\r\n    url.hash\r\n  );\r\n}\r\n\r\nexport function isURL(specifier: string) {\r\n  try {\r\n    if (specifier[0] === \"#\") return false;\r\n    new URL(specifier);\r\n  } catch {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function isPlain(specifier: string) {\r\n  return !isRelative(specifier) && !isURL(specifier);\r\n}\r\n\r\nexport function isRelative(specifier: string) {\r\n  return (\r\n    specifier.startsWith(\"./\") ||\r\n    specifier.startsWith(\"../\") ||\r\n    specifier.startsWith(\"/\")\r\n  );\r\n}\r\n"]}