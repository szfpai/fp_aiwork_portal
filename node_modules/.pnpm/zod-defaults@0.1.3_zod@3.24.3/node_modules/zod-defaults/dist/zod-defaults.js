"use strict";import{z as t}from"zod";const a=(e,o)=>e.constructor.name===o.name,n=new Map;n.set(t.ZodBoolean.name,()=>!1),n.set(t.ZodNumber.name,()=>0),n.set(t.ZodString.name,()=>""),n.set(t.ZodArray.name,()=>[]),n.set(t.ZodRecord.name,()=>({})),n.set(t.ZodDefault.name,e=>e._def.defaultValue()),n.set(t.ZodEffects.name,e=>c(e._def.schema)),n.set(t.ZodOptional.name,e=>a(e._def.innerType,t.ZodDefault)?e._def.innerType._def.defaultValue():void 0),n.set(t.ZodTuple.name,e=>{const o=[];for(const d of e._def.items)o.push(c(d));return o}),n.set(t.ZodEffects.name,e=>c(e._def.schema)),n.set(t.ZodUnion.name,e=>c(e._def.options[0])),n.set(t.ZodObject.name,e=>r(e)),n.set(t.ZodRecord.name,e=>r(e)),n.set(t.ZodIntersection.name,e=>r(e));function c(e){const o=e.constructor.name;if(!n.has(o)){console.warn("getSchemaDefaultForField: Unhandled type",e.constructor.name);return}return n.get(o)(e)}function r(e){if(a(e,t.ZodRecord))return{};if(a(e,t.ZodEffects))return r(e._def.schema);if(a(e,t.ZodIntersection))return{...r(e._def.left),...r(e._def.right)};if(a(e,t.ZodUnion)){for(const o of e._def.options)if(a(o,t.ZodObject))return r(o);return console.warn("getSchemaDefaultObject: No object found in union, returning empty object"),{}}return a(e,t.ZodObject)?Object.fromEntries(Object.entries(e.shape).map(([o,d])=>[o,c(d)]).filter(o=>o[1]!==void 0)):(console.warn(`getSchemaDefaultObject: Expected object schema, got ${e.constructor.name}`),{})}function s(e){return r(e)}export{s as getDefaultsForSchema};
