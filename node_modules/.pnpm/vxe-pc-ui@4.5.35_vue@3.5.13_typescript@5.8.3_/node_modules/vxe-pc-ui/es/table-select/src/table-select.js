import { defineComponent, ref, h, computed, inject, watch, provide, nextTick, Teleport, onMounted, onUnmounted, reactive } from 'vue';
import XEUtils from 'xe-utils';
import { VxeUI, getConfig, getIcon, globalEvents, getI18n, createEvent, useSize, renderEmptyElement } from '../../ui';
import { getEventTargetNode, getAbsolutePos, toCssUnit } from '../../ui/src/dom';
import { getOnName } from '../../ui/src/vn';
import { getLastZIndex, nextZIndex } from '../../ui/src/utils';
import { errLog } from '../../ui/src/log';
import VxeInputComponent from '../../input/src/input';
export function getRowUniqueId() {
    return XEUtils.uniqueId('row_');
}
export default defineComponent({
    name: 'VxeTableSelect',
    props: {
        modelValue: [String, Number, Array],
        clearable: Boolean,
        placeholder: {
            type: String,
            default: () => XEUtils.eqNull(getConfig().tableSelect.placeholder) ? getI18n('vxe.base.pleaseSelect') : getConfig().tableSelect.placeholder
        },
        readonly: {
            type: Boolean,
            default: null
        },
        loading: Boolean,
        disabled: {
            type: Boolean,
            default: null
        },
        multiple: Boolean,
        className: [String, Function],
        prefixIcon: String,
        placement: String,
        columns: Array,
        options: Array,
        optionProps: Object,
        size: {
            type: String,
            default: () => getConfig().select.size || getConfig().size
        },
        popupConfig: Object,
        gridConfig: Object,
        transfer: {
            type: Boolean,
            default: null
        }
    },
    emits: [
        'update:modelValue',
        'change',
        'clear',
        'blur',
        'focus',
        'click',
        'form-submit',
        'form-reset',
        'form-collapse',
        'page-change'
    ],
    setup(props, context) {
        const { emit, slots } = context;
        const VxeTableGridComponent = VxeUI.getComponent('VxeGrid');
        const $xeModal = inject('$xeModal', null);
        const $xeDrawer = inject('$xeDrawer', null);
        const $xeTable = inject('$xeTable', null);
        const $xeForm = inject('$xeForm', null);
        const formItemInfo = inject('xeFormItemInfo', null);
        const xID = XEUtils.uniqueId();
        const { computeSize } = useSize(props);
        const refElem = ref();
        const refInput = ref();
        const refGridWrapper = ref();
        const refOptionPanel = ref();
        const refGrid = ref();
        const reactData = reactive({
            initialized: false,
            tableColumns: [],
            fullOptionList: [],
            fullRowMaps: {},
            panelIndex: 0,
            panelStyle: {},
            panelPlacement: null,
            triggerFocusPanel: false,
            visiblePanel: false,
            isAniVisible: false,
            isActivated: false
        });
        const internalData = {
        // hpTimeout: undefined,
        // vpTimeout: undefined
        };
        const refMaps = {
            refElem
        };
        const computeFormReadonly = computed(() => {
            const { readonly } = props;
            if (readonly === null) {
                if ($xeForm) {
                    return $xeForm.props.readonly;
                }
                return false;
            }
            return readonly;
        });
        const computeIsDisabled = computed(() => {
            const { disabled } = props;
            if (disabled === null) {
                if ($xeForm) {
                    return $xeForm.props.disabled;
                }
                return false;
            }
            return disabled;
        });
        const computeBtnTransfer = computed(() => {
            const { transfer } = props;
            if (transfer === null) {
                const globalTransfer = getConfig().select.transfer;
                if (XEUtils.isBoolean(globalTransfer)) {
                    return globalTransfer;
                }
                if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
                    return true;
                }
            }
            return transfer;
        });
        const computePropsOpts = computed(() => {
            return props.optionProps || {};
        });
        const computeRowOpts = computed(() => {
            const gridOpts = computeGridOpts.value;
            return Object.assign({}, gridOpts.rowConfig, {
                isCurrent: true
            });
        });
        const computeRowKeyField = computed(() => {
            const rowOpts = computeRowOpts.value;
            return rowOpts.keyField || '_X_ROW_KEY';
        });
        const computeLabelField = computed(() => {
            const propsOpts = computePropsOpts.value;
            return propsOpts.label || 'label';
        });
        const computeValueField = computed(() => {
            const propsOpts = computePropsOpts.value;
            return propsOpts.value || 'value';
        });
        const computePopupOpts = computed(() => {
            return Object.assign({}, getConfig().tableSelect.popupConfig, props.popupConfig);
        });
        const computeGridOpts = computed(() => {
            return Object.assign({}, getConfig().tableSelect.gridConfig, props.gridConfig, { data: undefined, columns: undefined });
        });
        const computeSelectLabel = computed(() => {
            const { modelValue } = props;
            const { fullRowMaps } = reactData;
            const labelField = computeLabelField.value;
            return (XEUtils.isArray(modelValue) ? modelValue : [modelValue]).map(val => {
                const cacheItem = fullRowMaps[val];
                return cacheItem ? cacheItem.item[labelField] : val;
            }).join(', ');
        });
        const computePopupWrapperStyle = computed(() => {
            const popupOpts = computePopupOpts.value;
            const { height, width } = popupOpts;
            const stys = {};
            if (width) {
                stys.width = toCssUnit(width);
            }
            if (height) {
                stys.height = toCssUnit(height);
            }
            return stys;
        });
        const computeMaps = {};
        const $xeTableSelect = {
            xID,
            props,
            context,
            reactData,
            getRefMaps: () => refMaps,
            getComputeMaps: () => computeMaps
        };
        const gridEventKeys = [
            'form-submit',
            'form-reset',
            'form-collapse',
            'page-change'
        ];
        const gridEvents = {};
        gridEventKeys.forEach(name => {
            gridEvents[getOnName(XEUtils.camelCase(name))] = (params) => {
                dispatchEvent(name, params, params.$event);
            };
        });
        const dispatchEvent = (type, params, evnt) => {
            emit(type, createEvent(evnt, { $tableSelect: $xeTableSelect }, params));
        };
        const emitModel = (value) => {
            emit('update:modelValue', value);
        };
        const tableSelectMethods = {
            dispatchEvent
        };
        const tableSelectPrivateMethods = {};
        const getRowid = (option) => {
            const nodeKeyField = computeRowKeyField.value;
            const rowid = option[nodeKeyField];
            return rowid ? encodeURIComponent(rowid) : '';
        };
        const getRowsByValue = (modelValue) => {
            const { fullRowMaps } = reactData;
            const rows = [];
            const vals = XEUtils.eqNull(modelValue) ? [] : (XEUtils.isArray(modelValue) ? modelValue : [modelValue]);
            vals.forEach(val => {
                const cacheItem = fullRowMaps[val];
                if (cacheItem) {
                    rows.push(cacheItem.item);
                }
            });
            return rows;
        };
        const updateModel = (modelValue) => {
            const { multiple } = props;
            nextTick(() => {
                const $grid = refGrid.value;
                if ($grid) {
                    const selectList = getRowsByValue(modelValue);
                    if (selectList.length) {
                        if (multiple) {
                            $grid.setCheckboxRow(selectList, true);
                        }
                        else {
                            $grid.setRadioRow(selectList[0]);
                        }
                    }
                }
            });
        };
        const loadTableColumn = (columns) => {
            const { multiple } = props;
            const tableCols = [];
            if (multiple) {
                tableCols.push({
                    type: 'checkbox',
                    width: 70
                });
            }
            else {
                tableCols.push({
                    type: 'radio',
                    width: 70
                });
            }
            reactData.tableColumns = tableCols.concat(columns || []);
        };
        const cacheDataMap = () => {
            const { options } = props;
            const rowKeyField = computeRowKeyField.value;
            const valueField = computeValueField.value;
            const gridOpts = computeGridOpts.value;
            const { treeConfig } = gridOpts;
            const rowMaps = {};
            const keyMaps = {};
            if (treeConfig) {
                // x
            }
            else {
                XEUtils.arrayEach(options || [], (item, index, items) => {
                    let rowid = getRowid(item);
                    if (!rowid) {
                        rowid = getRowUniqueId();
                    }
                    if (keyMaps[rowid]) {
                        errLog('vxe.error.repeatKey', [rowKeyField, rowid]);
                    }
                    keyMaps[rowid] = true;
                    const value = item[valueField];
                    if (rowMaps[value]) {
                        errLog('vxe.error.repeatKey', [valueField, value]);
                    }
                    rowMaps[value] = { item, index, items, parent: null, nodes: [] };
                });
            }
            reactData.fullOptionList = options || [];
            reactData.fullRowMaps = rowMaps;
            updateModel(props.modelValue);
        };
        const updateZindex = () => {
            if (reactData.panelIndex < getLastZIndex()) {
                reactData.panelIndex = nextZIndex();
            }
        };
        const updatePlacement = () => {
            return nextTick().then(() => {
                const { placement } = props;
                const { panelIndex } = reactData;
                const el = refElem.value;
                const panelElem = refOptionPanel.value;
                const btnTransfer = computeBtnTransfer.value;
                if (panelElem && el) {
                    const targetHeight = el.offsetHeight;
                    const targetWidth = el.offsetWidth;
                    const panelHeight = panelElem.offsetHeight;
                    const panelWidth = panelElem.offsetWidth;
                    const marginSize = 5;
                    const panelStyle = {
                        zIndex: panelIndex
                    };
                    const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(el);
                    let panelPlacement = 'bottom';
                    if (btnTransfer) {
                        let left = boundingLeft;
                        let top = boundingTop + targetHeight;
                        if (placement === 'top') {
                            panelPlacement = 'top';
                            top = boundingTop - panelHeight;
                        }
                        else if (!placement) {
                            // 如果下面不够放，则向上
                            if (top + panelHeight + marginSize > visibleHeight) {
                                panelPlacement = 'top';
                                top = boundingTop - panelHeight;
                            }
                            // 如果上面不够放，则向下（优先）
                            if (top < marginSize) {
                                panelPlacement = 'bottom';
                                top = boundingTop + targetHeight;
                            }
                        }
                        // 如果溢出右边
                        if (left + panelWidth + marginSize > visibleWidth) {
                            left -= left + panelWidth + marginSize - visibleWidth;
                        }
                        // 如果溢出左边
                        if (left < marginSize) {
                            left = marginSize;
                        }
                        Object.assign(panelStyle, {
                            left: `${left}px`,
                            top: `${top}px`,
                            minWidth: `${targetWidth}px`
                        });
                    }
                    else {
                        if (placement === 'top') {
                            panelPlacement = 'top';
                            panelStyle.bottom = `${targetHeight}px`;
                        }
                        else if (!placement) {
                            // 如果下面不够放，则向上
                            if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                                // 如果上面不够放，则向下（优先）
                                if (boundingTop - targetHeight - panelHeight > marginSize) {
                                    panelPlacement = 'top';
                                    panelStyle.bottom = `${targetHeight}px`;
                                }
                            }
                        }
                    }
                    reactData.panelStyle = panelStyle;
                    reactData.panelPlacement = panelPlacement;
                    return nextTick();
                }
            });
        };
        const showOptionPanel = () => {
            const { loading } = props;
            const isDisabled = computeIsDisabled.value;
            if (!loading && !isDisabled) {
                if (internalData.vpTimeout) {
                    clearTimeout(internalData.vpTimeout);
                }
                if (internalData.hpTimeout) {
                    clearTimeout(internalData.hpTimeout);
                }
                if (!reactData.initialized) {
                    reactData.initialized = true;
                }
                reactData.isActivated = true;
                reactData.isAniVisible = true;
                internalData.vpTimeout = setTimeout(() => {
                    reactData.visiblePanel = true;
                    updateModel(props.modelValue);
                    internalData.vpTimeout = undefined;
                }, 10);
                updateZindex();
                updatePlacement();
            }
        };
        const hideOptionPanel = () => {
            reactData.visiblePanel = false;
            if (internalData.vpTimeout) {
                clearTimeout(internalData.vpTimeout);
            }
            if (internalData.hpTimeout) {
                clearTimeout(internalData.hpTimeout);
            }
            internalData.hpTimeout = setTimeout(() => {
                reactData.isAniVisible = false;
                internalData.hpTimeout = undefined;
            }, 350);
        };
        const changeEvent = (evnt, selectValue) => {
            const { fullRowMaps } = reactData;
            emitModel(selectValue);
            if (selectValue !== props.modelValue) {
                const cacheItem = fullRowMaps[selectValue];
                dispatchEvent('change', { value: selectValue, row: cacheItem ? cacheItem.item : null }, evnt);
                // 自动更新校验状态
                if ($xeForm && formItemInfo) {
                    $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
                }
            }
        };
        const clearValueEvent = (evnt, selectValue) => {
            changeEvent(evnt, selectValue);
            dispatchEvent('clear', { value: selectValue }, evnt);
        };
        const clearEvent = (params, evnt) => {
            clearValueEvent(evnt, null);
            hideOptionPanel();
        };
        const handleGlobalMousewheelEvent = (evnt) => {
            const { visiblePanel } = reactData;
            const isDisabled = computeIsDisabled.value;
            if (!isDisabled) {
                if (visiblePanel) {
                    const panelElem = refOptionPanel.value;
                    if (getEventTargetNode(evnt, panelElem).flag) {
                        updatePlacement();
                    }
                    else {
                        hideOptionPanel();
                    }
                }
            }
        };
        const handleGlobalMousedownEvent = (evnt) => {
            const { visiblePanel } = reactData;
            const isDisabled = computeIsDisabled.value;
            if (!isDisabled) {
                const el = refElem.value;
                const panelElem = refOptionPanel.value;
                reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
                if (visiblePanel && !reactData.isActivated) {
                    hideOptionPanel();
                }
            }
        };
        const handleGlobalBlurEvent = () => {
            hideOptionPanel();
        };
        const focusEvent = (evnt) => {
            const isDisabled = computeIsDisabled.value;
            if (!isDisabled) {
                if (!reactData.visiblePanel) {
                    reactData.triggerFocusPanel = true;
                    showOptionPanel();
                    setTimeout(() => {
                        reactData.triggerFocusPanel = false;
                    }, 150);
                }
            }
            dispatchEvent('focus', {}, evnt);
        };
        const clickEvent = (evnt) => {
            togglePanelEvent(evnt);
            dispatchEvent('click', {}, evnt);
        };
        const blurEvent = (evnt) => {
            reactData.isActivated = false;
            dispatchEvent('blur', {}, evnt);
        };
        const togglePanelEvent = (params) => {
            const { $event } = params;
            $event.preventDefault();
            if (reactData.triggerFocusPanel) {
                reactData.triggerFocusPanel = false;
            }
            else {
                if (reactData.visiblePanel) {
                    hideOptionPanel();
                }
                else {
                    showOptionPanel();
                }
            }
        };
        const radioChangeEvent = (params) => {
            const { $event, row } = params;
            const valueField = computeValueField.value;
            const value = row[valueField];
            changeEvent($event, value);
            hideOptionPanel();
        };
        const checkboxChangeEvent = (params) => {
            const { $grid, $event } = params;
            const valueField = computeValueField.value;
            if ($grid) {
                const checkboxRecords = $grid.getCheckboxRecords();
                const value = checkboxRecords.map(row => {
                    return row[valueField];
                });
                changeEvent($event, value);
            }
        };
        const checkboxAllEvent = (params) => {
            checkboxChangeEvent(params);
        };
        Object.assign($xeTableSelect, tableSelectMethods, tableSelectPrivateMethods);
        const renderVN = () => {
            const { className, options, loading } = props;
            const { initialized, isActivated, isAniVisible, visiblePanel, tableColumns } = reactData;
            const vSize = computeSize.value;
            const isDisabled = computeIsDisabled.value;
            const selectLabel = computeSelectLabel.value;
            const btnTransfer = computeBtnTransfer.value;
            const formReadonly = computeFormReadonly.value;
            const popupOpts = computePopupOpts.value;
            const { className: popupClassName } = popupOpts;
            const gridOpts = computeGridOpts.value;
            const rowOpts = computeRowOpts.value;
            const popupWrapperStyle = computePopupWrapperStyle.value;
            const headerSlot = slots.header;
            const footerSlot = slots.footer;
            const prefixSlot = slots.prefix;
            if (formReadonly) {
                return h('div', {
                    ref: refElem,
                    class: ['vxe-table-select--readonly', className]
                }, [
                    h('span', {
                        class: 'vxe-table-select-label'
                    }, selectLabel)
                ]);
            }
            return h('div', {
                ref: refElem,
                class: ['vxe-table-select', className ? (XEUtils.isFunction(className) ? className({ $tableSelect: $xeTableSelect }) : className) : '', {
                        [`size--${vSize}`]: vSize,
                        'is--visible': visiblePanel,
                        'is--disabled': isDisabled,
                        'is--loading': loading,
                        'is--active': isActivated
                    }]
            }, [
                h(VxeInputComponent, {
                    ref: refInput,
                    clearable: props.clearable,
                    placeholder: loading ? getI18n('vxe.select.loadingText') : props.placeholder,
                    readonly: true,
                    disabled: isDisabled,
                    type: 'text',
                    prefixIcon: props.prefixIcon,
                    suffixIcon: loading ? getIcon().TABLE_SELECT_LOADED : (visiblePanel ? getIcon().TABLE_SELECT_OPEN : getIcon().TABLE_SELECT_CLOSE),
                    modelValue: loading ? '' : selectLabel,
                    onClear: clearEvent,
                    onClick: clickEvent,
                    onFocus: focusEvent,
                    onBlur: blurEvent,
                    onSuffixClick: togglePanelEvent
                }, prefixSlot
                    ? {
                        prefix: () => prefixSlot({})
                    }
                    : {}),
                h(Teleport, {
                    to: 'body',
                    disabled: btnTransfer ? !initialized : true
                }, [
                    h('div', {
                        ref: refOptionPanel,
                        class: ['vxe-table--ignore-clear vxe-table-select--panel', popupClassName ? (XEUtils.isFunction(popupClassName) ? popupClassName({ $tableSelect: $xeTableSelect }) : popupClassName) : '', {
                                [`size--${vSize}`]: vSize,
                                'is--transfer': btnTransfer,
                                'ani--leave': !loading && isAniVisible,
                                'ani--enter': !loading && visiblePanel
                            }],
                        placement: reactData.panelPlacement,
                        style: reactData.panelStyle
                    }, initialized
                        ? [
                            h('div', {
                                class: 'vxe-table-select--panel-wrapper'
                            }, [
                                headerSlot
                                    ? h('div', {
                                        class: 'vxe-table-select--panel-header'
                                    }, headerSlot({}))
                                    : renderEmptyElement($xeTableSelect),
                                h('div', {
                                    class: 'vxe-table-select--panel-body'
                                }, [
                                    h('div', {
                                        ref: refGridWrapper,
                                        class: 'vxe-table-select-grid--wrapper',
                                        style: popupWrapperStyle
                                    }, [
                                        VxeTableGridComponent
                                            ? h(VxeTableGridComponent, Object.assign(Object.assign(Object.assign({}, gridOpts), gridEvents), { class: 'vxe-table-select--grid', ref: refGrid, rowConfig: rowOpts, data: options, columns: tableColumns, height: '100%', autoResize: true, onRadioChange: radioChangeEvent, onCheckboxChange: checkboxChangeEvent, onCheckboxAll: checkboxAllEvent }), Object.assign({}, slots, {
                                                header: undefined,
                                                footer: undefined,
                                                prefixSlot: undefined
                                            }))
                                            : renderEmptyElement($xeTableSelect)
                                    ])
                                ]),
                                footerSlot
                                    ? h('div', {
                                        class: 'vxe-table-select--panel-footer'
                                    }, footerSlot({}))
                                    : renderEmptyElement($xeTableSelect)
                            ])
                        ]
                        : [])
                ])
            ]);
        };
        watch(() => props.options, () => {
            cacheDataMap();
        });
        watch(() => props.columns, (val) => {
            loadTableColumn(val || []);
        });
        watch(() => props.modelValue, (val) => {
            updateModel(val);
        });
        loadTableColumn(props.columns || []);
        cacheDataMap();
        onMounted(() => {
            globalEvents.on($xeTableSelect, 'mousewheel', handleGlobalMousewheelEvent);
            globalEvents.on($xeTableSelect, 'mousedown', handleGlobalMousedownEvent);
            globalEvents.on($xeTableSelect, 'blur', handleGlobalBlurEvent);
        });
        onUnmounted(() => {
            globalEvents.off($xeTableSelect, 'mousewheel');
            globalEvents.off($xeTableSelect, 'mousedown');
            globalEvents.off($xeTableSelect, 'blur');
        });
        if (process.env.NODE_ENV === 'development') {
            nextTick(() => {
                if (!VxeTableGridComponent) {
                    errLog('vxe.error.reqComp', ['vxe-grid']);
                }
            });
        }
        provide('$xeTableSelect', $xeTableSelect);
        $xeTableSelect.renderVN = renderVN;
        return $xeTableSelect;
    },
    render() {
        return this.renderVN();
    }
});
