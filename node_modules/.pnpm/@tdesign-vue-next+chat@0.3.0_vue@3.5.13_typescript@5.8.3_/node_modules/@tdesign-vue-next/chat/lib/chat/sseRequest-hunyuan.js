/**
 * tdesign-vue-chat v0.3.0
 * (c) 2025 tdesign
 * @license MIT
 */

import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _regeneratorRuntime from '@babel/runtime/regenerator';

function sseRequest(_x, _x2) {
  return _sseRequest.apply(this, arguments);
}
function _sseRequest() {
  _sseRequest = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(params, apiKey) {
    var url, data, complete, cancel, abort, controller, signal, tokenHeaders, responsePromise;
    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          url = params.url, data = params.data, complete = params.complete, cancel = params.cancel, abort = params.abort;
          controller = new AbortController();
          signal = controller.signal;
          cancel === null || cancel === void 0 || cancel(controller);
          tokenHeaders = {
            "Content-Type": "application/json"
          };
          tokenHeaders.Authorization = "Bearer".concat(apiKey ? " ".concat(apiKey) : "");
          responsePromise = fetch(url, {
            method: "POST",
            headers: tokenHeaders,
            body: JSON.stringify(data),
            signal: controller.signal
          })["catch"](function (e) {
            var msg = e.toString() || "\u6D41\u5F0F\u63A5\u53E3\u5F02\u5E38";
            complete === null || complete === void 0 || complete(false, msg);
            return Promise.reject(e);
          });
          fetchSSE(function () {
            return responsePromise;
          }, params);
          signal.addEventListener("abort", function () {
            try {
              abort && abort();
            } catch (_unused) {}
          });
        case 9:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _sseRequest.apply(this, arguments);
}
var fetchSSE = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(fetchFn) {
    var options,
      success,
      fail,
      complete,
      responsePromise,
      _args2 = arguments;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
          success = options.success, fail = options.fail, complete = options.complete;
          responsePromise = fetchFn()["catch"](function (e) {
            var msg = e.toString() || "\u6D41\u5F0F\u63A5\u53E3\u5F02\u5E38";
            complete === null || complete === void 0 || complete(false, msg);
            return Promise.reject(e);
          });
          responsePromise.then(function (response) {
            if (!(response !== null && response !== void 0 && response.ok)) {
              complete === null || complete === void 0 || complete(false, response.statusText);
              fail === null || fail === void 0 || fail();
              throw new Error("Request failed");
            }
            var reader = response.body.getReader();
            var decoder = new TextDecoder();
            if (!reader) throw new Error("No reader available");
            var bufferArr = [];
            var event = {
              type: null,
              data: null
            };
            function processText(_x4) {
              return _processText.apply(this, arguments);
            }
            function _processText() {
              _processText = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref2) {
                var done, value, chunk, buffers, i, line, response2, _JSON$parse, choices, jsonData;
                return _regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) switch (_context.prev = _context.next) {
                    case 0:
                      done = _ref2.done, value = _ref2.value;
                      if (!done) {
                        _context.next = 4;
                        break;
                      }
                      complete === null || complete === void 0 || complete(true);
                      return _context.abrupt("return", Promise.resolve());
                    case 4:
                      chunk = decoder.decode(value);
                      buffers = chunk.toString().split(/\r?\n/);
                      bufferArr.push.apply(bufferArr, _toConsumableArray(buffers));
                      i = 0;
                      while (i < bufferArr.length) {
                        line = bufferArr[i];
                        if (line) {
                          response2 = line.slice(6);
                          if (response2 === "[DONE]") {
                            event.type = "finish";
                          } else {
                            choices = (_JSON$parse = JSON.parse(response2.trim())) === null || _JSON$parse === void 0 || (_JSON$parse = _JSON$parse.choices) === null || _JSON$parse === void 0 ? void 0 : _JSON$parse[0];
                            if (choices.finish_reason === "stop") {
                              event.type = "finish";
                            } else {
                              event.type = "delta";
                              event.data = choices;
                            }
                          }
                        }
                        if (event.type && event.data) {
                          jsonData = JSON.parse(JSON.stringify(event));
                          success(jsonData);
                          event.type = null;
                          event.data = null;
                        }
                        bufferArr.splice(i, 1);
                      }
                      return _context.abrupt("return", reader.read().then(processText));
                    case 10:
                    case "end":
                      return _context.stop();
                  }
                }, _callee);
              }));
              return _processText.apply(this, arguments);
            }
            return reader.read().then(processText);
          })["catch"](function () {
            fail === null || fail === void 0 || fail();
          });
        case 4:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function fetchSSE(_x3) {
    return _ref.apply(this, arguments);
  };
}();

export { fetchSSE, sseRequest };
//# sourceMappingURL=sseRequest-hunyuan.js.map
