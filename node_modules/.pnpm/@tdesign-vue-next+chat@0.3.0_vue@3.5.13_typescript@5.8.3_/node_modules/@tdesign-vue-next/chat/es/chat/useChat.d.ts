/// <reference types="node" />
export declare function useChat(props: any, emit: any): {
    chatList: import("vue").Ref<{
        actions?: string | ((h: typeof import("vue").h) => import("..").SlotReturnValue);
        animation?: "gradient" | "skeleton" | "moving";
        avatar?: ((h: typeof import("vue").h) => import("..").SlotReturnValue) | {
            [x: number]: string;
            toString: () => string;
            charAt: (pos: number) => string;
            charCodeAt: (index: number) => number;
            concat: (...strings: string[]) => string;
            indexOf: (searchString: string, position?: number) => number;
            lastIndexOf: (searchString: string, position?: number) => number;
            localeCompare: {
                (that: string): number;
                (that: string, locales?: string | string[], options?: Intl.CollatorOptions): number;
            };
            match: {
                (regexp: string | RegExp): RegExpMatchArray;
                (matcher: {
                    [Symbol.match](string: string): RegExpMatchArray;
                }): RegExpMatchArray;
            };
            replace: {
                (searchValue: string | RegExp, replaceValue: string): string;
                (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
                (searchValue: {
                    [Symbol.replace](string: string, replaceValue: string): string;
                }, replaceValue: string): string;
                (searchValue: {
                    [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;
                }, replacer: (substring: string, ...args: any[]) => string): string;
            };
            search: {
                (regexp: string | RegExp): number;
                (searcher: {
                    [Symbol.search](string: string): number;
                }): number;
            };
            slice: (start?: number, end?: number) => string;
            split: {
                (separator: string | RegExp, limit?: number): string[];
                (splitter: {
                    [Symbol.split](string: string, limit?: number): string[];
                }, limit?: number): string[];
            };
            substring: (start: number, end?: number) => string;
            toLowerCase: () => string;
            toLocaleLowerCase: (locales?: string | string[]) => string;
            toUpperCase: () => string;
            toLocaleUpperCase: (locales?: string | string[]) => string;
            trim: () => string;
            readonly length: number;
            substr: (from: number, length?: number) => string;
            valueOf: () => string;
            codePointAt: (pos: number) => number;
            includes: (searchString: string, position?: number) => boolean;
            endsWith: (searchString: string, endPosition?: number) => boolean;
            normalize: {
                (form: "NFC" | "NFD" | "NFKC" | "NFKD"): string;
                (form?: string): string;
            };
            repeat: (count: number) => string;
            startsWith: (searchString: string, position?: number) => boolean;
            anchor: (name: string) => string;
            big: () => string;
            blink: () => string;
            bold: () => string;
            fixed: () => string;
            fontcolor: (color: string) => string;
            fontsize: {
                (size: number): string;
                (size: string): string;
            };
            italics: () => string;
            link: (url: string) => string;
            small: () => string;
            strike: () => string;
            sub: () => string;
            sup: () => string;
            padStart: (maxLength: number, fillString?: string) => string;
            padEnd: (maxLength: number, fillString?: string) => string;
            trimEnd: () => string;
            trimStart: () => string;
            trimLeft: () => string;
            trimRight: () => string;
            matchAll: (regexp: RegExp) => IterableIterator<RegExpMatchArray>;
            replaceAll: {
                (searchValue: string | RegExp, replaceValue: string): string;
                (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
            };
            at: (index: number) => string;
            [Symbol.iterator]: () => IterableIterator<string>;
        } | {
            alt?: string;
            content?: string | ((h: typeof import("vue").h) => import("tdesign-vue-next").SlotReturnValue);
            default?: string | ((h: typeof import("vue").h) => import("tdesign-vue-next").SlotReturnValue);
            hideOnLoadFailed?: boolean;
            icon?: (h: typeof import("vue").h) => import("tdesign-vue-next").SlotReturnValue;
            image?: string;
            imageProps?: {
                alt?: string;
                error?: string | ((h: typeof import("vue").h) => import("tdesign-vue-next").SlotReturnValue);
                fallback?: string;
                fit?: "fill" | "none" | "contain" | "cover" | "scale-down";
                gallery?: boolean;
                lazy?: boolean;
                loading?: string | ((h: typeof import("vue").h) => import("tdesign-vue-next").SlotReturnValue);
                overlayContent?: string | ((h: typeof import("vue").h) => import("tdesign-vue-next").SlotReturnValue);
                overlayTrigger?: "always" | "hover";
                placeholder?: string | ((h: typeof import("vue").h) => import("tdesign-vue-next").SlotReturnValue);
                position?: string;
                referrerpolicy?: "origin" | "same-origin" | "no-referrer" | "no-referrer-when-downgrade" | "origin-when-cross-origin" | "strict-origin" | "strict-origin-when-cross-origin" | "unsafe-url";
                shape?: "square" | "round" | "circle";
                src?: string | {
                    readonly lastModified: number;
                    readonly name: string;
                    readonly webkitRelativePath: string;
                    readonly size: number;
                    readonly type: string;
                    arrayBuffer: {
                        (): Promise<ArrayBuffer>;
                        (): Promise<ArrayBuffer>;
                    };
                    slice: {
                        (start?: number, end?: number, contentType?: string): Blob;
                        (start?: number, end?: number, contentType?: string): Blob;
                    };
                    stream: {
                        (): ReadableStream<Uint8Array>;
                        (): NodeJS.ReadableStream;
                    };
                    text: {
                        (): Promise<string>;
                        (): Promise<string>;
                    };
                };
                srcset?: {
                    'image/avif': string;
                    'image/webp': string;
                };
                onError?: (context: {
                    e: Event;
                }) => void;
                onLoad?: (context: {
                    e: Event;
                }) => void;
            };
            shape?: import("tdesign-vue-next").ShapeEnum;
            size?: string;
            onError?: (context: {
                e: Event;
            }) => void;
        };
        content?: string | ((h: typeof import("vue").h) => import("..").SlotReturnValue);
        datetime?: string | ((h: typeof import("vue").h) => import("..").SlotReturnValue);
        name?: string | ((h: typeof import("vue").h) => import("..").SlotReturnValue);
        reasoning?: boolean | {
            expandIconPlacement?: "left" | "right";
            onExpandChange?: (isExpand: boolean) => void;
            collapsePanelProps?: Object;
            collapsed?: boolean;
        };
        role?: "error" | "user" | "assistant" | "model-change" | "system";
        textLoading?: boolean;
        variant?: "outline" | "base" | "text";
    }[]>;
    loading: import("vue").Ref<boolean>;
    isStreamLoad: import("vue").Ref<boolean>;
    onStop: () => void;
    setChatList: (inputValue: string) => void;
    operation: (type: string, options: {
        e: MouseEvent;
        index: number;
    }) => void;
    clearConfirm: (context: {
        e: MouseEvent;
    }) => void;
    sendRequest: (type: string, inputValue: string, modelOrMofaId?: string) => Promise<void>;
};
