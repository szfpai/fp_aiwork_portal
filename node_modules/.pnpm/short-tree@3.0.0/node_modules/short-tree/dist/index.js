import { RBTree } from 'bintrees';
function makeArrayCompare(cmp) {
    return function (a, b) {
        const lenA = a.length;
        const lenB = b.length;
        const minLength = Math.min(lenA, lenB);
        for (let i = 0; i < minLength; ++i) {
            const diff = cmp(a[i], b[i]);
            if (diff === 0)
                continue;
            return diff;
        }
        return lenA > lenB
            ? 1
            : lenA < lenB
                ? -1
                : 0;
    };
}
function arrayStartsWith(haystack, needle, cmp) {
    if (haystack.length < needle.length)
        return false;
    for (let i = 0; i < needle.length; ++i)
        if (cmp(haystack[i], needle[i]) !== 0)
            return false;
    return true;
}
export class ShortTree extends RBTree {
    constructor(cmp, arrayCmp = makeArrayCompare(cmp)) {
        super(arrayCmp);
        this.cmp = cmp;
        this.arrayCmp = arrayCmp;
    }
    arrayStartsWith(haystack, needle) {
        return arrayStartsWith(haystack, needle, this.cmp);
    }
    insert(path) {
        // Find shorter path, if so, do nothing
        const iter = this.lowerBound(path);
        const data = iter.data();
        if (data) {
            const cmp = this.arrayCmp(data, path);
            if (cmp === 0)
                return false;
            else if (this.arrayStartsWith(data, path))
                this.chopOff(path);
        }
        const prev = this.lowerBound(path).prev();
        if (prev && this.arrayStartsWith(path, prev))
            return false;
        return super.insert(path);
    }
    chopOff(path) {
        const iter = this.lowerBound(path);
        const found = [];
        do {
            const data = iter.data();
            if (data && this.arrayStartsWith(data, path))
                found.push(data);
            else
                break;
            iter.next();
        } while (true);
        for (const node of found)
            this.remove(node);
        return found.length > 0;
    }
    values() {
        const ret = [];
        this.each(node => ret.push(node));
        return ret;
    }
}
