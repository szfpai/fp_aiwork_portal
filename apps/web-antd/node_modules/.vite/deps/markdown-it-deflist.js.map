{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/markdown-it-deflist@3.0.0/node_modules/markdown-it-deflist/index.mjs"],
  "sourcesContent": ["// Process definition lists\n//\nexport default function deflist_plugin (md) {\n  const isSpace = md.utils.isSpace\n\n  // Search `[:~][\\n ]`, returns next pos after marker on success\n  // or -1 on fail.\n  function skipMarker (state, line) {\n    let start = state.bMarks[line] + state.tShift[line]\n    const max = state.eMarks[line]\n\n    if (start >= max) { return -1 }\n\n    // Check bullet\n    const marker = state.src.charCodeAt(start++)\n    if (marker !== 0x7E/* ~ */ && marker !== 0x3A/* : */) { return -1 }\n\n    const pos = state.skipSpaces(start)\n\n    // require space after \":\"\n    if (start === pos) { return -1 }\n\n    // no empty definitions, e.g. \"  : \"\n    if (pos >= max) { return -1 }\n\n    return start\n  }\n\n  function markTightParagraphs (state, idx) {\n    const level = state.level + 2\n\n    for (let i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n      if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n        state.tokens[i + 2].hidden = true\n        state.tokens[i].hidden = true\n        i += 2\n      }\n    }\n  }\n\n  function deflist (state, startLine, endLine, silent) {\n    if (silent) {\n      // quirk: validation mode validates a dd block only, not a whole deflist\n      if (state.ddIndent < 0) { return false }\n      return skipMarker(state, startLine) >= 0\n    }\n\n    let nextLine = startLine + 1\n    if (nextLine >= endLine) { return false }\n\n    if (state.isEmpty(nextLine)) {\n      nextLine++\n      if (nextLine >= endLine) { return false }\n    }\n\n    if (state.sCount[nextLine] < state.blkIndent) { return false }\n    let contentStart = skipMarker(state, nextLine)\n    if (contentStart < 0) { return false }\n\n    // Start list\n    const listTokIdx = state.tokens.length\n    let tight = true\n\n    const token_dl_o = state.push('dl_open', 'dl', 1)\n    const listLines = [startLine, 0]\n    token_dl_o.map = listLines\n\n    //\n    // Iterate list items\n    //\n\n    let dtLine = startLine\n    let ddLine = nextLine\n\n    // One definition list can contain multiple DTs,\n    // and one DT can be followed by multiple DDs.\n    //\n    // Thus, there is two loops here, and label is\n    // needed to break out of the second one\n    //\n    /* eslint no-labels:0,block-scoped-var:0 */\n    OUTER:\n    for (;;) {\n      let prevEmptyEnd = false\n\n      const token_dt_o = state.push('dt_open', 'dt', 1)\n      token_dt_o.map = [dtLine, dtLine]\n\n      const token_i = state.push('inline', '', 0)\n      token_i.map      = [dtLine, dtLine]\n      token_i.content  = state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim()\n      token_i.children = []\n\n      state.push('dt_close', 'dt', -1)\n\n      for (;;) {\n        const token_dd_o = state.push('dd_open', 'dd', 1)\n        const itemLines = [nextLine, 0]\n        token_dd_o.map = itemLines\n\n        let pos = contentStart\n        const max = state.eMarks[ddLine]\n        let offset = state.sCount[ddLine] + contentStart - (state.bMarks[ddLine] + state.tShift[ddLine])\n\n        while (pos < max) {\n          const ch = state.src.charCodeAt(pos)\n\n          if (isSpace(ch)) {\n            if (ch === 0x09) {\n              offset += 4 - offset % 4\n            } else {\n              offset++\n            }\n          } else {\n            break\n          }\n\n          pos++\n        }\n\n        contentStart = pos\n\n        const oldTight = state.tight\n        const oldDDIndent = state.ddIndent\n        const oldIndent = state.blkIndent\n        const oldTShift = state.tShift[ddLine]\n        const oldSCount = state.sCount[ddLine]\n        const oldParentType = state.parentType\n        state.blkIndent = state.ddIndent = state.sCount[ddLine] + 2\n        state.tShift[ddLine] = contentStart - state.bMarks[ddLine]\n        state.sCount[ddLine] = offset\n        state.tight = true\n        state.parentType = 'deflist'\n\n        state.md.block.tokenize(state, ddLine, endLine, true)\n\n        // If any of list item is tight, mark list as tight\n        if (!state.tight || prevEmptyEnd) {\n          tight = false\n        }\n        // Item become loose if finish with empty line,\n        // but we should filter last element, because it means list finish\n        prevEmptyEnd = (state.line - ddLine) > 1 && state.isEmpty(state.line - 1)\n\n        state.tShift[ddLine] = oldTShift\n        state.sCount[ddLine] = oldSCount\n        state.tight = oldTight\n        state.parentType = oldParentType\n        state.blkIndent = oldIndent\n        state.ddIndent = oldDDIndent\n\n        state.push('dd_close', 'dd', -1)\n\n        itemLines[1] = nextLine = state.line\n\n        if (nextLine >= endLine) { break OUTER }\n\n        if (state.sCount[nextLine] < state.blkIndent) { break OUTER }\n        contentStart = skipMarker(state, nextLine)\n        if (contentStart < 0) { break }\n\n        ddLine = nextLine\n\n        // go to the next loop iteration:\n        // insert DD tag and repeat checking\n      }\n\n      if (nextLine >= endLine) { break }\n      dtLine = nextLine\n\n      if (state.isEmpty(dtLine)) { break }\n      if (state.sCount[dtLine] < state.blkIndent) { break }\n\n      ddLine = dtLine + 1\n      if (ddLine >= endLine) { break }\n      if (state.isEmpty(ddLine)) { ddLine++ }\n      if (ddLine >= endLine) { break }\n\n      if (state.sCount[ddLine] < state.blkIndent) { break }\n      contentStart = skipMarker(state, ddLine)\n      if (contentStart < 0) { break }\n\n      // go to the next loop iteration:\n      // insert DT and DD tags and repeat checking\n    }\n\n    // Finilize list\n    state.push('dl_close', 'dl', -1)\n\n    listLines[1] = nextLine\n\n    state.line = nextLine\n\n    // mark paragraphs tight if needed\n    if (tight) {\n      markTightParagraphs(state, listTokIdx)\n    }\n\n    return true\n  }\n\n  md.block.ruler.before('paragraph', 'deflist', deflist, { alt: ['paragraph', 'reference', 'blockquote'] })\n};\n"],
  "mappings": "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",
  "names": []
}
