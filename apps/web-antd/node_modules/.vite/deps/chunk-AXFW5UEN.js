import {
  addClass,
  calcTreeLine,
  cell_default,
  clearTableAllStatus,
  colToVisible,
  convertHeaderColumnToRows,
  createHandleGetRowId,
  createHandleUpdateRowId,
  getCellHeight,
  getCellValue,
  getColReMinWidth,
  getEventTargetNode,
  getOffsetPos,
  getOffsetSize,
  getPaddingTopBottomSize,
  getPropClass,
  getRefElem,
  getRootColumn,
  getRowUniqueId,
  getRowid,
  getRowkey,
  getTpImg,
  handleFieldOrColumn,
  handleRowidOrRow,
  hasClass,
  hasControlKey,
  initTpImg,
  isPx,
  isScale,
  removeClass,
  restoreScrollLocation,
  rowToVisible,
  setCellValue,
  setScrollLeft,
  setScrollTop,
  toCssUnit,
  toTreePathSeq,
  updateCellTitle
} from "./chunk-26GWP7VR.js";
import {
  errLog,
  getSlotVNs,
  warnLog
} from "./chunk-Q2PQPNJT.js";
import {
  eqEmptyValue,
  formatText,
  getFuncText,
  getLastZIndex,
  hasChildrenList,
  isEnableConf,
  nextZIndex,
  parseFile
} from "./chunk-O4MT4GCA.js";
import {
  VxeUI,
  require_xe_utils
} from "./chunk-HLJGUNZZ.js";
import {
  Teleport,
  TransitionGroup,
  computed,
  createCommentVNode,
  defineComponent,
  h,
  inject,
  nextTick,
  onActivated,
  onBeforeUnmount,
  onDeactivated,
  onMounted,
  onUnmounted,
  provide,
  reactive,
  ref,
  watch
} from "./chunk-RWBQDMGA.js";
import {
  __toESM
} from "./chunk-DBU5TJLK.js";

// ../../node_modules/.pnpm/vxe-table@4.13.16_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-table/es/table/src/table.js
var import_xe_utils9 = __toESM(require_xe_utils());

// ../../node_modules/.pnpm/vxe-table@4.13.16_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-table/es/table/src/body.js
var import_xe_utils = __toESM(require_xe_utils());
var { getI18n, renderer, renderEmptyElement } = VxeUI;
var renderType = "body";
var body_default = defineComponent({
  name: "VxeTableBody",
  props: {
    tableData: Array,
    tableColumn: Array,
    fixedColumn: Array,
    fixedType: {
      type: String,
      default: ""
    }
  },
  setup(props) {
    const $xeTable = inject("$xeTable", {});
    const { xID, props: tableProps, context: tableContext, reactData: tableReactData, internalData: tableInternalData } = $xeTable;
    const { computeEditOpts, computeMouseOpts, computeCellOffsetWidth, computeAreaOpts, computeDefaultRowHeight, computeEmptyOpts, computeTooltipOpts, computeRadioOpts, computeExpandOpts, computeTreeOpts, computeCheckboxOpts, computeCellOpts, computeValidOpts, computeRowOpts, computeColumnOpts, computeRowDragOpts, computeColumnDragOpts, computeResizableOpts, computeVirtualXOpts, computeVirtualYOpts } = $xeTable.getComputeMaps();
    const refElem = ref();
    const refBodyScroll = ref();
    const refBodyTable = ref();
    const refBodyColgroup = ref();
    const refBodyTBody = ref();
    const refBodyXSpace = ref();
    const refBodyYSpace = ref();
    const refBodyEmptyBlock = ref();
    const isVMScrollProcess = () => {
      const { delayHover } = tableProps;
      const { lastScrollTime, isDragResize } = tableReactData;
      return !!(isDragResize || lastScrollTime && Date.now() < lastScrollTime + delayHover);
    };
    const renderLine = (rowid, params, cellHeight) => {
      const { row, column } = params;
      const { afterFullData } = tableInternalData;
      const { treeConfig } = tableProps;
      const treeOpts = computeTreeOpts.value;
      const { slots, treeNode } = column;
      const { fullAllDataRowIdData } = tableInternalData;
      if (slots && slots.line) {
        return $xeTable.callSlot(slots.line, params);
      }
      const rowRest = fullAllDataRowIdData[rowid];
      let rLevel = 0;
      let prevRow = null;
      if (rowRest) {
        rLevel = rowRest.level;
        prevRow = rowRest.items[rowRest.treeIndex - 1];
      }
      if (treeConfig && treeNode && (treeOpts.showLine || treeOpts.line)) {
        return [
          h("div", {
            key: "tl",
            class: "vxe-tree--line-wrapper"
          }, [
            h("div", {
              class: "vxe-tree--line",
              style: {
                height: `${$xeTable.eqRow(afterFullData[0], row) ? 1 : calcTreeLine(params, prevRow)}px`,
                bottom: `-${Math.floor(cellHeight / 2)}px`,
                left: `${rLevel * treeOpts.indent + (rLevel ? 2 - getOffsetSize($xeTable) : 0) + 16}px`
              }
            })
          ])
        ];
      }
      return [];
    };
    const renderTdColumn = (seq, rowid, fixedType, isOptimizeMode, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, columns, items) => {
      const $xeGrid = $xeTable.xeGrid;
      const { columnKey, resizable: allResizable, showOverflow: allShowOverflow, border, height, treeConfig, cellClassName: allCellClassName, cellStyle, align: allAlign, spanMethod, mouseConfig, editConfig, editRules, tooltipConfig, padding: allPadding } = tableProps;
      const { tableData, dragRow, overflowX, currentColumn, scrollXLoad, scrollYLoad, mergeBodyFlag, calcCellHeightFlag, resizeHeightFlag, resizeWidthFlag, editStore, isAllOverflow, validErrorMaps } = tableReactData;
      const { fullAllDataRowIdData, fullColumnIdData, mergeBodyCellMaps, visibleColumn, afterFullData, mergeBodyList, scrollXStore, scrollYStore } = tableInternalData;
      const cellOpts = computeCellOpts.value;
      const validOpts = computeValidOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const editOpts = computeEditOpts.value;
      const tooltipOpts = computeTooltipOpts.value;
      const resizableOpts = computeResizableOpts.value;
      const virtualXOpts = computeVirtualXOpts.value;
      const virtualYOpts = computeVirtualYOpts.value;
      const { isAllColumnDrag, isAllRowDrag } = resizableOpts;
      const rowOpts = computeRowOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const customCellHeight = calcCellHeightFlag ? cellOpts.height || rowOpts.height : 0;
      const { disabledMethod: dragDisabledMethod, isCrossDrag, isPeerDrag } = rowDragOpts;
      const columnOpts = computeColumnOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const areaOpts = computeAreaOpts.value;
      const cellOffsetWidth = computeCellOffsetWidth.value;
      const { selectCellToRow } = areaOpts;
      const { type, cellRender, editRender, align, showOverflow, className, treeNode, rowResize, padding, verticalAlign, slots } = column;
      const { verticalAlign: allVerticalAlign } = cellOpts;
      const { actived } = editStore;
      const rowRest = fullAllDataRowIdData[rowid] || {};
      const colid = column.id;
      const colRest = fullColumnIdData[colid] || {};
      const renderOpts = editRender || cellRender;
      const compConf = renderOpts ? renderer.get(renderOpts.name) : null;
      const compCellClassName = compConf ? compConf.tableCellClassName || compConf.cellClassName : null;
      const compCellStyle = compConf ? compConf.tableCellStyle || compConf.cellStyle : "";
      const showAllTip = tooltipOpts.showAll;
      const columnIndex = colRest.index;
      const _columnIndex = colRest._index;
      const isEdit = isEnableConf(editRender);
      const resizeHeight = resizeHeightFlag ? rowRest.resizeHeight : 0;
      let fixedHiddenColumn = fixedType ? column.fixed !== fixedType : column.fixed && overflowX;
      const isCellPadding = import_xe_utils.default.eqNull(padding) ? allPadding === null ? cellOpts.padding : allPadding : padding;
      const cellOverflow = import_xe_utils.default.eqNull(showOverflow) ? allShowOverflow : showOverflow;
      const showEllipsis = cellOverflow === "ellipsis";
      const showTitle = cellOverflow === "title";
      const showTooltip = cellOverflow === true || cellOverflow === "tooltip";
      const hasEllipsis = isAllOverflow || showTitle || showTooltip || showEllipsis;
      const showResizable = import_xe_utils.default.isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable;
      const isCsHeight = !!customCellHeight;
      const isRsHeight = resizeHeight > 0;
      let isDirty;
      const tdOns = {};
      const cellAlign = align || (compConf ? compConf.tableCellAlign : "") || allAlign;
      const cellVerticalAlign = import_xe_utils.default.eqNull(verticalAlign) ? allVerticalAlign : verticalAlign;
      const errorValidItem = validErrorMaps[`${rowid}:${colid}`];
      const showValidTip = editRules && validOpts.showMessage && (validOpts.message === "default" ? height || tableData.length > 1 : validOpts.message === "inline");
      const tdAttrs = { colid };
      const cellParams = {
        $table: $xeTable,
        $grid: $xeGrid,
        isEdit: false,
        seq,
        rowid,
        row,
        rowIndex,
        $rowIndex,
        _rowIndex,
        column,
        columnIndex,
        $columnIndex,
        _columnIndex,
        fixed: fixedType,
        type: renderType,
        isHidden: !!fixedHiddenColumn,
        level: rowLevel,
        visibleData: afterFullData,
        data: tableData,
        items
      };
      let isRowDragCell = false;
      let isDisabledDrag = false;
      if (rowOpts.drag) {
        isRowDragCell = rowDragOpts.trigger === "row" || column.dragSort && rowDragOpts.trigger === "cell";
      }
      if (isRowDragCell) {
        isDisabledDrag = !!(dragDisabledMethod && dragDisabledMethod(cellParams));
      }
      if (showTitle || showTooltip || showAllTip || tooltipConfig) {
        tdOns.onMouseenter = (evnt) => {
          if (isVMScrollProcess()) {
            return;
          }
          if (showTitle) {
            updateCellTitle(evnt.currentTarget, column);
          } else if (showTooltip || showAllTip) {
            $xeTable.triggerBodyTooltipEvent(evnt, cellParams);
          }
          $xeTable.dispatchEvent("cell-mouseenter", Object.assign({ cell: evnt.currentTarget }, cellParams), evnt);
        };
      }
      if (showTooltip || showAllTip || tooltipConfig) {
        tdOns.onMouseleave = (evnt) => {
          if (isVMScrollProcess()) {
            return;
          }
          if (showTooltip || showAllTip) {
            $xeTable.handleTargetLeaveEvent(evnt);
          }
          $xeTable.dispatchEvent("cell-mouseleave", Object.assign({ cell: evnt.currentTarget }, cellParams), evnt);
        };
      }
      if (isRowDragCell || checkboxOpts.range || mouseConfig) {
        tdOns.onMousedown = (evnt) => {
          $xeTable.triggerCellMousedownEvent(evnt, cellParams);
        };
      }
      if (isRowDragCell) {
        tdOns.onMouseup = $xeTable.triggerCellMouseupEvent;
      }
      tdOns.onClick = (evnt) => {
        $xeTable.triggerCellClickEvent(evnt, cellParams);
      };
      tdOns.onDblclick = (evnt) => {
        $xeTable.triggerCellDblclickEvent(evnt, cellParams);
      };
      let isMergeCell = false;
      if (mergeBodyFlag && mergeBodyList.length) {
        const spanRest = mergeBodyCellMaps[`${_rowIndex}:${_columnIndex}`];
        if (spanRest) {
          const { rowspan, colspan } = spanRest;
          if (!rowspan || !colspan) {
            return null;
          }
          if (rowspan > 1) {
            isMergeCell = true;
            tdAttrs.rowspan = rowspan;
          }
          if (colspan > 1) {
            isMergeCell = true;
            tdAttrs.colspan = colspan;
          }
        }
      } else if (spanMethod) {
        const { rowspan = 1, colspan = 1 } = spanMethod(cellParams) || {};
        if (!rowspan || !colspan) {
          return null;
        }
        if (rowspan > 1) {
          tdAttrs.rowspan = rowspan;
        }
        if (colspan > 1) {
          tdAttrs.colspan = colspan;
        }
      }
      if (fixedHiddenColumn && isMergeCell) {
        if (tdAttrs.colspan > 1 || tdAttrs.rowspan > 1) {
          fixedHiddenColumn = false;
        }
      }
      if (!fixedHiddenColumn && editConfig && (editRender || cellRender) && (editOpts.showStatus || editOpts.showUpdateStatus)) {
        isDirty = $xeTable.isUpdateByRow(row, column.field);
      }
      const isVNAutoHeight = scrollYLoad && !hasEllipsis;
      const cellHeight = rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
      const isLastColumn = $columnIndex === columns.length - 1;
      const isAutoCellWidth = !column.resizeWidth && (column.minWidth === "auto" || column.width === "auto");
      let isVNPreEmptyStatus = false;
      if (!isMergeCell) {
        if (!dragRow || getRowid($xeTable, dragRow) !== rowid) {
          if (scrollYLoad && !treeConfig && !virtualYOpts.immediate && (_rowIndex < scrollYStore.visibleStartIndex - scrollYStore.preloadSize || _rowIndex > scrollYStore.visibleEndIndex + scrollYStore.preloadSize)) {
            isVNPreEmptyStatus = true;
          } else if (scrollXLoad && !virtualXOpts.immediate && !column.fixed && (_columnIndex < scrollXStore.visibleStartIndex - scrollXStore.preloadSize || _columnIndex > scrollXStore.visibleEndIndex + scrollXStore.preloadSize)) {
            isVNPreEmptyStatus = true;
          }
        }
      }
      const tcStyle = {};
      if (hasEllipsis && resizeWidthFlag) {
        let tsColspan = tdAttrs.colspan || 0;
        if (tsColspan > 1) {
          for (let index = 1; index < tsColspan; index++) {
            const nextColumn = visibleColumn[columnIndex + index];
            if (nextColumn) {
              tsColspan += nextColumn.renderWidth;
            }
          }
        }
        tcStyle.width = `${column.renderWidth - cellOffsetWidth * tsColspan}px`;
      }
      if (scrollYLoad || hasEllipsis || isCsHeight || isRsHeight) {
        tcStyle.height = `${cellHeight}px`;
      } else {
        tcStyle.minHeight = `${cellHeight}px`;
      }
      const tdVNs = [];
      if (fixedHiddenColumn && isAllOverflow) {
        tdVNs.push(h("div", {
          key: "tc",
          class: ["vxe-cell", {
            "c--title": showTitle,
            "c--tooltip": showTooltip,
            "c--ellipsis": showEllipsis
          }],
          style: tcStyle
        }));
      } else {
        tdVNs.push(...renderLine(rowid, cellParams, cellHeight), h("div", {
          key: "tc",
          class: ["vxe-cell", {
            "c--title": showTitle,
            "c--tooltip": showTooltip,
            "c--ellipsis": showEllipsis
          }],
          style: tcStyle,
          title: showTitle ? $xeTable.getCellLabel(row, column) : null
        }, isVNPreEmptyStatus ? [] : [
          h("div", {
            colid,
            rowid,
            class: "vxe-cell--wrapper"
          }, column.renderCell(cellParams))
        ]));
        if (showValidTip && errorValidItem) {
          const errRule = errorValidItem.rule;
          const validSlot = slots ? slots.valid : null;
          const validParams = Object.assign(Object.assign(Object.assign({}, cellParams), errorValidItem), { rule: errorValidItem });
          tdVNs.push(h("div", {
            key: "tcv",
            class: ["vxe-cell--valid-error-tip", getPropClass(validOpts.className, validParams)],
            style: errRule && errRule.maxWidth ? {
              width: `${errRule.maxWidth}px`
            } : null
          }, [
            h("div", {
              class: `vxe-cell--valid-error-wrapper vxe-cell--valid-error-theme-${validOpts.theme || "normal"}`
            }, [
              validSlot ? $xeTable.callSlot(validSlot, validParams) : [
                h("span", {
                  class: "vxe-cell--valid-error-msg"
                }, errorValidItem.content)
              ]
            ])
          ]));
        }
      }
      let showAreaRowStatus = false;
      if (mouseConfig && mouseOpts.area && selectCellToRow) {
        if (!_columnIndex && selectCellToRow === true || selectCellToRow === column.field) {
          showAreaRowStatus = true;
        }
      }
      if (!fixedHiddenColumn && showResizable && isAllColumnDrag) {
        tdVNs.push(h("div", {
          key: "tcc",
          class: ["vxe-cell--col-resizable", {
            "is--line": !border || border === "none"
          }],
          onMousedown: (evnt) => $xeTable.handleColResizeMousedownEvent(evnt, fixedType, cellParams),
          onDblclick: (evnt) => $xeTable.handleColResizeDblclickEvent(evnt, cellParams)
        }));
      }
      if ((rowResize || isAllRowDrag) && rowOpts.resizable) {
        tdVNs.push(h("div", {
          key: "tcr",
          class: "vxe-cell--row-resizable",
          onMousedown: (evnt) => $xeTable.handleRowResizeMousedownEvent(evnt, cellParams),
          onDblclick: (evnt) => $xeTable.handleRowResizeDblclickEvent(evnt, cellParams)
        }));
      }
      return h("td", Object.assign(Object.assign(Object.assign({ class: [
        "vxe-body--column",
        colid,
        cellVerticalAlign ? `col--vertical-${cellVerticalAlign}` : "",
        cellAlign ? `col--${cellAlign}` : "",
        type ? `col--${type}` : "",
        {
          "col--last": isLastColumn,
          "col--tree-node": treeNode,
          "col--edit": isEdit,
          "col--ellipsis": hasEllipsis,
          "col--cs-height": isCsHeight,
          "col--rs-height": isRsHeight,
          "col--to-row": showAreaRowStatus,
          "col--auto-height": isVNAutoHeight,
          "fixed--width": !isAutoCellWidth,
          "fixed--hidden": fixedHiddenColumn,
          "is--padding": isCellPadding,
          "is--progress": fixedHiddenColumn && isAllOverflow || isVNPreEmptyStatus,
          "is--drag-cell": isRowDragCell && (isCrossDrag || isPeerDrag || !rowLevel),
          "is--drag-disabled": isDisabledDrag,
          "col--dirty": isDirty,
          "col--active": editConfig && isEdit && (actived.row === row && (actived.column === column || editOpts.mode === "row")),
          "col--valid-error": !!errorValidItem,
          "col--current": currentColumn === column
        },
        getPropClass(compCellClassName, cellParams),
        getPropClass(className, cellParams),
        getPropClass(allCellClassName, cellParams)
      ], key: columnKey || scrollXLoad || scrollYLoad || columnOpts.useKey || rowOpts.useKey || columnOpts.drag ? colid : $columnIndex }, tdAttrs), { style: Object.assign({}, import_xe_utils.default.isFunction(compCellStyle) ? compCellStyle(cellParams) : compCellStyle, import_xe_utils.default.isFunction(cellStyle) ? cellStyle(cellParams) : cellStyle) }), tdOns), isOptimizeMode && fixedHiddenColumn ? [] : tdVNs);
    };
    const renderRows = (fixedType, isOptimizeMode, tableData, tableColumn) => {
      const $xeGrid = $xeTable.xeGrid;
      const { stripe, rowKey, highlightHoverRow, rowClassName, rowStyle, editConfig, treeConfig } = tableProps;
      const { hasFixedColumn, treeExpandedFlag, isColLoading, scrollXLoad, scrollYLoad, isAllOverflow, rowExpandedFlag, expandColumn, selectRadioRow, pendingRowFlag, isDragColMove, rowExpandHeightFlag, isRowGroupStatus } = tableReactData;
      const { fullAllDataRowIdData, fullColumnIdData, treeExpandedMaps, pendingRowMaps, rowExpandedMaps } = tableInternalData;
      const checkboxOpts = computeCheckboxOpts.value;
      const radioOpts = computeRadioOpts.value;
      const treeOpts = computeTreeOpts.value;
      const editOpts = computeEditOpts.value;
      const rowOpts = computeRowOpts.value;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const { transform, seqMode } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const rows = [];
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      const isDeepRow = treeConfig || isRowGroupStatus;
      tableData.forEach((row, $rowIndex) => {
        const rowid = handleGetRowId(row);
        const rowRest = fullAllDataRowIdData[rowid] || {};
        let rowIndex = $rowIndex;
        let rowLevel = 0;
        let seq = -1;
        let _rowIndex = -1;
        const hasRowGroupAggregate = isRowGroupStatus && row.isAggregate;
        const trOn = {};
        if (rowOpts.isHover || highlightHoverRow) {
          trOn.onMouseenter = (evnt) => {
            if (isVMScrollProcess()) {
              return;
            }
            $xeTable.triggerHoverEvent(evnt, { row, rowIndex });
          };
          trOn.onMouseleave = () => {
            if (isVMScrollProcess()) {
              return;
            }
            $xeTable.clearHoverRow();
          };
        }
        if (rowRest) {
          rowLevel = rowRest.level;
          if (hasRowGroupAggregate || treeConfig && transform && seqMode === "increasing") {
            seq = rowRest._index + 1;
          } else {
            seq = rowRest.seq;
          }
          rowIndex = rowRest.index;
          _rowIndex = rowRest._index;
        }
        const params = { $table: $xeTable, seq, rowid, fixed: fixedType, type: renderType, level: rowLevel, row, rowIndex, $rowIndex, _rowIndex };
        const isExpandRow = expandColumn && !!rowExpandedFlag && !!rowExpandedMaps[rowid];
        let isExpandTree = false;
        let rowChildren = [];
        let isNewRow = false;
        if (editConfig) {
          isNewRow = $xeTable.isInsertByRow(row);
        }
        if (treeConfig && !scrollYLoad && !transform) {
          rowChildren = row[childrenField];
          isExpandTree = !!treeExpandedFlag && rowChildren && rowChildren.length > 0 && !!treeExpandedMaps[rowid];
        }
        if (rowOpts.drag && !isRowGroupStatus && (!treeConfig || transform)) {
          trOn.onDragstart = $xeTable.handleRowDragDragstartEvent;
          trOn.onDragend = $xeTable.handleRowDragDragendEvent;
          trOn.onDragover = $xeTable.handleRowDragDragoverEvent;
        }
        const trClass = [
          "vxe-body--row",
          isDeepRow ? `row--level-${rowLevel}` : "",
          {
            "row--stripe": stripe && (_rowIndex + 1) % 2 === 0,
            "is--new": isNewRow,
            "is--expand-row": isExpandRow,
            "is--expand-tree": isExpandTree,
            "row--new": isNewRow && (editOpts.showStatus || editOpts.showInsertStatus),
            "row--radio": radioOpts.highlight && $xeTable.eqRow(selectRadioRow, row),
            "row--checked": checkboxOpts.highlight && $xeTable.isCheckedByCheckboxRow(row),
            "row--pending": !!pendingRowFlag && !!pendingRowMaps[rowid],
            "row--group": hasRowGroupAggregate
          },
          getPropClass(rowClassName, params)
        ];
        const tdVNs = tableColumn.map((column, $columnIndex) => {
          return renderTdColumn(seq, rowid, fixedType, isOptimizeMode, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, tableColumn, tableData);
        });
        rows.push(!isColLoading && (columnOpts.drag && columnDragOpts.animation) ? h(TransitionGroup, Object.assign({ name: `vxe-header--col-list${isDragColMove ? "" : "-disabled"}`, tag: "tr", class: trClass, rowid, style: rowStyle ? import_xe_utils.default.isFunction(rowStyle) ? rowStyle(params) : rowStyle : null, key: rowKey || scrollXLoad || scrollYLoad || rowOpts.useKey || rowOpts.drag || columnOpts.drag || isRowGroupStatus || treeConfig ? rowid : $rowIndex }, trOn), {
          default: () => tdVNs
        }) : h("tr", Object.assign({ class: trClass, rowid, style: rowStyle ? import_xe_utils.default.isFunction(rowStyle) ? rowStyle(params) : rowStyle : null, key: rowKey || scrollXLoad || scrollYLoad || rowOpts.useKey || rowOpts.drag || columnOpts.drag || isRowGroupStatus || treeConfig ? rowid : $rowIndex }, trOn), tdVNs));
        if (isExpandRow) {
          const expandOpts = computeExpandOpts.value;
          const { height: expandHeight, padding, mode: expandMode } = expandOpts;
          if (expandMode === "fixed") {
            rows.push(h("tr", {
              class: "vxe-body--row-expanded-place",
              key: `expand_${rowid}`,
              rowid
            }, [
              h("td", {
                class: "vxe-body--row-expanded-place-column",
                colspan: tableColumn.length,
                style: {
                  height: `${rowExpandHeightFlag ? rowRest.expandHeight || expandHeight : 0}px`
                }
              })
            ]));
          } else {
            const cellStyle = {};
            if (expandHeight) {
              cellStyle.height = `${expandHeight}px`;
            }
            if (treeConfig) {
              cellStyle.paddingLeft = `${rowLevel * treeOpts.indent + 30}px`;
            }
            const { showOverflow } = expandColumn || {};
            const colid = expandColumn.id;
            const colRest = fullColumnIdData[colid] || {};
            const hasEllipsis = import_xe_utils.default.isUndefined(showOverflow) || import_xe_utils.default.isNull(showOverflow) ? isAllOverflow : showOverflow;
            let columnIndex = -1;
            let $columnIndex = -1;
            let _columnIndex = -1;
            if (colRest) {
              columnIndex = colRest.index;
              $columnIndex = colRest.$index;
              _columnIndex = colRest._index;
            }
            const expandParams = {
              $grid: $xeGrid,
              $table: $xeTable,
              seq,
              column: expandColumn,
              columnIndex,
              $columnIndex,
              _columnIndex,
              fixed: fixedType,
              type: renderType,
              level: rowLevel,
              row,
              rowid,
              rowIndex,
              $rowIndex,
              _rowIndex,
              isHidden: false,
              isEdit: false,
              visibleData: [],
              data: [],
              items: []
            };
            rows.push(h("tr", {
              class: ["vxe-body--expanded-row", {
                "is--padding": padding
              }],
              key: `expand_${rowid}`
            }, [
              h("td", {
                class: ["vxe-body--expanded-column", {
                  "fixed--hidden": fixedType && !hasFixedColumn,
                  "col--ellipsis": hasEllipsis
                }],
                colspan: tableColumn.length
              }, [
                h("div", {
                  class: ["vxe-body--expanded-cell", {
                    "is--ellipsis": expandHeight
                  }],
                  style: cellStyle
                }, [
                  expandColumn.renderData(expandParams)
                ])
              ])
            ]));
          }
        }
        if (isExpandTree) {
          rows.push(...renderRows(fixedType, isOptimizeMode, rowChildren, tableColumn));
        }
      });
      return rows;
    };
    onMounted(() => {
      nextTick(() => {
        const { fixedType } = props;
        const { elemStore } = tableInternalData;
        const prefix = `${fixedType || "main"}-body-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}scroll`] = refBodyScroll;
        elemStore[`${prefix}table`] = refBodyTable;
        elemStore[`${prefix}colgroup`] = refBodyColgroup;
        elemStore[`${prefix}list`] = refBodyTBody;
        elemStore[`${prefix}xSpace`] = refBodyXSpace;
        elemStore[`${prefix}ySpace`] = refBodyYSpace;
        elemStore[`${prefix}emptyBlock`] = refBodyEmptyBlock;
      });
    });
    onUnmounted(() => {
      const { fixedType } = props;
      const { elemStore } = tableInternalData;
      const prefix = `${fixedType || "main"}-body-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}scroll`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
      elemStore[`${prefix}ySpace`] = null;
      elemStore[`${prefix}emptyBlock`] = null;
    });
    const renderVN = () => {
      const { slots } = tableContext;
      const $xeGrid = $xeTable.xeGrid;
      const { fixedColumn, fixedType, tableColumn } = props;
      const { spanMethod, footerSpanMethod, mouseConfig } = tableProps;
      const { isGroup, tableData, isRowLoading, isColLoading, overflowX, scrollXLoad, scrollYLoad, isAllOverflow, isDragRowMove, expandColumn, dragRow, dragCol } = tableReactData;
      const { visibleColumn, fullAllDataRowIdData, fullColumnIdData } = tableInternalData;
      const rowOpts = computeRowOpts.value;
      const emptyOpts = computeEmptyOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      const expandOpts = computeExpandOpts.value;
      let renderDataList = tableData;
      let renderColumnList = tableColumn;
      let isOptimizeMode = false;
      if (scrollXLoad || scrollYLoad || isAllOverflow) {
        if (expandColumn && expandOpts.mode !== "fixed" || spanMethod || footerSpanMethod) {
        } else {
          isOptimizeMode = true;
        }
      }
      if (!isColLoading && (fixedType || !overflowX)) {
        renderColumnList = visibleColumn;
      }
      if (fixedType) {
        if (isOptimizeMode) {
          renderColumnList = fixedColumn || [];
        }
      }
      if (scrollYLoad && dragRow) {
        if (renderDataList.length > 2) {
          const dRowRest = fullAllDataRowIdData[getRowid($xeTable, dragRow)];
          if (dRowRest) {
            const drIndex = dRowRest._index;
            const firstRow = renderDataList[0];
            const lastRow = renderDataList[renderDataList.length - 1];
            const firstRowRest = fullAllDataRowIdData[getRowid($xeTable, firstRow)];
            const lastRowRest = fullAllDataRowIdData[getRowid($xeTable, lastRow)];
            if (firstRowRest && lastRowRest) {
              const frIndex = firstRowRest._index;
              const lrIndex = lastRowRest._index;
              if (drIndex < frIndex) {
                renderDataList = [dragRow].concat(renderDataList);
              } else if (drIndex > lrIndex) {
                renderDataList = renderDataList.concat([dragRow]);
              }
            }
          }
        }
      }
      if (!fixedType && !isGroup) {
        if (scrollXLoad && dragCol) {
          if (renderColumnList.length > 2) {
            const dCowRest = fullColumnIdData[dragCol.id];
            if (dCowRest) {
              const dcIndex = dCowRest._index;
              const firstCol = renderColumnList[0];
              const lastCol = renderColumnList[renderColumnList.length - 1];
              const firstColRest = fullColumnIdData[firstCol.id];
              const lastColRest = fullColumnIdData[lastCol.id];
              if (firstColRest && lastColRest) {
                const fcIndex = firstColRest._index;
                const lcIndex = lastColRest._index;
                if (dcIndex < fcIndex) {
                  renderColumnList = [dragCol].concat(renderColumnList);
                } else if (dcIndex > lcIndex) {
                  renderColumnList = renderColumnList.concat([dragCol]);
                }
              }
            }
          }
        }
      }
      let emptyContent;
      const emptySlot = slots ? slots.empty : null;
      if (emptySlot) {
        emptyContent = $xeTable.callSlot(emptySlot, { $table: $xeTable, $grid: $xeGrid });
      } else {
        const compConf = emptyOpts.name ? renderer.get(emptyOpts.name) : null;
        const rtEmptyView = compConf ? compConf.renderTableEmpty || compConf.renderTableEmptyView || compConf.renderEmpty : null;
        if (rtEmptyView) {
          emptyContent = getSlotVNs(rtEmptyView(emptyOpts, { $table: $xeTable }));
        } else {
          emptyContent = tableProps.emptyText || getI18n("vxe.table.emptyText");
        }
      }
      const ons = {
        onScroll(evnt) {
          $xeTable.triggerBodyScrollEvent(evnt, fixedType);
        }
      };
      return h("div", {
        ref: refElem,
        class: ["vxe-table--body-wrapper", fixedType ? `fixed-${fixedType}--wrapper` : "body--wrapper"],
        xid: xID
      }, [
        h("div", Object.assign({ ref: refBodyScroll, class: "vxe-table--body-inner-wrapper" }, ons), [
          fixedType ? renderEmptyElement($xeTable) : h("div", {
            ref: refBodyXSpace,
            class: "vxe-body--x-space"
          }),
          h("div", {
            ref: refBodyYSpace,
            class: "vxe-body--y-space"
          }),
          h("table", {
            ref: refBodyTable,
            class: "vxe-table--body",
            xid: xID,
            cellspacing: 0,
            cellpadding: 0,
            border: 0
          }, [
            /**
             * 列宽
             */
            h("colgroup", {
              ref: refBodyColgroup
            }, renderColumnList.map((column, $columnIndex) => {
              return h("col", {
                name: column.id,
                key: $columnIndex,
                style: {
                  width: `${column.renderWidth}px`
                }
              });
            })),
            /**
             * 内容
             */
            !(isRowLoading || isColLoading) && (rowOpts.drag && rowDragOpts.animation) ? h(TransitionGroup, {
              ref: refBodyTBody,
              name: `vxe-body--row-list${isDragRowMove ? "" : "-disabled"}`,
              tag: "tbody"
            }, {
              default: () => renderRows(fixedType, isOptimizeMode, renderDataList, renderColumnList)
            }) : h("tbody", {
              ref: refBodyTBody
            }, renderRows(fixedType, isOptimizeMode, renderDataList, renderColumnList))
          ]),
          h("div", {
            class: "vxe-table--checkbox-range"
          }),
          mouseConfig && mouseOpts.area ? h("div", {
            class: "vxe-table--cell-area"
          }, [
            h("span", {
              class: "vxe-table--cell-main-area"
            }, mouseOpts.extension ? [
              h("span", {
                class: "vxe-table--cell-main-area-btn",
                onMousedown(evnt) {
                  if ($xeTable.triggerCellAreaExtendMousedownEvent) {
                    $xeTable.triggerCellAreaExtendMousedownEvent(evnt, { $table: $xeTable, fixed: fixedType, type: renderType });
                  }
                }
              })
            ] : []),
            h("span", {
              class: "vxe-table--cell-copy-area"
            }),
            h("span", {
              class: "vxe-table--cell-extend-area"
            }),
            h("span", {
              class: "vxe-table--cell-multi-area"
            }),
            h("span", {
              class: "vxe-table--cell-active-area"
            }),
            h("span", {
              class: "vxe-table--cell-row-status-area"
            })
          ]) : renderEmptyElement($xeTable),
          !fixedType ? h("div", {
            class: "vxe-table--empty-block",
            ref: refBodyEmptyBlock
          }, [
            h("div", {
              class: "vxe-table--empty-content"
            }, emptyContent)
          ]) : renderEmptyElement($xeTable)
        ])
      ]);
    };
    return renderVN;
  }
});

// ../../node_modules/.pnpm/vxe-table@4.13.16_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-table/es/table/src/header.js
var import_xe_utils2 = __toESM(require_xe_utils());
var { renderer: renderer2, renderEmptyElement: renderEmptyElement2 } = VxeUI;
var renderType2 = "header";
var header_default = defineComponent({
  name: "VxeTableHeader",
  props: {
    tableData: Array,
    tableColumn: Array,
    tableGroupColumn: Array,
    fixedColumn: Array,
    fixedType: {
      type: String,
      default: null
    }
  },
  setup(props) {
    const $xeTable = inject("$xeTable", {});
    const { xID, props: tableProps, reactData: tableReactData, internalData: tableInternalData } = $xeTable;
    const { computeColumnOpts, computeColumnDragOpts, computeCellOpts, computeMouseOpts, computeHeaderCellOpts, computeDefaultRowHeight, computeVirtualXOpts } = $xeTable.getComputeMaps();
    const headerColumn = ref([]);
    const refElem = ref();
    const refHeaderScroll = ref();
    const refHeaderTable = ref();
    const refHeaderColgroup = ref();
    const refHeaderTHead = ref();
    const refHeaderXSpace = ref();
    const refHeaderBorderRepair = ref();
    const uploadColumn = () => {
      const { isGroup } = tableReactData;
      headerColumn.value = isGroup ? convertHeaderColumnToRows(props.tableGroupColumn) : [];
    };
    const renderRows = (isGroup, isOptimizeMode, cols, $rowIndex) => {
      const $xeGrid = $xeTable.xeGrid;
      const { fixedType } = props;
      const { resizable: allResizable, columnKey, headerCellClassName, headerCellStyle, showHeaderOverflow: allColumnHeaderOverflow, headerAlign: allHeaderAlign, align: allAlign, mouseConfig } = tableProps;
      const { currentColumn, dragCol, scrollXLoad, scrollYLoad, overflowX } = tableReactData;
      const { fullColumnIdData, scrollXStore } = tableInternalData;
      const virtualXOpts = computeVirtualXOpts.value;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const cellOpts = computeCellOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const headerCellOpts = computeHeaderCellOpts.value;
      const currCellHeight = getCellHeight(headerCellOpts.height) || defaultRowHeight;
      const { disabledMethod: dragDisabledMethod, isCrossDrag, isPeerDrag } = columnDragOpts;
      return cols.map((column, $columnIndex) => {
        const { type, showHeaderOverflow, headerAlign, align, filters, headerClassName, editRender, cellRender } = column;
        const colid = column.id;
        const colRest = fullColumnIdData[colid] || {};
        const renderOpts = editRender || cellRender;
        const compConf = renderOpts ? renderer2.get(renderOpts.name) : null;
        const isColGroup = column.children && column.children.length;
        const fixedHiddenColumn = fixedType ? column.fixed !== fixedType && !isColGroup : !!column.fixed && overflowX;
        const isPadding = import_xe_utils2.default.isBoolean(headerCellOpts.padding) ? headerCellOpts.padding : cellOpts.padding;
        const headOverflow = import_xe_utils2.default.eqNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
        const headAlign = headerAlign || (compConf ? compConf.tableHeaderCellAlign : "") || allHeaderAlign || align || (compConf ? compConf.tableCellAlign : "") || allAlign;
        const showEllipsis = headOverflow === "ellipsis";
        const showTitle = headOverflow === "title";
        const showTooltip = headOverflow === true || headOverflow === "tooltip";
        const hasEllipsis = showTitle || showTooltip || showEllipsis;
        let hasFilter = false;
        let firstFilterOption = null;
        if (filters) {
          firstFilterOption = filters[0];
          hasFilter = filters.some((item) => item.checked);
        }
        const columnIndex = colRest.index;
        const _columnIndex = colRest._index;
        const cellParams = {
          $table: $xeTable,
          $grid: $xeGrid,
          $rowIndex,
          column,
          columnIndex,
          $columnIndex,
          _columnIndex,
          firstFilterOption,
          fixed: fixedType,
          type: renderType2,
          isHidden: fixedHiddenColumn,
          hasFilter
        };
        const thAttrs = {
          colid,
          colspan: column.colSpan > 1 ? column.colSpan : null,
          rowspan: column.rowSpan > 1 ? column.rowSpan : null
        };
        const thOns = {
          onClick: (evnt) => $xeTable.triggerHeaderCellClickEvent(evnt, cellParams),
          onDblclick: (evnt) => $xeTable.triggerHeaderCellDblclickEvent(evnt, cellParams)
        };
        const isColDragCell = columnOpts.drag && columnDragOpts.trigger === "cell";
        let isDisabledDrag = false;
        if (isColDragCell) {
          isDisabledDrag = !!(dragDisabledMethod && dragDisabledMethod(cellParams));
        }
        if (mouseConfig || isColDragCell) {
          thOns.onMousedown = (evnt) => $xeTable.triggerHeaderCellMousedownEvent(evnt, cellParams);
        }
        if (columnOpts.drag) {
          thOns.onDragstart = $xeTable.handleHeaderCellDragDragstartEvent;
          thOns.onDragend = $xeTable.handleHeaderCellDragDragendEvent;
          thOns.onDragover = $xeTable.handleHeaderCellDragDragoverEvent;
          if (isColDragCell) {
            thOns.onMouseup = $xeTable.handleHeaderCellDragMouseupEvent;
          }
        }
        const isLastColumn = $columnIndex === cols.length - 1;
        const showResizable = import_xe_utils2.default.isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable;
        const isAutoCellWidth = !column.resizeWidth && (column.minWidth === "auto" || column.width === "auto");
        let isVNPreEmptyStatus = false;
        if (isOptimizeMode && !isGroup) {
          if (!dragCol || dragCol.id !== colid) {
            if (scrollXLoad && !column.fixed && !virtualXOpts.immediate && (_columnIndex < scrollXStore.visibleStartIndex - scrollXStore.preloadSize || _columnIndex > scrollXStore.visibleEndIndex + scrollXStore.preloadSize)) {
              isVNPreEmptyStatus = true;
            }
          }
        }
        const tcStyle = {};
        if (hasEllipsis) {
          tcStyle.height = `${currCellHeight}px`;
        } else {
          tcStyle.minHeight = `${currCellHeight}px`;
        }
        return h("th", Object.assign(Object.assign(Object.assign({ class: [
          "vxe-header--column",
          colid,
          {
            [`col--${headAlign}`]: headAlign,
            [`col--${type}`]: type,
            "col--last": isLastColumn,
            "col--fixed": column.fixed,
            "col--group": isColGroup,
            "col--ellipsis": hasEllipsis,
            "fixed--width": !isAutoCellWidth,
            "fixed--hidden": fixedHiddenColumn,
            "is--padding": isPadding,
            "is--sortable": column.sortable,
            "col--filter": !!filters,
            "is--filter-active": hasFilter,
            "is--drag-active": columnOpts.drag && !column.fixed && !isDisabledDrag && (isCrossDrag || isPeerDrag || !column.parentId),
            "is--drag-disabled": columnOpts.drag && isDisabledDrag,
            "col--current": currentColumn === column
          },
          headerClassName ? import_xe_utils2.default.isFunction(headerClassName) ? headerClassName(cellParams) : headerClassName : "",
          headerCellClassName ? import_xe_utils2.default.isFunction(headerCellClassName) ? headerCellClassName(cellParams) : headerCellClassName : ""
        ], style: headerCellStyle ? import_xe_utils2.default.isFunction(headerCellStyle) ? headerCellStyle(cellParams) : headerCellStyle : null }, thAttrs), thOns), { key: columnKey || scrollXLoad || scrollYLoad || columnOpts.useKey || columnOpts.drag || isColGroup ? colid : $columnIndex }), [
          h("div", {
            class: ["vxe-cell", {
              "c--title": showTitle,
              "c--tooltip": showTooltip,
              "c--ellipsis": showEllipsis
            }],
            style: tcStyle
          }, isVNPreEmptyStatus || isOptimizeMode && fixedHiddenColumn ? [] : [
            h("div", {
              colid,
              class: "vxe-cell--wrapper"
            }, column.renderHeader(cellParams))
          ]),
          /**
           * 列宽拖动
           */
          !fixedHiddenColumn && showResizable ? h("div", {
            class: "vxe-cell--col-resizable",
            onMousedown: (evnt) => $xeTable.handleColResizeMousedownEvent(evnt, fixedType, cellParams),
            onDblclick: (evnt) => $xeTable.handleColResizeDblclickEvent(evnt, cellParams)
          }) : renderEmptyElement2($xeTable)
        ]);
      });
    };
    const renderHeads = (isGroup, isOptimizeMode, headerGroups) => {
      const { fixedType } = props;
      const { headerRowClassName, headerRowStyle } = tableProps;
      const { isColLoading, isDragColMove } = tableReactData;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      return headerGroups.map((cols, $rowIndex) => {
        const params = { $table: $xeTable, $rowIndex, fixed: fixedType, type: renderType2 };
        if (!isColLoading && columnOpts.drag && columnDragOpts.animation) {
          return h(TransitionGroup, {
            key: $rowIndex,
            name: `vxe-header--col-list${isDragColMove ? "" : "-disabled"}`,
            tag: "tr",
            class: [
              "vxe-header--row",
              headerRowClassName ? import_xe_utils2.default.isFunction(headerRowClassName) ? headerRowClassName(params) : headerRowClassName : ""
            ],
            style: headerRowStyle ? import_xe_utils2.default.isFunction(headerRowStyle) ? headerRowStyle(params) : headerRowStyle : null
          }, {
            default: () => renderRows(isGroup, isOptimizeMode, cols, $rowIndex)
          });
        }
        return h("tr", {
          key: $rowIndex,
          class: [
            "vxe-header--row",
            headerRowClassName ? import_xe_utils2.default.isFunction(headerRowClassName) ? headerRowClassName(params) : headerRowClassName : ""
          ],
          style: headerRowStyle ? import_xe_utils2.default.isFunction(headerRowStyle) ? headerRowStyle(params) : headerRowStyle : null
        }, renderRows(isGroup, isOptimizeMode, cols, $rowIndex));
      });
    };
    const renderVN = () => {
      const { fixedType, fixedColumn, tableColumn } = props;
      const { mouseConfig, showHeaderOverflow: allColumnHeaderOverflow, spanMethod, footerSpanMethod } = tableProps;
      const { isGroup, isColLoading, overflowX, scrollXLoad, dragCol } = tableReactData;
      const { visibleColumn, fullColumnIdData } = tableInternalData;
      const mouseOpts = computeMouseOpts.value;
      let renderHeaderList = headerColumn.value;
      let renderColumnList = tableColumn;
      let isOptimizeMode = false;
      if (isGroup) {
        renderColumnList = visibleColumn;
      } else {
        if (scrollXLoad && allColumnHeaderOverflow) {
          if (spanMethod || footerSpanMethod) {
          } else {
            isOptimizeMode = true;
          }
        }
        if (!isOptimizeMode || !isColLoading && (fixedType || !overflowX)) {
          renderColumnList = visibleColumn;
        }
        if (fixedType) {
          if (isOptimizeMode) {
            renderColumnList = fixedColumn || [];
          }
        }
        renderHeaderList = [renderColumnList];
      }
      if (!fixedType && !isGroup) {
        if (scrollXLoad && dragCol) {
          if (renderColumnList.length > 2) {
            const dCowRest = fullColumnIdData[dragCol.id];
            if (dCowRest) {
              const dcIndex = dCowRest._index;
              const firstCol = renderColumnList[0];
              const lastCol = renderColumnList[renderColumnList.length - 1];
              const firstColRest = fullColumnIdData[firstCol.id];
              const lastColRest = fullColumnIdData[lastCol.id];
              if (firstColRest && lastColRest) {
                const fcIndex = firstColRest._index;
                const lcIndex = lastColRest._index;
                if (dcIndex < fcIndex) {
                  renderColumnList = [dragCol].concat(renderColumnList);
                  renderHeaderList = [[dragCol].concat(renderHeaderList[0])].concat(renderHeaderList.slice(1));
                } else if (dcIndex > lcIndex) {
                  renderColumnList = renderColumnList.concat([dragCol]);
                  renderHeaderList = [renderHeaderList[0].concat([dragCol])].concat(renderHeaderList.slice(1));
                }
              }
            }
          }
        }
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-table--header-wrapper", fixedType ? `fixed-${fixedType}--wrapper` : "body--wrapper"],
        xid: xID
      }, [
        h("div", {
          ref: refHeaderScroll,
          class: "vxe-table--header-inner-wrapper",
          onScroll(evnt) {
            $xeTable.triggerHeaderScrollEvent(evnt, fixedType);
          }
        }, [
          fixedType ? renderEmptyElement2($xeTable) : h("div", {
            ref: refHeaderXSpace,
            class: "vxe-body--x-space"
          }),
          h("table", {
            ref: refHeaderTable,
            class: "vxe-table--header",
            xid: xID,
            cellspacing: 0,
            cellpadding: 0,
            border: 0,
            xvm: isOptimizeMode ? "1" : null
          }, [
            /**
             * 列宽
             */
            h("colgroup", {
              ref: refHeaderColgroup
            }, renderColumnList.map((column, $columnIndex) => {
              return h("col", {
                name: column.id,
                key: $columnIndex,
                style: {
                  width: `${column.renderWidth}px`
                }
              });
            })),
            /**
            * 头部
            */
            h("thead", {
              ref: refHeaderTHead
            }, renderHeads(isGroup, isOptimizeMode, renderHeaderList))
          ]),
          mouseConfig && mouseOpts.area ? h("div", {
            class: "vxe-table--cell-area"
          }, [
            h("span", {
              class: "vxe-table--cell-main-area"
            }),
            h("span", {
              class: "vxe-table--cell-copy-area"
            }),
            h("span", {
              class: "vxe-table--cell-extend-area"
            }),
            h("span", {
              class: "vxe-table--cell-multi-area"
            }),
            h("span", {
              class: "vxe-table--cell-active-area"
            }),
            h("span", {
              class: "vxe-table--cell-col-status-area"
            })
          ]) : renderEmptyElement2($xeTable)
        ])
      ]);
    };
    watch(() => props.tableColumn, uploadColumn);
    onMounted(() => {
      nextTick(() => {
        const { fixedType } = props;
        const { internalData } = $xeTable;
        const { elemStore } = internalData;
        const prefix = `${fixedType || "main"}-header-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}scroll`] = refHeaderScroll;
        elemStore[`${prefix}table`] = refHeaderTable;
        elemStore[`${prefix}colgroup`] = refHeaderColgroup;
        elemStore[`${prefix}list`] = refHeaderTHead;
        elemStore[`${prefix}xSpace`] = refHeaderXSpace;
        elemStore[`${prefix}repair`] = refHeaderBorderRepair;
        uploadColumn();
      });
    });
    onUnmounted(() => {
      const { fixedType } = props;
      const { internalData } = $xeTable;
      const { elemStore } = internalData;
      const prefix = `${fixedType || "main"}-header-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}scroll`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
      elemStore[`${prefix}repair`] = null;
    });
    return renderVN;
  }
});

// ../../node_modules/.pnpm/vxe-table@4.13.16_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-table/es/table/src/footer.js
var import_xe_utils3 = __toESM(require_xe_utils());
var { renderer: renderer3, renderEmptyElement: renderEmptyElement3 } = VxeUI;
var renderType3 = "footer";
var footer_default = defineComponent({
  name: "VxeTableFooter",
  props: {
    footerTableData: {
      type: Array,
      default: () => []
    },
    tableColumn: {
      type: Array,
      default: () => []
    },
    fixedColumn: {
      type: Array,
      default: () => []
    },
    fixedType: {
      type: String,
      default: null
    }
  },
  setup(props) {
    const $xeTable = inject("$xeTable", {});
    const { xID, props: tableProps, reactData: tableReactData, internalData: tableInternalData } = $xeTable;
    const { computeTooltipOpts, computeColumnOpts, computeColumnDragOpts, computeCellOpts, computeFooterCellOpts, computeDefaultRowHeight, computeResizableOpts, computeVirtualXOpts } = $xeTable.getComputeMaps();
    const refElem = ref();
    const refFooterScroll = ref();
    const refFooterTable = ref();
    const refFooterColgroup = ref();
    const refFooterTFoot = ref();
    const refFooterXSpace = ref();
    const renderRows = (isOptimizeMode, tableColumn, footerTableData, row, $rowIndex, _rowIndex) => {
      const $xeGrid = $xeTable.xeGrid;
      const { fixedType } = props;
      const { resizable: allResizable, border, footerCellClassName, footerCellStyle, footerAlign: allFooterAlign, footerSpanMethod, align: allAlign, columnKey, showFooterOverflow: allColumnFooterOverflow } = tableProps;
      const { scrollXLoad, scrollYLoad, overflowX, currentColumn } = tableReactData;
      const { fullColumnIdData, mergeFooterList, mergeFooterCellMaps, scrollXStore } = tableInternalData;
      const virtualXOpts = computeVirtualXOpts.value;
      const tooltipOpts = computeTooltipOpts.value;
      const resizableOpts = computeResizableOpts.value;
      const { isAllColumnDrag } = resizableOpts;
      const columnOpts = computeColumnOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const cellOpts = computeCellOpts.value;
      const footerCellOpts = computeFooterCellOpts.value;
      const currCellHeight = getCellHeight(footerCellOpts.height) || defaultRowHeight;
      return tableColumn.map((column, $columnIndex) => {
        const { type, showFooterOverflow, footerAlign, align, footerClassName, editRender, cellRender } = column;
        const colid = column.id;
        const colRest = fullColumnIdData[colid] || {};
        const renderOpts = editRender || cellRender;
        const compConf = renderOpts ? renderer3.get(renderOpts.name) : null;
        const showAllTip = tooltipOpts.showAll;
        const isColGroup = column.children && column.children.length;
        const fixedHiddenColumn = fixedType ? column.fixed !== fixedType && !isColGroup : column.fixed && overflowX;
        const isPadding = import_xe_utils3.default.isBoolean(footerCellOpts.padding) ? footerCellOpts.padding : cellOpts.padding;
        const footOverflow = import_xe_utils3.default.eqNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;
        const footAlign = footerAlign || (compConf ? compConf.tableFooterCellAlign : "") || allFooterAlign || align || (compConf ? compConf.tableCellAlign : "") || allAlign;
        const showEllipsis = footOverflow === "ellipsis";
        const showTitle = footOverflow === "title";
        const showTooltip = footOverflow === true || footOverflow === "tooltip";
        const hasEllipsis = showTitle || showTooltip || showEllipsis;
        const showResizable = import_xe_utils3.default.isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable;
        const attrs = { colid };
        const tfOns = {};
        const columnIndex = colRest.index;
        const _columnIndex = colRest._index;
        const itemIndex = _columnIndex;
        const cellParams = {
          $table: $xeTable,
          $grid: $xeGrid,
          row,
          rowIndex: _rowIndex,
          _rowIndex,
          $rowIndex,
          column,
          columnIndex,
          $columnIndex,
          _columnIndex,
          itemIndex,
          items: row,
          fixed: fixedType,
          type: renderType3,
          data: footerTableData
        };
        if (showTitle || showTooltip || showAllTip) {
          tfOns.onMouseenter = (evnt) => {
            if (showTitle) {
              updateCellTitle(evnt.currentTarget, column);
            } else if (showTooltip || showAllTip) {
              $xeTable.triggerFooterTooltipEvent(evnt, cellParams);
            }
          };
        }
        if (showTooltip || showAllTip) {
          tfOns.onMouseleave = (evnt) => {
            if (showTooltip || showAllTip) {
              $xeTable.handleTargetLeaveEvent(evnt);
            }
          };
        }
        tfOns.onClick = (evnt) => {
          $xeTable.dispatchEvent("footer-cell-click", Object.assign({ cell: evnt.currentTarget }, cellParams), evnt);
        };
        tfOns.onDblclick = (evnt) => {
          $xeTable.dispatchEvent("footer-cell-dblclick", Object.assign({ cell: evnt.currentTarget }, cellParams), evnt);
        };
        let isMergeCell = false;
        if (mergeFooterList.length) {
          const spanRest = mergeFooterCellMaps[`${_rowIndex}:${_columnIndex}`];
          if (spanRest) {
            const { rowspan, colspan } = spanRest;
            if (!rowspan || !colspan) {
              return null;
            }
            if (rowspan > 1) {
              isMergeCell = true;
              attrs.rowspan = rowspan;
            }
            if (colspan > 1) {
              isMergeCell = true;
              attrs.colspan = colspan;
            }
          }
        } else if (footerSpanMethod) {
          const { rowspan = 1, colspan = 1 } = footerSpanMethod(cellParams) || {};
          if (!rowspan || !colspan) {
            return null;
          }
          if (rowspan > 1) {
            attrs.rowspan = rowspan;
          }
          if (colspan > 1) {
            attrs.colspan = colspan;
          }
        }
        const isLastColumn = $columnIndex === tableColumn.length - 1;
        const isAutoCellWidth = !column.resizeWidth && (column.minWidth === "auto" || column.width === "auto");
        let isVNPreEmptyStatus = false;
        if (isOptimizeMode && !isMergeCell) {
          if (scrollXLoad && !column.fixed && !virtualXOpts.immediate && (_columnIndex < scrollXStore.visibleStartIndex - scrollXStore.preloadSize || _columnIndex > scrollXStore.visibleEndIndex + scrollXStore.preloadSize)) {
            isVNPreEmptyStatus = true;
          }
        }
        const tcStyle = {};
        if (hasEllipsis) {
          tcStyle.height = `${currCellHeight}px`;
        } else {
          tcStyle.minHeight = `${currCellHeight}px`;
        }
        return h("td", Object.assign(Object.assign(Object.assign(Object.assign({ class: ["vxe-footer--column", column.id, {
          [`col--${footAlign}`]: footAlign,
          [`col--${type}`]: type,
          "col--last": isLastColumn,
          "fixed--width": !isAutoCellWidth,
          "fixed--hidden": fixedHiddenColumn,
          "is--padding": isPadding,
          "col--ellipsis": hasEllipsis,
          "col--current": currentColumn === column
        }, getPropClass(footerClassName, cellParams), getPropClass(footerCellClassName, cellParams)] }, attrs), { style: footerCellStyle ? import_xe_utils3.default.isFunction(footerCellStyle) ? footerCellStyle(cellParams) : footerCellStyle : null }), tfOns), { key: columnKey || scrollXLoad || scrollYLoad || columnOpts.useKey || columnOpts.drag ? column.id : $columnIndex }), [
          h("div", {
            class: ["vxe-cell", {
              "c--title": showTitle,
              "c--tooltip": showTooltip,
              "c--ellipsis": showEllipsis
            }],
            style: tcStyle
          }, isVNPreEmptyStatus ? [] : [
            h("div", {
              colid,
              class: "vxe-cell--wrapper"
            }, column.renderFooter(cellParams))
          ]),
          /**
           * 列宽拖动
           */
          !fixedHiddenColumn && showResizable && isAllColumnDrag ? h("div", {
            class: ["vxe-cell--col-resizable", {
              "is--line": !border || border === "none"
            }],
            onMousedown: (evnt) => $xeTable.handleColResizeMousedownEvent(evnt, fixedType, cellParams),
            onDblclick: (evnt) => $xeTable.handleColResizeDblclickEvent(evnt, cellParams)
          }) : renderEmptyElement3($xeTable)
        ]);
      });
    };
    const renderHeads = (isOptimizeMode, renderColumnList) => {
      const { fixedType, footerTableData } = props;
      const { footerRowClassName, footerRowStyle } = tableProps;
      const { isColLoading, isDragColMove } = tableReactData;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      return footerTableData.map((row, $rowIndex) => {
        const _rowIndex = $rowIndex;
        const rowParams = { $table: $xeTable, row, _rowIndex, $rowIndex, fixed: fixedType, type: renderType3 };
        if (!isColLoading && columnOpts.drag && columnDragOpts.animation) {
          return h(TransitionGroup, {
            key: $rowIndex,
            name: `vxe-header--col-list${isDragColMove ? "" : "-disabled"}`,
            tag: "tr",
            class: [
              "vxe-footer--row",
              footerRowClassName ? import_xe_utils3.default.isFunction(footerRowClassName) ? footerRowClassName(rowParams) : footerRowClassName : ""
            ],
            style: footerRowStyle ? import_xe_utils3.default.isFunction(footerRowStyle) ? footerRowStyle(rowParams) : footerRowStyle : null
          }, {
            default: () => renderRows(isOptimizeMode, renderColumnList, footerTableData, row, $rowIndex, _rowIndex)
          });
        }
        return h("tr", {
          key: $rowIndex,
          class: [
            "vxe-footer--row",
            footerRowClassName ? import_xe_utils3.default.isFunction(footerRowClassName) ? footerRowClassName(rowParams) : footerRowClassName : ""
          ],
          style: footerRowStyle ? import_xe_utils3.default.isFunction(footerRowStyle) ? footerRowStyle(rowParams) : footerRowStyle : null
        }, renderRows(isOptimizeMode, renderColumnList, footerTableData, row, $rowIndex, _rowIndex));
      });
    };
    const renderVN = () => {
      const { fixedType, fixedColumn, tableColumn } = props;
      const { spanMethod, footerSpanMethod, showFooterOverflow: allColumnFooterOverflow } = tableProps;
      const { visibleColumn, fullColumnIdData } = tableInternalData;
      const { isGroup, isColLoading, overflowX, scrollXLoad, dragCol } = tableReactData;
      let renderColumnList = tableColumn;
      let isOptimizeMode = false;
      if (scrollXLoad && allColumnFooterOverflow) {
        if (spanMethod || footerSpanMethod) {
        } else {
          isOptimizeMode = true;
        }
      }
      if (!isOptimizeMode || !isColLoading && (fixedType || !overflowX)) {
        renderColumnList = visibleColumn;
      }
      if (fixedType) {
        if (isOptimizeMode) {
          renderColumnList = fixedColumn || [];
        }
      }
      if (!fixedType && !isGroup) {
        if (scrollXLoad && dragCol) {
          if (renderColumnList.length > 2) {
            const dCowRest = fullColumnIdData[dragCol.id];
            if (dCowRest) {
              const dcIndex = dCowRest._index;
              const firstCol = renderColumnList[0];
              const lastCol = renderColumnList[renderColumnList.length - 1];
              const firstColRest = fullColumnIdData[firstCol.id];
              const lastColRest = fullColumnIdData[lastCol.id];
              if (firstColRest && lastColRest) {
                const fcIndex = firstColRest._index;
                const lcIndex = lastColRest._index;
                if (dcIndex < fcIndex) {
                  renderColumnList = [dragCol].concat(renderColumnList);
                } else if (dcIndex > lcIndex) {
                  renderColumnList = renderColumnList.concat([dragCol]);
                }
              }
            }
          }
        }
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-table--footer-wrapper", fixedType ? `fixed-${fixedType}--wrapper` : "body--wrapper"],
        xid: xID
      }, [
        h("div", {
          ref: refFooterScroll,
          class: "vxe-table--footer-inner-wrapper",
          onScroll(evnt) {
            $xeTable.triggerFooterScrollEvent(evnt, fixedType);
          }
        }, [
          fixedType ? renderEmptyElement3($xeTable) : h("div", {
            ref: refFooterXSpace,
            class: "vxe-body--x-space"
          }),
          h("table", {
            ref: refFooterTable,
            class: "vxe-table--footer",
            xid: xID,
            cellspacing: 0,
            cellpadding: 0,
            border: 0,
            xvm: isOptimizeMode ? "1" : null
          }, [
            /**
            * 列宽
            */
            h("colgroup", {
              ref: refFooterColgroup
            }, renderColumnList.map((column, $columnIndex) => {
              return h("col", {
                name: column.id,
                key: $columnIndex,
                style: {
                  width: `${column.renderWidth}px`
                }
              });
            })),
            /**
            * 底部
            */
            h("tfoot", {
              ref: refFooterTFoot
            }, renderHeads(isOptimizeMode, renderColumnList))
          ])
        ])
      ]);
    };
    onMounted(() => {
      nextTick(() => {
        const { fixedType } = props;
        const { elemStore } = tableInternalData;
        const prefix = `${fixedType || "main"}-footer-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}scroll`] = refFooterScroll;
        elemStore[`${prefix}table`] = refFooterTable;
        elemStore[`${prefix}colgroup`] = refFooterColgroup;
        elemStore[`${prefix}list`] = refFooterTFoot;
        elemStore[`${prefix}xSpace`] = refFooterXSpace;
      });
    });
    onUnmounted(() => {
      const { fixedType } = props;
      const { elemStore } = tableInternalData;
      const prefix = `${fixedType || "main"}-footer-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}scroll`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
    });
    return renderVN;
  }
});

// ../../node_modules/.pnpm/vxe-table@4.13.16_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-table/es/table/src/props.js
var { getConfig } = VxeUI;
var props_default = {
  /** 基本属性 */
  id: [String, Function],
  // 数据
  data: Array,
  // 表格的高度
  height: [Number, String],
  // 表格的最小高度
  minHeight: {
    type: [Number, String],
    default: () => getConfig().table.minHeight
  },
  // 表格的最大高度
  maxHeight: [Number, String],
  // 已废弃，被 column-config.resizable 替换
  resizable: {
    type: Boolean,
    default: () => getConfig().table.resizable
  },
  // 是否带有斑马纹
  stripe: {
    type: Boolean,
    default: () => getConfig().table.stripe
  },
  // 是否带有边框
  border: {
    type: [Boolean, String],
    default: () => getConfig().table.border
  },
  // 已废弃，被 cell-config.padding 替换
  padding: {
    type: Boolean,
    default: null
  },
  // 是否圆角边框
  round: {
    type: Boolean,
    default: () => getConfig().table.round
  },
  // 表格的尺寸
  size: {
    type: String,
    default: () => getConfig().table.size || getConfig().size
  },
  // 列的宽度是否自撑开（可能会被废弃的参数，不要使用）
  fit: {
    type: Boolean,
    default: () => getConfig().table.fit
  },
  // 表格是否加载中
  loading: Boolean,
  // 所有的列对其方式
  align: {
    type: String,
    default: () => getConfig().table.align
  },
  // 所有的表头列的对齐方式
  headerAlign: {
    type: String,
    default: () => getConfig().table.headerAlign
  },
  // 所有的表尾列的对齐方式
  footerAlign: {
    type: String,
    default: () => getConfig().table.footerAlign
  },
  // 是否显示表头
  showHeader: {
    type: Boolean,
    default: () => getConfig().table.showHeader
  },
  // （即将废弃）是否要高亮当前选中行
  highlightCurrentRow: {
    type: Boolean,
    default: () => getConfig().table.highlightCurrentRow
  },
  // （即将废弃）鼠标移到行是否要高亮显示
  highlightHoverRow: {
    type: Boolean,
    default: () => getConfig().table.highlightHoverRow
  },
  /**
   * （即将废弃）是否要高亮当前选中列
   * @deprecated
   */
  highlightCurrentColumn: {
    type: Boolean,
    default: () => getConfig().table.highlightCurrentColumn
  },
  /**
   * （即将废弃）鼠标移到列是否要高亮显示
   * @deprecated
   */
  highlightHoverColumn: {
    type: Boolean,
    default: () => getConfig().table.highlightHoverColumn
  },
  // （即将废弃）激活单元格编辑时是否高亮显示
  highlightCell: Boolean,
  // 是否显示表尾合计
  showFooter: Boolean,
  // 表尾数据
  footerData: Array,
  // 表尾合计的计算方法
  footerMethod: Function,
  // 给行附加 className
  rowClassName: [String, Function],
  // 给单元格附加 className
  cellClassName: [String, Function],
  // 给表头的行附加 className
  headerRowClassName: [String, Function],
  // 给表头的单元格附加 className
  headerCellClassName: [String, Function],
  // 给表尾的行附加 className
  footerRowClassName: [String, Function],
  // 给表尾的单元格附加 className
  footerCellClassName: [String, Function],
  // 给单元格附加样式
  cellStyle: [Object, Function],
  // 给表头单元格附加样式
  headerCellStyle: [Object, Function],
  // 给表尾单元格附加样式
  footerCellStyle: [Object, Function],
  // 给行附加样式
  rowStyle: [Object, Function],
  // 给表头行附加样式
  headerRowStyle: [Object, Function],
  // 给表尾行附加样式
  footerRowStyle: [Object, Function],
  // 合并指定单元格
  mergeCells: Array,
  // 合并指定的表尾
  mergeFooterItems: Array,
  // 自定义合并行或列的方法
  spanMethod: Function,
  // 表尾合并行或列
  footerSpanMethod: Function,
  // 设置所有内容过长时显示为省略号
  showOverflow: {
    type: [Boolean, String],
    default: () => getConfig().table.showOverflow
  },
  // 设置表头所有内容过长时显示为省略号
  showHeaderOverflow: {
    type: [Boolean, String],
    default: () => getConfig().table.showHeaderOverflow
  },
  // 设置表尾所有内容过长时显示为省略号
  showFooterOverflow: {
    type: [Boolean, String],
    default: () => getConfig().table.showFooterOverflow
  },
  /** 高级属性 */
  // （即将废弃）columnKey 已废弃，被 column-config.useKey 替换
  columnKey: Boolean,
  // （即将废弃）rowKey 已废弃，被 row-config.useKey 替换
  rowKey: Boolean,
  // （即将废弃）rowId 已废弃，被 row-config.keyField 替换
  rowId: {
    type: String,
    default: () => getConfig().table.rowId
  },
  zIndex: Number,
  emptyText: {
    type: String,
    default: () => getConfig().table.emptyText
  },
  keepSource: {
    type: Boolean,
    default: () => getConfig().table.keepSource
  },
  // 是否自动监听父容器变化去更新响应式表格宽高
  autoResize: {
    type: Boolean,
    default: () => getConfig().table.autoResize
  },
  // 是否自动根据状态属性去更新响应式表格宽高
  syncResize: [Boolean, String, Number],
  // 响应式布局配置项
  resizeConfig: Object,
  // 列配置项
  columnConfig: Object,
  // 当前列配置项
  currentColumnConfig: Object,
  // 单元格配置项
  cellConfig: Object,
  // 表头单元格配置项
  headerCellConfig: Object,
  // 表尾单元格配置项
  footerCellConfig: Object,
  // 行配置项
  rowConfig: Object,
  // 行分组配置项
  rowGroupConfig: Object,
  // 当前行配置项
  currentRowConfig: Object,
  // 已废弃，被 rowDragConfig 替换
  dragConfig: Object,
  // 行拖拽排序配置项
  rowDragConfig: Object,
  // 列拖拽排序配置项
  columnDragConfig: Object,
  // 列调整配置项
  resizableConfig: Object,
  // 序号配置项
  seqConfig: Object,
  // 排序配置项
  sortConfig: Object,
  // 筛选配置项
  filterConfig: Object,
  // 单选框配置
  radioConfig: Object,
  // 复选框配置项
  checkboxConfig: Object,
  // tooltip 配置项
  tooltipConfig: Object,
  // 导出配置项
  exportConfig: Object,
  // 导入配置项
  importConfig: Object,
  // 打印配置项
  printConfig: Object,
  // 展开行配置项
  expandConfig: Object,
  // 树形结构配置项
  treeConfig: Object,
  // 快捷菜单配置项
  menuConfig: Object,
  // 鼠标配置项
  mouseConfig: Object,
  // 区域配置项
  areaConfig: Object,
  // 按键配置项
  keyboardConfig: Object,
  // 复制粘/贴配置项
  clipConfig: Object,
  // 查找/替换配置项
  fnrConfig: Object,
  // 编辑配置项
  editConfig: Object,
  // 校验配置项
  validConfig: Object,
  // 校验规则配置项
  editRules: Object,
  // 加载中配置项
  loadingConfig: Object,
  // 空内容渲染配置项
  emptyRender: Object,
  // 自定义列配置项
  customConfig: Object,
  // （即将废弃）横向虚拟滚动配置项
  scrollX: Object,
  // （即将废弃）纵向虚拟滚动配置项
  scrollY: Object,
  // 横向虚拟滚动配置项
  virtualXConfig: Object,
  // 纵向虚拟滚动配置项
  virtualYConfig: Object,
  // 滚动条配置项
  scrollbarConfig: Object,
  // （即将废弃）优化相关
  animat: {
    type: Boolean,
    default: () => getConfig().table.animat
  },
  // （可能会被废弃的参数，不要使用）
  delayHover: {
    type: Number,
    default: () => getConfig().table.delayHover
  },
  // 额外的参数
  params: Object
};

// ../../node_modules/.pnpm/vxe-table@4.13.16_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-table/es/table/src/emits.js
var emits_default = [
  "update:data",
  "keydown-start",
  "keydown",
  "keydown-end",
  "paste",
  "copy",
  "cut",
  "current-change",
  "current-row-change",
  "current-row-disabled",
  "current-column-change",
  "current-column-disabled",
  "radio-change",
  "checkbox-change",
  "checkbox-all",
  "checkbox-range-start",
  "checkbox-range-change",
  "checkbox-range-end",
  "checkbox-range-select",
  "cell-click",
  "cell-dblclick",
  "cell-menu",
  "cell-mouseenter",
  "cell-mouseleave",
  "cell-selected",
  "cell-delete-value",
  "cell-backspace-value",
  "header-cell-click",
  "header-cell-dblclick",
  "header-cell-menu",
  "footer-cell-click",
  "footer-cell-dblclick",
  "footer-cell-menu",
  "clear-merge",
  "sort-change",
  "clear-sort",
  "filter-change",
  "filter-visible",
  "clear-filter",
  "resizable-change",
  "column-resizable-change",
  "row-resizable-change",
  "toggle-row-group-expand",
  "toggle-row-expand",
  "toggle-tree-expand",
  "menu-click",
  "edit-closed",
  "row-dragstart",
  "row-dragover",
  "row-dragend",
  "column-dragstart",
  "column-dragover",
  "column-dragend",
  "enter-append-row",
  "edit-actived",
  "edit-activated",
  "edit-disabled",
  "valid-error",
  "scroll",
  "scroll-boundary",
  "custom",
  "change-fnr",
  "open-fnr",
  "show-fnr",
  "hide-fnr",
  "fnr-change",
  "fnr-find",
  "fnr-find-all",
  "fnr-replace",
  "fnr-replace-all",
  "cell-area-copy",
  "cell-area-cut",
  "cell-area-paste",
  "cell-area-merge",
  "clear-cell-area-selection",
  "clear-cell-area-merge",
  "header-cell-area-selection",
  "cell-area-selection-invalid",
  "cell-area-selection-start",
  "cell-area-selection-drag",
  "cell-area-selection-end",
  "cell-area-extension-start",
  "cell-area-extension-drag",
  "cell-area-extension-end",
  "cell-area-selection-all-start",
  "cell-area-selection-all-end",
  "cell-area-arrows-start",
  "cell-area-arrows-end",
  "active-cell-change-start",
  "active-cell-change-end"
];

// ../../node_modules/.pnpm/vxe-table@4.13.16_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-table/es/table/module/custom/panel.js
var import_xe_utils4 = __toESM(require_xe_utils());
var { getI18n: getI18n2, getIcon, renderEmptyElement: renderEmptyElement4 } = VxeUI;
var panel_default = defineComponent({
  name: "TableCustomPanel",
  props: {
    customStore: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props) {
    const VxeUIModalComponent = VxeUI.getComponent("VxeModal");
    const VxeUIDrawerComponent = VxeUI.getComponent("VxeDrawer");
    const VxeUIButtonComponent = VxeUI.getComponent("VxeButton");
    const VxeUINumberInputComponent = VxeUI.getComponent("VxeNumberInput");
    const VxeUIRadioGroupComponent = VxeUI.getComponent("VxeRadioGroup");
    const $xeTable = inject("$xeTable", {});
    const { props: tableProps, reactData, internalData } = $xeTable;
    const { computeCustomOpts, computeColumnDragOpts, computeColumnOpts, computeIsMaxFixedColumn, computeResizableOpts } = $xeTable.getComputeMaps();
    const refElem = ref();
    const bodyElemRef = ref();
    const refDragLineElem = ref();
    const refDragTipElem = ref();
    const dragColumnRef = ref();
    let prevDragCol;
    let prevDragToChild = false;
    let prevDragPos;
    const handleWrapperMouseenterEvent = (evnt) => {
      const { customStore } = props;
      customStore.activeWrapper = true;
      $xeTable.customOpenEvent(evnt);
    };
    const handleWrapperMouseleaveEvent = (evnt) => {
      const { customStore } = props;
      customStore.activeWrapper = false;
      setTimeout(() => {
        if (!customStore.activeBtn && !customStore.activeWrapper) {
          $xeTable.customCloseEvent(evnt);
        }
      }, 300);
    };
    const confirmCustomEvent = ({ $event }) => {
      reactData.isCustomStatus = true;
      $xeTable.saveCustom();
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent("confirm", $event);
    };
    const cancelCloseEvent = ({ $event }) => {
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent("close", $event);
    };
    const cancelCustomEvent = ({ $event }) => {
      $xeTable.cancelCustom();
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent("cancel", $event);
    };
    const handleResetCustomEvent = (evnt) => {
      $xeTable.resetCustom(true);
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent("reset", evnt);
    };
    const resetCustomEvent = ({ $event }) => {
      if (VxeUI.modal) {
        VxeUI.modal.confirm({
          content: getI18n2("vxe.custom.cstmConfirmRestore"),
          className: "vxe-table--ignore-clear",
          escClosable: true
        }).then((type) => {
          if (type === "confirm") {
            handleResetCustomEvent($event);
          }
        });
      } else {
        handleResetCustomEvent($event);
      }
    };
    const handleOptionCheck = (column) => {
      const { customColumnList } = reactData;
      const matchObj = import_xe_utils4.default.findTree(customColumnList, (item) => item === column);
      if (matchObj && matchObj.parent) {
        const { parent } = matchObj;
        if (parent.children && parent.children.length) {
          parent.renderVisible = parent.children.every((column2) => column2.renderVisible);
          parent.halfVisible = !parent.renderVisible && parent.children.some((column2) => column2.renderVisible || column2.halfVisible);
          handleOptionCheck(parent);
        }
      }
    };
    const changeCheckboxOption = (column) => {
      const isChecked = !column.renderVisible;
      const customOpts = computeCustomOpts.value;
      if (customOpts.immediate) {
        import_xe_utils4.default.eachTree([column], (item) => {
          item.visible = isChecked;
          item.renderVisible = isChecked;
          item.halfVisible = false;
        });
        reactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore("update:visible");
      } else {
        import_xe_utils4.default.eachTree([column], (item) => {
          item.renderVisible = isChecked;
          item.halfVisible = false;
        });
      }
      handleOptionCheck(column);
      $xeTable.checkCustomStatus();
    };
    const changeColumnWidth = (column) => {
      const customOpts = computeCustomOpts.value;
      if (customOpts.immediate) {
        if (column.renderResizeWidth !== column.renderWidth) {
          column.resizeWidth = column.renderResizeWidth;
          column.renderWidth = column.renderResizeWidth;
          reactData.isCustomStatus = true;
          $xeTable.handleCustom();
          $xeTable.saveCustomStore("update:width");
        }
      }
    };
    const changeFixedOption = (column, colFixed) => {
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const customOpts = computeCustomOpts.value;
      if (customOpts.immediate) {
        if (column.renderFixed === colFixed) {
          import_xe_utils4.default.eachTree([column], (col) => {
            col.fixed = "";
            col.renderFixed = "";
          });
        } else {
          if (!isMaxFixedColumn || column.renderFixed) {
            import_xe_utils4.default.eachTree([column], (col) => {
              col.fixed = colFixed;
              col.renderFixed = colFixed;
            });
          }
        }
        reactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore("update:fixed");
      } else {
        if (column.renderFixed === colFixed) {
          import_xe_utils4.default.eachTree([column], (col) => {
            col.renderFixed = "";
          });
        } else {
          if (!isMaxFixedColumn || column.renderFixed) {
            import_xe_utils4.default.eachTree([column], (col) => {
              col.renderFixed = colFixed;
            });
          }
        }
      }
    };
    const allOptionEvent = () => {
      $xeTable.toggleCustomAllCheckbox();
    };
    const showDropTip = (evnt, optEl, showLine, dragPos) => {
      const el = bodyElemRef.value;
      if (!el) {
        return;
      }
      const wrapperRect = el.getBoundingClientRect();
      if (optEl) {
        const dragLineEl = refDragLineElem.value;
        if (dragLineEl) {
          if (showLine) {
            const optRect = optEl.getBoundingClientRect();
            dragLineEl.style.display = "block";
            dragLineEl.style.top = `${Math.max(1, optRect.y + el.scrollTop - wrapperRect.y)}px`;
            dragLineEl.style.height = `${optRect.height}px`;
            dragLineEl.style.width = `${optRect.width}px`;
            dragLineEl.setAttribute("drag-pos", dragPos);
            dragLineEl.setAttribute("drag-to-child", prevDragToChild ? "y" : "n");
          } else {
            dragLineEl.style.display = "";
          }
        }
      }
      const dragTipEl = refDragTipElem.value;
      if (dragTipEl) {
        dragTipEl.style.display = "block";
        dragTipEl.style.top = `${Math.min(el.clientHeight + el.scrollTop - dragTipEl.clientHeight, evnt.clientY + el.scrollTop - wrapperRect.y)}px`;
        dragTipEl.style.left = `${Math.min(el.clientWidth + el.scrollLeft - dragTipEl.clientWidth, evnt.clientX + el.scrollLeft - wrapperRect.x)}px`;
        dragTipEl.setAttribute("drag-status", showLine ? prevDragToChild ? "sub" : "normal" : "disabled");
      }
    };
    const hideDropTip = () => {
      const dragTipEl = refDragTipElem.value;
      const dragLineEl = refDragLineElem.value;
      if (dragTipEl) {
        dragTipEl.style.display = "";
      }
      if (dragLineEl) {
        dragLineEl.style.display = "";
      }
    };
    const sortMousedownEvent = (evnt) => {
      const btnEl = evnt.currentTarget;
      const cellEl = btnEl.parentElement;
      const tdEl = cellEl.parentElement;
      const trEl = tdEl.parentElement;
      const colid = trEl.getAttribute("colid");
      const column = $xeTable.getColumnById(colid);
      trEl.draggable = true;
      dragColumnRef.value = column;
      addClass(trEl, "active--drag-origin");
    };
    const sortMouseupEvent = (evnt) => {
      const btnEl = evnt.currentTarget;
      const cellEl = btnEl.parentElement;
      const tdEl = cellEl.parentElement;
      const trEl = tdEl.parentElement;
      hideDropTip();
      trEl.draggable = false;
      dragColumnRef.value = null;
      removeClass(trEl, "active--drag-origin");
    };
    const sortDragstartEvent = (evnt) => {
      if (evnt.dataTransfer) {
        evnt.dataTransfer.setDragImage(getTpImg(), 0, 0);
      }
    };
    const sortDragendEvent = (evnt) => {
      const { mouseConfig } = tableProps;
      const { customColumnList } = reactData;
      const { collectColumn } = internalData;
      const customOpts = computeCustomOpts.value;
      const { immediate } = customOpts;
      const trEl = evnt.currentTarget;
      const dragCol = dragColumnRef.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const { isCrossDrag, isSelfToChildDrag, isToChildDrag, dragEndMethod } = columnDragOpts;
      const dragOffsetIndex = prevDragPos === "bottom" ? 1 : 0;
      if (prevDragCol && dragCol) {
        if (prevDragCol !== dragCol) {
          const dragColumn = dragCol;
          const newColumn = prevDragCol;
          Promise.resolve(dragEndMethod ? dragEndMethod({
            oldColumn: dragColumn,
            newColumn,
            dragColumn,
            dragPos: prevDragPos,
            dragToChild: !!prevDragToChild,
            offsetIndex: dragOffsetIndex
          }) : true).then((status) => {
            if (!status) {
              return;
            }
            let oafIndex = -1;
            let nafIndex = -1;
            const oldAllMaps = {};
            import_xe_utils4.default.eachTree([dragColumn], (column) => {
              oldAllMaps[column.id] = column;
            });
            let isSelfToChildStatus = false;
            if (immediate) {
              if (dragColumn.parentId && newColumn.parentId) {
                if (!isCrossDrag) {
                  return;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!(isCrossDrag && isSelfToChildDrag)) {
                    if (VxeUI.modal) {
                      VxeUI.modal.message({
                        status: "error",
                        content: getI18n2("vxe.error.treeDragChild")
                      });
                    }
                    return;
                  }
                }
              } else if (dragColumn.parentId) {
                if (!isCrossDrag) {
                  return;
                }
              } else if (newColumn.parentId) {
                if (!isCrossDrag) {
                  return;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!(isCrossDrag && isSelfToChildDrag)) {
                    if (VxeUI.modal) {
                      VxeUI.modal.message({
                        status: "error",
                        content: getI18n2("vxe.error.treeDragChild")
                      });
                    }
                    return;
                  }
                }
              } else {
              }
              const oldewMatchRest = import_xe_utils4.default.findTree(collectColumn, (item) => item.id === dragColumn.id);
              if (isSelfToChildStatus && (isCrossDrag && isSelfToChildDrag)) {
                if (oldewMatchRest) {
                  const { items: oCols, index: oIndex } = oldewMatchRest;
                  const childList = dragColumn.children || [];
                  childList.forEach((column) => {
                    column.parentId = dragColumn.parentId;
                  });
                  oCols.splice(oIndex, 1, ...childList);
                  dragColumn.children = [];
                }
              } else {
                if (oldewMatchRest) {
                  const { items: oCols, index: oIndex, parent: oParent } = oldewMatchRest;
                  oCols.splice(oIndex, 1);
                  if (!oParent) {
                    oafIndex = oIndex;
                  }
                }
              }
              const newMatchRest = import_xe_utils4.default.findTree(collectColumn, (item) => item.id === newColumn.id);
              if (newMatchRest) {
                const { items: nCols, index: nIndex, parent: nParent } = newMatchRest;
                if (isCrossDrag && isToChildDrag && prevDragToChild) {
                  dragColumn.parentId = newColumn.id;
                  newColumn.children = (newColumn.children || []).concat([dragColumn]);
                } else {
                  dragColumn.parentId = newColumn.parentId;
                  nCols.splice(nIndex + dragOffsetIndex, 0, dragColumn);
                }
                if (!nParent) {
                  nafIndex = nIndex;
                }
              }
              import_xe_utils4.default.eachTree(collectColumn, (column, index, items, path, parent) => {
                if (!parent) {
                  const sortIndex = index + 1;
                  column.renderSortNumber = sortIndex;
                }
              });
            } else {
              oafIndex = import_xe_utils4.default.findIndexOf(customColumnList, (item) => item.id === dragColumn.id);
              customColumnList.splice(oafIndex, 1);
              nafIndex = import_xe_utils4.default.findIndexOf(customColumnList, (item) => item.id === newColumn.id);
              customColumnList.splice(nafIndex + dragOffsetIndex, 0, dragColumn);
            }
            reactData.isDragColMove = true;
            if (mouseConfig) {
              if ($xeTable.clearSelected) {
                $xeTable.clearSelected();
              }
              if ($xeTable.clearCellAreas) {
                $xeTable.clearCellAreas();
                $xeTable.clearCopyCellArea();
              }
            }
            $xeTable.dispatchEvent("column-dragend", {
              oldColumn: dragColumn,
              newColumn,
              dragColumn,
              dragPos: prevDragPos,
              offsetIndex: dragOffsetIndex,
              _index: {
                newIndex: nafIndex,
                oldIndex: oafIndex
              }
            }, evnt);
            if (immediate) {
              reactData.customColumnList = collectColumn.slice(0);
              $xeTable.handleColDragSwapColumn();
            }
          }).catch(() => {
          });
        }
      }
      hideDropTip();
      dragColumnRef.value = null;
      trEl.draggable = false;
      trEl.removeAttribute("drag-pos");
      removeClass(trEl, "active--drag-target");
      removeClass(trEl, "active--drag-origin");
    };
    const sortDragoverEvent = (evnt) => {
      const customOpts = computeCustomOpts.value;
      const { immediate } = customOpts;
      const columnDragOpts = computeColumnDragOpts.value;
      const { isCrossDrag, isToChildDrag } = columnDragOpts;
      const optEl = evnt.currentTarget;
      const isControlKey = hasControlKey(evnt);
      const colid = optEl.getAttribute("colid");
      const column = $xeTable.getColumnById(colid);
      const dragCol = dragColumnRef.value;
      if (column && (isCrossDrag || column.level === 1)) {
        evnt.preventDefault();
        const offsetY = evnt.clientY - optEl.getBoundingClientRect().y;
        const dragPos = offsetY < optEl.clientHeight / 2 ? "top" : "bottom";
        if (dragCol && dragCol.id === column.id || !isCrossDrag && column.level > 1 || !immediate && column.level > 1 || column.renderFixed) {
          showDropTip(evnt, optEl, false, dragPos);
          return;
        }
        prevDragToChild = !!(isCrossDrag && isToChildDrag && isControlKey && immediate);
        prevDragCol = column;
        prevDragPos = dragPos;
        showDropTip(evnt, optEl, true, dragPos);
      }
    };
    const renderDragTip = () => {
      const dragCol = dragColumnRef.value;
      const columnDragOpts = computeColumnDragOpts.value;
      return h("div", {}, [
        h("div", {
          ref: refDragLineElem,
          class: ["vxe-table-custom-popup--drag-line", {
            "is--guides": columnDragOpts.showGuidesStatus
          }]
        }),
        h("div", {
          ref: refDragTipElem,
          class: "vxe-table-custom-popup--drag-tip"
        }, [
          h("div", {
            class: "vxe-table-custom-popup--drag-tip-wrapper"
          }, [
            h("div", {
              class: "vxe-table-custom-popup--drag-tip-status"
            }, [
              h("span", {
                class: ["vxe-table-custom-popup--drag-tip-normal-status", getIcon().TABLE_DRAG_STATUS_ROW]
              }),
              h("span", {
                class: ["vxe-table-custom-popup--drag-tip-sub-status", getIcon().TABLE_DRAG_STATUS_SUB_ROW]
              }),
              h("span", {
                class: ["vxe-table-custom-popup--drag-tip-disabled-status", getIcon().TABLE_DRAG_DISABLED]
              })
            ]),
            h("div", {
              class: "vxe-table-custom-popup--drag-tip-content"
            }, getI18n2("vxe.custom.cstmDragTarget", [dragCol && dragCol.type !== "html" ? dragCol.getTitle() : ""]))
          ])
        ])
      ]);
    };
    const renderSimplePanel = () => {
      const $xeGrid = $xeTable.xeGrid;
      const { customStore } = props;
      const { isCustomStatus, customColumnList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { immediate } = customOpts;
      const columnDragOpts = computeColumnDragOpts.value;
      const { maxHeight } = customStore;
      const { checkMethod, visibleMethod, allowVisible, allowSort, allowFixed, trigger, placement } = customOpts;
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const { isCrossDrag } = columnDragOpts;
      const slots = customOpts.slots || {};
      const headerSlot = slots.header;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const colVNs = [];
      const customWrapperOns = {};
      const isAllChecked = customStore.isAll;
      const isAllIndeterminate = customStore.isIndeterminate;
      if (trigger === "hover") {
        customWrapperOns.onMouseenter = handleWrapperMouseenterEvent;
        customWrapperOns.onMouseleave = handleWrapperMouseleaveEvent;
      }
      const params = {
        $table: $xeTable,
        $grid: $xeGrid,
        columns: customColumnList,
        isAllChecked,
        isAllIndeterminate,
        isCustomStatus
      };
      import_xe_utils4.default.eachTree(customColumnList, (column, index, items, path, parent) => {
        const isVisible = visibleMethod ? visibleMethod({ $table: $xeTable, column }) : true;
        if (isVisible) {
          const isChecked = column.renderVisible;
          const isIndeterminate = column.halfVisible;
          const isColGroup = column.children && column.children.length;
          const colTitle = formatText(column.getTitle(), 1);
          const isDisabled = checkMethod ? !checkMethod({ $table: $xeTable, column }) : false;
          const isHidden = !isChecked;
          colVNs.push(h("li", {
            key: column.id,
            colid: column.id,
            class: ["vxe-table-custom--option", `level--${column.level}`, {
              "is--hidden": isDisabled || isHidden,
              "is--group": isColGroup
            }],
            onDragstart: sortDragstartEvent,
            onDragend: sortDragendEvent,
            onDragover: sortDragoverEvent
          }, [
            allowVisible ? h("div", {
              class: ["vxe-table-custom--checkbox-option", {
                "is--checked": isChecked,
                "is--indeterminate": isIndeterminate,
                "is--disabled": isDisabled
              }],
              title: getI18n2("vxe.custom.setting.colVisible"),
              onClick: () => {
                if (!isDisabled) {
                  changeCheckboxOption(column);
                }
              }
            }, [
              h("span", {
                class: ["vxe-checkbox--icon", isIndeterminate ? getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon().TABLE_CHECKBOX_CHECKED : getIcon().TABLE_CHECKBOX_UNCHECKED]
              })
            ]) : createCommentVNode(),
            h("div", {
              class: "vxe-table-custom--name-option"
            }, [
              allowSort && ((isCrossDrag ? immediate : false) || column.level === 1) ? h("div", {
                class: "vxe-table-custom--sort-option"
              }, [
                h("span", Object.assign({ class: ["vxe-table-custom--sort-btn", {
                  "is--disabled": isDisabled || isHidden || column.renderFixed
                }], title: getI18n2("vxe.custom.setting.sortHelpTip") }, isDisabled || isHidden || column.renderFixed ? {} : {
                  onMousedown: sortMousedownEvent,
                  onMouseup: sortMouseupEvent
                }), [
                  h("i", {
                    class: getIcon().TABLE_CUSTOM_SORT
                  })
                ])
              ]) : createCommentVNode(),
              column.type === "html" ? h("div", {
                key: "1",
                class: "vxe-table-custom--checkbox-label",
                innerHTML: colTitle
              }) : h("div", {
                key: "0",
                class: "vxe-table-custom--checkbox-label"
              }, colTitle)
            ]),
            !parent && allowFixed ? h("div", {
              class: "vxe-table-custom--fixed-option"
            }, [
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                mode: "text",
                icon: column.renderFixed === "left" ? getIcon().TOOLBAR_TOOLS_FIXED_LEFT_ACTIVE : getIcon().TOOLBAR_TOOLS_FIXED_LEFT,
                status: column.renderFixed === "left" ? "primary" : "",
                disabled: isDisabled || isHidden || isMaxFixedColumn && !column.renderFixed,
                title: getI18n2(column.renderFixed === "left" ? "vxe.toolbar.cancelFixed" : "vxe.toolbar.fixedLeft"),
                onClick: () => {
                  changeFixedOption(column, "left");
                }
              }) : createCommentVNode(),
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                mode: "text",
                icon: column.renderFixed === "right" ? getIcon().TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVE : getIcon().TOOLBAR_TOOLS_FIXED_RIGHT,
                status: column.renderFixed === "right" ? "primary" : "",
                disabled: isDisabled || isHidden || isMaxFixedColumn && !column.renderFixed,
                title: getI18n2(column.renderFixed === "right" ? "vxe.toolbar.cancelFixed" : "vxe.toolbar.fixedRight"),
                onClick: () => {
                  changeFixedOption(column, "right");
                }
              }) : createCommentVNode()
            ]) : createCommentVNode()
          ]));
        }
      });
      return h("div", {
        ref: refElem,
        key: "simple",
        class: ["vxe-table-custom-wrapper", `placement--${placement}`, {
          "is--active": customStore.visible
        }],
        style: maxHeight && !["left", "right"].includes(placement) ? {
          maxHeight: `${maxHeight}px`
        } : {}
      }, customStore.visible ? [
        h("div", {
          class: "vxe-table-custom--header"
        }, headerSlot ? $xeTable.callSlot(headerSlot, params) : [
          h("ul", {
            class: "vxe-table-custom--panel-list"
          }, [
            h("li", {
              class: "vxe-table-custom--option"
            }, [
              allowVisible ? h("div", {
                class: ["vxe-table-custom--checkbox-option", {
                  "is--checked": isAllChecked,
                  "is--indeterminate": isAllIndeterminate
                }],
                title: getI18n2("vxe.table.allTitle"),
                onClick: allOptionEvent
              }, [
                h("span", {
                  class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? getIcon().TABLE_CHECKBOX_CHECKED : getIcon().TABLE_CHECKBOX_UNCHECKED]
                }),
                h("span", {
                  class: "vxe-checkbox--label"
                }, getI18n2("vxe.toolbar.customAll"))
              ]) : h("span", {
                class: "vxe-checkbox--label"
              }, getI18n2("vxe.table.customTitle"))
            ])
          ])
        ]),
        h("div", {
          ref: bodyElemRef,
          class: "vxe-table-custom--body"
        }, [
          topSlot ? h("div", {
            class: "vxe-table-custom--panel-top"
          }, $xeTable.callSlot(topSlot, params)) : renderEmptyElement4($xeTable),
          defaultSlot ? h("div", {
            class: "vxe-table-custom--panel-body"
          }, $xeTable.callSlot(defaultSlot, params)) : h(TransitionGroup, Object.assign({ class: "vxe-table-custom--panel-list", name: "vxe-table-custom--list", tag: "ul" }, customWrapperOns), {
            default: () => colVNs
          }),
          bottomSlot ? h("div", {
            class: "vxe-table-custom--panel-bottom"
          }, $xeTable.callSlot(bottomSlot, params)) : renderEmptyElement4($xeTable),
          renderDragTip()
        ]),
        customOpts.showFooter ? h("div", {
          class: "vxe-table-custom--footer"
        }, footerSlot ? $xeTable.callSlot(footerSlot, params) : [
          h("div", {
            class: "vxe-table-custom--footer-buttons"
          }, [
            VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              mode: "text",
              content: customOpts.resetButtonText || getI18n2("vxe.table.customRestore"),
              disabled: !isCustomStatus,
              onClick: resetCustomEvent
            }) : createCommentVNode(),
            immediate ? VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              mode: "text",
              content: customOpts.closeButtonText || getI18n2("vxe.table.customClose"),
              onClick: cancelCloseEvent
            }) : createCommentVNode() : VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              mode: "text",
              content: customOpts.cancelButtonText || getI18n2("vxe.table.customCancel"),
              onClick: cancelCustomEvent
            }) : createCommentVNode(),
            immediate ? createCommentVNode() : VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              mode: "text",
              status: "primary",
              content: customOpts.confirmButtonText || getI18n2("vxe.table.customConfirm"),
              onClick: confirmCustomEvent
            }) : createCommentVNode()
          ])
        ]) : null
      ] : []);
    };
    const renderPopupPanel = () => {
      const $xeGrid = $xeTable.xeGrid;
      const { customStore } = props;
      const { resizable: allResizable } = tableProps;
      const { isCustomStatus, customColumnList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { immediate } = customOpts;
      const columnDragOpts = computeColumnDragOpts.value;
      const { mode, modalOptions, drawerOptions, allowVisible, allowSort, allowFixed, allowResizable, checkMethod, visibleMethod } = customOpts;
      const columnOpts = computeColumnOpts.value;
      const { maxFixedSize } = columnOpts;
      const resizableOpts = computeResizableOpts.value;
      const { minWidth: reMinWidth, maxWidth: reMaxWidth } = resizableOpts;
      const modalOpts = Object.assign({}, modalOptions);
      const drawerOpts = Object.assign({}, drawerOptions);
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const { isCrossDrag } = columnDragOpts;
      const slots = customOpts.slots || {};
      const headerSlot = slots.header;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const trVNs = [];
      const isAllChecked = customStore.isAll;
      const isAllIndeterminate = customStore.isIndeterminate;
      const params = {
        $table: $xeTable,
        $grid: $xeGrid,
        columns: customColumnList,
        isAllChecked,
        isAllIndeterminate,
        isCustomStatus
      };
      import_xe_utils4.default.eachTree(customColumnList, (column, index, items, path, parent) => {
        const isVisible = visibleMethod ? visibleMethod({ $table: $xeTable, column }) : true;
        if (isVisible) {
          let customMinWidth = 0;
          let customMaxWidth = 0;
          if (allowResizable) {
            const resizeParams = {
              $table: $xeTable,
              column,
              columnIndex: index,
              $columnIndex: index,
              $rowIndex: -1
            };
            if (reMinWidth) {
              customMinWidth = import_xe_utils4.default.toNumber(import_xe_utils4.default.isFunction(reMinWidth) ? reMinWidth(resizeParams) : reMinWidth);
            }
            if (reMaxWidth) {
              customMaxWidth = import_xe_utils4.default.toNumber(import_xe_utils4.default.isFunction(reMaxWidth) ? reMaxWidth(resizeParams) : reMaxWidth);
            }
          }
          const isChecked = column.renderVisible;
          const isIndeterminate = column.halfVisible;
          const colTitle = formatText(column.getTitle(), 1);
          const isColGroup = column.children && column.children.length;
          const isDisabled = checkMethod ? !checkMethod({ $table: $xeTable, column }) : false;
          const isHidden = !isChecked;
          trVNs.push(h("tr", {
            key: column.id,
            colid: column.id,
            class: [`vxe-table-custom-popup--row level--${column.level}`, {
              "is--group": isColGroup
            }],
            onDragstart: sortDragstartEvent,
            onDragend: sortDragendEvent,
            onDragover: sortDragoverEvent
          }, [
            allowVisible ? h("td", {
              class: "vxe-table-custom-popup--column-item col--visible"
            }, [
              h("div", {
                class: ["vxe-table-custom--checkbox-option", {
                  "is--checked": isChecked,
                  "is--indeterminate": isIndeterminate,
                  "is--disabled": isDisabled
                }],
                title: getI18n2("vxe.custom.setting.colVisible"),
                onClick: () => {
                  if (!isDisabled) {
                    changeCheckboxOption(column);
                  }
                }
              }, [
                h("span", {
                  class: ["vxe-checkbox--icon", isIndeterminate ? getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon().TABLE_CHECKBOX_CHECKED : getIcon().TABLE_CHECKBOX_UNCHECKED]
                })
              ])
            ]) : createCommentVNode(),
            h("td", {
              class: "vxe-table-custom-popup--column-item col--name"
            }, [
              h("div", {
                class: "vxe-table-custom-popup--name"
              }, [
                allowSort ? (isCrossDrag ? immediate : false) || column.level === 1 ? h("div", Object.assign({ class: ["vxe-table-custom-popup--column-sort-btn", {
                  "is--disabled": isDisabled || isHidden || column.renderFixed
                }], title: getI18n2("vxe.custom.setting.sortHelpTip") }, isDisabled || isHidden || column.renderFixed ? {} : {
                  onMousedown: sortMousedownEvent,
                  onMouseup: sortMouseupEvent
                }), [
                  h("i", {
                    class: getIcon().TABLE_CUSTOM_SORT
                  })
                ]) : h("div", {
                  class: "vxe-table-custom-popup--column-sort-placeholder"
                }) : createCommentVNode(),
                column.type === "html" ? h("div", {
                  key: "1",
                  class: "vxe-table-custom-popup--title",
                  innerHTML: colTitle
                }) : h("div", {
                  key: "0",
                  class: "vxe-table-custom-popup--title",
                  title: colTitle
                }, colTitle)
              ])
            ]),
            allowResizable ? h("td", {
              class: "vxe-table-custom-popup--column-item col--resizable"
            }, [
              column.children && column.children.length || !(import_xe_utils4.default.isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable) ? h("span", "-") : VxeUINumberInputComponent ? h(VxeUINumberInputComponent, {
                type: "integer",
                immediate: false,
                disabled: isDisabled || isHidden,
                modelValue: column.renderResizeWidth,
                min: customMinWidth || void 0,
                max: customMaxWidth || void 0,
                "onUpdate:modelValue"(value) {
                  const width = Math.max(0, Number(value));
                  column.renderResizeWidth = width;
                },
                onChange() {
                  changeColumnWidth(column);
                }
              }) : createCommentVNode()
            ]) : createCommentVNode(),
            allowFixed ? h("td", {
              class: "vxe-table-custom-popup--column-item col--fixed"
            }, [
              parent ? h("span", "-") : VxeUIRadioGroupComponent ? h(VxeUIRadioGroupComponent, {
                modelValue: column.renderFixed || "",
                type: "button",
                size: "mini",
                disabled: isDisabled || isHidden,
                options: [
                  { label: getI18n2("vxe.custom.setting.fixedLeft"), value: "left", disabled: isDisabled || isHidden || isMaxFixedColumn },
                  { label: getI18n2("vxe.custom.setting.fixedUnset"), value: "", disabled: isDisabled || isHidden },
                  { label: getI18n2("vxe.custom.setting.fixedRight"), value: "right", disabled: isDisabled || isHidden || isMaxFixedColumn }
                ],
                "onUpdate:modelValue"(value) {
                  changeFixedOption(column, value);
                }
              }) : createCommentVNode()
            ]) : createCommentVNode()
          ]));
        }
      });
      const scopedSlots = {
        default: () => {
          if (defaultSlot) {
            return $xeTable.callSlot(defaultSlot, params);
          }
          return h("div", {
            ref: bodyElemRef,
            class: "vxe-table-custom-popup--body"
          }, [
            topSlot ? h("div", {
              class: "vxe-table-custom-popup--table-top"
            }, $xeTable.callSlot(topSlot, params)) : renderEmptyElement4($xeTable),
            h("div", {
              class: "vxe-table-custom-popup--table-wrapper"
            }, [
              h("table", {}, [
                h("colgroup", {}, [
                  allowVisible ? h("col", {
                    class: "vxe-table-custom-popup--table-col-seq"
                  }) : createCommentVNode(),
                  h("col", {
                    class: "vxe-table-custom-popup--table-col-title"
                  }),
                  allowResizable ? h("col", {
                    class: "vxe-table-custom-popup--table-col-width"
                  }) : createCommentVNode(),
                  allowFixed ? h("col", {
                    class: "vxe-table-custom-popup--table-col-fixed"
                  }) : createCommentVNode()
                ]),
                h("thead", {}, [
                  h("tr", {}, [
                    allowVisible ? h("th", {}, [
                      h("div", {
                        class: ["vxe-table-custom--checkbox-option", {
                          "is--checked": isAllChecked,
                          "is--indeterminate": isAllIndeterminate
                        }],
                        title: getI18n2("vxe.table.allTitle"),
                        onClick: allOptionEvent
                      }, [
                        h("span", {
                          class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? getIcon().TABLE_CHECKBOX_CHECKED : getIcon().TABLE_CHECKBOX_UNCHECKED]
                        }),
                        h("span", {
                          class: "vxe-checkbox--label"
                        }, getI18n2("vxe.toolbar.customAll"))
                      ])
                    ]) : createCommentVNode(),
                    h("th", {}, getI18n2("vxe.custom.setting.colTitle")),
                    allowResizable ? h("th", {}, getI18n2("vxe.custom.setting.colResizable")) : createCommentVNode(),
                    allowFixed ? h("th", {}, getI18n2(`vxe.custom.setting.${maxFixedSize ? "colFixedMax" : "colFixed"}`, [maxFixedSize])) : createCommentVNode()
                  ])
                ]),
                h(TransitionGroup, {
                  class: "vxe-table-custom--panel-list",
                  tag: "tbody",
                  name: "vxe-table-custom--list"
                }, {
                  default: () => trVNs
                })
              ])
            ]),
            bottomSlot ? h("div", {
              class: "vxe-table-custom-popup--table-bottom"
            }, $xeTable.callSlot(bottomSlot, params)) : renderEmptyElement4($xeTable),
            renderDragTip()
          ]);
        },
        footer: () => {
          if (footerSlot) {
            return $xeTable.callSlot(footerSlot, params);
          }
          return h("div", {
            class: "vxe-table-custom-popup--footer"
          }, [
            VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              content: customOpts.resetButtonText || getI18n2("vxe.custom.cstmRestore"),
              disabled: !isCustomStatus,
              onClick: resetCustomEvent
            }) : createCommentVNode(),
            immediate ? VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              content: customOpts.closeButtonText || getI18n2("vxe.table.customClose"),
              onClick: cancelCloseEvent
            }) : createCommentVNode() : VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              content: customOpts.cancelButtonText || getI18n2("vxe.table.customCancel"),
              onClick: cancelCustomEvent
            }) : createCommentVNode(),
            immediate ? createCommentVNode() : VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              status: "primary",
              content: customOpts.confirmButtonText || getI18n2("vxe.custom.cstmConfirm"),
              onClick: confirmCustomEvent
            }) : createCommentVNode()
          ]);
        }
      };
      if (headerSlot) {
        scopedSlots.header = () => $xeTable.callSlot(headerSlot, params);
      }
      if (mode === "drawer") {
        return VxeUIDrawerComponent ? h(VxeUIDrawerComponent, {
          key: "drawer",
          className: ["vxe-table-custom-drawer-wrapper", "vxe-table--ignore-clear", drawerOpts.className || ""].join(" "),
          modelValue: customStore.visible,
          title: drawerOpts.title || getI18n2("vxe.custom.cstmTitle"),
          width: drawerOpts.width || Math.min(880, Math.floor(document.documentElement.clientWidth * 0.6)),
          position: drawerOpts.position,
          resize: !!drawerOpts.resize,
          escClosable: !!drawerOpts.escClosable,
          maskClosable: !!drawerOpts.maskClosable,
          destroyOnClose: true,
          showFooter: true,
          "onUpdate:modelValue"(value) {
            customStore.visible = value;
          }
        }, scopedSlots) : createCommentVNode();
      }
      return VxeUIModalComponent ? h(VxeUIModalComponent, {
        key: "modal",
        className: ["vxe-table-custom-modal-wrapper", "vxe-table--ignore-clear", modalOpts.className || ""].join(" "),
        modelValue: customStore.visible,
        title: modalOpts.title || getI18n2("vxe.custom.cstmTitle"),
        width: modalOpts.width || Math.min(880, document.documentElement.clientWidth),
        minWidth: modalOpts.minWidth || 700,
        height: modalOpts.height || Math.min(680, document.documentElement.clientHeight),
        minHeight: modalOpts.minHeight || 400,
        showZoom: modalOpts.showZoom,
        showMaximize: modalOpts.showMaximize,
        showMinimize: modalOpts.showMinimize,
        mask: modalOpts.mask,
        lockView: modalOpts.lockView,
        resize: modalOpts.resize,
        escClosable: !!modalOpts.escClosable,
        maskClosable: !!modalOpts.maskClosable,
        destroyOnClose: true,
        showFooter: true,
        "onUpdate:modelValue"(value) {
          customStore.visible = value;
        }
      }, scopedSlots) : createCommentVNode();
    };
    const renderVN = () => {
      const customOpts = computeCustomOpts.value;
      if (["modal", "drawer", "popup"].includes(`${customOpts.mode}`)) {
        return renderPopupPanel();
      }
      return renderSimplePanel();
    };
    nextTick(() => {
      const customOpts = computeCustomOpts.value;
      const { mode } = customOpts;
      if (!VxeUIModalComponent) {
        errLog("vxe.error.reqComp", ["vxe-modal"]);
      }
      if (!VxeUIDrawerComponent && mode === "drawer") {
        errLog("vxe.error.reqComp", ["vxe-drawer"]);
      }
      if (!VxeUIButtonComponent) {
        errLog("vxe.error.reqComp", ["vxe-button"]);
      }
      if (!VxeUINumberInputComponent) {
        errLog("vxe.error.reqComp", ["vxe-number-input"]);
      }
      if (!VxeUIRadioGroupComponent) {
        errLog("vxe.error.reqComp", ["vxe-radio-group"]);
      }
    });
    return renderVN;
  }
});

// ../../node_modules/.pnpm/vxe-table@4.13.16_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-table/es/table/module/filter/panel.js
var import_xe_utils5 = __toESM(require_xe_utils());
var { getI18n: getI18n3, getIcon: getIcon2, renderer: renderer4 } = VxeUI;
var panel_default2 = defineComponent({
  name: "VxeTableFilterPanel",
  props: {
    filterStore: Object
  },
  setup(props, context) {
    const xID = import_xe_utils5.default.uniqueId();
    const $xeTable = inject("$xeTable", {});
    const { reactData: tableReactData, internalData: tableInternalData, getComputeMaps } = $xeTable;
    const { computeFilterOpts } = getComputeMaps();
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xeFilterPanel = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    const computeHasCheckOption = computed(() => {
      const { filterStore } = props;
      return filterStore && filterStore.options.some((option) => option.checked);
    });
    const filterCheckAllEvent = (evnt, value) => {
      const { filterStore } = props;
      filterStore.options.forEach((option) => {
        option._checked = value;
        option.checked = value;
      });
      filterStore.isAllSelected = value;
      filterStore.isIndeterminate = false;
    };
    const confirmFilter = (evnt) => {
      $xeTable.handleFilterConfirmFilter(evnt);
    };
    const changeRadioOption = (evnt, checked, item) => {
      $xeTable.handleFilterChangeRadioOption(evnt, checked, item);
    };
    const resetFilter = (evnt) => {
      $xeTable.handleFilterResetFilter(evnt);
    };
    const changeMultipleOption = (evnt, checked, item) => {
      $xeTable.handleFilterChangeMultipleOption(evnt, checked, item);
    };
    const changeOption = (evnt, checked, item) => {
      $xeTable.handleFilterChangeOption(evnt, checked, item);
    };
    const changeAllOption = (evnt, checked) => {
      const { filterStore } = props;
      if (filterStore.multiple) {
        filterCheckAllEvent(evnt, checked);
      } else {
        resetFilter(evnt);
      }
    };
    const filterPanelMethods = {
      changeRadioOption,
      changeMultipleOption,
      changeAllOption,
      changeOption,
      confirmFilter,
      resetFilter
    };
    Object.assign($xeFilterPanel, filterPanelMethods);
    const renderOptions = (filterRender, compConf) => {
      const { filterStore } = props;
      const { column, multiple, maxHeight } = filterStore;
      const slots = column ? column.slots : null;
      const filterSlot = slots ? slots.filter : null;
      const params = Object.assign({}, tableInternalData._currFilterParams, { $panel: $xeFilterPanel, $table: $xeTable });
      const rtFilter = compConf ? compConf.renderTableFilter || compConf.renderFilter : null;
      if (filterSlot) {
        return [
          h("div", {
            class: "vxe-table--filter-template",
            style: maxHeight ? {
              maxHeight: `${maxHeight}px`
            } : {}
          }, $xeTable.callSlot(filterSlot, params))
        ];
      } else if (rtFilter) {
        return [
          h("div", {
            class: "vxe-table--filter-template",
            style: maxHeight ? {
              maxHeight: `${maxHeight}px`
            } : {}
          }, getSlotVNs(rtFilter(filterRender, params)))
        ];
      }
      const isAllChecked = multiple ? filterStore.isAllSelected : !filterStore.options.some((item) => item._checked);
      const isAllIndeterminate = multiple && filterStore.isIndeterminate;
      return [
        h("ul", {
          class: "vxe-table--filter-header"
        }, [
          h("li", {
            class: ["vxe-table--filter-option", {
              "is--checked": isAllChecked,
              "is--indeterminate": isAllIndeterminate
            }],
            title: getI18n3(multiple ? "vxe.table.allTitle" : "vxe.table.allFilter"),
            onClick: (evnt) => {
              changeAllOption(evnt, !filterStore.isAllSelected);
            }
          }, (multiple ? [
            h("span", {
              class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon2().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? getIcon2().TABLE_CHECKBOX_CHECKED : getIcon2().TABLE_CHECKBOX_UNCHECKED]
            })
          ] : []).concat([
            h("span", {
              class: "vxe-checkbox--label"
            }, getI18n3("vxe.table.allFilter"))
          ]))
        ]),
        h("ul", {
          class: "vxe-table--filter-body",
          style: maxHeight ? {
            maxHeight: `${maxHeight}px`
          } : {}
        }, filterStore.options.map((item) => {
          const isChecked = item._checked;
          const isIndeterminate = false;
          return h("li", {
            class: ["vxe-table--filter-option", {
              "is--checked": item._checked
            }],
            title: item.label,
            onClick: (evnt) => {
              changeOption(evnt, !item._checked, item);
            }
          }, (multiple ? [
            h("span", {
              class: ["vxe-checkbox--icon", isIndeterminate ? getIcon2().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon2().TABLE_CHECKBOX_CHECKED : getIcon2().TABLE_CHECKBOX_UNCHECKED]
            })
          ] : []).concat([
            h("span", {
              class: "vxe-checkbox--label"
            }, formatText(item.label, 1))
          ]));
        }))
      ];
    };
    const renderFooters = () => {
      const { filterStore } = props;
      const { column, multiple } = filterStore;
      const filterOpts = computeFilterOpts.value;
      const hasCheckOption = computeHasCheckOption.value;
      const { filterRender } = column;
      const compConf = isEnableConf(filterRender) ? renderer4.get(filterRender.name) : null;
      const isDisabled = !hasCheckOption && !filterStore.isAllSelected && !filterStore.isIndeterminate;
      return multiple && (compConf ? !(compConf.showTableFilterFooter === false || compConf.showFilterFooter === false || compConf.isFooter === false) : true) ? [
        h("div", {
          class: "vxe-table--filter-footer"
        }, [
          h("button", {
            class: {
              "is--disabled": isDisabled
            },
            disabled: isDisabled,
            onClick: confirmFilter
          }, filterOpts.confirmButtonText || getI18n3("vxe.table.confirmFilter")),
          h("button", {
            onClick: resetFilter
          }, filterOpts.resetButtonText || getI18n3("vxe.table.resetFilter"))
        ])
      ] : [];
    };
    const renderVN = () => {
      const { filterStore } = props;
      const { initStore } = tableReactData;
      const { visible, multiple, column } = filterStore;
      const filterRender = column ? column.filterRender : null;
      const compConf = isEnableConf(filterRender) ? renderer4.get(filterRender.name) : null;
      const filterClassName = compConf ? compConf.tableFilterClassName || compConf.filterClassName : "";
      const params = Object.assign({}, tableInternalData._currFilterParams, { $panel: $xeFilterPanel, $table: $xeTable });
      const tableProps = $xeTable.props;
      const { computeSize } = $xeTable.getComputeMaps();
      const vSize = computeSize.value;
      const filterOpts = computeFilterOpts.value;
      const { transfer, destroyOnClose } = filterOpts;
      return h(Teleport, {
        to: "body",
        disabled: !transfer
      }, [
        h("div", {
          ref: refElem,
          class: [
            "vxe-table--filter-wrapper",
            "filter--prevent-default",
            getPropClass(filterClassName, params),
            {
              [`size--${vSize}`]: vSize,
              "is--animat": tableProps.animat,
              "is--multiple": multiple,
              "is--active": visible
            }
          ],
          style: filterStore.style
        }, initStore.filter && (destroyOnClose ? visible : true) && column ? renderOptions(filterRender, compConf).concat(renderFooters()) : [])
      ]);
    };
    $xeFilterPanel.renderVN = renderVN;
    return $xeFilterPanel;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-table@4.13.16_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-table/es/table/module/export/import-panel.js
var import_xe_utils6 = __toESM(require_xe_utils());
var { getI18n: getI18n4, getIcon: getIcon3 } = VxeUI;
var import_panel_default = defineComponent({
  name: "VxeTableImportPanel",
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(props) {
    const VxeUIModalComponent = VxeUI.getComponent("VxeModal");
    const VxeUIButtonComponent = VxeUI.getComponent("VxeButton");
    const VxeUISelectComponent = VxeUI.getComponent("VxeSelect");
    const $xeTable = inject("$xeTable", {});
    const { computeImportOpts } = $xeTable.getComputeMaps();
    const reactData = reactive({
      loading: false
    });
    const refFileBtn = ref();
    const computeSelectName = computed(() => {
      const { storeData } = props;
      return `${storeData.filename}.${storeData.type}`;
    });
    const computeHasFile = computed(() => {
      const { storeData } = props;
      return storeData.file && storeData.type;
    });
    const computeParseTypeLabel = computed(() => {
      const { storeData } = props;
      const { type, typeList } = storeData;
      if (type) {
        const selectItem = import_xe_utils6.default.find(typeList, (item) => type === item.value);
        return selectItem ? selectItem.label : "*.*";
      }
      return `*.${typeList.map((item) => item.value).join(", *.")}`;
    });
    const clearFileEvent = () => {
      const { storeData } = props;
      Object.assign(storeData, {
        filename: "",
        sheetName: "",
        type: ""
      });
    };
    const selectFileEvent = () => {
      const { storeData, defaultOptions } = props;
      $xeTable.readFile(defaultOptions).then((params) => {
        const { file } = params;
        Object.assign(storeData, parseFile(file), { file });
      }).catch((e) => e);
    };
    const showEvent = () => {
      nextTick(() => {
        const targetElem = refFileBtn.value;
        if (targetElem) {
          targetElem.focus();
        }
      });
    };
    const cancelEvent = () => {
      const { storeData } = props;
      storeData.visible = false;
    };
    const importEvent = () => {
      const { storeData, defaultOptions } = props;
      const importOpts = computeImportOpts.value;
      reactData.loading = true;
      $xeTable.importByFile(storeData.file, Object.assign({}, importOpts, defaultOptions)).then(() => {
        reactData.loading = false;
        storeData.visible = false;
      }).catch(() => {
        reactData.loading = false;
      });
    };
    const renderVN = () => {
      const $xeGrid = $xeTable.xeGrid;
      const { defaultOptions, storeData } = props;
      const selectName = computeSelectName.value;
      const hasFile = computeHasFile.value;
      const parseTypeLabel = computeParseTypeLabel.value;
      const slots = defaultOptions.slots || {};
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      return VxeUIModalComponent ? h(VxeUIModalComponent, {
        id: "VXE_IMPORT_MODAL",
        modelValue: storeData.visible,
        title: getI18n4("vxe.import.impTitle"),
        className: "vxe-table-export-popup-wrapper",
        width: 540,
        minWidth: 360,
        minHeight: 240,
        mask: true,
        lockView: true,
        showFooter: true,
        escClosable: true,
        maskClosable: true,
        showMaximize: true,
        resize: true,
        loading: reactData.loading,
        "onUpdate:modelValue"(value) {
          storeData.visible = value;
        },
        onShow: showEvent
      }, {
        default: () => {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            options: defaultOptions,
            params: defaultOptions.params
          };
          return h("div", {
            class: "vxe-table-export--panel"
          }, [
            topSlot ? h("div", {
              class: "vxe-table-export--panel-top"
            }, $xeTable.callSlot(topSlot, params)) : createCommentVNode(),
            h("div", {
              class: "vxe-table-export--panel-body"
            }, defaultSlot ? $xeTable.callSlot(defaultSlot, params) : [
              h("table", {
                class: "vxe-table-export--panel-table",
                cellspacing: 0,
                cellpadding: 0,
                border: 0
              }, [
                h("tbody", [
                  h("tr", [
                    h("td", getI18n4("vxe.import.impFile")),
                    h("td", [
                      hasFile ? h("div", {
                        class: "vxe-table-export--selected--file",
                        title: selectName
                      }, [
                        h("span", selectName),
                        h("i", {
                          class: getIcon3().INPUT_CLEAR,
                          onClick: clearFileEvent
                        })
                      ]) : h("button", {
                        ref: refFileBtn,
                        class: "vxe-table-export--select--file",
                        onClick: selectFileEvent
                      }, getI18n4("vxe.import.impSelect"))
                    ])
                  ]),
                  h("tr", [
                    h("td", getI18n4("vxe.import.impType")),
                    h("td", parseTypeLabel)
                  ]),
                  h("tr", [
                    h("td", getI18n4("vxe.import.impMode")),
                    h("td", [
                      VxeUISelectComponent ? h(VxeUISelectComponent, {
                        modelValue: defaultOptions.mode,
                        options: storeData.modeList,
                        "onUpdate:modelValue"(value) {
                          defaultOptions.mode = value;
                        }
                      }) : createCommentVNode()
                    ])
                  ])
                ])
              ])
            ]),
            bottomSlot ? h("div", {
              class: "vxe-table-export--panel-bottom"
            }, $xeTable.callSlot(bottomSlot, params)) : createCommentVNode()
          ]);
        },
        footer() {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            options: defaultOptions,
            params: defaultOptions.params
          };
          return h("div", {
            class: "vxe-table-export--panel-footer"
          }, footerSlot ? $xeTable.callSlot(footerSlot, params) : [
            h("div", {
              class: "vxe-table-export--panel-btns"
            }, [
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                content: getI18n4("vxe.import.impCancel"),
                onClick: cancelEvent
              }) : createCommentVNode(),
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                status: "primary",
                disabled: !hasFile || reactData.loading,
                content: getI18n4("vxe.import.impConfirm"),
                onClick: importEvent
              }) : createCommentVNode()
            ])
          ]);
        }
      }) : createCommentVNode();
    };
    nextTick(() => {
      if (!VxeUIModalComponent) {
        errLog("vxe.error.reqComp", ["vxe-modal"]);
      }
      if (!VxeUIButtonComponent) {
        errLog("vxe.error.reqComp", ["vxe-button"]);
      }
      if (!VxeUISelectComponent) {
        errLog("vxe.error.reqComp", ["vxe-select"]);
      }
    });
    return renderVN;
  }
});

// ../../node_modules/.pnpm/vxe-table@4.13.16_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-table/es/table/module/export/export-panel.js
var import_xe_utils7 = __toESM(require_xe_utils());
var { getI18n: getI18n5, getIcon: getIcon4 } = VxeUI;
var export_panel_default = defineComponent({
  name: "VxeTableExportPanel",
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(props) {
    const VxeUIModalComponent = VxeUI.getComponent("VxeModal");
    const VxeUIButtonComponent = VxeUI.getComponent("VxeButton");
    const VxeUISelectComponent = VxeUI.getComponent("VxeSelect");
    const VxeUIInputComponent = VxeUI.getComponent("VxeInput");
    const VxeUICheckboxComponent = VxeUI.getComponent("VxeCheckbox");
    const $xeTable = inject("$xeTable", {});
    const { computeExportOpts, computePrintOpts } = $xeTable.getComputeMaps();
    const reactData = reactive({
      isAll: false,
      isIndeterminate: false,
      loading: false
    });
    const xButtonConfirm = ref();
    const xInputFilename = ref();
    const xInputSheetname = ref();
    const computeCheckedAll = computed(() => {
      const { storeData } = props;
      return storeData.columns.every((column) => column.checked);
    });
    const computeShowSheet = computed(() => {
      const { defaultOptions } = props;
      return ["html", "xml", "xlsx", "pdf"].indexOf(defaultOptions.type) > -1;
    });
    const computeSupportMerge = computed(() => {
      const { storeData, defaultOptions } = props;
      return !defaultOptions.original && defaultOptions.mode === "current" && (storeData.isPrint || ["html", "xlsx"].indexOf(defaultOptions.type) > -1);
    });
    const computeSupportStyle = computed(() => {
      const { defaultOptions } = props;
      return !defaultOptions.original && ["xlsx"].indexOf(defaultOptions.type) > -1;
    });
    const handleOptionCheck = (column) => {
      const { storeData } = props;
      const matchObj = import_xe_utils7.default.findTree(storeData.columns, (item) => item === column);
      if (matchObj && matchObj.parent) {
        const { parent } = matchObj;
        if (parent.children && parent.children.length) {
          parent.checked = parent.children.every((column2) => column2.checked);
          parent.halfChecked = !parent.checked && parent.children.some((column2) => column2.checked || column2.halfChecked);
          handleOptionCheck(parent);
        }
      }
    };
    const checkStatus = () => {
      const { storeData } = props;
      const columns = storeData.columns;
      reactData.isAll = columns.every((column) => column.disabled || column.checked);
      reactData.isIndeterminate = !reactData.isAll && columns.some((column) => !column.disabled && (column.checked || column.halfChecked));
    };
    const changeOption = (column) => {
      const isChecked = !column.checked;
      import_xe_utils7.default.eachTree([column], (item) => {
        item.checked = isChecked;
        item.halfChecked = false;
      });
      handleOptionCheck(column);
      checkStatus();
    };
    const allColumnEvent = () => {
      const { storeData } = props;
      const isAll = !reactData.isAll;
      import_xe_utils7.default.eachTree(storeData.columns, (column) => {
        if (!column.disabled) {
          column.checked = isAll;
          column.halfChecked = false;
        }
      });
      reactData.isAll = isAll;
      checkStatus();
    };
    const showEvent = () => {
      nextTick(() => {
        const filenameInp = xInputFilename.value;
        const sheetnameInp = xInputSheetname.value;
        const confirmBtn = xButtonConfirm.value;
        const targetElem = filenameInp || sheetnameInp || confirmBtn;
        if (targetElem) {
          targetElem.focus();
        }
      });
      checkStatus();
    };
    const getExportOption = () => {
      const { storeData, defaultOptions } = props;
      const { hasMerge, columns } = storeData;
      const checkedAll = computeCheckedAll.value;
      const supportMerge = computeSupportMerge.value;
      const expColumns = import_xe_utils7.default.searchTree(columns, (column) => column.checked, { children: "children", mapChildren: "childNodes", original: true });
      return Object.assign({}, defaultOptions, {
        columns: expColumns,
        isMerge: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false
      });
    };
    const printEvent = () => {
      const { storeData } = props;
      const printOpts = computePrintOpts.value;
      storeData.visible = false;
      $xeTable.print(Object.assign({}, printOpts, getExportOption()));
    };
    const exportEvent = () => {
      const { storeData } = props;
      const exportOpts = computeExportOpts.value;
      reactData.loading = true;
      $xeTable.exportData(Object.assign({}, exportOpts, getExportOption())).then(() => {
        reactData.loading = false;
        storeData.visible = false;
      }).catch(() => {
        reactData.loading = false;
      });
    };
    const cancelEvent = () => {
      const { storeData } = props;
      storeData.visible = false;
    };
    const confirmEvent = () => {
      const { storeData } = props;
      if (storeData.isPrint) {
        printEvent();
      } else {
        exportEvent();
      }
    };
    const renderVN = () => {
      const $xeGrid = $xeTable.xeGrid;
      const { defaultOptions, storeData } = props;
      const { isAll: isAllChecked, isIndeterminate: isAllIndeterminate } = reactData;
      const { hasTree, hasMerge, isPrint, hasColgroup, columns } = storeData;
      const { isHeader } = defaultOptions;
      const cols = [];
      const checkedAll = computeCheckedAll.value;
      const showSheet = computeShowSheet.value;
      const supportMerge = computeSupportMerge.value;
      const supportStyle = computeSupportStyle.value;
      const slots = defaultOptions.slots || {};
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const parameterSlot = slots.parameter;
      import_xe_utils7.default.eachTree(columns, (column) => {
        const colTitle = formatText(column.getTitle(), 1);
        const isColGroup = column.children && column.children.length;
        const isChecked = column.checked;
        const indeterminate = column.halfChecked;
        const isHtml = column.type === "html";
        cols.push(h("li", {
          key: column.id,
          class: ["vxe-table-export--panel-column-option", `level--${column.level}`, {
            "is--group": isColGroup,
            "is--checked": isChecked,
            "is--indeterminate": indeterminate,
            "is--disabled": column.disabled
          }],
          title: isHtml ? "" : colTitle,
          onClick: () => {
            if (!column.disabled) {
              changeOption(column);
            }
          }
        }, [
          h("span", {
            class: ["vxe-checkbox--icon", indeterminate ? getIcon4().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon4().TABLE_CHECKBOX_CHECKED : getIcon4().TABLE_CHECKBOX_UNCHECKED]
          }),
          isHtml ? h("span", {
            key: "1",
            class: "vxe-checkbox--label",
            innerHTML: colTitle
          }) : h("span", {
            key: "0",
            class: "vxe-checkbox--label"
          }, colTitle)
        ]));
      });
      return VxeUIModalComponent ? h(VxeUIModalComponent, {
        id: "VXE_EXPORT_MODAL",
        modelValue: storeData.visible,
        title: getI18n5(isPrint ? "vxe.export.printTitle" : "vxe.export.expTitle"),
        className: "vxe-table-export-popup-wrapper",
        width: 660,
        minWidth: 500,
        minHeight: 400,
        mask: true,
        lockView: true,
        showFooter: true,
        escClosable: true,
        maskClosable: true,
        showMaximize: true,
        resize: true,
        loading: reactData.loading,
        "onUpdate:modelValue"(value) {
          storeData.visible = value;
        },
        onShow: showEvent
      }, {
        default: () => {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            options: defaultOptions,
            columns,
            params: defaultOptions.params
          };
          const hasEmptyData = defaultOptions.mode === "empty";
          return h("div", {
            class: "vxe-table-export--panel"
          }, [
            topSlot ? h("div", {
              class: "vxe-table-export--panel-top"
            }, $xeTable.callSlot(topSlot, params)) : createCommentVNode(),
            h("div", {
              class: "vxe-table-export--panel-body"
            }, defaultSlot ? $xeTable.callSlot(defaultSlot, params) : [
              h("table", {
                class: "vxe-table-export--panel-table",
                cellspacing: 0,
                cellpadding: 0,
                border: 0
              }, [
                h("tbody", [
                  [
                    isPrint ? createCommentVNode() : h("tr", [
                      h("td", getI18n5("vxe.export.expName")),
                      h("td", [
                        VxeUIInputComponent ? h(VxeUIInputComponent, {
                          ref: xInputFilename,
                          modelValue: defaultOptions.filename,
                          type: "text",
                          clearable: true,
                          placeholder: getI18n5("vxe.export.expNamePlaceholder"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.filename = value;
                          }
                        }) : createCommentVNode()
                      ])
                    ]),
                    isPrint ? createCommentVNode() : h("tr", [
                      h("td", getI18n5("vxe.export.expType")),
                      h("td", [
                        VxeUISelectComponent ? h(VxeUISelectComponent, {
                          modelValue: defaultOptions.type,
                          options: storeData.typeList,
                          "onUpdate:modelValue"(value) {
                            defaultOptions.type = value;
                          }
                        }) : createCommentVNode()
                      ])
                    ]),
                    isPrint || showSheet ? h("tr", [
                      h("td", getI18n5("vxe.export.expSheetName")),
                      h("td", [
                        VxeUIInputComponent ? h(VxeUIInputComponent, {
                          ref: xInputSheetname,
                          modelValue: defaultOptions.sheetName,
                          type: "text",
                          clearable: true,
                          placeholder: getI18n5("vxe.export.expSheetNamePlaceholder"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.sheetName = value;
                          }
                        }) : createCommentVNode()
                      ])
                    ]) : createCommentVNode(),
                    h("tr", [
                      h("td", getI18n5("vxe.export.expMode")),
                      h("td", [
                        VxeUISelectComponent ? h(VxeUISelectComponent, {
                          modelValue: defaultOptions.mode,
                          options: storeData.modeList.map((item) => {
                            return {
                              value: item.value,
                              label: getI18n5(item.label)
                            };
                          }),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.mode = value;
                          }
                        }) : createCommentVNode()
                      ])
                    ]),
                    h("tr", [
                      h("td", [getI18n5("vxe.export.expColumn")]),
                      h("td", [
                        h("div", {
                          class: "vxe-table-export--panel-column"
                        }, [
                          h("ul", {
                            class: "vxe-table-export--panel-column-header"
                          }, [
                            h("li", {
                              class: ["vxe-table-export--panel-column-option", {
                                "is--checked": isAllChecked,
                                "is--indeterminate": isAllIndeterminate
                              }],
                              title: getI18n5("vxe.table.allTitle"),
                              onClick: allColumnEvent
                            }, [
                              h("span", {
                                class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon4().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? getIcon4().TABLE_CHECKBOX_CHECKED : getIcon4().TABLE_CHECKBOX_UNCHECKED]
                              }),
                              h("span", {
                                class: "vxe-checkbox--label"
                              }, getI18n5("vxe.export.expCurrentColumn"))
                            ])
                          ]),
                          h("ul", {
                            class: "vxe-table-export--panel-column-body"
                          }, cols)
                        ])
                      ])
                    ]),
                    h("tr", [
                      h("td", getI18n5("vxe.export.expOpts")),
                      parameterSlot ? h("td", [
                        h("div", {
                          class: "vxe-table-export--panel-option-row"
                        }, $xeTable.callSlot(parameterSlot, params))
                      ]) : h("td", [
                        h("div", {
                          class: "vxe-table-export--panel-option-row"
                        }, [
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: hasEmptyData || isHeader,
                            disabled: hasEmptyData,
                            title: getI18n5("vxe.export.expHeaderTitle"),
                            content: getI18n5("vxe.export.expOptHeader"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isHeader = value;
                            }
                          }) : createCommentVNode(),
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: isHeader ? defaultOptions.isTitle : false,
                            disabled: !isHeader,
                            title: getI18n5("vxe.export.expTitleTitle"),
                            content: getI18n5("vxe.export.expOptTitle"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isTitle = value;
                            }
                          }) : createCommentVNode(),
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: isHeader && hasColgroup && supportMerge ? defaultOptions.isColgroup : false,
                            title: getI18n5("vxe.export.expColgroupTitle"),
                            disabled: !isHeader || !hasColgroup || !supportMerge,
                            content: getI18n5("vxe.export.expOptColgroup"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isColgroup = value;
                            }
                          }) : createCommentVNode()
                        ]),
                        h("div", {
                          class: "vxe-table-export--panel-option-row"
                        }, [
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: hasEmptyData ? false : defaultOptions.original,
                            disabled: hasEmptyData,
                            title: getI18n5("vxe.export.expOriginalTitle"),
                            content: getI18n5("vxe.export.expOptOriginal"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.original = value;
                            }
                          }) : createCommentVNode(),
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false,
                            title: getI18n5("vxe.export.expMergeTitle"),
                            disabled: hasEmptyData || !hasMerge || !supportMerge || !checkedAll,
                            content: getI18n5("vxe.export.expOptMerge"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isMerge = value;
                            }
                          }) : createCommentVNode(),
                          isPrint || !VxeUICheckboxComponent ? createCommentVNode() : h(VxeUICheckboxComponent, {
                            modelValue: supportStyle ? defaultOptions.useStyle : false,
                            disabled: !supportStyle,
                            title: getI18n5("vxe.export.expUseStyleTitle"),
                            content: getI18n5("vxe.export.expOptUseStyle"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.useStyle = value;
                            }
                          }),
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: hasTree ? defaultOptions.isAllExpand : false,
                            disabled: hasEmptyData || !hasTree,
                            title: getI18n5("vxe.export.expAllExpandTitle"),
                            content: getI18n5("vxe.export.expOptAllExpand"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isAllExpand = value;
                            }
                          }) : createCommentVNode()
                        ]),
                        h("div", {
                          class: "vxe-table-export--panel-option-row"
                        }, [
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: defaultOptions.isFooter,
                            disabled: !storeData.hasFooter,
                            title: getI18n5("vxe.export.expFooterTitle"),
                            content: getI18n5("vxe.export.expOptFooter"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isFooter = value;
                            }
                          }) : createCommentVNode()
                        ])
                      ])
                    ])
                  ]
                ])
              ])
            ]),
            bottomSlot ? h("div", {
              class: "vxe-table-export--panel-bottom"
            }, $xeTable.callSlot(bottomSlot, params)) : createCommentVNode()
          ]);
        },
        footer() {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            options: defaultOptions,
            columns,
            params: defaultOptions.params
          };
          return h("div", {
            class: "vxe-table-export--panel-footer"
          }, footerSlot ? $xeTable.callSlot(footerSlot, params) : [
            h("div", {
              class: "vxe-table-export--panel-btns"
            }, [
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                content: getI18n5("vxe.export.expCancel"),
                onClick: cancelEvent
              }) : createCommentVNode(),
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                ref: xButtonConfirm,
                status: "primary",
                content: getI18n5(isPrint ? "vxe.export.expPrint" : "vxe.export.expConfirm"),
                onClick: confirmEvent
              }) : createCommentVNode()
            ])
          ]);
        }
      }) : createCommentVNode();
    };
    nextTick(() => {
      if (!VxeUIModalComponent) {
        errLog("vxe.error.reqComp", ["vxe-modal"]);
      }
      if (!VxeUIButtonComponent) {
        errLog("vxe.error.reqComp", ["vxe-button"]);
      }
      if (!VxeUISelectComponent) {
        errLog("vxe.error.reqComp", ["vxe-select"]);
      }
      if (!VxeUIInputComponent) {
        errLog("vxe.error.reqComp", ["vxe-input"]);
      }
      if (!VxeUICheckboxComponent) {
        errLog("vxe.error.reqComp", ["vxe-checkbox"]);
      }
    });
    return renderVN;
  }
});

// ../../node_modules/.pnpm/vxe-table@4.13.16_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-table/es/table/module/menu/panel.js
var import_xe_utils8 = __toESM(require_xe_utils());
var { getIcon: getIcon5 } = VxeUI;
var panel_default3 = defineComponent({
  name: "VxeTableMenuPanel",
  setup(props, context) {
    const xID = import_xe_utils8.default.uniqueId();
    const $xeTable = inject("$xeTable", {});
    const { reactData: tableReactData } = $xeTable;
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xeMenuPanel = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    const renderVN = () => {
      const { ctxMenuStore } = tableReactData;
      const { computeMenuOpts } = $xeTable.getComputeMaps();
      const menuOpts = computeMenuOpts.value;
      return h(Teleport, {
        to: "body",
        disabled: false
      }, [
        h("div", {
          ref: refElem,
          class: ["vxe-table--context-menu-wrapper", menuOpts.className, {
            "is--visible": ctxMenuStore.visible
          }],
          style: ctxMenuStore.style
        }, ctxMenuStore.list.map((options, gIndex) => {
          return options.every((item) => item.visible === false) ? createCommentVNode() : h("ul", {
            class: "vxe-context-menu--option-wrapper",
            key: gIndex
          }, options.map((item, index) => {
            const hasChildMenus = item.children && item.children.some((child) => child.visible !== false);
            const prefixOpts = Object.assign({}, item.prefixConfig);
            const suffixOpts = Object.assign({}, item.suffixConfig);
            const menuContent = getFuncText(item.name);
            return item.visible === false ? null : h("li", {
              class: [item.className, {
                "link--disabled": item.disabled,
                "link--active": item === ctxMenuStore.selected
              }],
              key: `${gIndex}_${index}`
            }, [
              h("a", {
                class: "vxe-context-menu--link",
                onClick(evnt) {
                  $xeTable.ctxMenuLinkEvent(evnt, item);
                },
                onMouseover(evnt) {
                  $xeTable.ctxMenuMouseoverEvent(evnt, item);
                },
                onMouseout(evnt) {
                  $xeTable.ctxMenuMouseoutEvent(evnt, item);
                }
              }, [
                h("div", {
                  class: ["vxe-context-menu--link-prefix", prefixOpts.className || ""]
                }, [
                  h("i", {
                    class: prefixOpts.icon || item.prefixIcon
                  }),
                  prefixOpts.content ? h("span", {}, `${prefixOpts.content}`) : createCommentVNode()
                ]),
                h("div", {
                  class: "vxe-context-menu--link-content",
                  title: menuContent
                }, menuContent),
                h("div", {
                  class: ["vxe-context-menu--link-suffix", suffixOpts.className || ""]
                }, [
                  h("i", {
                    class: suffixOpts.icon || item.suffixIcon || (hasChildMenus ? getIcon5().TABLE_MENU_OPTIONS : "")
                  }),
                  suffixOpts.content ? h("span", `${suffixOpts.content}`) : createCommentVNode()
                ])
              ]),
              hasChildMenus ? h("ul", {
                class: ["vxe-table--context-menu-clild-wrapper", {
                  "is--show": item === ctxMenuStore.selected && ctxMenuStore.showChild
                }]
              }, item.children.map((child, cIndex) => {
                const childPrefixOpts = Object.assign({}, child.prefixConfig);
                const childSuffixOpts = Object.assign({}, child.suffixConfig);
                const childMenuContent = getFuncText(child.name);
                return child.visible === false ? null : h("li", {
                  class: [child.className, {
                    "link--disabled": child.disabled,
                    "link--active": child === ctxMenuStore.selectChild
                  }],
                  key: `${gIndex}_${index}_${cIndex}`
                }, [
                  h("a", {
                    class: "vxe-context-menu--link",
                    onClick(evnt) {
                      $xeTable.ctxMenuLinkEvent(evnt, child);
                    },
                    onMouseover(evnt) {
                      $xeTable.ctxMenuMouseoverEvent(evnt, item, child);
                    },
                    onMouseout(evnt) {
                      $xeTable.ctxMenuMouseoutEvent(evnt, item);
                    }
                  }, [
                    h("div", {
                      class: ["vxe-context-menu--link-prefix", childPrefixOpts.className || ""]
                    }, [
                      h("i", {
                        class: childPrefixOpts.icon || child.prefixIcon
                      }),
                      childPrefixOpts.content ? h("span", `${childPrefixOpts.content}`) : createCommentVNode()
                    ]),
                    h("div", {
                      class: "vxe-context-menu--link-content",
                      title: childMenuContent
                    }, childMenuContent),
                    h("div", {
                      class: ["vxe-context-menu--link-suffix", childSuffixOpts.className || ""]
                    }, [
                      h("i", {
                        class: childSuffixOpts.icon
                      }),
                      childSuffixOpts.content ? h("span", `${childSuffixOpts.content}`) : createCommentVNode()
                    ])
                  ])
                ]);
              })) : null
            ]);
          }));
        }))
      ]);
    };
    $xeMenuPanel.renderVN = renderVN;
    return $xeMenuPanel;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-table@4.13.16_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-table/es/table/src/table.js
var { getConfig: getConfig2, getIcon: getIcon6, getI18n: getI18n6, renderer: renderer5, formats, createEvent, globalResize, interceptor, hooks, globalEvents, GLOBAL_EVENT_KEYS, useFns, renderEmptyElement: renderEmptyElement5 } = VxeUI;
var supportMaxRow = 5e6;
var customStorageKey = "VXE_CUSTOM_STORE";
var maxYHeight = 5e6;
var maxXWidth = 5e6;
var table_default = defineComponent({
  name: "VxeTable",
  props: props_default,
  emits: emits_default,
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils9.default.uniqueId();
    const browseObj = import_xe_utils9.default.browse();
    const VxeUILoadingComponent = VxeUI.getComponent("VxeLoading");
    const VxeUITooltipComponent = VxeUI.getComponent("VxeTooltip");
    const $xeTabs = inject("$xeTabs", null);
    const { computeSize } = useFns.useSize(props);
    const reactData = reactive({
      // 低性能的静态列
      staticColumns: [],
      // 渲染的列分组
      tableGroupColumn: [],
      // 可视区渲染的列
      tableColumn: [],
      // 渲染中的数据
      tableData: [],
      // 是否启用了横向 X 可视渲染方式加载
      scrollXLoad: false,
      // 是否启用了纵向 Y 可视渲染方式加载
      scrollYLoad: false,
      // 是否存在纵向滚动条
      overflowY: true,
      // 是否存在横向滚动条
      overflowX: false,
      // 纵向滚动条的宽度
      scrollbarWidth: 0,
      // 横向滚动条的高度
      scrollbarHeight: 0,
      // 最后滚动时间戳
      lastScrollTime: 0,
      // 行高
      rowHeight: 0,
      // 表格父容器的高度
      parentHeight: 0,
      // 是否使用分组表头
      isGroup: false,
      isAllOverflow: false,
      // 复选框属性，是否全选
      isAllSelected: false,
      // 复选框属性，有选中且非全选状态
      isIndeterminate: false,
      // 当前行
      currentRow: null,
      // 单选框属性，选中列
      currentColumn: null,
      // 单选框属性，选中行
      selectRadioRow: null,
      // 表尾合计数据
      footerTableData: [],
      // 行分组列信息
      rowGroupColumn: null,
      // 展开列信息
      expandColumn: null,
      // 树节点列信息
      treeNodeColumn: null,
      hasFixedColumn: false,
      // 刷新列标识，当列筛选被改变时，触发表格刷新数据
      upDataFlag: 0,
      // 刷新列标识，当列的特定属性被改变时，触发表格刷新列
      reColumnFlag: 0,
      // 初始化标识
      initStore: {
        filter: false,
        import: false,
        export: false,
        custom: false
      },
      // 自定义列相关的信息
      customStore: {
        btnEl: null,
        isAll: false,
        isIndeterminate: false,
        activeBtn: false,
        activeWrapper: false,
        visible: false,
        maxHeight: 0,
        oldSortMaps: {},
        oldFixedMaps: {},
        oldVisibleMaps: {}
      },
      customColumnList: [],
      // 当前选中的筛选列
      filterStore: {
        isAllSelected: false,
        isIndeterminate: false,
        style: null,
        options: [],
        column: null,
        multiple: false,
        visible: false,
        maxHeight: null
      },
      // 存放列相关的信息
      columnStore: {
        leftList: [],
        centerList: [],
        rightList: [],
        resizeList: [],
        pxList: [],
        pxMinList: [],
        autoMinList: [],
        scaleList: [],
        scaleMinList: [],
        autoList: [],
        remainList: []
      },
      // 存放快捷菜单的信息
      ctxMenuStore: {
        selected: null,
        visible: false,
        showChild: false,
        selectChild: null,
        list: [],
        style: null
      },
      // 存放可编辑相关信息
      editStore: {
        indexs: {
          columns: []
        },
        titles: {
          columns: []
        },
        // 选中源
        selected: {
          row: null,
          column: null
        },
        // 已复制源
        copyed: {
          cut: false,
          rows: [],
          columns: []
        },
        // 激活
        actived: {
          row: null,
          column: null
        },
        // 当前被强制聚焦单元格，只会在鼠标点击后算聚焦
        focused: {
          row: null,
          column: null
        }
      },
      // 存放 tooltip 相关信息
      tooltipStore: {
        row: null,
        column: null,
        content: null,
        visible: false,
        currOpts: {}
      },
      // 存放数据校验相关信息
      validStore: {
        visible: false
      },
      validErrorMaps: {},
      // 导入相关信息
      importStore: {
        inited: false,
        file: null,
        type: "",
        modeList: [],
        typeList: [],
        filename: "",
        visible: false
      },
      importParams: {
        mode: "",
        types: null,
        message: true
      },
      // 导出相关信息
      exportStore: {
        inited: false,
        name: "",
        modeList: [],
        typeList: [],
        columns: [],
        isPrint: false,
        hasFooter: false,
        hasMerge: false,
        hasTree: false,
        hasColgroup: false,
        visible: false
      },
      exportParams: {
        filename: "",
        sheetName: "",
        mode: "",
        type: "",
        isColgroup: false,
        isMerge: false,
        isAllExpand: false,
        useStyle: false,
        original: false,
        message: true,
        isHeader: false,
        isTitle: false,
        isFooter: false
      },
      visiblwRowsFlag: 1,
      isRowGroupStatus: false,
      rowGroupList: [],
      rowGroupExpandedFlag: 1,
      rowExpandedFlag: 1,
      treeExpandedFlag: 1,
      updateCheckboxFlag: 1,
      pendingRowFlag: 1,
      insertRowFlag: 1,
      removeRowFlag: 1,
      mergeBodyFlag: 1,
      mergeFootFlag: 1,
      rowHeightStore: {
        large: 52,
        default: 48,
        medium: 44,
        small: 40,
        mini: 36
      },
      scrollVMLoading: false,
      scrollYHeight: 0,
      scrollYTop: 0,
      isScrollYBig: false,
      scrollXLeft: 0,
      scrollXWidth: 0,
      isScrollXBig: false,
      rowExpandHeightFlag: 1,
      calcCellHeightFlag: 1,
      resizeHeightFlag: 1,
      resizeWidthFlag: 1,
      isCustomStatus: false,
      isDragRowMove: false,
      dragRow: null,
      isDragColMove: false,
      dragCol: null,
      dragTipText: "",
      isDragResize: false,
      isRowLoading: false,
      isColLoading: false
    });
    const internalData = {
      tZindex: 0,
      elemStore: {},
      // 存放横向 X 虚拟滚动相关的信息
      scrollXStore: {
        preloadSize: 0,
        offsetSize: 0,
        visibleSize: 0,
        visibleStartIndex: 0,
        visibleEndIndex: 0,
        startIndex: 0,
        endIndex: 0
      },
      // 存放纵向 Y 虚拟滚动相关信息
      scrollYStore: {
        preloadSize: 0,
        offsetSize: 0,
        visibleSize: 0,
        visibleStartIndex: 0,
        visibleEndIndex: 0,
        startIndex: 0,
        endIndex: 0
      },
      // 表格宽度
      tableWidth: 0,
      // 表格高度
      tableHeight: 0,
      // 表头高度
      headerHeight: 0,
      // 表尾高度
      footerHeight: 0,
      customHeight: 0,
      customMinHeight: 0,
      customMaxHeight: 0,
      // 当前 hover 行
      hoverRow: null,
      // 最后滚动位置
      lastScrollLeft: 0,
      lastScrollTop: 0,
      // 单选框属性，已选中保留的行
      radioReserveRow: null,
      // 复选框属性，已选中保留的行集合
      checkboxReserveRowMap: {},
      // 行数据，已展开保留的行集合
      rowExpandedReserveRowMap: {},
      // 树结构数据，已展开保留的行集合
      treeExpandedReserveRowMap: {},
      // 树结构数据，不确定状态的集合
      treeIndeterminateRowMaps: {},
      // 列表完整数据、条件处理后
      tableFullData: [],
      afterFullData: [],
      afterTreeFullData: [],
      afterGroupFullData: [],
      // 列表条件处理后数据集合
      afterFullRowMaps: {},
      // 树结构完整数据、条件处理后
      tableFullTreeData: [],
      // 行分组全量数据、条件处理后
      tableFullGroupData: [],
      tableSynchData: [],
      tableSourceData: [],
      // 收集的列配置（带分组）
      collectColumn: [],
      // 完整所有列（不带分组）
      tableFullColumn: [],
      // 渲染所有列
      visibleColumn: [],
      // 全量数据集（包括当前和已删除）
      fullAllDataRowIdData: {},
      // 数据集（仅当前）
      fullDataRowIdData: {},
      // 数据集（仅可视）
      visibleDataRowIdData: {},
      // 渲染中缓存数据
      sourceDataRowIdData: {},
      fullColumnIdData: {},
      fullColumnFieldData: {},
      // 合并单元格的数据
      mergeBodyList: [],
      mergeBodyMaps: {},
      // 合并表尾的数据
      mergeFooterList: [],
      mergeFooterMaps: {},
      // 已合并单元格数据集合
      mergeBodyCellMaps: {},
      // 已合并表尾数据集合
      mergeFooterCellMaps: {},
      // 已展开的行集合
      rowExpandedMaps: {},
      // 懒加载中的展开行的集合
      rowExpandLazyLoadedMaps: {},
      // 已展开的分组行
      rowGroupExpandedMaps: {},
      // 已展开树节点集合
      treeExpandedMaps: {},
      // 懒加载中的树节点的集合
      treeExpandLazyLoadedMaps: {},
      // 复选框属性，已选中的行集合
      selectCheckboxMaps: {},
      // 已标记的对象集
      pendingRowMaps: {},
      // 已新增的临时行
      insertRowMaps: {},
      // 已删除行
      removeRowMaps: {},
      cvCacheMaps: {},
      inited: false,
      tooltipTimeout: null,
      initStatus: false,
      isActivated: false
    };
    let tableMethods = {};
    let tablePrivateMethods = {};
    const refElem = ref();
    const refVarElem = ref();
    const refTooltip = ref();
    const refCommTooltip = ref();
    const refValidTooltip = ref();
    const refTableMenu = ref();
    const refTableFilter = ref();
    const refTableCustom = ref();
    const refTableViewportElem = ref();
    const refTableHeader = ref();
    const refTableBody = ref();
    const refTableFooter = ref();
    const refTableLeftHeader = ref();
    const refTableLeftBody = ref();
    const refTableLeftFooter = ref();
    const refTableRightHeader = ref();
    const refTableRightBody = ref();
    const refTableRightFooter = ref();
    const refLeftContainer = ref();
    const refRightContainer = ref();
    const refColResizeBar = ref();
    const refRowResizeBar = ref();
    const refEmptyPlaceholder = ref();
    const refDragTipElem = ref();
    const refDragRowLineElem = ref();
    const refDragColLineElem = ref();
    const refRowExpandElem = ref();
    const refRowExpandYSpaceElem = ref();
    const refScrollXVirtualElem = ref();
    const refScrollYVirtualElem = ref();
    const refScrollXHandleElem = ref();
    const refScrollXLeftCornerElem = ref();
    const refScrollXRightCornerElem = ref();
    const refScrollYHandleElem = ref();
    const refScrollYTopCornerElem = ref();
    const refScrollXWrapperElem = ref();
    const refScrollYWrapperElem = ref();
    const refScrollYBottomCornerElem = ref();
    const refScrollXSpaceElem = ref();
    const refScrollYSpaceElem = ref();
    const $xeGrid = inject("$xeGrid", null);
    let $xeToolbar;
    const computeTableId = computed(() => {
      const { id } = props;
      if (id) {
        if (import_xe_utils9.default.isFunction(id)) {
          return `${id({ $table: $xeTable, $grid: $xeGrid }) || ""}`;
        }
        return `${id}`;
      }
      return "";
    });
    const computeValidOpts = computed(() => {
      return Object.assign({}, getConfig2().table.validConfig, props.validConfig);
    });
    const computeSXOpts = computed(() => {
      const virtualXOpts = computeVirtualXOpts.value;
      return virtualXOpts;
    });
    const computeScrollXThreshold = computed(() => {
      const virtualXOpts = computeVirtualXOpts.value;
      const { threshold } = virtualXOpts;
      if (threshold) {
        return import_xe_utils9.default.toNumber(threshold);
      }
      return 0;
    });
    const computeSYOpts = computed(() => {
      const virtualYOpts = computeVirtualYOpts.value;
      return virtualYOpts;
    });
    const computeVirtualXOpts = computed(() => {
      return Object.assign({}, getConfig2().table.scrollX, getConfig2().table.virtualXConfig, props.scrollX, props.virtualXConfig);
    });
    const computeVirtualYOpts = computed(() => {
      return Object.assign({}, getConfig2().table.scrollY, getConfig2().table.virtualYConfig, props.scrollY, props.virtualYConfig);
    });
    const computeScrollbarOpts = computed(() => {
      return Object.assign({}, getConfig2().table.scrollbarConfig, props.scrollbarConfig);
    });
    const computeScrollbarXToTop = computed(() => {
      const scrollbarOpts = computeScrollbarOpts.value;
      return !!(scrollbarOpts.x && scrollbarOpts.x.position === "top");
    });
    const computeScrollbarYToLeft = computed(() => {
      const scrollbarOpts = computeScrollbarOpts.value;
      return !!(scrollbarOpts.y && scrollbarOpts.y.position === "left");
    });
    const computeScrollYThreshold = computed(() => {
      const virtualYOpts = computeVirtualYOpts.value;
      const { threshold } = virtualYOpts;
      if (threshold) {
        return import_xe_utils9.default.toNumber(threshold);
      }
      return 0;
    });
    const computeRowHeightMaps = computed(() => {
      return reactData.rowHeightStore;
    });
    const computeDefaultRowHeight = computed(() => {
      const vSize = computeSize.value;
      const rowHeightMaps = computeRowHeightMaps.value;
      return rowHeightMaps[vSize || "default"] || 18;
    });
    const computeColumnOpts = computed(() => {
      return Object.assign({}, getConfig2().table.columnConfig, props.columnConfig);
    });
    const computeCurrentColumnOpts = computed(() => {
      return Object.assign({}, getConfig2().table.currentColumnConfig, props.currentColumnConfig);
    });
    const computeCellOpts = computed(() => {
      const cellOpts = Object.assign({}, getConfig2().table.cellConfig, props.cellConfig);
      if (cellOpts.height) {
        cellOpts.height = import_xe_utils9.default.toNumber(cellOpts.height);
      }
      return cellOpts;
    });
    const computeHeaderCellOpts = computed(() => {
      const headerCellOpts = Object.assign({}, getConfig2().table.headerCellConfig, props.headerCellConfig);
      const cellOpts = computeCellOpts.value;
      headerCellOpts.height = import_xe_utils9.default.toNumber(getCellHeight(headerCellOpts.height || cellOpts.height));
      return headerCellOpts;
    });
    const computeFooterCellOpts = computed(() => {
      const footerCellOpts = Object.assign({}, getConfig2().table.footerCellConfig, props.footerCellConfig);
      const cellOpts = computeCellOpts.value;
      footerCellOpts.height = import_xe_utils9.default.toNumber(getCellHeight(footerCellOpts.height || cellOpts.height));
      return footerCellOpts;
    });
    const computeRowOpts = computed(() => {
      return Object.assign({}, getConfig2().table.rowConfig, props.rowConfig);
    });
    const computeRowGroupOpts = computed(() => {
      return Object.assign({}, getConfig2().table.rowGroupConfig, props.rowGroupConfig);
    });
    const computeCurrentRowOpts = computed(() => {
      return Object.assign({}, getConfig2().table.currentRowConfig, props.currentRowConfig);
    });
    const computeRowDragOpts = computed(() => {
      return Object.assign({}, getConfig2().table.rowDragConfig, props.rowDragConfig);
    });
    const computeColumnDragOpts = computed(() => {
      return Object.assign({}, getConfig2().table.columnDragConfig, props.columnDragConfig);
    });
    const computeResizeOpts = computed(() => {
      return Object.assign({}, getConfig2().table.resizeConfig, props.resizeConfig);
    });
    const computeResizableOpts = computed(() => {
      return Object.assign({}, getConfig2().table.resizableConfig, props.resizableConfig);
    });
    const computeSeqOpts = computed(() => {
      return Object.assign({ startIndex: 0 }, getConfig2().table.seqConfig, props.seqConfig);
    });
    const computeRadioOpts = computed(() => {
      return Object.assign({}, getConfig2().table.radioConfig, props.radioConfig);
    });
    const computeCheckboxOpts = computed(() => {
      return Object.assign({}, getConfig2().table.checkboxConfig, props.checkboxConfig);
    });
    const computeTooltipOpts = computed(() => {
      return Object.assign({}, getConfig2().tooltip, getConfig2().table.tooltipConfig, props.tooltipConfig);
    });
    const computeTableTipConfig = computed(() => {
      const { tooltipStore } = reactData;
      const tooltipOpts = computeTooltipOpts.value;
      return Object.assign({}, tooltipOpts, tooltipStore.currOpts);
    });
    const computeValidTipConfig = computed(() => {
      const tooltipOpts = computeTooltipOpts.value;
      return Object.assign({}, tooltipOpts);
    });
    const computeEditOpts = computed(() => {
      return Object.assign({}, getConfig2().table.editConfig, props.editConfig);
    });
    const computeSortOpts = computed(() => {
      return Object.assign({ orders: ["asc", "desc", null] }, getConfig2().table.sortConfig, props.sortConfig);
    });
    const computeFilterOpts = computed(() => {
      return Object.assign({}, getConfig2().table.filterConfig, props.filterConfig);
    });
    const computeMouseOpts = computed(() => {
      return Object.assign({}, getConfig2().table.mouseConfig, props.mouseConfig);
    });
    const computeAreaOpts = computed(() => {
      return Object.assign({}, getConfig2().table.areaConfig, props.areaConfig);
    });
    const computeKeyboardOpts = computed(() => {
      return Object.assign({}, getConfig2().table.keyboardConfig, props.keyboardConfig);
    });
    const computeClipOpts = computed(() => {
      return Object.assign({}, getConfig2().table.clipConfig, props.clipConfig);
    });
    const computeFNROpts = computed(() => {
      return Object.assign({}, getConfig2().table.fnrConfig, props.fnrConfig);
    });
    const computeMenuOpts = computed(() => {
      return Object.assign({}, getConfig2().table.menuConfig, props.menuConfig);
    });
    const computeLeftFixedWidth = computed(() => {
      const { columnStore } = reactData;
      const { leftList } = columnStore;
      let leftWidth = 0;
      for (let i = 0; i < leftList.length; i++) {
        const column = leftList[i];
        leftWidth += column.renderWidth;
      }
      return leftWidth;
    });
    const computeRightFixedWidth = computed(() => {
      const { columnStore } = reactData;
      const { rightList } = columnStore;
      let leftWidth = 0;
      for (let i = 0; i < rightList.length; i++) {
        const column = rightList[i];
        leftWidth += column.renderWidth;
      }
      return leftWidth;
    });
    const computeHeaderMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const headerOpts = menuOpts.header;
      return headerOpts && headerOpts.options ? headerOpts.options : [];
    });
    const computeBodyMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const bodyOpts = menuOpts.body;
      return bodyOpts && bodyOpts.options ? bodyOpts.options : [];
    });
    const computeFooterMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const footerOpts = menuOpts.footer;
      return footerOpts && footerOpts.options ? footerOpts.options : [];
    });
    const computeIsMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const headerMenu = computeHeaderMenu.value;
      const bodyMenu = computeBodyMenu.value;
      const footerMenu = computeFooterMenu.value;
      return !!(props.menuConfig && isEnableConf(menuOpts) && (headerMenu.length || bodyMenu.length || footerMenu.length));
    });
    const computeMenuList = computed(() => {
      const { ctxMenuStore } = reactData;
      const rest = [];
      ctxMenuStore.list.forEach((list) => {
        list.forEach((item) => {
          rest.push(item);
        });
      });
      return rest;
    });
    const computeExportOpts = computed(() => {
      return Object.assign({}, getConfig2().table.exportConfig, props.exportConfig);
    });
    const computeImportOpts = computed(() => {
      return Object.assign({}, getConfig2().table.importConfig, props.importConfig);
    });
    const computePrintOpts = computed(() => {
      return Object.assign({}, getConfig2().table.printConfig, props.printConfig);
    });
    const computeExpandOpts = computed(() => {
      return Object.assign({}, getConfig2().table.expandConfig, props.expandConfig);
    });
    const computeTreeOpts = computed(() => {
      return Object.assign({}, getConfig2().table.treeConfig, props.treeConfig);
    });
    const computeEmptyOpts = computed(() => {
      return Object.assign({}, getConfig2().table.emptyRender, props.emptyRender);
    });
    const computeLoadingOpts = computed(() => {
      return Object.assign({}, getConfig2().table.loadingConfig, props.loadingConfig);
    });
    const computeCellOffsetWidth = computed(() => {
      return props.border ? Math.max(2, Math.ceil(reactData.scrollbarWidth / reactData.tableColumn.length)) : 1;
    });
    const computeCustomOpts = computed(() => {
      return Object.assign({}, getConfig2().table.customConfig, props.customConfig);
    });
    const computeTableRowExpandedList = computed(() => {
      const { treeConfig } = props;
      const { rowExpandedFlag, expandColumn, rowGroupExpandedFlag, treeExpandedFlag, isRowGroupStatus } = reactData;
      const { visibleDataRowIdData, rowExpandedMaps } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { transform } = treeOpts;
      const expandList = [];
      if (expandColumn && rowExpandedFlag && rowGroupExpandedFlag && treeExpandedFlag) {
        if (isRowGroupStatus || treeConfig && transform) {
          import_xe_utils9.default.each(rowExpandedMaps, (row, rowid) => {
            if (visibleDataRowIdData[rowid]) {
              expandList.push(row);
            }
          });
        } else {
          return import_xe_utils9.default.values(rowExpandedMaps);
        }
      }
      return expandList;
    });
    const computeAutoWidthColumnList = computed(() => {
      const { visibleColumn } = internalData;
      const { tableColumn } = reactData;
      return tableColumn.length || visibleColumn.length ? visibleColumn.filter((column) => column.width === "auto" || column.minWidth === "auto") : [];
    });
    const computeFixedColumnSize = computed(() => {
      const { tableColumn } = reactData;
      const { collectColumn } = internalData;
      let fixedSize = 0;
      if (tableColumn.length && collectColumn.length) {
        collectColumn.forEach((column) => {
          if (column.renderFixed) {
            fixedSize++;
          }
        });
      }
      return fixedSize;
    });
    const computeIsMaxFixedColumn = computed(() => {
      const fixedColumnSize = computeFixedColumnSize.value;
      const columnOpts = computeColumnOpts.value;
      const { maxFixedSize } = columnOpts;
      if (maxFixedSize) {
        return fixedColumnSize >= maxFixedSize;
      }
      return false;
    });
    const computeTableBorder = computed(() => {
      const { border } = props;
      if (border === true) {
        return "full";
      }
      if (border) {
        return border;
      }
      return "default";
    });
    const computeIsAllCheckboxDisabled = computed(() => {
      const { treeConfig } = props;
      const { tableData } = reactData;
      const { tableFullData } = internalData;
      const checkboxOpts = computeCheckboxOpts.value;
      const { strict, checkMethod } = checkboxOpts;
      if (strict) {
        if (tableData.length || tableFullData.length) {
          if (checkMethod) {
            if (treeConfig) {
            }
            return tableFullData.every((row) => !checkMethod({ $table: $xeTable, row }));
          }
          return false;
        }
        return true;
      }
      return false;
    });
    const computeVirtualScrollBars = computed(() => {
      const { overflowX, scrollXLoad, overflowY, scrollYLoad } = reactData;
      return {
        x: overflowX && scrollXLoad,
        y: overflowY && scrollYLoad
      };
    });
    const computeRowGroupFields = computed(() => {
      const rowGroupOpts = computeRowGroupOpts.value;
      return rowGroupOpts.groupFields;
    });
    const refMaps = {
      refElem,
      refTooltip,
      refValidTooltip,
      refTableFilter,
      refTableCustom,
      refTableMenu,
      refTableHeader,
      refTableBody,
      refTableFooter,
      refTableLeftHeader,
      refTableLeftBody,
      refTableLeftFooter,
      refTableRightHeader,
      refTableRightBody,
      refTableRightFooter,
      refLeftContainer,
      refRightContainer,
      refColResizeBar,
      refRowResizeBar,
      refScrollXVirtualElem,
      refScrollYVirtualElem,
      refScrollXHandleElem,
      refScrollYHandleElem,
      refScrollXSpaceElem,
      refScrollYSpaceElem
    };
    const computeMaps = {
      computeSize,
      computeTableId,
      computeValidOpts,
      computeVirtualXOpts,
      computeVirtualYOpts,
      computeScrollbarOpts,
      computeScrollbarXToTop,
      computeScrollbarYToLeft,
      computeColumnOpts,
      computeCurrentColumnOpts,
      computeScrollXThreshold,
      computeScrollYThreshold,
      computeRowHeightMaps,
      computeDefaultRowHeight,
      computeCellOpts,
      computeHeaderCellOpts,
      computeFooterCellOpts,
      computeRowOpts,
      computeRowGroupOpts,
      computeCurrentRowOpts,
      computeRowDragOpts,
      computeColumnDragOpts,
      computeResizeOpts,
      computeResizableOpts,
      computeSeqOpts,
      computeRadioOpts,
      computeCheckboxOpts,
      computeTooltipOpts,
      computeEditOpts,
      computeSortOpts,
      computeFilterOpts,
      computeMouseOpts,
      computeAreaOpts,
      computeKeyboardOpts,
      computeClipOpts,
      computeFNROpts,
      computeHeaderMenu,
      computeBodyMenu,
      computeFooterMenu,
      computeIsMenu,
      computeMenuList,
      computeMenuOpts,
      computeExportOpts,
      computeImportOpts,
      computePrintOpts,
      computeExpandOpts,
      computeTreeOpts,
      computeEmptyOpts,
      computeLoadingOpts,
      computeCellOffsetWidth,
      computeCustomOpts,
      computeLeftFixedWidth,
      computeRightFixedWidth,
      computeFixedColumnSize,
      computeIsMaxFixedColumn,
      computeIsAllCheckboxDisabled,
      computeVirtualScrollBars,
      computeSXOpts,
      computeSYOpts
    };
    const $xeTable = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps,
      xeGrid: $xeGrid,
      xegrid: $xeGrid
    };
    const eqCellValue = (row1, row2, field) => {
      const val1 = import_xe_utils9.default.get(row1, field);
      const val2 = import_xe_utils9.default.get(row2, field);
      if (eqEmptyValue(val1) && eqEmptyValue(val2)) {
        return true;
      }
      if (import_xe_utils9.default.isString(val1) || import_xe_utils9.default.isNumber(val1)) {
        return "" + val1 === "" + val2;
      }
      return import_xe_utils9.default.isEqual(val1, val2);
    };
    const getNextSortOrder = (column) => {
      const sortOpts = computeSortOpts.value;
      const { orders } = sortOpts;
      const currOrder = column.order || null;
      const oIndex = orders.indexOf(currOrder) + 1;
      return orders[oIndex < orders.length ? oIndex : 0];
    };
    const getCustomStorageMap = (id) => {
      const version = getConfig2().version;
      const rest = import_xe_utils9.default.toStringJSON(localStorage.getItem(customStorageKey) || "");
      const maps = rest && rest._v === version ? rest : { _v: version };
      return (id ? maps[id] : maps) || {};
    };
    const setCustomStorageMap = (id, data) => {
      const version = getConfig2().version;
      const maps = getCustomStorageMap();
      maps[id] = data || void 0;
      maps._v = version;
      localStorage.setItem(customStorageKey, import_xe_utils9.default.toJSONString(maps));
    };
    const getRecoverRowMaps = (keyMaps) => {
      const { fullAllDataRowIdData } = internalData;
      const restKeys = {};
      import_xe_utils9.default.each(keyMaps, (row, rowid) => {
        if (fullAllDataRowIdData[rowid]) {
          restKeys[rowid] = row;
        }
      });
      return restKeys;
    };
    const handleReserveRow = (reserveRowMap) => {
      const { fullDataRowIdData } = internalData;
      const reserveList = [];
      import_xe_utils9.default.each(reserveRowMap, (item, rowid) => {
        if (fullDataRowIdData[rowid] && $xeTable.findRowIndexOf(reserveList, fullDataRowIdData[rowid].row) === -1) {
          reserveList.push(fullDataRowIdData[rowid].row);
        }
      });
      return reserveList;
    };
    const handleVirtualXVisible = () => {
      const { isScrollXBig, scrollXWidth } = reactData;
      const { elemStore, visibleColumn, fullColumnIdData } = internalData;
      const leftFixedWidth = computeLeftFixedWidth.value;
      const rightFixedWidth = computeRightFixedWidth.value;
      const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
      if (bodyScrollElem) {
        const clientWidth = bodyScrollElem.clientWidth;
        let scrollLeft = bodyScrollElem.scrollLeft;
        if (isScrollXBig) {
          scrollLeft = Math.ceil((scrollXWidth - clientWidth) * Math.min(1, scrollLeft / (maxXWidth - clientWidth)));
        }
        const startLeft = scrollLeft + leftFixedWidth;
        const endLeft = scrollLeft + clientWidth - rightFixedWidth;
        let leftIndex = 0;
        let rightIndex = visibleColumn.length;
        while (leftIndex < rightIndex) {
          const cIndex = Math.floor((leftIndex + rightIndex) / 2);
          const column = visibleColumn[cIndex];
          const colid = column.id;
          const colRest = fullColumnIdData[colid] || {};
          if (colRest.oLeft <= startLeft) {
            leftIndex = cIndex + 1;
          } else {
            rightIndex = cIndex;
          }
        }
        let visibleSize = 0;
        const toVisibleIndex = Math.max(0, leftIndex < visibleColumn.length ? leftIndex - 2 : 0);
        for (let cIndex = toVisibleIndex, cLen = visibleColumn.length; cIndex < cLen; cIndex++) {
          const column = visibleColumn[cIndex];
          const colid = column.id;
          const colRest = fullColumnIdData[colid] || {};
          visibleSize++;
          if (colRest.oLeft > endLeft || visibleSize >= 60) {
            break;
          }
        }
        return { toVisibleIndex: Math.max(0, toVisibleIndex), visibleSize: Math.max(1, visibleSize) };
      }
      return { toVisibleIndex: 0, visibleSize: 6 };
    };
    const calcVarRowHeightConfig = (sizeKey, sizeEl) => {
      const { rowHeightStore } = reactData;
      if (sizeEl && sizeEl.clientHeight) {
        rowHeightStore[sizeKey] = sizeEl.clientHeight;
      }
    };
    const computeRowHeight = () => {
      const { isAllOverflow } = reactData;
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableBodyElem = tableBody ? tableBody.$el : null;
      const defaultRowHeight = computeDefaultRowHeight.value;
      let rowHeight = 0;
      if (isAllOverflow) {
        if (tableBodyElem) {
          const tableHeaderElem = tableHeader ? tableHeader.$el : null;
          let firstTrElem;
          firstTrElem = tableBodyElem.querySelector("tr");
          if (!firstTrElem && tableHeaderElem) {
            firstTrElem = tableHeaderElem.querySelector("tr");
          }
          if (firstTrElem) {
            rowHeight = firstTrElem.clientHeight;
          }
        }
        if (!rowHeight) {
          rowHeight = defaultRowHeight;
        }
      } else {
        rowHeight = defaultRowHeight;
      }
      return Math.max(18, rowHeight);
    };
    const handleVirtualYVisible = () => {
      const { isAllOverflow, expandColumn, isScrollYBig, scrollYHeight } = reactData;
      const { elemStore, isResizeCellHeight, afterFullData, fullAllDataRowIdData } = internalData;
      const rowOpts = computeRowOpts.value;
      const cellOpts = computeCellOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
      if (bodyScrollElem) {
        const clientHeight = bodyScrollElem.clientHeight;
        let scrollTop = bodyScrollElem.scrollTop;
        if (isScrollYBig) {
          scrollTop = Math.ceil((scrollYHeight - clientHeight) * Math.min(1, scrollTop / (maxYHeight - clientHeight)));
        }
        const startTop = scrollTop;
        const endTop = scrollTop + clientHeight;
        let toVisibleIndex = -1;
        let visibleSize = 0;
        const isCustomCellHeight = isResizeCellHeight || cellOpts.height || rowOpts.height;
        if (!isCustomCellHeight && !expandColumn && isAllOverflow) {
          toVisibleIndex = Math.floor(startTop / defaultRowHeight) - 1;
          visibleSize = Math.ceil(clientHeight / defaultRowHeight) + 1;
        } else {
          const { handleGetRowId } = createHandleGetRowId($xeTable);
          let leftIndex = 0;
          let rightIndex = afterFullData.length;
          while (leftIndex < rightIndex) {
            const rIndex = Math.floor((leftIndex + rightIndex) / 2);
            const row = afterFullData[rIndex];
            const rowid = handleGetRowId(row);
            const rowRest = fullAllDataRowIdData[rowid] || {};
            if (rowRest.oTop <= startTop) {
              leftIndex = rIndex + 1;
            } else {
              rightIndex = rIndex;
            }
          }
          toVisibleIndex = Math.max(0, leftIndex < afterFullData.length ? leftIndex - 2 : 0);
          for (let rIndex = toVisibleIndex, rLen = afterFullData.length; rIndex < rLen; rIndex++) {
            const row = afterFullData[rIndex];
            const rowid = handleGetRowId(row);
            const rowRest = fullAllDataRowIdData[rowid] || {};
            visibleSize++;
            if (rowRest.oTop > endTop || visibleSize >= 100) {
              break;
            }
          }
        }
        return { toVisibleIndex: Math.max(0, toVisibleIndex), visibleSize: Math.max(6, visibleSize) };
      }
      return { toVisibleIndex: 0, visibleSize: 6 };
    };
    const calculateMergerOffsetIndex = (list, offsetItem, type) => {
      for (let mcIndex = 0, len = list.length; mcIndex < len; mcIndex++) {
        const mergeItem = list[mcIndex];
        const { startIndex, endIndex } = offsetItem;
        const mergeStartIndex = mergeItem[type];
        const mergeSpanNumber = mergeItem[type + "span"];
        const mergeEndIndex = mergeStartIndex + mergeSpanNumber;
        if (mergeStartIndex < startIndex && startIndex < mergeEndIndex) {
          offsetItem.startIndex = mergeStartIndex;
        }
        if (mergeStartIndex < endIndex && endIndex < mergeEndIndex) {
          offsetItem.endIndex = mergeEndIndex;
        }
        if (offsetItem.startIndex !== startIndex || offsetItem.endIndex !== endIndex) {
          mcIndex = -1;
        }
      }
    };
    function buildMergeData(mergeConfigs) {
      const mergeMaps = {};
      if (mergeConfigs && mergeConfigs.length) {
        for (let mIndex = 0; mIndex < mergeConfigs.length; mIndex++) {
          const { row: _rowIndex, col: _columnIndex, rowspan: mergeRowspan, colspan: mergeColspan } = mergeConfigs[mIndex];
          for (let i = 0; i < mergeRowspan; i++) {
            for (let j = 0; j < mergeColspan; j++) {
              mergeMaps[`${_rowIndex + i}:${_columnIndex + j}`] = !i && !j ? {
                rowspan: mergeRowspan,
                colspan: mergeColspan
              } : {
                rowspan: 0,
                colspan: 0
              };
            }
          }
        }
      }
      return mergeMaps;
    }
    const handleBodyMerge = (merges) => {
      const { fullAllDataRowIdData, fullColumnIdData, visibleColumn, afterFullData, mergeBodyList, mergeBodyMaps } = internalData;
      if (merges) {
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        if (!import_xe_utils9.default.isArray(merges)) {
          merges = [merges];
        }
        merges.forEach((item) => {
          let { row: margeRow, col: margeCol, rowspan, colspan } = item;
          let mergeRowIndex = -1;
          let mergeColumnIndex = -1;
          if (import_xe_utils9.default.isNumber(margeRow)) {
            mergeRowIndex = margeRow;
          } else {
            const rowid = margeRow ? handleGetRowId(margeRow) : null;
            const rowRest = rowid ? fullAllDataRowIdData[rowid] : null;
            if (rowRest) {
              mergeRowIndex = rowRest._index;
            }
          }
          if (import_xe_utils9.default.isNumber(margeCol)) {
            mergeColumnIndex = margeCol;
          } else {
            const colid = margeCol ? margeCol.id : null;
            const colRest = colid ? fullColumnIdData[colid] : null;
            if (colRest) {
              mergeColumnIndex = colRest._index;
            }
          }
          if (mergeRowIndex > -1 && mergeColumnIndex > -1 && (rowspan || colspan)) {
            rowspan = import_xe_utils9.default.toNumber(rowspan) || 1;
            colspan = import_xe_utils9.default.toNumber(colspan) || 1;
            if (rowspan > 1 || colspan > 1) {
              const row = afterFullData[mergeRowIndex];
              const column = visibleColumn[mergeColumnIndex];
              let mergeItem = mergeBodyMaps[`${mergeRowIndex}:${mergeColumnIndex}`];
              if (mergeItem) {
                mergeItem.rowspan = rowspan;
                mergeItem.colspan = colspan;
                mergeItem._rowspan = rowspan;
                mergeItem._colspan = colspan;
              } else {
                mergeItem = {
                  row: mergeRowIndex,
                  col: mergeColumnIndex,
                  rowspan,
                  colspan,
                  _row: row,
                  _col: column,
                  _rowspan: rowspan,
                  _colspan: colspan
                };
                mergeBodyMaps[`${mergeRowIndex}:${mergeColumnIndex}`] = mergeItem;
                mergeBodyList.push(mergeItem);
              }
            }
          }
        });
      }
    };
    const handleFooterMerge = (merges) => {
      const { footerTableData } = reactData;
      const { mergeFooterList, mergeFooterMaps } = internalData;
      if (merges) {
        const { visibleColumn } = internalData;
        if (!import_xe_utils9.default.isArray(merges)) {
          merges = [merges];
        }
        merges.forEach((item) => {
          let { row: margeRow, col: margeCol, rowspan, colspan } = item;
          const mergeRowIndex = import_xe_utils9.default.isNumber(margeRow) ? margeRow : -1;
          let mergeColumnIndex = -1;
          if (import_xe_utils9.default.isNumber(margeCol)) {
            mergeColumnIndex = margeCol;
          }
          if (mergeRowIndex > -1 && mergeColumnIndex > -1 && (rowspan || colspan)) {
            rowspan = import_xe_utils9.default.toNumber(rowspan) || 1;
            colspan = import_xe_utils9.default.toNumber(colspan) || 1;
            if (rowspan > 1 || colspan > 1) {
              const row = footerTableData[mergeRowIndex];
              const column = visibleColumn[mergeColumnIndex];
              let mergeItem = mergeFooterMaps[`${mergeRowIndex}:${mergeColumnIndex}`];
              if (mergeItem) {
                mergeItem.rowspan = rowspan;
                mergeItem.colspan = colspan;
                mergeItem._rowspan = rowspan;
                mergeItem._colspan = colspan;
              } else {
                mergeItem = {
                  row: mergeRowIndex,
                  col: mergeColumnIndex,
                  rowspan,
                  colspan,
                  _row: row,
                  _col: column,
                  _rowspan: rowspan,
                  _colspan: colspan
                };
                mergeFooterMaps[`${mergeRowIndex}:${mergeColumnIndex}`] = mergeItem;
                mergeFooterList.push(mergeItem);
              }
            }
          }
        });
      }
    };
    const removeMerges = (merges, mList, rowList) => {
      const rest = [];
      if (merges) {
        const { visibleColumn } = internalData;
        if (!import_xe_utils9.default.isArray(merges)) {
          merges = [merges];
        }
        merges.forEach((item) => {
          let { row, col } = item;
          if (rowList && import_xe_utils9.default.isNumber(row)) {
            row = rowList[row];
          }
          if (import_xe_utils9.default.isNumber(col)) {
            col = visibleColumn[col];
          }
          const mcIndex = import_xe_utils9.default.findIndexOf(mList, (item2) => (item2._row === row || getRowid($xeTable, item2._row) === getRowid($xeTable, row)) && (item2._col.id === col || item2._col.id === col.id));
          if (mcIndex > -1) {
            const rItems = mList.splice(mcIndex, 1);
            rest.push(rItems[0]);
          }
        });
      }
      return rest;
    };
    const clearAllSort = () => {
      const { tableFullColumn } = internalData;
      tableFullColumn.forEach((column) => {
        column.order = null;
      });
    };
    const calcTableHeight = (key) => {
      const { parentHeight } = reactData;
      const val = props[key];
      let num = 0;
      if (val) {
        if (val === "100%" || val === "auto") {
          num = parentHeight;
        } else {
          const excludeHeight = $xeTable.getExcludeHeight();
          if (isScale(val)) {
            num = Math.floor((import_xe_utils9.default.toInteger(val) || 1) / 100 * parentHeight);
          } else {
            num = import_xe_utils9.default.toNumber(val);
          }
          num = Math.max(40, num - excludeHeight);
        }
      }
      return num;
    };
    const handleCustomRestore = (storeData) => {
      let { collectColumn } = internalData;
      const { resizableData, sortData, visibleData, fixedData } = storeData;
      let hasCustomSort = false;
      if (resizableData || sortData || visibleData || fixedData) {
        import_xe_utils9.default.eachTree(collectColumn, (column, index, items, path, parentColumn) => {
          const colKey = column.getKey();
          if (!parentColumn) {
            if (fixedData && fixedData[colKey] !== void 0) {
              column.fixed = fixedData[colKey];
            }
            if (sortData && import_xe_utils9.default.isNumber(sortData[colKey])) {
              hasCustomSort = true;
              column.renderSortNumber = sortData[colKey];
            }
          }
          if (resizableData && import_xe_utils9.default.isNumber(resizableData[colKey])) {
            column.resizeWidth = resizableData[colKey];
          }
          if (visibleData && import_xe_utils9.default.isBoolean(visibleData[colKey])) {
            column.visible = visibleData[colKey];
          }
        });
        if (hasCustomSort) {
          collectColumn = import_xe_utils9.default.orderBy(collectColumn, "renderSortNumber");
          internalData.collectColumn = collectColumn;
          internalData.tableFullColumn = getColumnList(collectColumn);
        }
        reactData.isCustomStatus = true;
      } else {
        reactData.isCustomStatus = false;
      }
    };
    const restoreCustomStorage = () => {
      const { customConfig } = props;
      const tableId = computeTableId.value;
      const customOpts = computeCustomOpts.value;
      const { storage, restoreStore } = customOpts;
      const isAllCustom = storage === true;
      const storageOpts = isAllCustom ? {} : Object.assign({}, storage || {});
      const isCustomResizable = isAllCustom || storageOpts.resizable;
      const isCustomVisible = isAllCustom || storageOpts.visible;
      const isCustomFixed = isAllCustom || storageOpts.fixed;
      const isCustomSort = isAllCustom || storageOpts.sort;
      if ((customConfig ? isEnableConf(customOpts) : customOpts.enabled) && (isCustomResizable || isCustomVisible || isCustomFixed || isCustomSort)) {
        if (!tableId) {
          errLog("vxe.error.reqProp", ["id"]);
          return;
        }
        const storeData = getCustomStorageMap(tableId);
        if (restoreStore) {
          return Promise.resolve(restoreStore({ $table: $xeTable, id: tableId, type: "restore", storeData })).then((storeData2) => {
            if (!storeData2) {
              return;
            }
            return handleCustomRestore(storeData2);
          }).catch((e) => e);
        } else {
          return handleCustomRestore(storeData);
        }
      }
    };
    const cacheColumnMap = () => {
      const { tableFullColumn, collectColumn } = internalData;
      const fullColumnIdData = internalData.fullColumnIdData = {};
      const fullColumnFieldData = internalData.fullColumnFieldData = {};
      const mouseOpts = computeMouseOpts.value;
      const expandOpts = computeExpandOpts.value;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const virtualYOpts = computeVirtualYOpts.value;
      const { isCrossDrag, isSelfToChildDrag } = columnDragOpts;
      const customOpts = computeCustomOpts.value;
      const { storage } = customOpts;
      const rowOpts = computeRowOpts.value;
      const isGroup = collectColumn.some(hasChildrenList);
      let isAllOverflow = !!props.showOverflow;
      let rowGroupColumn;
      let expandColumn;
      let treeNodeColumn;
      let checkboxColumn;
      let radioColumn;
      let htmlColumn;
      let hasFixed;
      const handleFunc = (column, index, items, path, parentColumn) => {
        const { id: colid, field, fixed, type, treeNode, rowGroupNode } = column;
        const rest = { $index: -1, _index: -1, column, colid, index, items, parent: parentColumn || null, width: 0, oLeft: 0 };
        if (field) {
          if (fullColumnFieldData[field]) {
            errLog("vxe.error.colRepet", ["field", field]);
          }
          fullColumnFieldData[field] = rest;
        } else {
          if (storage && !type || columnOpts.drag && (isCrossDrag || isSelfToChildDrag)) {
            errLog("vxe.error.reqProp", [`${column.getTitle() || type || ""} -> column.field=?`]);
          }
        }
        if (!hasFixed && fixed) {
          hasFixed = fixed;
        }
        if (!htmlColumn && type === "html") {
          htmlColumn = column;
        }
        if (treeNode) {
          if (treeNodeColumn) {
            warnLog("vxe.error.colRepet", ["tree-node", treeNode]);
          }
          if (!treeNodeColumn) {
            treeNodeColumn = column;
          }
        }
        if (rowGroupNode) {
          if (treeNodeColumn) {
            warnLog("vxe.error.colRepet", ["row-group-node", rowGroupNode]);
          }
          if (!rowGroupColumn) {
            rowGroupColumn = column;
          }
        }
        if (type === "expand") {
          if (expandColumn) {
            warnLog("vxe.error.colRepet", ["type", type]);
          }
          if (!expandColumn) {
            expandColumn = column;
          }
        }
        if (type === "checkbox") {
          if (checkboxColumn) {
            warnLog("vxe.error.colRepet", ["type", type]);
          }
          if (!checkboxColumn) {
            checkboxColumn = column;
          }
        } else if (type === "radio") {
          if (radioColumn) {
            warnLog("vxe.error.colRepet", ["type", type]);
          }
          if (!radioColumn) {
            radioColumn = column;
          }
        }
        if (isAllOverflow && column.showOverflow === false) {
          isAllOverflow = false;
        }
        if (fullColumnIdData[colid]) {
          errLog("vxe.error.colRepet", ["colId", colid]);
        }
        fullColumnIdData[colid] = rest;
      };
      if (isGroup) {
        import_xe_utils9.default.eachTree(collectColumn, (column, index, items, path, parentColumn, nodes) => {
          column.level = nodes.length;
          handleFunc(column, index, items, path, parentColumn);
        });
      } else {
        tableFullColumn.forEach(handleFunc);
      }
      if (expandColumn && expandOpts.mode !== "fixed" && virtualYOpts.enabled) {
        warnLog("vxe.error.notConflictProp", ['column.type="expand', "virtual-y-config.enabled=false"]);
      }
      if (expandColumn && expandOpts.mode !== "fixed" && mouseOpts.area) {
        errLog("vxe.error.errConflicts", ["mouse-config.area", "column.type=expand"]);
      }
      if (htmlColumn) {
        if (!columnOpts.useKey) {
          errLog("vxe.error.reqProp", ["column-config.useKey & column.type=html"]);
        }
        if (!rowOpts.useKey) {
          errLog("vxe.error.reqProp", ["row-config.useKey & column.type=html"]);
        }
      }
      reactData.isGroup = isGroup;
      reactData.rowGroupColumn = rowGroupColumn;
      reactData.treeNodeColumn = treeNodeColumn;
      reactData.expandColumn = expandColumn;
      reactData.isAllOverflow = isAllOverflow;
    };
    const updateHeight = () => {
      internalData.customHeight = calcTableHeight("height");
      internalData.customMinHeight = calcTableHeight("minHeight");
      internalData.customMaxHeight = calcTableHeight("maxHeight");
      if (reactData.scrollYLoad && !(internalData.customHeight || internalData.customMinHeight)) {
        internalData.customHeight = 300;
      }
    };
    const calcColumnAutoWidth = (column, wrapperEl) => {
      const cellElemList = wrapperEl.querySelectorAll(`.vxe-cell--wrapper[colid="${column.id}"]`);
      let leftRightPadding = 0;
      const firstCellEl = cellElemList[0];
      if (firstCellEl && firstCellEl.parentElement) {
        const cellStyle = getComputedStyle(firstCellEl.parentElement);
        leftRightPadding = Math.ceil(import_xe_utils9.default.toNumber(cellStyle.paddingLeft) + import_xe_utils9.default.toNumber(cellStyle.paddingRight));
      }
      let colWidth = column.renderAutoWidth - leftRightPadding;
      for (let i = 0; i < cellElemList.length; i++) {
        const celEl = cellElemList[i];
        colWidth = Math.max(colWidth, celEl ? Math.ceil(celEl.scrollWidth) + 4 : 0);
      }
      return colWidth + leftRightPadding;
    };
    const calcCellWidth = () => {
      const autoWidthColumnList = computeAutoWidthColumnList.value;
      const { fullColumnIdData } = internalData;
      const el = refElem.value;
      if (el) {
        el.setAttribute("data-calc-col", "Y");
        autoWidthColumnList.forEach((column) => {
          const colid = column.id;
          const colRest = fullColumnIdData[colid];
          const colWidth = calcColumnAutoWidth(column, el);
          if (colRest) {
            colRest.width = Math.max(colWidth, colRest.width);
          }
          column.renderAutoWidth = colWidth;
        });
        $xeTable.analyColumnWidth();
        el.removeAttribute("data-calc-col");
      }
    };
    const autoCellWidth = () => {
      const { elemStore } = internalData;
      const bodyWrapperElem = getRefElem(elemStore["main-body-wrapper"]);
      if (!bodyWrapperElem) {
        return;
      }
      const yHandleEl = refScrollYHandleElem.value;
      if (!yHandleEl) {
        return;
      }
      const xHandleEl = refScrollXHandleElem.value;
      if (!xHandleEl) {
        return;
      }
      let tWidth = 0;
      const minCellWidth = 40;
      const bodyWidth = bodyWrapperElem.clientWidth;
      let remainWidth = bodyWidth;
      let meanWidth = remainWidth / 100;
      const { fit } = props;
      const { columnStore } = reactData;
      const { resizeList, pxMinList, autoMinList, pxList, scaleList, scaleMinList, autoList, remainList } = columnStore;
      pxMinList.forEach((column) => {
        const minWidth = import_xe_utils9.default.toInteger(column.minWidth);
        tWidth += minWidth;
        column.renderWidth = minWidth;
      });
      autoMinList.forEach((column) => {
        const caWidth = Math.max(60, import_xe_utils9.default.toInteger(column.renderAutoWidth));
        tWidth += caWidth;
        column.renderWidth = caWidth;
      });
      scaleMinList.forEach((column) => {
        const smWidth = Math.floor(import_xe_utils9.default.toInteger(column.minWidth) * meanWidth);
        tWidth += smWidth;
        column.renderWidth = smWidth;
      });
      scaleList.forEach((column) => {
        const sfWidth = Math.floor(import_xe_utils9.default.toInteger(column.width) * meanWidth);
        tWidth += sfWidth;
        column.renderWidth = sfWidth;
      });
      pxList.forEach((column) => {
        const pWidth = import_xe_utils9.default.toInteger(column.width);
        tWidth += pWidth;
        column.renderWidth = pWidth;
      });
      autoList.forEach((column) => {
        const aWidth = Math.max(60, import_xe_utils9.default.toInteger(column.renderAutoWidth));
        tWidth += aWidth;
        column.renderWidth = aWidth;
      });
      resizeList.forEach((column) => {
        const reWidth = import_xe_utils9.default.toInteger(column.resizeWidth);
        tWidth += reWidth;
        column.renderWidth = reWidth;
      });
      remainWidth -= tWidth;
      meanWidth = remainWidth > 0 ? Math.floor(remainWidth / (scaleMinList.length + pxMinList.length + autoMinList.length + remainList.length)) : 0;
      if (fit) {
        if (remainWidth > 0) {
          scaleMinList.concat(pxMinList).concat(autoMinList).forEach((column) => {
            tWidth += meanWidth;
            column.renderWidth += meanWidth;
          });
        }
      } else {
        meanWidth = minCellWidth;
      }
      remainList.forEach((column) => {
        const width = Math.max(meanWidth, minCellWidth);
        column.renderWidth = width;
        tWidth += width;
      });
      if (fit) {
        const dynamicList = scaleList.concat(scaleMinList).concat(pxMinList).concat(autoMinList).concat(remainList);
        let dynamicSize = dynamicList.length - 1;
        if (dynamicSize > 0) {
          let i = bodyWidth - tWidth;
          if (i > 0) {
            while (i > 0 && dynamicSize >= 0) {
              i--;
              dynamicList[dynamicSize--].renderWidth++;
            }
            tWidth = bodyWidth;
          }
        }
      }
      reactData.scrollXWidth = tWidth;
      reactData.resizeWidthFlag++;
      updateColumnOffsetLeft();
      updateHeight();
    };
    const calcCellAutoHeight = (rowRest, wrapperEl) => {
      const cellElemList = wrapperEl.querySelectorAll(`.vxe-cell--wrapper[rowid="${rowRest.rowid}"]`);
      let colHeight = rowRest.height;
      for (let i = 0; i < cellElemList.length; i++) {
        const cellElem = cellElemList[i];
        const tdEl = cellElem.parentElement;
        const topBottomPadding = Math.ceil(import_xe_utils9.default.toNumber(tdEl.style.paddingTop) + import_xe_utils9.default.toNumber(tdEl.style.paddingBottom));
        const cellHeight = cellElem ? cellElem.clientHeight : 0;
        colHeight = Math.max(colHeight - topBottomPadding, Math.ceil(cellHeight));
      }
      return colHeight;
    };
    const calcCellHeight = () => {
      const { tableData, isAllOverflow, scrollYLoad, scrollXLoad } = reactData;
      const { fullAllDataRowIdData } = internalData;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const el = refElem.value;
      if (!isAllOverflow && scrollYLoad && el) {
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        el.setAttribute("data-calc-row", "Y");
        tableData.forEach((row) => {
          const rowid = handleGetRowId(row);
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            const reHeight = calcCellAutoHeight(rowRest, el);
            rowRest.height = Math.max(defaultRowHeight, scrollXLoad ? Math.max(rowRest.height, reHeight) : reHeight);
          }
          el.removeAttribute("data-calc-row");
        });
        reactData.calcCellHeightFlag++;
      }
    };
    const getOrderField = (column) => {
      const { sortBy, sortType } = column;
      return (row) => {
        let cellValue;
        if (sortBy) {
          cellValue = import_xe_utils9.default.isFunction(sortBy) ? sortBy({ row, column }) : import_xe_utils9.default.get(row, sortBy);
        } else {
          cellValue = tableMethods.getCellLabel(row, column);
        }
        if (!sortType || sortType === "auto") {
          return isNaN(cellValue) ? cellValue : import_xe_utils9.default.toNumber(cellValue);
        } else if (sortType === "number") {
          return import_xe_utils9.default.toNumber(cellValue);
        } else if (sortType === "string") {
          return import_xe_utils9.default.toValueString(cellValue);
        }
        return cellValue;
      };
    };
    const updateAfterListIndex = () => {
      const { treeConfig } = props;
      const { afterFullData, fullDataRowIdData, fullAllDataRowIdData } = internalData;
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      const fullMaps = {};
      afterFullData.forEach((row, index) => {
        const rowid = handleGetRowId(row);
        const rowRest = fullAllDataRowIdData[rowid];
        const seq = index + 1;
        if (rowRest) {
          if (!treeConfig) {
            rowRest.seq = seq;
          }
          rowRest._index = index;
        } else {
          const rest = { row, rowid, seq, index: -1, $index: -1, _index: index, treeIndex: -1, items: [], parent: null, level: 0, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
          fullAllDataRowIdData[rowid] = rest;
          fullDataRowIdData[rowid] = rest;
        }
        fullMaps[rowid] = row;
      });
      internalData.afterFullRowMaps = fullMaps;
    };
    const updateAfterDataIndex = () => {
      const { treeConfig } = props;
      const { fullDataRowIdData, fullAllDataRowIdData, afterTreeFullData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { transform } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const fullMaps = {};
      if (treeConfig) {
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        import_xe_utils9.default.eachTree(afterTreeFullData, (row, index, items, path) => {
          const rowid = handleGetRowId(row);
          const rowRest = fullAllDataRowIdData[rowid];
          const seq = path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : ".").join("");
          if (rowRest) {
            rowRest.seq = seq;
            rowRest.treeIndex = index;
          } else {
            const rest = { row, rowid, seq, index: -1, $index: -1, _index: -1, treeIndex: -1, items: [], parent: null, level: 0, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
            fullAllDataRowIdData[rowid] = rest;
            fullDataRowIdData[rowid] = rest;
          }
          fullMaps[rowid] = row;
        }, { children: transform ? treeOpts.mapChildrenField : childrenField });
        internalData.afterFullRowMaps = fullMaps;
        updateAfterListIndex();
      } else {
        updateAfterListIndex();
      }
    };
    const handleVirtualTreeToList = () => {
      const { treeConfig } = props;
      const { isRowGroupStatus } = reactData;
      const { fullAllDataRowIdData, treeExpandedMaps, rowGroupExpandedMaps } = internalData;
      const rowGroupOpts = computeRowGroupOpts.value;
      const treeOpts = computeTreeOpts.value;
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      const fullData = [];
      const expandMaps = {};
      if (treeConfig && treeOpts.transform) {
        const childrenField = treeOpts.children || treeOpts.childrenField;
        import_xe_utils9.default.eachTree(internalData.afterTreeFullData, (row, index, items, path, parentRow) => {
          const rowid = handleGetRowId(row);
          const parentRowid = handleGetRowId(parentRow);
          if (!parentRow || expandMaps[parentRowid] && treeExpandedMaps[parentRowid]) {
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              rowRest._index = fullData.length;
            }
            expandMaps[rowid] = 1;
            fullData.push(row);
          }
        }, { children: childrenField });
        internalData.afterFullData = fullData;
        updateScrollYStatus(fullData);
        return fullData;
      } else if (isRowGroupStatus) {
        const { childrenField } = rowGroupOpts;
        import_xe_utils9.default.eachTree(internalData.afterGroupFullData, (row, index, items, path, parentRow) => {
          const rowid = handleGetRowId(row);
          const parentRowid = handleGetRowId(parentRow);
          if (!parentRow || expandMaps[parentRowid] && rowGroupExpandedMaps[parentRowid]) {
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              rowRest._index = fullData.length;
            }
            expandMaps[rowid] = 1;
            fullData.push(row);
          }
        }, { children: childrenField });
        internalData.afterFullData = fullData;
        updateScrollYStatus(fullData);
        return fullData;
      }
      return internalData.afterFullData;
    };
    const updateAfterFullData = () => {
      const { treeConfig } = props;
      const { isRowGroupStatus } = reactData;
      const { tableFullColumn, tableFullData, tableFullTreeData, tableFullGroupData } = internalData;
      const filterOpts = computeFilterOpts.value;
      const sortOpts = computeSortOpts.value;
      const rowGroupOpts = computeRowGroupOpts.value;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const { transform, rowField, parentField, mapChildrenField } = treeOpts;
      const { isEvery, remote: allRemoteFilter, filterMethod: allFilterMethod } = filterOpts;
      const { remote: allRemoteSort, sortMethod: allSortMethod, multiple: sortMultiple, chronological } = sortOpts;
      let tableData = [];
      let tableTree = [];
      if (!allRemoteFilter || !allRemoteSort) {
        const filterColumns = [];
        let orderColumns = [];
        tableFullColumn.forEach((column) => {
          const { field, sortable, order, filters } = column;
          if (!allRemoteFilter && filters && filters.length) {
            const valueList = [];
            const itemList = [];
            filters.forEach((item) => {
              if (item.checked) {
                itemList.push(item);
                valueList.push(item.value);
              }
            });
            if (itemList.length) {
              filterColumns.push({ column, valueList, itemList });
            }
          }
          if (!allRemoteSort && sortable && order) {
            orderColumns.push({ column, field, property: field, order, sortTime: column.sortTime });
          }
        });
        if (sortMultiple && chronological && orderColumns.length > 1) {
          orderColumns = import_xe_utils9.default.orderBy(orderColumns, "sortTime");
        }
        if (!allRemoteFilter && filterColumns.length) {
          const handleFilter = (row) => {
            return filterColumns.every(({ column, valueList, itemList }) => {
              const { filterMethod, filterRender } = column;
              const compConf = isEnableConf(filterRender) ? renderer5.get(filterRender.name) : null;
              const compFilterMethod = compConf ? compConf.tableFilterMethod || compConf.filterMethod : null;
              const tdFilterMethod = compConf ? compConf.tableFilterDefaultMethod || compConf.defaultTableFilterMethod || compConf.defaultFilterMethod : null;
              const cellValue = getCellValue(row, column);
              if (filterMethod) {
                return itemList.some((item) => filterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xeTable }));
              } else if (compFilterMethod) {
                return itemList.some((item) => compFilterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xeTable }));
              } else if (allFilterMethod) {
                return allFilterMethod({ $table: $xeTable, options: itemList, values: valueList, cellValue, row, column });
              } else if (tdFilterMethod) {
                return itemList.some((item) => tdFilterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xeTable }));
              }
              return valueList.indexOf(import_xe_utils9.default.get(row, column.field)) > -1;
            });
          };
          if (isRowGroupStatus) {
            tableTree = import_xe_utils9.default.searchTree(tableFullGroupData, handleFilter, {
              original: true,
              isEvery: true,
              children: rowGroupOpts.mapChildrenField,
              mapChildren: rowGroupOpts.childrenField
            });
            tableData = tableTree;
          } else if (treeConfig && transform) {
            tableTree = import_xe_utils9.default.searchTree(tableFullTreeData, handleFilter, {
              original: true,
              isEvery,
              children: mapChildrenField,
              mapChildren: childrenField
            });
            tableData = tableTree;
          } else {
            tableData = treeConfig ? tableFullTreeData.filter(handleFilter) : tableFullData.filter(handleFilter);
            tableTree = tableData;
          }
        } else {
          if (isRowGroupStatus) {
            tableTree = import_xe_utils9.default.searchTree(tableFullGroupData, () => true, {
              original: true,
              isEvery: true,
              children: rowGroupOpts.mapChildrenField,
              mapChildren: rowGroupOpts.childrenField
            });
            tableData = tableTree;
          } else if (treeConfig && transform) {
            tableTree = import_xe_utils9.default.searchTree(tableFullTreeData, () => true, {
              original: true,
              isEvery,
              children: mapChildrenField,
              mapChildren: childrenField
            });
            tableData = tableTree;
          } else {
            tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);
            tableTree = tableData;
          }
        }
        if (!allRemoteSort && orderColumns.length) {
          if (isRowGroupStatus) {
            if (allSortMethod) {
              const sortRests = allSortMethod({ data: tableTree, sortList: orderColumns, $table: $xeTable });
              tableTree = import_xe_utils9.default.isArray(sortRests) ? sortRests : tableTree;
            } else {
              const treeList = import_xe_utils9.default.toTreeArray(tableTree, {
                key: rowGroupOpts.rowField,
                parentKey: rowGroupOpts.parentField,
                children: rowGroupOpts.mapChildrenField
              });
              tableTree = import_xe_utils9.default.toArrayTree(import_xe_utils9.default.orderBy(treeList, orderColumns.map(({ column, order }) => [getOrderField(column), order])), {
                key: rowGroupOpts.rowField,
                parentKey: rowGroupOpts.parentField,
                children: rowGroupOpts.childrenField,
                mapChildren: rowGroupOpts.mapChildrenField
              });
            }
            tableData = tableTree;
          } else if (treeConfig && transform) {
            if (allSortMethod) {
              const sortRests = allSortMethod({ data: tableTree, sortList: orderColumns, $table: $xeTable });
              tableTree = import_xe_utils9.default.isArray(sortRests) ? sortRests : tableTree;
            } else {
              const treeList = import_xe_utils9.default.toTreeArray(tableTree, {
                children: mapChildrenField
              });
              tableTree = import_xe_utils9.default.toArrayTree(import_xe_utils9.default.orderBy(treeList, orderColumns.map(({ column, order }) => [getOrderField(column), order])), {
                key: rowField,
                parentKey: parentField,
                children: childrenField,
                mapChildren: mapChildrenField
              });
            }
            tableData = tableTree;
          } else {
            if (allSortMethod) {
              const sortRests = allSortMethod({ data: tableData, sortList: orderColumns, $table: $xeTable });
              tableData = import_xe_utils9.default.isArray(sortRests) ? sortRests : tableData;
            } else {
              tableData = import_xe_utils9.default.orderBy(tableData, orderColumns.map(({ column, order }) => [getOrderField(column), order]));
            }
            tableTree = tableData;
          }
        }
      } else {
        if (isRowGroupStatus) {
          tableTree = import_xe_utils9.default.searchTree(tableFullGroupData, () => true, {
            original: true,
            isEvery: true,
            children: rowGroupOpts.mapChildrenField,
            mapChildren: rowGroupOpts.childrenField
          });
          tableData = tableTree;
        } else if (treeConfig && transform) {
          tableTree = import_xe_utils9.default.searchTree(tableFullTreeData, () => true, {
            original: true,
            isEvery,
            children: mapChildrenField,
            mapChildren: childrenField
          });
          tableData = tableTree;
        } else {
          tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);
          tableTree = tableData;
        }
      }
      internalData.afterFullData = tableData;
      internalData.afterTreeFullData = tableTree;
      internalData.afterGroupFullData = tableTree;
      updateAfterDataIndex();
    };
    const updateStyle = () => {
      const { showHeaderOverflow: allColumnHeaderOverflow, showFooterOverflow: allColumnFooterOverflow, mouseConfig, spanMethod, footerSpanMethod } = props;
      const { isGroup, currentRow, tableColumn, scrollXLoad, scrollYLoad, overflowX, scrollbarWidth, overflowY, scrollbarHeight, scrollXWidth, columnStore, editStore, isAllOverflow, expandColumn, isColLoading } = reactData;
      const { visibleColumn, tableHeight, headerHeight, footerHeight, elemStore, customHeight, customMinHeight, customMaxHeight } = internalData;
      const el = refElem.value;
      if (!el) {
        return;
      }
      const containerList = ["main", "left", "right"];
      const osbWidth = overflowY ? scrollbarWidth : 0;
      const osbHeight = overflowX ? scrollbarHeight : 0;
      const emptyPlaceholderElem = refEmptyPlaceholder.value;
      const mouseOpts = computeMouseOpts.value;
      const expandOpts = computeExpandOpts.value;
      const bodyWrapperElem = getRefElem(elemStore["main-body-wrapper"]);
      const bodyTableElem = getRefElem(elemStore["main-body-table"]);
      if (emptyPlaceholderElem) {
        emptyPlaceholderElem.style.top = `${headerHeight}px`;
        emptyPlaceholderElem.style.height = bodyWrapperElem ? `${bodyWrapperElem.offsetHeight - osbHeight}px` : "";
      }
      let bodyHeight = 0;
      let bodyMaxHeight = 0;
      const bodyMinHeight = customMinHeight - headerHeight - footerHeight - osbHeight;
      if (customMaxHeight) {
        bodyMaxHeight = Math.max(bodyMinHeight, customMaxHeight - headerHeight - footerHeight - osbHeight);
      }
      if (customHeight) {
        bodyHeight = customHeight - headerHeight - footerHeight - osbHeight;
      }
      if (!bodyHeight) {
        if (bodyTableElem) {
          bodyHeight = bodyTableElem.clientHeight;
        }
      }
      if (bodyHeight) {
        if (bodyMaxHeight) {
          bodyHeight = Math.min(bodyMaxHeight, bodyHeight);
        }
        bodyHeight = Math.max(bodyMinHeight, bodyHeight);
      }
      const scrollbarXToTop = computeScrollbarXToTop.value;
      const xLeftCornerEl = refScrollXLeftCornerElem.value;
      const xRightCornerEl = refScrollXRightCornerElem.value;
      const scrollXVirtualEl = refScrollXVirtualElem.value;
      if (scrollXVirtualEl) {
        scrollXVirtualEl.style.height = `${osbHeight}px`;
        scrollXVirtualEl.style.visibility = overflowX ? "visible" : "hidden";
      }
      const xWrapperEl = refScrollXWrapperElem.value;
      if (xWrapperEl) {
        xWrapperEl.style.left = scrollbarXToTop ? `${osbWidth}px` : "";
        xWrapperEl.style.width = `${el.clientWidth - osbWidth}px`;
      }
      if (xLeftCornerEl) {
        xLeftCornerEl.style.width = scrollbarXToTop ? `${osbWidth}px` : "";
        xLeftCornerEl.style.display = scrollbarXToTop ? overflowX && osbHeight ? "block" : "" : "";
      }
      if (xRightCornerEl) {
        xRightCornerEl.style.width = scrollbarXToTop ? "" : `${osbWidth}px`;
        xRightCornerEl.style.display = scrollbarXToTop ? "" : overflowX && osbHeight ? "block" : "";
      }
      const scrollYVirtualEl = refScrollYVirtualElem.value;
      if (scrollYVirtualEl) {
        scrollYVirtualEl.style.width = `${osbWidth}px`;
        scrollYVirtualEl.style.height = `${bodyHeight + headerHeight + footerHeight}px`;
        scrollYVirtualEl.style.visibility = overflowY ? "visible" : "hidden";
      }
      const yTopCornerEl = refScrollYTopCornerElem.value;
      if (yTopCornerEl) {
        yTopCornerEl.style.height = `${headerHeight}px`;
        yTopCornerEl.style.display = overflowY && headerHeight ? "block" : "";
      }
      const yWrapperEl = refScrollYWrapperElem.value;
      if (yWrapperEl) {
        yWrapperEl.style.height = `${bodyHeight}px`;
        yWrapperEl.style.top = `${headerHeight}px`;
      }
      const yBottomCornerEl = refScrollYBottomCornerElem.value;
      if (yBottomCornerEl) {
        yBottomCornerEl.style.height = `${footerHeight}px`;
        yBottomCornerEl.style.top = `${headerHeight + bodyHeight}px`;
        yBottomCornerEl.style.display = overflowY && footerHeight ? "block" : "";
      }
      const rowExpandEl = refRowExpandElem.value;
      if (rowExpandEl) {
        rowExpandEl.style.height = `${bodyHeight}px`;
        rowExpandEl.style.top = `${headerHeight}px`;
      }
      containerList.forEach((name, index) => {
        const fixedType = index > 0 ? name : "";
        const layoutList = ["header", "body", "footer"];
        const isFixedLeft = fixedType === "left";
        let fixedColumn = [];
        let fixedWrapperElem;
        if (fixedType) {
          fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;
          fixedWrapperElem = isFixedLeft ? refLeftContainer.value : refRightContainer.value;
        }
        layoutList.forEach((layout) => {
          const wrapperElem = getRefElem(elemStore[`${name}-${layout}-wrapper`]);
          const currScrollElem = getRefElem(elemStore[`${name}-${layout}-scroll`]);
          const tableElem = getRefElem(elemStore[`${name}-${layout}-table`]);
          if (layout === "header") {
            let renderColumnList = tableColumn;
            let isOptimizeMode = false;
            if (isGroup) {
              renderColumnList = visibleColumn;
            } else {
              if (scrollXLoad && allColumnHeaderOverflow) {
                if (spanMethod || footerSpanMethod) {
                } else {
                  isOptimizeMode = true;
                }
              }
              if (!isOptimizeMode || !isColLoading && (fixedType || !overflowX)) {
                renderColumnList = visibleColumn;
              }
              if (fixedType) {
                if (isOptimizeMode) {
                  renderColumnList = fixedColumn || [];
                }
              }
            }
            const tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (fixedType) {
              if (isGroup) {
                if (wrapperElem) {
                  wrapperElem.style.width = scrollXWidth ? `${scrollXWidth}px` : "";
                }
              } else {
                if (isOptimizeMode) {
                  if (wrapperElem) {
                    wrapperElem.style.width = tWidth ? `${tWidth}px` : "";
                  }
                } else {
                  if (wrapperElem) {
                    wrapperElem.style.width = scrollXWidth ? `${scrollXWidth}px` : "";
                  }
                }
              }
            }
            if (currScrollElem) {
              currScrollElem.style.height = `${headerHeight}px`;
            }
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth}px` : "";
            }
          } else if (layout === "body") {
            if (currScrollElem) {
              currScrollElem.style.maxHeight = customMaxHeight ? `${bodyMaxHeight}px` : "";
              currScrollElem.style.height = customHeight ? `${bodyHeight}px` : "";
              currScrollElem.style.minHeight = `${bodyMinHeight}px`;
            }
            if (fixedWrapperElem) {
              if (wrapperElem) {
                wrapperElem.style.top = `${headerHeight}px`;
              }
              fixedWrapperElem.style.height = `${customHeight > 0 ? customHeight : tableHeight + headerHeight + footerHeight + osbHeight}px`;
              fixedWrapperElem.style.width = `${fixedColumn.reduce((previous, column) => previous + column.renderWidth, 0)}px`;
            }
            let renderColumnList = tableColumn;
            let isOptimizeMode = false;
            if (scrollXLoad || scrollYLoad || isAllOverflow) {
              if (expandColumn && expandOpts.mode !== "fixed" || spanMethod || footerSpanMethod) {
              } else {
                isOptimizeMode = true;
              }
            }
            if (fixedType) {
              renderColumnList = visibleColumn;
              if (isOptimizeMode) {
                renderColumnList = fixedColumn || [];
              }
            }
            const tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (fixedType) {
              if (isOptimizeMode) {
                if (wrapperElem) {
                  wrapperElem.style.width = tWidth ? `${tWidth}px` : "";
                }
              } else {
                if (wrapperElem) {
                  wrapperElem.style.width = scrollXWidth ? `${scrollXWidth}px` : "";
                }
              }
            }
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth}px` : "";
              tableElem.style.paddingRight = osbWidth && fixedType && (browseObj.firefox || browseObj.safari) ? `${osbWidth}px` : "";
            }
            const emptyBlockElem = getRefElem(elemStore[`${name}-${layout}-emptyBlock`]);
            if (emptyBlockElem) {
              emptyBlockElem.style.width = tWidth ? `${tWidth}px` : "";
            }
          } else if (layout === "footer") {
            let renderColumnList = tableColumn;
            let isOptimizeMode = false;
            if (scrollXLoad && allColumnFooterOverflow) {
              if (spanMethod || footerSpanMethod) {
              } else {
                isOptimizeMode = true;
              }
            }
            if (!isOptimizeMode || !isColLoading && (fixedType || !overflowX)) {
              renderColumnList = visibleColumn;
            }
            if (fixedType) {
              if (isOptimizeMode) {
                renderColumnList = fixedColumn || [];
              }
            }
            const tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (fixedType) {
              if (isOptimizeMode) {
                if (wrapperElem) {
                  wrapperElem.style.width = tWidth ? `${tWidth}px` : "";
                }
              } else {
                if (wrapperElem) {
                  wrapperElem.style.width = scrollXWidth ? `${scrollXWidth}px` : "";
                }
              }
            }
            if (currScrollElem) {
              currScrollElem.style.height = `${footerHeight}px`;
              if (fixedWrapperElem) {
                if (wrapperElem) {
                  wrapperElem.style.top = `${customHeight > 0 ? customHeight - footerHeight - osbHeight : tableHeight + headerHeight}px`;
                }
              }
            }
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth}px` : "";
            }
          }
        });
      });
      if (currentRow) {
        $xeTable.setCurrentRow(currentRow);
      }
      if (mouseConfig && mouseOpts.selected && editStore.selected.row && editStore.selected.column) {
        $xeTable.addCellSelectedClass();
      }
      return nextTick();
    };
    const checkValidate = (type) => {
      if ($xeTable.triggerValidate) {
        return $xeTable.triggerValidate(type);
      }
      return nextTick();
    };
    const handleChangeCell = (evnt, params) => {
      checkValidate("blur").catch((e) => e).then(() => {
        $xeTable.handleEdit(params, evnt).then(() => checkValidate("change")).catch((e) => e);
      });
    };
    const handleDefaultSort = () => {
      const { sortConfig } = props;
      if (sortConfig) {
        const sortOpts = computeSortOpts.value;
        let { defaultSort } = sortOpts;
        if (defaultSort) {
          if (!import_xe_utils9.default.isArray(defaultSort)) {
            defaultSort = [defaultSort];
          }
          if (defaultSort.length) {
            (sortConfig.multiple ? defaultSort : defaultSort.slice(0, 1)).forEach((item, index) => {
              const { field, order } = item;
              if (field && order) {
                const column = $xeTable.getColumnByField(field);
                if (column && column.sortable) {
                  column.order = order;
                  column.sortTime = Date.now() + index;
                }
              }
            });
            if (!sortOpts.remote) {
              $xeTable.handleTableData(true).then(updateStyle);
            }
          }
        }
      }
    };
    const handleDefaultSelectionChecked = () => {
      const { checkboxConfig } = props;
      if (checkboxConfig) {
        const { fullDataRowIdData } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkAll, checkRowKeys } = checkboxOpts;
        if (checkAll) {
          handleCheckedAllCheckboxRow(true, true);
        } else if (checkRowKeys) {
          const defSelection = [];
          checkRowKeys.forEach((rowid) => {
            if (fullDataRowIdData[rowid]) {
              defSelection.push(fullDataRowIdData[rowid].row);
            }
          });
          handleCheckedCheckboxRow(defSelection, true, true);
        }
      }
    };
    const handleDefaultRadioChecked = () => {
      const { radioConfig } = props;
      if (radioConfig) {
        const { fullDataRowIdData } = internalData;
        const radioOpts = computeRadioOpts.value;
        const { checkRowKey: rowid, reserve } = radioOpts;
        if (rowid) {
          if (fullDataRowIdData[rowid]) {
            handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);
          }
          if (reserve) {
            const rowkey = getRowkey($xeTable);
            internalData.radioReserveRow = { [rowkey]: rowid };
          }
        }
      }
    };
    const handleDefaultRowExpand = () => {
      const { expandConfig } = props;
      if (expandConfig) {
        const { fullDataRowIdData } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { expandAll, expandRowKeys } = expandOpts;
        if (expandAll) {
          $xeTable.setAllRowExpand(true);
        } else if (expandRowKeys) {
          const defExpandeds = [];
          expandRowKeys.forEach((rowid) => {
            if (fullDataRowIdData[rowid]) {
              defExpandeds.push(fullDataRowIdData[rowid].row);
            }
          });
          $xeTable.setRowExpand(defExpandeds, true);
        }
      }
    };
    const handleRadioReserveRow = (row) => {
      const radioOpts = computeRadioOpts.value;
      if (radioOpts.reserve) {
        internalData.radioReserveRow = row;
      }
    };
    const handleCheckboxReserveRow = (row, checked) => {
      const { checkboxReserveRowMap } = internalData;
      const checkboxOpts = computeCheckboxOpts.value;
      if (checkboxOpts.reserve) {
        const rowid = getRowid($xeTable, row);
        if (checked) {
          checkboxReserveRowMap[rowid] = row;
        } else if (checkboxReserveRowMap[rowid]) {
          delete checkboxReserveRowMap[rowid];
        }
      }
    };
    const handleCheckedRadioRow = (row, isForce) => {
      const radioOpts = computeRadioOpts.value;
      const { checkMethod } = radioOpts;
      if (row && (isForce || (!checkMethod || checkMethod({ $table: $xeTable, row })))) {
        reactData.selectRadioRow = row;
        handleRadioReserveRow(row);
      }
      return nextTick();
    };
    const handleCheckedCheckboxRow = (rows, value, isForce) => {
      if (rows && !import_xe_utils9.default.isArray(rows)) {
        rows = [rows];
      }
      $xeTable.handleBatchSelectRows(rows, !!value, isForce);
      $xeTable.checkSelectionStatus();
      return nextTick();
    };
    const handleCheckedAllCheckboxRow = (checked, isForce) => {
      const { treeConfig } = props;
      const { isRowGroupStatus } = reactData;
      const { afterFullData, afterTreeFullData, afterGroupFullData, checkboxReserveRowMap, selectCheckboxMaps } = internalData;
      const treeOpts = computeTreeOpts.value;
      const rowGroupOpts = computeRowGroupOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const checkboxOpts = computeCheckboxOpts.value;
      const { checkField, reserve, checkMethod } = checkboxOpts;
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
      const selectRowMaps = {};
      if (checkField) {
        const checkValFn = (row) => {
          if (isForce || (!checkMethod || checkMethod({ $table: $xeTable, row }))) {
            if (checked) {
              selectRowMaps[handleGetRowId(row)] = row;
            }
            import_xe_utils9.default.set(row, checkField, checked);
          }
          if ((treeConfig || isRowGroupStatus) && indeterminateField) {
            import_xe_utils9.default.set(row, indeterminateField, false);
          }
        };
        if (treeConfig || isRowGroupStatus) {
          import_xe_utils9.default.eachTree(afterFullData, checkValFn, { children: childrenField });
        } else {
          afterFullData.forEach(checkValFn);
        }
      } else {
        if (isRowGroupStatus) {
          if (checked) {
            import_xe_utils9.default.eachTree(afterGroupFullData, (row) => {
              if (isForce || (!checkMethod || checkMethod({ $table: $xeTable, row }))) {
                const rowid = handleGetRowId(row);
                selectRowMaps[rowid] = row;
              }
            }, { children: rowGroupOpts.mapChildrenField });
          } else {
            if (!isForce && checkMethod) {
              import_xe_utils9.default.eachTree(afterGroupFullData, (row) => {
                const rowid = handleGetRowId(row);
                if (checkMethod({ $table: $xeTable, row }) ? false : selectCheckboxMaps[rowid]) {
                  selectRowMaps[rowid] = row;
                }
              }, { children: rowGroupOpts.mapChildrenField });
            }
          }
        } else if (treeConfig) {
          if (checked) {
            import_xe_utils9.default.eachTree(afterTreeFullData, (row) => {
              if (isForce || (!checkMethod || checkMethod({ $table: $xeTable, row }))) {
                const rowid = handleGetRowId(row);
                selectRowMaps[rowid] = row;
              }
            }, { children: childrenField });
          } else {
            if (!isForce && checkMethod) {
              import_xe_utils9.default.eachTree(afterTreeFullData, (row) => {
                const rowid = handleGetRowId(row);
                if (checkMethod({ $table: $xeTable, row }) ? false : selectCheckboxMaps[rowid]) {
                  selectRowMaps[rowid] = row;
                }
              }, { children: childrenField });
            }
          }
        } else {
          if (checked) {
            if (!isForce && checkMethod) {
              afterFullData.forEach((row) => {
                const rowid = handleGetRowId(row);
                if (selectCheckboxMaps[rowid] || checkMethod({ $table: $xeTable, row })) {
                  selectRowMaps[rowid] = row;
                }
              });
            } else {
              afterFullData.forEach((row) => {
                const rowid = handleGetRowId(row);
                selectRowMaps[rowid] = row;
              });
            }
          } else {
            if (!isForce && checkMethod) {
              afterFullData.forEach((row) => {
                const rowid = handleGetRowId(row);
                if (checkMethod({ $table: $xeTable, row }) ? false : selectCheckboxMaps[rowid]) {
                  selectRowMaps[rowid] = row;
                }
              });
            }
          }
        }
      }
      if (reserve) {
        if (checked) {
          import_xe_utils9.default.each(selectRowMaps, (row, rowid) => {
            checkboxReserveRowMap[rowid] = row;
          });
        } else {
          afterFullData.forEach((row) => handleCheckboxReserveRow(row, false));
        }
      }
      reactData.updateCheckboxFlag++;
      internalData.selectCheckboxMaps = checkField ? {} : selectRowMaps;
      reactData.isAllSelected = checked;
      reactData.isIndeterminate = false;
      internalData.treeIndeterminateRowMaps = {};
      $xeTable.checkSelectionStatus();
      return nextTick();
    };
    const handleReserveStatus = () => {
      const { treeConfig } = props;
      const { expandColumn, currentRow, selectRadioRow } = reactData;
      const { fullDataRowIdData, fullAllDataRowIdData, radioReserveRow, selectCheckboxMaps, treeExpandedMaps, rowExpandedMaps } = internalData;
      const expandOpts = computeExpandOpts.value;
      const treeOpts = computeTreeOpts.value;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      if (selectRadioRow && !fullAllDataRowIdData[getRowid($xeTable, selectRadioRow)]) {
        reactData.selectRadioRow = null;
      }
      if (radioOpts.reserve && radioReserveRow) {
        const rowid = getRowid($xeTable, radioReserveRow);
        if (fullDataRowIdData[rowid]) {
          handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);
        }
      }
      internalData.selectCheckboxMaps = getRecoverRowMaps(selectCheckboxMaps);
      reactData.updateCheckboxFlag++;
      if (checkboxOpts.reserve) {
        handleCheckedCheckboxRow(handleReserveRow(internalData.checkboxReserveRowMap), true, true);
      }
      if (currentRow && !fullAllDataRowIdData[getRowid($xeTable, currentRow)]) {
        reactData.currentRow = null;
      }
      internalData.rowExpandedMaps = expandColumn ? getRecoverRowMaps(rowExpandedMaps) : {};
      reactData.rowExpandedFlag++;
      if (expandColumn && expandOpts.reserve) {
        $xeTable.setRowExpand(handleReserveRow(internalData.rowExpandedReserveRowMap), true);
      }
      internalData.treeExpandedMaps = treeConfig ? getRecoverRowMaps(treeExpandedMaps) : {};
      reactData.treeExpandedFlag++;
      if (treeConfig && treeOpts.reserve) {
        $xeTable.setTreeExpand(handleReserveRow(internalData.treeExpandedReserveRowMap), true);
      }
    };
    const handleDefaultTreeExpand = () => {
      const { treeConfig } = props;
      if (treeConfig) {
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { expandAll, expandRowKeys } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        if (expandAll) {
          $xeTable.setAllTreeExpand(true);
        } else if (expandRowKeys) {
          const defExpandeds = [];
          const rowkey = getRowkey($xeTable);
          expandRowKeys.forEach((rowid) => {
            const matchObj = import_xe_utils9.default.findTree(tableFullData, (item) => rowid === import_xe_utils9.default.get(item, rowkey), { children: childrenField });
            if (matchObj) {
              defExpandeds.push(matchObj.item);
            }
          });
          $xeTable.setTreeExpand(defExpandeds, true);
        }
      }
    };
    const handleAsyncTreeExpandChilds = (row) => {
      const treeOpts = computeTreeOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const { transform, loadMethod } = treeOpts;
      const { checkStrictly } = checkboxOpts;
      return new Promise((resolve) => {
        if (loadMethod) {
          const { fullAllDataRowIdData, treeExpandLazyLoadedMaps } = internalData;
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          treeExpandLazyLoadedMaps[rowid] = row;
          Promise.resolve(loadMethod({ $table: $xeTable, row })).then((childRecords) => {
            if (rowRest) {
              rowRest.treeLoaded = true;
            }
            if (treeExpandLazyLoadedMaps[rowid]) {
              delete treeExpandLazyLoadedMaps[rowid];
            }
            if (!import_xe_utils9.default.isArray(childRecords)) {
              childRecords = [];
            }
            if (childRecords) {
              return $xeTable.loadTreeChildren(row, childRecords).then((childRows) => {
                const { treeExpandedMaps } = internalData;
                if (childRows.length && !treeExpandedMaps[rowid]) {
                  treeExpandedMaps[rowid] = row;
                }
                reactData.treeExpandedFlag++;
                if (!checkStrictly && $xeTable.isCheckedByCheckboxRow(row)) {
                  handleCheckedCheckboxRow(childRows, true);
                }
                return nextTick().then(() => {
                  if (transform) {
                    $xeTable.handleTableData();
                    updateAfterDataIndex();
                    return nextTick();
                  }
                });
              });
            }
          }).catch(() => {
            const { treeExpandLazyLoadedMaps: treeExpandLazyLoadedMaps2 } = internalData;
            if (rowRest) {
              rowRest.treeLoaded = false;
            }
            if (treeExpandLazyLoadedMaps2[rowid]) {
              delete treeExpandLazyLoadedMaps2[rowid];
            }
          }).finally(() => {
            reactData.treeExpandedFlag++;
            nextTick().then(() => $xeTable.recalculate()).then(() => resolve());
          });
        } else {
          resolve();
        }
      });
    };
    const handleTreeExpandReserve = (row, expanded) => {
      const { treeExpandedReserveRowMap } = internalData;
      const treeOpts = computeTreeOpts.value;
      if (treeOpts.reserve) {
        const rowid = getRowid($xeTable, row);
        if (expanded) {
          treeExpandedReserveRowMap[rowid] = row;
        } else if (treeExpandedReserveRowMap[rowid]) {
          delete treeExpandedReserveRowMap[rowid];
        }
      }
    };
    const handleAsyncRowExpand = (row) => {
      return new Promise((resolve) => {
        const expandOpts = computeExpandOpts.value;
        const { loadMethod } = expandOpts;
        if (loadMethod) {
          const { fullAllDataRowIdData, rowExpandLazyLoadedMaps } = internalData;
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          rowExpandLazyLoadedMaps[rowid] = row;
          loadMethod({ $table: $xeTable, row, rowIndex: $xeTable.getRowIndex(row), $rowIndex: $xeTable.getVMRowIndex(row) }).then(() => {
            const { rowExpandedMaps } = internalData;
            if (rowRest) {
              rowRest.expandLoaded = true;
            }
            rowExpandedMaps[rowid] = row;
            reactData.rowExpandedFlag++;
          }).catch(() => {
            if (rowRest) {
              rowRest.expandLoaded = false;
            }
          }).finally(() => {
            const { rowExpandLazyLoadedMaps: rowExpandLazyLoadedMaps2 } = internalData;
            if (rowExpandLazyLoadedMaps2[rowid]) {
              delete rowExpandLazyLoadedMaps2[rowid];
            }
            reactData.rowExpandedFlag++;
            nextTick().then(() => $xeTable.recalculate()).then(() => $xeTable.updateCellAreas()).then(() => resolve());
          });
        } else {
          resolve();
        }
      });
    };
    const handleRowExpandReserve = (row, expanded) => {
      const { rowExpandedReserveRowMap } = internalData;
      const expandOpts = computeExpandOpts.value;
      if (expandOpts.reserve) {
        const rowid = getRowid($xeTable, row);
        if (expanded) {
          rowExpandedReserveRowMap[rowid] = row;
        } else if (rowExpandedReserveRowMap[rowid]) {
          delete rowExpandedReserveRowMap[rowid];
        }
      }
    };
    const handleDefaultMergeCells = () => {
      const { mergeCells } = props;
      if (mergeCells) {
        $xeTable.setMergeCells(mergeCells);
      }
    };
    const handleDefaultMergeFooterItems = () => {
      const { mergeFooterItems } = props;
      if (mergeFooterItems) {
        $xeTable.setMergeFooterItems(mergeFooterItems);
      }
    };
    const computeScrollLoad = () => {
      return nextTick().then(() => {
        const { scrollXLoad, scrollYLoad } = reactData;
        const { scrollXStore, scrollYStore } = internalData;
        const virtualYOpts = computeVirtualYOpts.value;
        const virtualXOpts = computeVirtualXOpts.value;
        if (scrollXLoad) {
          const { toVisibleIndex: toXVisibleIndex, visibleSize: visibleXSize } = handleVirtualXVisible();
          const offsetXSize = Math.max(0, virtualXOpts.oSize ? import_xe_utils9.default.toNumber(virtualXOpts.oSize) : 0);
          scrollXStore.preloadSize = import_xe_utils9.default.toNumber(virtualXOpts.preSize);
          scrollXStore.offsetSize = offsetXSize;
          scrollXStore.visibleSize = visibleXSize;
          scrollXStore.endIndex = Math.max(scrollXStore.startIndex + scrollXStore.visibleSize + offsetXSize, scrollXStore.endIndex);
          scrollXStore.visibleStartIndex = Math.max(scrollXStore.startIndex, toXVisibleIndex);
          scrollXStore.visibleEndIndex = Math.min(scrollXStore.endIndex, toXVisibleIndex + visibleXSize);
          $xeTable.updateScrollXData().then(() => {
            loadScrollXData();
          });
        } else {
          $xeTable.updateScrollXSpace();
        }
        const rowHeight = computeRowHeight();
        scrollYStore.rowHeight = rowHeight;
        reactData.rowHeight = rowHeight;
        const { toVisibleIndex: toYVisibleIndex, visibleSize: visibleYSize } = handleVirtualYVisible();
        if (scrollYLoad) {
          const offsetYSize = Math.max(0, virtualYOpts.oSize ? import_xe_utils9.default.toNumber(virtualYOpts.oSize) : 0);
          scrollYStore.preloadSize = import_xe_utils9.default.toNumber(virtualYOpts.preSize);
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex + visibleYSize + offsetYSize, scrollYStore.endIndex);
          scrollYStore.visibleStartIndex = Math.max(scrollYStore.startIndex, toYVisibleIndex);
          scrollYStore.visibleEndIndex = Math.min(scrollYStore.endIndex, toYVisibleIndex + visibleYSize);
          $xeTable.updateScrollYData().then(() => {
            loadScrollYData();
          });
        } else {
          $xeTable.updateScrollYSpace();
        }
      });
    };
    const calcScrollbar = () => {
      const { scrollXWidth, scrollYHeight } = reactData;
      const { elemStore } = internalData;
      const scrollbarOpts = computeScrollbarOpts.value;
      const bodyWrapperElem = getRefElem(elemStore["main-body-wrapper"]);
      const headerTableElem = getRefElem(elemStore["main-header-table"]);
      const footerTableElem = getRefElem(elemStore["main-footer-table"]);
      const xHandleEl = refScrollXHandleElem.value;
      const yHandleEl = refScrollYHandleElem.value;
      let overflowY = false;
      let overflowX = false;
      if (bodyWrapperElem) {
        overflowY = scrollYHeight > bodyWrapperElem.clientHeight;
        if (yHandleEl) {
          reactData.scrollbarWidth = scrollbarOpts.width || yHandleEl.offsetWidth - yHandleEl.clientWidth || 14;
        }
        reactData.overflowY = overflowY;
        overflowX = scrollXWidth > bodyWrapperElem.clientWidth;
        if (xHandleEl) {
          reactData.scrollbarHeight = scrollbarOpts.height || xHandleEl.offsetHeight - xHandleEl.clientHeight || 14;
        }
        const headerHeight = headerTableElem ? headerTableElem.clientHeight : 0;
        const footerHeight = footerTableElem ? footerTableElem.clientHeight : 0;
        internalData.tableHeight = bodyWrapperElem.offsetHeight;
        internalData.headerHeight = headerHeight;
        internalData.footerHeight = footerHeight;
        reactData.overflowX = overflowX;
        reactData.parentHeight = Math.max(internalData.headerHeight + footerHeight + 20, $xeTable.getParentHeight());
      }
      if (overflowX) {
        $xeTable.checkScrolling();
      }
    };
    const handleRecalculateLayout = (reFull) => {
      const el = refElem.value;
      internalData.rceRunTime = Date.now();
      if (!el || !el.clientWidth) {
        return nextTick();
      }
      const varEl = refVarElem.value;
      if (varEl) {
        const [defEl, mediumEl, smallEl, miniEl] = varEl.children;
        calcVarRowHeightConfig("default", defEl);
        calcVarRowHeightConfig("medium", mediumEl);
        calcVarRowHeightConfig("small", smallEl);
        calcVarRowHeightConfig("mini", miniEl);
      }
      calcCellWidth();
      autoCellWidth();
      calcScrollbar();
      updateStyle();
      updateRowExpandStyle();
      return computeScrollLoad().then(() => {
        calcCellWidth();
        if (reFull) {
          autoCellWidth();
        }
        calcScrollbar();
        updateStyle();
        if (reFull) {
          updateRowOffsetTop();
        }
        updateRowExpandStyle();
        if (reFull) {
          return computeScrollLoad();
        }
      });
    };
    const handleUpdateRowGroup = (groupFields) => {
      reactData.rowGroupList = groupFields ? (import_xe_utils9.default.isArray(groupFields) ? groupFields : [groupFields]).map((field) => {
        return {
          field
        };
      }) : [];
    };
    const handleGroupData = (list, rowGroups) => {
      let fullData = list;
      let treeData = list;
      if (rowGroups) {
        const rowGroupOpts = computeRowGroupOpts.value;
        const { rowField, parentField, childrenField, mapChildrenField } = rowGroupOpts;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
        const rgItem = rowGroups[0];
        if (rgItem && rowField && parentField && childrenField && mapChildrenField) {
          fullData = [];
          treeData = [];
          const groupField = rgItem.field;
          const groupColumn = $xeTable.getColumnByField(groupField);
          const groupMaps = {};
          const rowkey = getRowkey($xeTable);
          list.forEach((row) => {
            const cellValue = groupColumn ? $xeTable.getCellLabel(row, groupColumn) : import_xe_utils9.default.get(row, groupField);
            const groupValue = import_xe_utils9.default.eqNull(cellValue) ? "" : cellValue;
            let childList = groupMaps[groupValue];
            if (!childList) {
              childList = [];
              groupMaps[groupValue] = childList;
            }
            if (row.isAggregate) {
              row.isAggregate = void 0;
            }
            childList.push(row);
          });
          import_xe_utils9.default.objectEach(groupMaps, (childList, groupValue) => {
            const { fullData: childFullData, treeData: childTreeData } = handleGroupData(childList, rowGroups.slice(1));
            const groupRow = {
              isAggregate: true,
              groupContent: groupValue,
              groupField,
              [rowField]: getRowUniqueId(),
              [parentField]: null,
              [rowkey]: getRowUniqueId(),
              [childrenField]: childTreeData,
              [mapChildrenField]: childTreeData
            };
            if (checkField) {
              groupRow[checkField] = false;
            }
            if (indeterminateField) {
              groupRow[indeterminateField] = false;
            }
            treeData.push(groupRow);
            fullData.push(groupRow);
            if (childFullData.length) {
              fullData.push(...childFullData);
            }
          });
        }
      }
      return {
        treeData,
        fullData
      };
    };
    const loadTableData = (datas, isReset) => {
      const { keepSource, treeConfig, rowGroupConfig } = props;
      const { rowGroupList, scrollYLoad: oldScrollYLoad } = reactData;
      const { scrollYStore, scrollXStore, lastScrollLeft, lastScrollTop } = internalData;
      const rowOpts = computeRowOpts.value;
      const treeOpts = computeTreeOpts.value;
      const expandOpts = computeExpandOpts.value;
      const { transform } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      let treeData = [];
      let fullData = reactive(datas ? datas.slice(0) : []);
      if (fullData.length > supportMaxRow) {
        errLog("vxe.error.errMaxRow", [supportMaxRow]);
      }
      if (treeConfig && rowGroupList.length) {
        errLog("vxe.error.noTree", ["row-group-config"]);
        return nextTick();
      }
      if (rowOpts.drag && rowGroupList.length) {
        errLog("vxe.error.errConflicts", ["row-config.drag", "row-group-config"]);
        return nextTick();
      }
      let isRGroup = false;
      if (treeConfig) {
        if (transform) {
          if (!treeOpts.rowField) {
            errLog("vxe.error.reqProp", ["tree-config.rowField"]);
          }
          if (!treeOpts.parentField) {
            errLog("vxe.error.reqProp", ["tree-config.parentField"]);
          }
          if (!childrenField) {
            errLog("vxe.error.reqProp", ["tree-config.childrenField"]);
          }
          if (!treeOpts.mapChildrenField) {
            errLog("vxe.error.reqProp", ["tree-config.mapChildrenField"]);
          }
          if (childrenField === treeOpts.mapChildrenField) {
            errLog("vxe.error.errConflicts", ["tree-config.childrenField", "tree-config.mapChildrenField"]);
          }
          treeData = import_xe_utils9.default.toArrayTree(fullData, {
            key: treeOpts.rowField,
            parentKey: treeOpts.parentField,
            children: childrenField,
            mapChildren: treeOpts.mapChildrenField
          });
          fullData = treeData.slice(0);
        } else {
          treeData = fullData.slice(0);
        }
      } else if (rowGroupConfig && rowGroupList.length) {
        const groupRest = handleGroupData(fullData, rowGroupList);
        treeData = groupRest.treeData;
        fullData = groupRest.fullData;
        isRGroup = true;
      }
      reactData.isRowGroupStatus = isRGroup;
      scrollYStore.startIndex = 0;
      scrollYStore.endIndex = 1;
      scrollXStore.startIndex = 0;
      scrollXStore.endIndex = 1;
      internalData.cvCacheMaps = {};
      reactData.isRowLoading = true;
      reactData.scrollVMLoading = false;
      internalData.treeExpandedMaps = {};
      reactData.treeExpandedFlag++;
      internalData.rowExpandedMaps = {};
      reactData.rowExpandedFlag++;
      internalData.insertRowMaps = {};
      reactData.insertRowFlag++;
      internalData.removeRowMaps = {};
      reactData.removeRowFlag++;
      const sYLoad = updateScrollYStatus(fullData);
      reactData.isDragColMove = false;
      reactData.isDragRowMove = false;
      internalData.tableFullData = fullData;
      internalData.tableFullTreeData = isRGroup ? [] : treeData;
      internalData.tableFullGroupData = isRGroup ? treeData : [];
      $xeTable.cacheRowMap(isReset);
      internalData.tableSynchData = datas;
      if (isReset) {
        internalData.isResizeCellHeight = false;
      }
      if (keepSource) {
        $xeTable.cacheSourceMap(fullData);
      }
      if ($xeTable.clearCellAreas && props.mouseConfig) {
        $xeTable.clearCellAreas();
        $xeTable.clearCopyCellArea();
      }
      $xeTable.clearMergeCells();
      $xeTable.clearMergeFooterItems();
      $xeTable.handleTableData(true);
      $xeTable.updateFooter();
      $xeTable.handleUpdateBodyMerge();
      return nextTick().then(() => {
        updateHeight();
        updateStyle();
      }).then(() => {
        computeScrollLoad();
      }).then(() => {
        if (sYLoad) {
          scrollYStore.endIndex = scrollYStore.visibleSize;
        }
        if (sYLoad) {
          if (reactData.expandColumn && expandOpts.mode !== "fixed") {
            errLog("vxe.error.notConflictProp", ['column.type="expand', 'expand-config.mode="fixed"']);
          }
          if (!(props.height || props.maxHeight)) {
            errLog("vxe.error.reqProp", ["height | max-height | virtual-y-config={enabled: false}"]);
          }
          if (props.spanMethod) {
            errLog("vxe.error.scrollErrProp", ["table.span-method"]);
          }
        }
        handleReserveStatus();
        $xeTable.checkSelectionStatus();
        return new Promise((resolve) => {
          nextTick().then(() => handleRecalculateLayout(false)).then(() => {
            calcCellHeight();
            updateRowOffsetTop();
            return handleRecalculateLayout(false);
          }).then(() => {
            let targetScrollLeft = lastScrollLeft;
            let targetScrollTop = lastScrollTop;
            const virtualXOpts = computeVirtualXOpts.value;
            const virtualYOpts = computeVirtualYOpts.value;
            if (virtualXOpts.scrollToLeftOnChange) {
              targetScrollLeft = 0;
            }
            if (virtualYOpts.scrollToTopOnChange) {
              targetScrollTop = 0;
            }
            reactData.isRowLoading = false;
            handleRecalculateLayout(false);
            if (oldScrollYLoad === sYLoad) {
              restoreScrollLocation($xeTable, targetScrollLeft, targetScrollTop).then(() => {
                resolve();
              });
            } else {
              setTimeout(() => {
                restoreScrollLocation($xeTable, targetScrollLeft, targetScrollTop).then(() => {
                  resolve();
                });
              });
            }
          });
        });
      });
    };
    const handleLoadDefaults = () => {
      handleDefaultSelectionChecked();
      handleDefaultRadioChecked();
      handleDefaultRowExpand();
      handleDefaultTreeExpand();
      handleDefaultMergeCells();
      handleDefaultMergeFooterItems();
      nextTick(() => setTimeout(() => $xeTable.recalculate()));
    };
    const handleInitDefaults = () => {
      handleDefaultSort();
    };
    const handleTableColumn = () => {
      const { scrollXLoad } = reactData;
      const { visibleColumn, scrollXStore, fullColumnIdData } = internalData;
      const tableColumn = scrollXLoad ? visibleColumn.slice(scrollXStore.startIndex, scrollXStore.endIndex) : visibleColumn.slice(0);
      tableColumn.forEach((column, $index) => {
        const colid = column.id;
        const colRest = fullColumnIdData[colid];
        if (colRest) {
          colRest.$index = $index;
        }
      });
      reactData.tableColumn = tableColumn;
    };
    const handleUpdateColumn = () => {
      const columnList = import_xe_utils9.default.orderBy(internalData.collectColumn, "renderSortNumber");
      internalData.collectColumn = columnList;
      const tableFullColumn = getColumnList(columnList);
      internalData.tableFullColumn = tableFullColumn;
      cacheColumnMap();
    };
    const loadScrollXData = () => {
      const { isScrollXBig } = reactData;
      const { mergeBodyList, mergeFooterList, scrollXStore } = internalData;
      const { preloadSize, startIndex, endIndex, offsetSize } = scrollXStore;
      const { toVisibleIndex, visibleSize } = handleVirtualXVisible();
      const offsetItem = {
        startIndex: Math.max(0, isScrollXBig ? toVisibleIndex - 1 : toVisibleIndex - 1 - offsetSize - preloadSize),
        endIndex: isScrollXBig ? toVisibleIndex + visibleSize : toVisibleIndex + visibleSize + offsetSize + preloadSize
      };
      scrollXStore.visibleStartIndex = toVisibleIndex - 1;
      scrollXStore.visibleEndIndex = toVisibleIndex + visibleSize + 1;
      calculateMergerOffsetIndex(mergeBodyList.concat(mergeFooterList), offsetItem, "col");
      const { startIndex: offsetStartIndex, endIndex: offsetEndIndex } = offsetItem;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollXStore.startIndex = offsetStartIndex;
          scrollXStore.endIndex = offsetEndIndex;
          $xeTable.updateScrollXData();
        }
      }
      $xeTable.closeTooltip();
    };
    const getColumnList = (columns) => {
      const result = [];
      columns.forEach((column) => {
        result.push(...column.children && column.children.length ? getColumnList(column.children) : [column]);
      });
      return result;
    };
    const parseColumns = (isReset) => {
      const leftList = [];
      const centerList = [];
      const rightList = [];
      const { isGroup, columnStore } = reactData;
      const virtualXOpts = computeVirtualXOpts.value;
      const { collectColumn, tableFullColumn, scrollXStore, fullColumnIdData } = internalData;
      if (isGroup) {
        const leftGroupList = [];
        const centerGroupList = [];
        const rightGroupList = [];
        import_xe_utils9.default.eachTree(collectColumn, (column, index, items, path, parentColumn) => {
          const isColGroup = hasChildrenList(column);
          if (parentColumn && parentColumn.fixed) {
            column.fixed = parentColumn.fixed;
          }
          if (parentColumn && column.fixed !== parentColumn.fixed) {
            errLog("vxe.error.groupFixed");
          }
          if (isColGroup) {
            column.visible = !!import_xe_utils9.default.findTree(column.children, (subColumn) => hasChildrenList(subColumn) ? false : subColumn.visible);
          } else if (column.visible) {
            if (column.fixed === "left") {
              leftList.push(column);
            } else if (column.fixed === "right") {
              rightList.push(column);
            } else {
              centerList.push(column);
            }
          }
        });
        collectColumn.forEach((column) => {
          if (column.visible) {
            if (column.fixed === "left") {
              leftGroupList.push(column);
            } else if (column.fixed === "right") {
              rightGroupList.push(column);
            } else {
              centerGroupList.push(column);
            }
          }
        });
        reactData.tableGroupColumn = leftGroupList.concat(centerGroupList).concat(rightGroupList);
      } else {
        tableFullColumn.forEach((column) => {
          if (column.visible) {
            if (column.fixed === "left") {
              leftList.push(column);
            } else if (column.fixed === "right") {
              rightList.push(column);
            } else {
              centerList.push(column);
            }
          }
        });
      }
      const visibleColumn = leftList.concat(centerList).concat(rightList);
      const scrollXLoad = !!virtualXOpts.enabled && virtualXOpts.gt > -1 && (virtualXOpts.gt === 0 || virtualXOpts.gt < tableFullColumn.length);
      reactData.hasFixedColumn = leftList.length > 0 || rightList.length > 0;
      Object.assign(columnStore, { leftList, centerList, rightList });
      if (scrollXLoad) {
        if (props.spanMethod) {
          warnLog("vxe.error.scrollErrProp", ["span-method"]);
        }
        if (props.footerSpanMethod) {
          warnLog("vxe.error.scrollErrProp", ["footer-span-method"]);
        }
        if (isReset) {
          const { visibleSize } = handleVirtualXVisible();
          scrollXStore.startIndex = 0;
          scrollXStore.endIndex = visibleSize;
          scrollXStore.visibleSize = visibleSize;
          scrollXStore.visibleStartIndex = 0;
          scrollXStore.visibleEndIndex = visibleSize;
        }
      }
      if (visibleColumn.length !== internalData.visibleColumn.length || !internalData.visibleColumn.every((column, index) => column === visibleColumn[index])) {
        $xeTable.clearMergeCells();
        $xeTable.clearMergeFooterItems();
      }
      reactData.scrollXLoad = scrollXLoad;
      visibleColumn.forEach((column, index) => {
        const colid = column.id;
        const colRest = fullColumnIdData[colid];
        if (colRest) {
          colRest._index = index;
        }
      });
      internalData.visibleColumn = visibleColumn;
      handleTableColumn();
      if (isReset) {
        updateColumnOffsetLeft();
        return $xeTable.updateFooter().then(() => {
          return $xeTable.recalculate();
        }).then(() => {
          $xeTable.updateCellAreas();
          return $xeTable.recalculate();
        });
      }
      return $xeTable.updateFooter();
    };
    const initColumnSort = () => {
      const { collectColumn } = internalData;
      collectColumn.forEach((column, index) => {
        const sortIndex = index + 1;
        column.sortNumber = sortIndex;
        column.renderSortNumber = sortIndex;
      });
    };
    const handleColumn = (collectColumn) => {
      const expandOpts = computeExpandOpts.value;
      internalData.collectColumn = collectColumn;
      const tableFullColumn = getColumnList(collectColumn);
      internalData.tableFullColumn = tableFullColumn;
      reactData.isColLoading = true;
      reactData.isDragColMove = false;
      initColumnSort();
      return Promise.resolve(restoreCustomStorage()).then(() => {
        const { scrollXLoad, scrollYLoad, expandColumn } = reactData;
        cacheColumnMap();
        parseColumns(true).then(() => {
          if (reactData.scrollXLoad) {
            loadScrollXData();
          }
        });
        $xeTable.clearMergeCells();
        $xeTable.clearMergeFooterItems();
        $xeTable.handleTableData(true);
        if ((scrollXLoad || scrollYLoad) && (expandColumn && expandOpts.mode !== "fixed")) {
          warnLog("vxe.error.scrollErrProp", ["column.type=expand"]);
        }
        return nextTick().then(() => {
          if ($xeToolbar) {
            $xeToolbar.syncUpdate({
              collectColumn: internalData.collectColumn,
              $table: $xeTable
            });
          }
          if ($xeTable.handleUpdateCustomColumn) {
            $xeTable.handleUpdateCustomColumn();
          }
          reactData.isColLoading = false;
          return $xeTable.recalculate();
        });
      });
    };
    const updateScrollYStatus = (fullData) => {
      const { treeConfig } = props;
      const virtualYOpts = computeVirtualYOpts.value;
      const treeOpts = computeTreeOpts.value;
      const { transform } = treeOpts;
      const allList = fullData || internalData.tableFullData;
      const scrollYLoad = (transform || !treeConfig) && !!virtualYOpts.enabled && virtualYOpts.gt > -1 && (virtualYOpts.gt === 0 || virtualYOpts.gt < allList.length);
      reactData.scrollYLoad = scrollYLoad;
      return scrollYLoad;
    };
    const handleBaseTreeExpand = (rows, expanded) => {
      const { treeNodeColumn } = reactData;
      const { fullAllDataRowIdData, tableFullTreeData, treeExpandedMaps, treeExpandLazyLoadedMaps } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { reserve, lazy, accordion, toggleMethod } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
      const result = [];
      const columnIndex = $xeTable.getColumnIndex(treeNodeColumn);
      const $columnIndex = $xeTable.getVMColumnIndex(treeNodeColumn);
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      let validRows = toggleMethod ? rows.filter((row) => toggleMethod({ $table: $xeTable, expanded, column: treeNodeColumn, columnIndex, $columnIndex, row })) : rows;
      if (accordion) {
        validRows = validRows.length ? [validRows[validRows.length - 1]] : [];
        const matchObj = import_xe_utils9.default.findTree(tableFullTreeData, (item) => item === validRows[0], { children: childrenField });
        if (matchObj) {
          matchObj.items.forEach((item) => {
            const rowid = handleGetRowId(item);
            if (treeExpandedMaps[rowid]) {
              delete treeExpandedMaps[rowid];
            }
          });
        }
      }
      if (expanded) {
        validRows.forEach((row) => {
          const rowid = handleGetRowId(row);
          if (!treeExpandedMaps[rowid]) {
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              const isLoad = lazy && row[hasChildField] && !rowRest.treeLoaded && !treeExpandLazyLoadedMaps[rowid];
              if (isLoad) {
                result.push(handleAsyncTreeExpandChilds(row));
              } else {
                if (row[childrenField] && row[childrenField].length) {
                  treeExpandedMaps[rowid] = row;
                }
              }
            }
          }
        });
      } else {
        validRows.forEach((item) => {
          const rowid = handleGetRowId(item);
          if (treeExpandedMaps[rowid]) {
            delete treeExpandedMaps[rowid];
          }
        });
      }
      if (reserve) {
        validRows.forEach((row) => handleTreeExpandReserve(row, expanded));
      }
      reactData.treeExpandedFlag++;
      return Promise.all(result).then(() => {
        return $xeTable.recalculate();
      });
    };
    const handleVirtualTreeExpand = (rows, expanded) => {
      return handleBaseTreeExpand(rows, expanded).then(() => {
        handleVirtualTreeToList();
        $xeTable.handleTableData();
        reactData.treeExpandedFlag++;
        updateAfterDataIndex();
        return nextTick();
      }).then(() => {
        return $xeTable.recalculate(true);
      }).then(() => {
        setTimeout(() => {
          $xeTable.updateCellAreas();
        }, 30);
      });
    };
    const handleRowGroupBaseExpand = (rows, expanded) => {
      const { fullAllDataRowIdData, tableFullGroupData, rowGroupExpandedMaps } = internalData;
      const rowGroupOpts = computeRowGroupOpts.value;
      const { mapChildrenField, accordion } = rowGroupOpts;
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      let validRows = rows;
      if (mapChildrenField) {
        if (accordion) {
          validRows = validRows.length ? [validRows[validRows.length - 1]] : [];
          const matchObj = import_xe_utils9.default.findTree(tableFullGroupData, (item) => getRowid($xeTable, item) === getRowid($xeTable, validRows[0]), { children: mapChildrenField });
          if (matchObj) {
            matchObj.items.forEach((item) => {
              const rowid = handleGetRowId(item);
              if (rowGroupExpandedMaps[rowid]) {
                delete rowGroupExpandedMaps[rowid];
              }
            });
          }
        }
        if (expanded) {
          validRows.forEach((row) => {
            const rowid = handleGetRowId(row);
            if (!rowGroupExpandedMaps[rowid]) {
              const rowRest = fullAllDataRowIdData[rowid];
              if (rowRest) {
                if (row[mapChildrenField] && row[mapChildrenField].length) {
                  rowGroupExpandedMaps[rowid] = row;
                }
              }
            }
          });
        } else {
          validRows.forEach((item) => {
            const rowid = handleGetRowId(item);
            if (rowGroupExpandedMaps[rowid]) {
              delete rowGroupExpandedMaps[rowid];
            }
          });
        }
      }
      reactData.rowGroupExpandedFlag++;
      return $xeTable.recalculate();
    };
    const handleRowGroupVirtualExpand = (rows, expanded) => {
      return handleRowGroupBaseExpand(rows, expanded).then(() => {
        handleVirtualTreeToList();
        $xeTable.handleTableData();
        reactData.rowGroupExpandedFlag++;
        updateAfterDataIndex();
        return nextTick();
      }).then(() => {
        return $xeTable.recalculate(true);
      }).then(() => {
        setTimeout(() => {
          $xeTable.updateCellAreas();
        }, 30);
      });
    };
    const handleCheckAllEvent = (evnt, value) => {
      handleCheckedAllCheckboxRow(value);
      if (evnt) {
        dispatchEvent("checkbox-all", {
          records: () => $xeTable.getCheckboxRecords(),
          reserves: () => $xeTable.getCheckboxReserveRecords(),
          indeterminates: () => $xeTable.getCheckboxIndeterminateRecords(),
          checked: value
        }, evnt);
      }
    };
    const loadScrollYData = () => {
      const { isAllOverflow, isScrollYBig } = reactData;
      const { mergeBodyList, scrollYStore } = internalData;
      const { preloadSize, startIndex, endIndex, offsetSize } = scrollYStore;
      const autoOffsetYSize = isAllOverflow ? offsetSize : offsetSize + 1;
      const { toVisibleIndex, visibleSize } = handleVirtualYVisible();
      const offsetItem = {
        startIndex: Math.max(0, isScrollYBig ? toVisibleIndex - 1 : toVisibleIndex - 1 - offsetSize - preloadSize),
        endIndex: isScrollYBig ? toVisibleIndex + visibleSize : toVisibleIndex + visibleSize + autoOffsetYSize + preloadSize
      };
      scrollYStore.visibleStartIndex = toVisibleIndex - 1;
      scrollYStore.visibleEndIndex = toVisibleIndex + visibleSize + 1;
      calculateMergerOffsetIndex(mergeBodyList, offsetItem, "row");
      const { startIndex: offsetStartIndex, endIndex: offsetEndIndex } = offsetItem;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          $xeTable.updateScrollYData();
        }
      }
    };
    const createGetRowCacheProp = (prop) => {
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      return function(row) {
        const { fullAllDataRowIdData } = internalData;
        if (row) {
          const rowid = handleGetRowId(row);
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            return rowRest[prop];
          }
        }
        return -1;
      };
    };
    const createGetColumnCacheProp = (prop) => {
      return function(column) {
        const { fullColumnIdData } = internalData;
        if (column) {
          const colRest = fullColumnIdData[column.id];
          if (colRest) {
            return colRest[prop];
          }
        }
        return -1;
      };
    };
    const lazyScrollXData = () => {
      const { lxTimeout, lxRunTime, scrollXStore } = internalData;
      const { visibleSize } = scrollXStore;
      const fpsTime = visibleSize > 26 ? 26 : visibleSize > 16 ? 14 : 6;
      if (lxTimeout) {
        clearTimeout(lxTimeout);
      }
      if (!lxRunTime || lxRunTime + fpsTime < Date.now()) {
        internalData.lxRunTime = Date.now();
        loadScrollXData();
      }
      internalData.lxTimeout = setTimeout(() => {
        internalData.lxTimeout = void 0;
        internalData.lxRunTime = void 0;
        loadScrollXData();
      }, fpsTime);
    };
    const lazyScrollYData = () => {
      const { lyTimeout, lyRunTime, scrollYStore } = internalData;
      const { visibleSize } = scrollYStore;
      const fpsTime = visibleSize > 30 ? 32 : visibleSize > 20 ? 18 : 8;
      if (lyTimeout) {
        clearTimeout(lyTimeout);
      }
      if (!lyRunTime || lyRunTime + fpsTime < Date.now()) {
        internalData.lyRunTime = Date.now();
        loadScrollYData();
      }
      internalData.lyTimeout = setTimeout(() => {
        internalData.lyTimeout = void 0;
        internalData.lyRunTime = void 0;
        loadScrollYData();
      }, fpsTime);
    };
    const checkLastSyncScroll = (isRollX, isRollY) => {
      const { scrollXLoad, scrollYLoad } = reactData;
      const { lcsTimeout } = internalData;
      if (lcsTimeout) {
        clearTimeout(lcsTimeout);
      }
      internalData.lcsTimeout = setTimeout(() => {
        internalData.lcsRunTime = Date.now();
        internalData.lcsTimeout = void 0;
        internalData.intoRunScroll = false;
        internalData.inVirtualScroll = false;
        internalData.inWheelScroll = false;
        internalData.inHeaderScroll = false;
        internalData.inBodyScroll = false;
        internalData.inFooterScroll = false;
        internalData.scrollRenderType = "";
        calcCellHeight();
        if (isRollX && scrollXLoad) {
          $xeTable.updateScrollXData();
        }
        if (isRollY && scrollYLoad) {
          $xeTable.updateScrollYData().then(() => {
            calcCellHeight();
            $xeTable.updateScrollYSpace();
          });
        }
        updateRowExpandStyle();
        $xeTable.updateCellAreas();
      }, 200);
    };
    const getWheelSpeed = (lastScrollTime) => {
      let multiple = 1;
      const currTime = Date.now();
      if (lastScrollTime + 25 > currTime) {
        multiple = 1.18;
      } else if (lastScrollTime + 30 > currTime) {
        multiple = 1.15;
      } else if (lastScrollTime + 40 > currTime) {
        multiple = 1.12;
      } else if (lastScrollTime + 55 > currTime) {
        multiple = 1.09;
      } else if (lastScrollTime + 75 > currTime) {
        multiple = 1.06;
      } else if (lastScrollTime + 100 > currTime) {
        multiple = 1.03;
      }
      return multiple;
    };
    const wheelScrollLeftTo = (scrollLeft, cb) => {
      requestAnimationFrame(() => {
        cb(scrollLeft);
      });
    };
    const wheelScrollTopTo = (diffNum, cb) => {
      const duration = Math.abs(diffNum);
      const startTime = performance.now();
      let countTop = 0;
      const step = (timestamp) => {
        let progress = (timestamp - startTime) / duration;
        if (progress > 1) {
          progress = 1;
        }
        const easedProgress = Math.pow(progress, 2);
        const offsetTop = Math.floor(diffNum * easedProgress) - countTop;
        countTop += offsetTop;
        cb(offsetTop);
        if (progress < 1) {
          requestAnimationFrame(step);
        }
      };
      requestAnimationFrame(step);
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $table: $xeTable, $grid: $xeGrid }, params));
    };
    const handleScrollToRowColumn = (fieldOrColumn, row) => {
      const { fullColumnIdData } = internalData;
      const column = handleFieldOrColumn($xeTable, fieldOrColumn);
      if (column && fullColumnIdData[column.id]) {
        return colToVisible($xeTable, column, row);
      }
      return nextTick();
    };
    const handleUpdateResize = () => {
      const el = refElem.value;
      if (el && el.clientWidth && el.clientHeight) {
        tableMethods.recalculate();
      }
    };
    const handleUpdateColResize = (evnt, params) => {
      $xeTable.analyColumnWidth();
      $xeTable.recalculate().then(() => {
        $xeTable.saveCustomStore("update:width");
        $xeTable.updateCellAreas();
        $xeTable.dispatchEvent("column-resizable-change", params, evnt);
        $xeTable.dispatchEvent("resizable-change", params, evnt);
        setTimeout(() => $xeTable.recalculate(true), 300);
      });
    };
    const handleUpdateRowResize = (evnt, params) => {
      reactData.resizeHeightFlag++;
      $xeTable.recalculate().then(() => {
        $xeTable.updateCellAreas();
        $xeTable.dispatchEvent("row-resizable-change", params, evnt);
        setTimeout(() => $xeTable.recalculate(true), 300);
      });
    };
    const updateColumnOffsetLeft = () => {
      const { visibleColumn, fullColumnIdData } = internalData;
      let offsetLeft = 0;
      for (let cIndex = 0, rLen = visibleColumn.length; cIndex < rLen; cIndex++) {
        const column = visibleColumn[cIndex];
        const colid = column.id;
        const colRest = fullColumnIdData[colid];
        colRest.oLeft = offsetLeft;
        offsetLeft += column.renderWidth;
      }
    };
    const updateRowOffsetTop = () => {
      const { expandColumn } = reactData;
      const { afterFullData, fullAllDataRowIdData, rowExpandedMaps } = internalData;
      const expandOpts = computeExpandOpts.value;
      const rowOpts = computeRowOpts.value;
      const cellOpts = computeCellOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      let offsetTop = 0;
      for (let rIndex = 0, rLen = afterFullData.length; rIndex < rLen; rIndex++) {
        const row = afterFullData[rIndex];
        const rowid = handleGetRowId(row);
        const rowRest = fullAllDataRowIdData[rowid] || {};
        rowRest.oTop = offsetTop;
        offsetTop += rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
        if (expandColumn && rowExpandedMaps[rowid]) {
          offsetTop += rowRest.expandHeight || expandOpts.height || 0;
        }
      }
    };
    const updateRowExpandStyle = () => {
      const { expandColumn, scrollYLoad, scrollYTop, isScrollYBig } = reactData;
      const expandOpts = computeExpandOpts.value;
      const rowOpts = computeRowOpts.value;
      const cellOpts = computeCellOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const { mode } = expandOpts;
      if (expandColumn && mode === "fixed") {
        const { elemStore, fullAllDataRowIdData } = internalData;
        const rowExpandEl = refRowExpandElem.value;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        if (rowExpandEl && bodyScrollElem) {
          let isUpdateHeight = false;
          import_xe_utils9.default.arrayEach(rowExpandEl.children, (reEl) => {
            const expandEl = reEl;
            const rowid = expandEl.getAttribute("rowid") || "";
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              const expandHeight = expandEl.offsetHeight + 1;
              const trEl = bodyScrollElem.querySelector(`.vxe-body--row[rowid="${rowid}"]`);
              let offsetTop = 0;
              if (scrollYLoad) {
                if (isScrollYBig && trEl) {
                  offsetTop = trEl.offsetTop + trEl.offsetHeight;
                } else {
                  offsetTop = rowRest.oTop + (rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight);
                }
              } else {
                if (trEl) {
                  offsetTop = trEl.offsetTop + trEl.offsetHeight;
                }
              }
              if (isScrollYBig) {
                offsetTop += scrollYTop;
              }
              expandEl.style.top = toCssUnit(offsetTop);
              if (!isUpdateHeight) {
                if (rowRest.expandHeight !== expandHeight) {
                  isUpdateHeight = true;
                }
              }
              rowRest.expandHeight = expandHeight;
            }
          });
          if (isUpdateHeight) {
            reactData.rowExpandHeightFlag++;
            nextTick(() => {
              updateRowOffsetTop();
            });
          }
        }
      }
    };
    const handleRowExpandScroll = () => {
      const { elemStore } = internalData;
      const rowExpandEl = refRowExpandElem.value;
      const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
      if (rowExpandEl && bodyScrollElem) {
        rowExpandEl.scrollTop = bodyScrollElem.scrollTop;
      }
    };
    tableMethods = {
      dispatchEvent,
      getEl() {
        return refElem.value;
      },
      /**
       * 重置表格的一切数据状态
       */
      clearAll() {
        return clearTableAllStatus($xeTable);
      },
      /**
       * 同步 data 数据（即将废弃）
       * 如果用了该方法，那么组件将不再记录增删改的状态，只能自行实现对应逻辑
       * 对于某些特殊的场景，比如深层树节点元素发生变动时可能会用到
       */
      syncData() {
        errLog("vxe.error.delFunc", ["syncData", "getData"]);
        return nextTick().then(() => {
          reactData.tableData = [];
          emit("update:data", internalData.tableFullData);
          return nextTick();
        });
      },
      /**
       * 手动处理数据，用于手动排序与筛选
       * 对于手动更改了排序、筛选...等条件后需要重新处理数据时可能会用到
       */
      updateData() {
        const { scrollXLoad, scrollYLoad } = reactData;
        return tablePrivateMethods.handleTableData(true).then(() => {
          tableMethods.updateFooter();
          if (scrollXLoad || scrollYLoad) {
            if (scrollXLoad) {
              tablePrivateMethods.updateScrollXSpace();
            }
            if (scrollYLoad) {
              tablePrivateMethods.updateScrollYSpace();
            }
            return tableMethods.refreshScroll();
          }
        }).then(() => {
          tableMethods.updateCellAreas();
          return tableMethods.recalculate(true);
        }).then(() => {
          setTimeout(() => $xeTable.recalculate(), 50);
        });
      },
      /**
       * 重新加载数据，不会清空表格状态
       * @param {Array} datas 数据
       */
      loadData(datas) {
        const { initStatus } = internalData;
        return loadTableData(datas, false).then(() => {
          internalData.inited = true;
          internalData.initStatus = true;
          if (!initStatus) {
            handleLoadDefaults();
          }
          return tableMethods.recalculate();
        });
      },
      /**
       * 重新加载数据，会清空表格状态
       * @param {Array} datas 数据
       */
      reloadData(datas) {
        return tableMethods.clearAll().then(() => {
          internalData.inited = true;
          internalData.initStatus = true;
          return loadTableData(datas, true);
        }).then(() => {
          handleLoadDefaults();
          return tableMethods.recalculate();
        });
      },
      /**
       * 修改行数据
       */
      setRow(rows, record) {
        if (rows && record) {
          let rest = rows;
          if (!import_xe_utils9.default.isArray(rows)) {
            rest = [rows];
          }
          const rowkey = getRowkey($xeTable);
          rest.forEach((row) => {
            const rowid = getRowid($xeTable, row);
            const newRecord = import_xe_utils9.default.clone(Object.assign({}, record), true);
            import_xe_utils9.default.set(newRecord, rowkey, rowid);
            Object.assign(row, newRecord);
          });
        }
        return nextTick();
      },
      /**
       * 局部加载行数据并恢复到初始状态
       * 对于行数据需要局部更改的场景中可能会用到
       * @param {Row} row 行对象
       * @param {Object} record 新数据
       * @param {String} field 字段名
       */
      reloadRow(row, record, field) {
        const { keepSource } = props;
        const { tableData } = reactData;
        const { tableSourceData } = internalData;
        if (keepSource) {
          const rowIndex = tableMethods.getRowIndex(row);
          const oRow = tableSourceData[rowIndex];
          if (oRow && row) {
            if (field) {
              const newValue = import_xe_utils9.default.clone(import_xe_utils9.default.get(record || row, field), true);
              import_xe_utils9.default.set(row, field, newValue);
              import_xe_utils9.default.set(oRow, field, newValue);
            } else {
              const rowkey = getRowkey($xeTable);
              const rowid = getRowid($xeTable, row);
              const newRecord = import_xe_utils9.default.clone(Object.assign({}, record), true);
              import_xe_utils9.default.set(newRecord, rowkey, rowid);
              import_xe_utils9.default.destructuring(oRow, Object.assign(row, newRecord));
            }
          }
          reactData.tableData = tableData.slice(0);
        } else {
          if (true) {
            warnLog("vxe.error.reqProp", ["keep-source"]);
          }
        }
        return nextTick();
      },
      getParams() {
        return props.params;
      },
      /**
       * 用于树结构，给行数据加载子节点
       */
      loadTreeChildren(row, childRecords) {
        const { keepSource } = props;
        const { tableSourceData, fullDataRowIdData, fullAllDataRowIdData, sourceDataRowIdData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const parentRest = fullAllDataRowIdData[getRowid($xeTable, row)];
        const parentLevel = parentRest ? parentRest.level : 0;
        return tableMethods.createData(childRecords).then((rows) => {
          if (keepSource) {
            const rowid = getRowid($xeTable, row);
            const matchObj = import_xe_utils9.default.findTree(tableSourceData, (item) => rowid === getRowid($xeTable, item), { children: childrenField });
            if (matchObj) {
              matchObj.item[childrenField] = import_xe_utils9.default.clone(rows, true);
            }
            rows.forEach((childRow) => {
              const rowid2 = getRowid($xeTable, childRow);
              sourceDataRowIdData[rowid2] = import_xe_utils9.default.clone(childRow, true);
            });
          }
          import_xe_utils9.default.eachTree(rows, (childRow, index, items, path, parentItem, nodes) => {
            const rowid = getRowid($xeTable, childRow);
            const parentRow = parentItem || parentRest.row;
            const rest = { row: childRow, rowid, seq: -1, index, _index: -1, $index: -1, treeIndex: -1, items, parent: parentRow, level: parentLevel + nodes.length, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
            fullDataRowIdData[rowid] = rest;
            fullAllDataRowIdData[rowid] = rest;
          }, { children: childrenField });
          row[childrenField] = rows;
          if (transform) {
            row[mapChildrenField] = import_xe_utils9.default.clone(rows, false);
          }
          updateAfterDataIndex();
          return rows;
        });
      },
      /**
       * 加载列配置
       * 对于表格列需要重载、局部递增场景下可能会用到
       * @param {ColumnInfo} columns 列配置
       */
      loadColumn(columns) {
        const collectColumn = import_xe_utils9.default.mapTree(columns, (column) => reactive(cell_default.createColumn($xeTable, column)));
        return handleColumn(collectColumn);
      },
      /**
       * 加载列配置并恢复到初始状态
       * 对于表格列需要重载、局部递增场景下可能会用到
       * @param {ColumnInfo} columns 列配置
       */
      reloadColumn(columns) {
        return tableMethods.clearAll().then(() => {
          return tableMethods.loadColumn(columns);
        });
      },
      /**
       * 根据 tr 元素获取对应的 row 信息
       * @param {Element} tr 元素
       */
      getRowNode(tr) {
        if (tr) {
          const { fullAllDataRowIdData } = internalData;
          const rowid = tr.getAttribute("rowid");
          if (rowid) {
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              return {
                rowid: rowRest.rowid,
                item: rowRest.row,
                index: rowRest.index,
                items: rowRest.items,
                parent: rowRest.parent
              };
            }
          }
        }
        return null;
      },
      /**
       * 根据 th/td 元素获取对应的 column 信息
       * @param {Element} cell 元素
       */
      getColumnNode(cell) {
        if (cell) {
          const { fullColumnIdData } = internalData;
          const colid = cell.getAttribute("colid");
          if (colid) {
            const colRest = fullColumnIdData[colid];
            if (colRest) {
              return {
                colid: colRest.colid,
                item: colRest.column,
                index: colRest.index,
                items: colRest.items,
                parent: colRest.parent
              };
            }
          }
        }
        return null;
      },
      /**
       * 根据 row 获取序号
       * @param {Row} row 行对象
       */
      getRowSeq: createGetRowCacheProp("seq"),
      /**
       * 根据 row 获取相对于 data 中的索引
       * @param {Row} row 行对象
       */
      getRowIndex: createGetRowCacheProp("index"),
      /**
       * 根据 row 获取相对于当前数据中的索引
       * @param {Row} row 行对象
       */
      getVTRowIndex: createGetRowCacheProp("_index"),
      /**
       * 根据 row 获取渲染中的虚拟索引
       * @param {Row} row 行对象
       */
      getVMRowIndex: createGetRowCacheProp("$index"),
      /**
       * 根据 column 获取相对于 columns 中的索引
       * @param {ColumnInfo} column 列配置
       */
      getColumnIndex: createGetColumnCacheProp("index"),
      /**
       * 根据 column 获取相对于当前表格列中的索引
       * @param {ColumnInfo} column 列配置
       */
      getVTColumnIndex: createGetColumnCacheProp("_index"),
      /**
       * 根据 column 获取渲染中的虚拟索引
       * @param {ColumnInfo} column 列配置
       */
      getVMColumnIndex: createGetColumnCacheProp("$index"),
      /**
       * 创建 data 对象
       * 对于某些特殊场景可能会用到，会自动对数据的字段名进行检测，如果不存在就自动定义
       * @param {Array} records 新数据
       */
      createData(records) {
        return nextTick().then(() => {
          return reactive(tablePrivateMethods.defineField(records));
        });
      },
      /**
       * 创建 Row|Rows 对象
       * 对于某些特殊场景需要对数据进行手动插入时可能会用到
       * @param {Array/Object} records 新数据
       */
      createRow(records) {
        const isArr = import_xe_utils9.default.isArray(records);
        if (!isArr) {
          records = [records || {}];
        }
        return tableMethods.createData(records).then((rows) => isArr ? rows : rows[0]);
      },
      /**
       * 还原数据
       * 如果不传任何参数，则还原整个表格
       * 如果传 row 则还原一行
       * 如果传 rows 则还原多行
       * 如果还额外传了 field 则还原指定的单元格数据
       */
      revertData(rows, field) {
        const { keepSource, treeConfig } = props;
        const { fullAllDataRowIdData, fullDataRowIdData, tableSourceData, sourceDataRowIdData, tableFullData, afterFullData, removeRowMaps } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform } = treeOpts;
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        if (!keepSource) {
          if (true) {
            errLog("vxe.error.reqProp", ["keep-source"]);
          }
          return nextTick();
        }
        let targetRows = rows;
        if (rows) {
          if (!import_xe_utils9.default.isArray(rows)) {
            targetRows = [rows];
          }
        } else {
          targetRows = import_xe_utils9.default.toArray($xeTable.getUpdateRecords());
        }
        let reDelFlag = false;
        if (targetRows.length) {
          targetRows.forEach((item) => {
            const rowid = handleGetRowId(item);
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              const row = rowRest.row;
              if (!$xeTable.isInsertByRow(row)) {
                const oRow = sourceDataRowIdData[rowid];
                if (oRow && row) {
                  if (field) {
                    import_xe_utils9.default.set(row, field, import_xe_utils9.default.clone(import_xe_utils9.default.get(oRow, field), true));
                  } else {
                    import_xe_utils9.default.destructuring(row, import_xe_utils9.default.clone(oRow, true));
                  }
                  if (!fullDataRowIdData[rowid] && $xeTable.isRemoveByRow(row)) {
                    if (removeRowMaps[rowid]) {
                      delete removeRowMaps[rowid];
                    }
                    tableFullData.unshift(row);
                    afterFullData.unshift(row);
                    reDelFlag = true;
                  }
                }
              }
            }
          });
        }
        if (rows) {
          if (reDelFlag) {
            reactData.removeRowFlag++;
            $xeTable.updateFooter();
            $xeTable.cacheRowMap(false);
            $xeTable.handleTableData(treeConfig && transform);
            if (!(treeConfig && transform)) {
              $xeTable.updateAfterDataIndex();
            }
            $xeTable.checkSelectionStatus();
            if (reactData.scrollYLoad) {
              $xeTable.updateScrollYSpace();
            }
          }
          return nextTick().then(() => {
            $xeTable.updateCellAreas();
            return $xeTable.recalculate();
          });
        }
        return $xeTable.reloadData(tableSourceData);
      },
      /**
       * 清空单元格内容
       * 如果不创参数，则清空整个表格内容
       * 如果传 row 则清空一行内容
       * 如果传 rows 则清空多行内容
       * 如果还额外传了 field 则清空指定单元格内容
       * @param {Array/Row} rows 行数据
       * @param {String} field 字段名
       */
      clearData(rows, field) {
        const { tableFullData, visibleColumn } = internalData;
        if (!arguments.length) {
          rows = tableFullData;
        } else if (rows && !import_xe_utils9.default.isArray(rows)) {
          rows = [rows];
        }
        if (field) {
          rows.forEach((row) => import_xe_utils9.default.set(row, field, null));
        } else {
          rows.forEach((row) => {
            visibleColumn.forEach((column) => {
              if (column.field) {
                setCellValue(row, column, null);
              }
            });
          });
        }
        return nextTick();
      },
      getCellElement(row, fieldOrColumn) {
        const { elemStore } = internalData;
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (!column) {
          return null;
        }
        const rowid = getRowid($xeTable, row);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
        const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
        let bodyElem;
        if (column) {
          if (column.fixed) {
            if (column.fixed === "left") {
              if (leftScrollElem) {
                bodyElem = leftScrollElem;
              }
            } else {
              if (rightScrollElem) {
                bodyElem = rightScrollElem;
              }
            }
          }
          if (!bodyElem) {
            bodyElem = bodyScrollElem;
          }
          if (bodyElem) {
            return bodyElem.querySelector(`.vxe-body--row[rowid="${rowid}"] .${column.id}`);
          }
        }
        return null;
      },
      getCellLabel(row, fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (!column) {
          return null;
        }
        const { formatter } = column;
        const cellValue = getCellValue(row, column);
        let cellLabel = cellValue;
        if (formatter) {
          let formatData;
          const { fullAllDataRowIdData } = internalData;
          const rowid = getRowid($xeTable, row);
          const colid = column.id;
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            formatData = rowRest.formatData;
            if (!formatData) {
              formatData = fullAllDataRowIdData[rowid].formatData = {};
            }
            if (rowRest && formatData[colid]) {
              if (formatData[colid].value === cellValue) {
                return formatData[colid].label;
              }
            }
          }
          const formatParams = { cellValue, row, rowIndex: tableMethods.getRowIndex(row), column, columnIndex: tableMethods.getColumnIndex(column) };
          if (import_xe_utils9.default.isString(formatter)) {
            const gFormatOpts = formats.get(formatter);
            const tcFormatMethod = gFormatOpts ? gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod : null;
            cellLabel = tcFormatMethod ? tcFormatMethod(formatParams) : "";
          } else if (import_xe_utils9.default.isArray(formatter)) {
            const gFormatOpts = formats.get(formatter[0]);
            const tcFormatMethod = gFormatOpts ? gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod : null;
            cellLabel = tcFormatMethod ? tcFormatMethod(formatParams, ...formatter.slice(1)) : "";
          } else {
            cellLabel = formatter(formatParams);
          }
          if (formatData) {
            formatData[colid] = { value: cellValue, label: cellLabel };
          }
        }
        return cellLabel;
      },
      /**
       * 检查是否为临时行数据
       * @param {Row} row 行对象
       */
      isInsertByRow(row) {
        const rowid = getRowid($xeTable, row);
        return !!reactData.insertRowFlag && !!internalData.insertRowMaps[rowid];
      },
      isRemoveByRow(row) {
        const rowid = getRowid($xeTable, row);
        return !!reactData.removeRowFlag && !!internalData.removeRowMaps[rowid];
      },
      /**
       * 删除所有新增的临时数据
       * @returns
       */
      removeInsertRow() {
        internalData.insertRowMaps = {};
        return $xeTable.remove($xeTable.getInsertRecords());
      },
      /**
       * 检查行或列数据是否发生改变
       * @param {Row} rowidOrRow 行对象、行主键
       * @param {String} field 字段名
       */
      isUpdateByRow(rowidOrRow, field) {
        const { keepSource } = props;
        const { tableFullColumn, fullDataRowIdData, sourceDataRowIdData } = internalData;
        if (keepSource) {
          const rowid = import_xe_utils9.default.isString(rowidOrRow) || import_xe_utils9.default.isNumber(rowidOrRow) ? rowidOrRow : getRowid($xeTable, rowidOrRow);
          const rowRest = fullDataRowIdData[rowid];
          if (!rowRest) {
            return false;
          }
          const row = rowRest.row;
          const oRow = sourceDataRowIdData[rowid];
          if (oRow) {
            if (arguments.length > 1) {
              return !eqCellValue(oRow, row, field);
            }
            for (let index = 0, len = tableFullColumn.length; index < len; index++) {
              const property = tableFullColumn[index].field;
              if (property && !eqCellValue(oRow, row, property)) {
                return true;
              }
            }
          }
        }
        return false;
      },
      /**
       * 获取表格的可视列，也可以指定索引获取列
       * @param {Number} columnIndex 索引
       */
      getColumns(columnIndex) {
        const { visibleColumn } = internalData;
        return import_xe_utils9.default.isUndefined(columnIndex) ? visibleColumn.slice(0) : visibleColumn[columnIndex];
      },
      /**
       * 根据列获取列的唯一主键
       */
      getColid(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        return column ? column.id : null;
      },
      /**
       * 根据列的唯一主键获取列
       * @param {String} colid 列主键
       */
      getColumnById(colid) {
        const { fullColumnIdData } = internalData;
        return colid && fullColumnIdData[colid] ? fullColumnIdData[colid].column : null;
      },
      /**
       * 根据列的字段名获取列
       * @param {String} field 字段名
       */
      getColumnByField(field) {
        const fullColumnFieldData = internalData.fullColumnFieldData;
        return field && fullColumnFieldData[field] ? fullColumnFieldData[field].column : null;
      },
      getParentColumn(fieldOrColumn) {
        const { fullColumnIdData } = internalData;
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        return column && column.parentId && fullColumnIdData[column.parentId] ? fullColumnIdData[column.parentId].column : null;
      },
      /**
       * 获取当前表格的列
       * 收集到的全量列、全量表头列、处理条件之后的全量表头列、当前渲染中的表头列
       */
      getTableColumn() {
        return {
          collectColumn: internalData.collectColumn.slice(0),
          fullColumn: internalData.tableFullColumn.slice(0),
          visibleColumn: internalData.visibleColumn.slice(0),
          tableColumn: reactData.tableColumn.slice(0)
        };
      },
      /**
       * 移动列到指定列的位置
       * @param fieldOrColumn
       * @param targetFieldOrColumn
       * @param options
       */
      moveColumnTo(fieldOrColumn, targetFieldOrColumn, options) {
        const { fullColumnIdData, visibleColumn } = internalData;
        const { dragToChild, dragPos, isCrossDrag } = Object.assign({}, options);
        const dragCol = handleFieldOrColumn($xeTable, fieldOrColumn);
        let prevDragCol = null;
        const colRest = dragCol ? fullColumnIdData[dragCol.id] : null;
        let defPos = "left";
        if (import_xe_utils9.default.isNumber(targetFieldOrColumn)) {
          if (colRest && targetFieldOrColumn) {
            let currList = colRest.items;
            let offsetIndex = colRest._index + targetFieldOrColumn;
            if (isCrossDrag) {
              currList = visibleColumn;
              offsetIndex = colRest._index + targetFieldOrColumn;
            }
            if (offsetIndex > 0 && offsetIndex < currList.length - 1) {
              prevDragCol = currList[offsetIndex];
            }
            if (targetFieldOrColumn > 0) {
              defPos = "right";
            }
          }
        } else {
          prevDragCol = handleFieldOrColumn($xeTable, targetFieldOrColumn);
          const targetColRest = prevDragCol ? fullColumnIdData[prevDragCol.id] : null;
          if (colRest && targetColRest) {
            if (targetColRest._index > colRest._index) {
              defPos = "right";
            }
          }
        }
        return $xeTable.handleColDragSwapEvent(null, true, dragCol, prevDragCol, dragPos || defPos, dragToChild === true);
      },
      /**
       * 移动行到指定行的位置
       * @param rowidOrRow
       * @param targetRowidOrRow
       * @param options
       */
      moveRowTo(rowidOrRow, targetRowidOrRow, options) {
        const { treeConfig } = props;
        const { fullAllDataRowIdData, afterFullData } = internalData;
        const { dragToChild, dragPos, isCrossDrag } = Object.assign({}, options);
        const treeOpts = computeTreeOpts.value;
        const dragRow = handleRowidOrRow($xeTable, rowidOrRow);
        let prevDragRow = null;
        let defPos = "top";
        const rowRest = dragRow ? fullAllDataRowIdData[getRowid($xeTable, dragRow)] : null;
        if (import_xe_utils9.default.isNumber(targetRowidOrRow)) {
          if (rowRest && targetRowidOrRow) {
            let currList = afterFullData;
            let offsetIndex = rowRest._index + targetRowidOrRow;
            if (treeConfig) {
              currList = rowRest.items;
              if (treeOpts.transform) {
                offsetIndex = rowRest.treeIndex + targetRowidOrRow;
                if (isCrossDrag) {
                  currList = afterFullData;
                  offsetIndex = rowRest._index + targetRowidOrRow;
                }
              }
            }
            if (offsetIndex >= 0 && offsetIndex <= currList.length - 1) {
              prevDragRow = currList[offsetIndex];
            }
            if (targetRowidOrRow > 0) {
              defPos = "bottom";
            }
          }
        } else {
          prevDragRow = handleRowidOrRow($xeTable, targetRowidOrRow);
          const targetRowRest = prevDragRow ? fullAllDataRowIdData[getRowid($xeTable, prevDragRow)] : null;
          if (rowRest && targetRowRest) {
            if (targetRowRest._index > rowRest._index) {
              defPos = "bottom";
            }
          }
        }
        return $xeTable.handleRowDragSwapEvent(null, true, dragRow, prevDragRow, dragPos || defPos, dragToChild === true);
      },
      /**
       * 获取表格的全量列
       */
      getFullColumns() {
        const { collectColumn } = internalData;
        return collectColumn.slice(0);
      },
      /**
       * 获取数据，和 data 的行为一致，也可以指定索引获取数据
       */
      getData(rowIndex) {
        const tableSynchData = props.data || internalData.tableSynchData;
        return import_xe_utils9.default.isUndefined(rowIndex) ? tableSynchData.slice(0) : tableSynchData[rowIndex];
      },
      /**
       * 用于多选行，获取已选中的数据
       */
      getCheckboxRecords(isFull) {
        const { treeConfig } = props;
        const { updateCheckboxFlag } = reactData;
        const { tableFullData, afterFullData, tableFullTreeData, fullDataRowIdData, afterFullRowMaps, selectCheckboxMaps } = internalData;
        const treeOpts = computeTreeOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const { transform, mapChildrenField } = treeOpts;
        const { checkField } = checkboxOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let rowList = [];
        if (updateCheckboxFlag) {
          if (checkField) {
            if (treeConfig) {
              const currTableData = isFull ? transform ? tableFullTreeData : tableFullData : transform ? tableFullTreeData : afterFullData;
              rowList = import_xe_utils9.default.filterTree(currTableData, (row) => import_xe_utils9.default.get(row, checkField), { children: transform ? mapChildrenField : childrenField });
            } else {
              const currTableData = isFull ? tableFullData : afterFullData;
              rowList = currTableData.filter((row) => import_xe_utils9.default.get(row, checkField));
            }
          } else {
            import_xe_utils9.default.each(selectCheckboxMaps, (row, rowid) => {
              if (isFull) {
                if (fullDataRowIdData[rowid]) {
                  rowList.push(fullDataRowIdData[rowid].row);
                }
              } else {
                if (afterFullRowMaps[rowid]) {
                  rowList.push(afterFullRowMaps[rowid]);
                }
              }
            });
          }
        }
        return rowList;
      },
      /**
       * 只对 tree-config 有效，获取行的子级
       */
      getTreeRowChildren(rowOrRowid) {
        const { treeConfig } = props;
        const { fullAllDataRowIdData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        if (rowOrRowid && treeConfig) {
          let rowid;
          if (import_xe_utils9.default.isString(rowOrRowid)) {
            rowid = rowOrRowid;
          } else {
            rowid = getRowid($xeTable, rowOrRowid);
          }
          if (rowid) {
            const rest = fullAllDataRowIdData[rowid];
            const row = rest ? rest.row : null;
            if (row) {
              return row[transform ? mapChildrenField : childrenField] || [];
            }
          }
        }
        return [];
      },
      /**
       * 只对 tree-config 有效，获取行的父级
       */
      getTreeParentRow(rowOrRowid) {
        const { treeConfig } = props;
        const { fullAllDataRowIdData } = internalData;
        if (rowOrRowid && treeConfig) {
          let rowid;
          if (import_xe_utils9.default.isString(rowOrRowid)) {
            rowid = rowOrRowid;
          } else {
            rowid = getRowid($xeTable, rowOrRowid);
          }
          if (rowid) {
            const rest = fullAllDataRowIdData[rowid];
            return rest ? rest.parent : null;
          }
        }
        return null;
      },
      getParentRow(rowOrRowid) {
        warnLog("vxe.error.delFunc", ["getParentRow", "getTreeParentRow"]);
        return $xeTable.getTreeParentRow(rowOrRowid);
      },
      /**
       * 根据行的唯一主键获取行
       * @param {String/Number} rowid 行主键
       */
      getRowById(cellValue) {
        const { fullAllDataRowIdData } = internalData;
        const rowid = import_xe_utils9.default.eqNull(cellValue) ? "" : encodeURIComponent(cellValue || "");
        return fullAllDataRowIdData[rowid] ? fullAllDataRowIdData[rowid].row : null;
      },
      /**
       * 根据行获取行的唯一主键
       * @param {Row} row 行对象
       */
      getRowid(row) {
        return getRowid($xeTable, row);
      },
      /**
       * 获取处理后的表格数据
       * 如果存在筛选条件，继续处理
       * 如果存在排序，继续处理
       */
      getTableData() {
        const { tableData, footerTableData } = reactData;
        const { tableFullData, afterFullData, tableFullTreeData } = internalData;
        return {
          fullData: props.treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0),
          visibleData: afterFullData.slice(0),
          tableData: tableData.slice(0),
          footerData: footerTableData.slice(0)
        };
      },
      /**
       * 获取表格的全量数据，如果是 tree-config 则返回带层级的树结构
       */
      getFullData() {
        const { treeConfig } = props;
        const { tableFullData, tableFullTreeData } = internalData;
        if (treeConfig) {
          const treeOpts = computeTreeOpts.value;
          const { transform, mapChildrenField, rowField, parentField } = treeOpts;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          if (transform) {
            return import_xe_utils9.default.toArrayTree(import_xe_utils9.default.toTreeArray(tableFullTreeData, {
              children: mapChildrenField
            }), {
              key: rowField,
              parentKey: parentField,
              children: childrenField,
              mapChildren: mapChildrenField
            });
          }
          return tableFullTreeData.slice(0);
        }
        return tableFullData.slice(0);
      },
      /**
       * 设置为固定列
       */
      setColumnFixed(fieldOrColumn, fixed) {
        let status = false;
        const cols = import_xe_utils9.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        const columnOpts = computeColumnOpts.value;
        const isMaxFixedColumn = computeIsMaxFixedColumn.value;
        for (let i = 0; i < cols.length; i++) {
          const item = cols[i];
          const column = handleFieldOrColumn($xeTable, item);
          const targetColumn = getRootColumn($xeTable, column);
          if (targetColumn && targetColumn.fixed !== fixed) {
            if (!targetColumn.fixed && isMaxFixedColumn) {
              if (VxeUI.modal) {
                VxeUI.modal.message({
                  status: "error",
                  content: getI18n6("vxe.table.maxFixedCol", [columnOpts.maxFixedSize])
                });
              }
              return nextTick();
            }
            import_xe_utils9.default.eachTree([targetColumn], (column2) => {
              column2.fixed = fixed;
            });
            tablePrivateMethods.saveCustomStore("update:fixed");
            if (!status) {
              status = true;
            }
          }
        }
        if (status) {
          return tableMethods.refreshColumn();
        }
        return nextTick();
      },
      /**
       * 取消指定固定列
       */
      clearColumnFixed(fieldOrColumn) {
        let status = false;
        const cols = import_xe_utils9.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        cols.forEach((item) => {
          const column = handleFieldOrColumn($xeTable, item);
          const targetColumn = getRootColumn($xeTable, column);
          if (targetColumn && targetColumn.fixed) {
            import_xe_utils9.default.eachTree([targetColumn], (column2) => {
              column2.fixed = null;
            });
            tablePrivateMethods.saveCustomStore("update:fixed");
            if (!status) {
              status = true;
            }
          }
        });
        if (status) {
          return tableMethods.refreshColumn();
        }
        return nextTick();
      },
      /**
       * 隐藏指定列
       */
      hideColumn(fieldOrColumn) {
        let status = false;
        const cols = import_xe_utils9.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        cols.forEach((item) => {
          const column = handleFieldOrColumn($xeTable, item);
          if (column && column.visible) {
            column.visible = false;
            if (!status) {
              status = true;
            }
          }
        });
        if (status) {
          return tablePrivateMethods.handleCustom();
        }
        return nextTick();
      },
      /**
       * 显示指定列
       */
      showColumn(fieldOrColumn) {
        let status = false;
        const cols = import_xe_utils9.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        cols.forEach((item) => {
          const column = handleFieldOrColumn($xeTable, item);
          if (column && !column.visible) {
            column.visible = true;
            if (!status) {
              status = true;
            }
          }
        });
        if (status) {
          return tablePrivateMethods.handleCustom();
        }
        return nextTick();
      },
      setColumnWidth(fieldOrColumn, width) {
        const { elemStore } = internalData;
        let status = false;
        const cols = import_xe_utils9.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        let cWidth = import_xe_utils9.default.toInteger(width);
        if (isScale(width)) {
          const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
          const bodyWidth = bodyScrollElem ? bodyScrollElem.clientWidth - 1 : 0;
          cWidth = Math.floor(cWidth * bodyWidth);
        }
        if (cWidth) {
          cols.forEach((item) => {
            const column = handleFieldOrColumn($xeTable, item);
            if (column) {
              column.resizeWidth = cWidth;
              if (!status) {
                status = true;
              }
            }
          });
          if (status) {
            return $xeTable.refreshColumn().then(() => {
              return { status };
            });
          }
        }
        return nextTick().then(() => {
          return { status };
        });
      },
      getColumnWidth(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column) {
          return column.renderWidth;
        }
        return 0;
      },
      /**
       * 手动重置列的显示隐藏、列宽拖动的状态、固定列、排序列；
       * 如果为 true 则重置所有状态
       * 如果已关联工具栏，则会同步更新
       */
      resetColumn(options) {
        warnLog("vxe.error.delFunc", ["resetColumn", "resetCustom"]);
        return $xeTable.resetCustom(options);
      },
      /**
       * 刷新列信息
       * 将固定的列左边、右边分别靠边
       * 如果传 true 则会检查列顺序并排序
       */
      refreshColumn(initSort) {
        if (initSort) {
          handleUpdateColumn();
        }
        return parseColumns(true).then(() => {
          return tableMethods.refreshScroll();
        }).then(() => {
          return tableMethods.recalculate();
        });
      },
      setRowHeightConf(heightConf) {
        const { fullAllDataRowIdData } = internalData;
        let status = false;
        if (heightConf) {
          import_xe_utils9.default.each(heightConf, (height, rowid) => {
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              const rHeight = import_xe_utils9.default.toInteger(height);
              if (rHeight) {
                rowRest.resizeHeight = rHeight;
                if (!status) {
                  status = true;
                }
              }
            }
          });
          if (status) {
            internalData.isResizeCellHeight = true;
            reactData.resizeHeightFlag++;
          }
        }
        return nextTick().then(() => {
          updateRowOffsetTop();
          return { status };
        });
      },
      getRowHeightConf(isFull) {
        const { fullAllDataRowIdData, afterFullData } = internalData;
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        const rowOpts = computeRowOpts.value;
        const cellOpts = computeCellOpts.value;
        const defaultRowHeight = computeDefaultRowHeight.value;
        const rest = {};
        afterFullData.forEach((row) => {
          const rowid = handleGetRowId(row);
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            const resizeHeight = rowRest.resizeHeight;
            if (resizeHeight || isFull) {
              const currCellHeight = resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
              rest[rowid] = currCellHeight;
            }
          }
        });
        return rest;
      },
      setRowHeight(rowOrId, height) {
        const { fullAllDataRowIdData } = internalData;
        let status = false;
        const rows = import_xe_utils9.default.isArray(rowOrId) ? rowOrId : [rowOrId];
        let rHeight = import_xe_utils9.default.toInteger(height);
        if (isScale(height)) {
          const tableBody = refTableBody.value;
          const bodyElem = tableBody ? tableBody.$el : null;
          const bodyHeight = bodyElem ? bodyElem.clientHeight - 1 : 0;
          rHeight = Math.floor(rHeight * bodyHeight);
        }
        if (rHeight) {
          const { handleGetRowId } = createHandleGetRowId($xeTable);
          rows.forEach((row) => {
            const rowid = import_xe_utils9.default.isString(row) || import_xe_utils9.default.isNumber(row) ? row : handleGetRowId(row);
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              rowRest.resizeHeight = rHeight;
              if (!status) {
                status = true;
              }
            }
          });
          if (status) {
            internalData.isResizeCellHeight = true;
            reactData.resizeHeightFlag++;
          }
        }
        return nextTick().then(() => {
          return { status };
        });
      },
      getRowHeight(rowOrId) {
        const { fullAllDataRowIdData } = internalData;
        const rowOpts = computeRowOpts.value;
        const cellOpts = computeCellOpts.value;
        const defaultRowHeight = computeDefaultRowHeight.value;
        const rowid = import_xe_utils9.default.isString(rowOrId) || import_xe_utils9.default.isNumber(rowOrId) ? rowOrId : getRowid($xeTable, rowOrId);
        const rowRest = fullAllDataRowIdData[rowid];
        if (rowRest) {
          return rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
        }
        return 0;
      },
      /**
       * 刷新滚动操作，手动同步滚动相关位置（对于某些特殊的操作，比如滚动条错位、固定列不同步）
       */
      refreshScroll() {
        const { elemStore, lastScrollLeft, lastScrollTop } = internalData;
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
        const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
        const xHandleEl = refScrollXHandleElem.value;
        const yHandleEl = refScrollYHandleElem.value;
        return new Promise((resolve) => {
          if (lastScrollLeft || lastScrollTop) {
            return restoreScrollLocation($xeTable, lastScrollLeft, lastScrollTop).then().then(() => {
              setTimeout(resolve, 10);
            });
          }
          internalData.intoRunScroll = true;
          setScrollTop(yHandleEl, lastScrollTop);
          setScrollTop(bodyScrollElem, lastScrollTop);
          setScrollTop(leftScrollElem, lastScrollTop);
          setScrollTop(rightScrollElem, lastScrollTop);
          setScrollLeft(xHandleEl, lastScrollLeft);
          setScrollLeft(bodyScrollElem, lastScrollLeft);
          setScrollLeft(headerScrollElem, lastScrollLeft);
          setScrollLeft(footerScrollElem, lastScrollLeft);
          setTimeout(() => {
            internalData.intoRunScroll = false;
            resolve();
          }, 10);
        });
      },
      /**
       * 重新渲染布局
       * 刷新布局
       */
      recalculate(reFull) {
        return new Promise((resolve) => {
          const { rceTimeout, rceRunTime } = internalData;
          const resizeOpts = computeResizeOpts.value;
          const refreshDelay = resizeOpts.refreshDelay || 20;
          const el = refElem.value;
          if (el && el.clientWidth) {
            autoCellWidth();
            updateRowExpandStyle();
          }
          if (rceTimeout) {
            clearTimeout(rceTimeout);
            if (rceRunTime && rceRunTime + (refreshDelay - 5) < Date.now()) {
              resolve(handleRecalculateLayout(!!reFull));
            } else {
              nextTick(() => {
                resolve();
              });
            }
          } else {
            resolve(handleRecalculateLayout(!!reFull));
          }
          internalData.rceTimeout = setTimeout(() => {
            internalData.rceTimeout = void 0;
            handleRecalculateLayout(!!reFull);
          }, refreshDelay);
        });
      },
      openTooltip(target, content) {
        const $commTip = refCommTooltip.value;
        if ($commTip && $commTip.open) {
          return $commTip.open(target, content);
        }
        return nextTick();
      },
      /**
       * 关闭 tooltip
       */
      closeTooltip() {
        const { tooltipStore } = reactData;
        const $tooltip = refTooltip.value;
        const $commTip = refCommTooltip.value;
        if (tooltipStore.visible) {
          Object.assign(tooltipStore, {
            row: null,
            column: null,
            content: null,
            visible: false,
            currOpts: {}
          });
          if ($tooltip && $tooltip.close) {
            $tooltip.close();
          }
        }
        if ($commTip && $commTip.close) {
          $commTip.close();
        }
        return nextTick();
      },
      /**
       * 判断列头复选框是否被选中
       */
      isAllCheckboxChecked() {
        return reactData.isAllSelected;
      },
      /**
       * 判断列头复选框是否被半选
       */
      isAllCheckboxIndeterminate() {
        return !reactData.isAllSelected && reactData.isIndeterminate;
      },
      /**
       * 获取复选框半选状态的行数据
       */
      getCheckboxIndeterminateRecords(isFull) {
        const { treeConfig } = props;
        const { fullDataRowIdData, treeIndeterminateRowMaps } = internalData;
        if (treeConfig) {
          const fullRest = [];
          const defRest = [];
          import_xe_utils9.default.each(treeIndeterminateRowMaps, (item, rowid) => {
            if (item) {
              fullRest.push(item);
              if (fullDataRowIdData[rowid]) {
                defRest.push(item);
              }
            }
          });
          if (isFull) {
            return fullRest;
          }
          return defRest;
        }
        return [];
      },
      /**
       * 用于多选行，设置行为选中状态，第二个参数为选中与否
       * @param {Array/Row} rows 行数据
       * @param {Boolean} value 是否选中
       */
      setCheckboxRow(rows, checked) {
        if (rows && !import_xe_utils9.default.isArray(rows)) {
          rows = [rows];
        }
        return handleCheckedCheckboxRow(rows, checked, true);
      },
      setCheckboxRowKey(keys, checked) {
        const { fullAllDataRowIdData } = internalData;
        if (!import_xe_utils9.default.isArray(keys)) {
          keys = [keys];
        }
        const rows = [];
        keys.forEach((rowid) => {
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            rows.push(rowRest.row);
          }
        });
        return handleCheckedCheckboxRow(rows, checked, true);
      },
      isCheckedByCheckboxRow(row) {
        const { updateCheckboxFlag } = reactData;
        const { selectCheckboxMaps } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        if (checkField) {
          return import_xe_utils9.default.get(row, checkField);
        }
        return !!updateCheckboxFlag && !!selectCheckboxMaps[getRowid($xeTable, row)];
      },
      isCheckedByCheckboxRowKey(rowid) {
        const { updateCheckboxFlag } = reactData;
        const { fullAllDataRowIdData, selectCheckboxMaps } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        if (checkField) {
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            return import_xe_utils9.default.get(rowRest.row, checkField);
          }
          return false;
        }
        return !!updateCheckboxFlag && !!selectCheckboxMaps[rowid];
      },
      isIndeterminateByCheckboxRow(row) {
        const { treeIndeterminateRowMaps } = internalData;
        return !!treeIndeterminateRowMaps[getRowid($xeTable, row)] && !$xeTable.isCheckedByCheckboxRow(row);
      },
      isIndeterminateByCheckboxRowKey(rowid) {
        const { treeIndeterminateRowMaps } = internalData;
        return !!treeIndeterminateRowMaps[rowid] && !$xeTable.isCheckedByCheckboxRowKey(rowid);
      },
      /**
       * 多选，切换某一行的选中状态
       */
      toggleCheckboxRow(row) {
        const { selectCheckboxMaps } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        const checked = checkField ? !import_xe_utils9.default.get(row, checkField) : !selectCheckboxMaps[getRowid($xeTable, row)];
        tablePrivateMethods.handleBatchSelectRows([row], checked, true);
        tablePrivateMethods.checkSelectionStatus();
        return nextTick();
      },
      /**
       * 用于多选行，设置所有行的选中状态
       * @param {Boolean} value 是否选中
       */
      setAllCheckboxRow(value) {
        return handleCheckedAllCheckboxRow(value, true);
      },
      /**
       * 获取单选框保留选中的行
       */
      getRadioReserveRecord(isFull) {
        const { treeConfig } = props;
        const { fullDataRowIdData, radioReserveRow, afterFullData } = internalData;
        const radioOpts = computeRadioOpts.value;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        if (radioOpts.reserve && radioReserveRow) {
          const rowid = getRowid($xeTable, radioReserveRow);
          if (isFull) {
            if (!fullDataRowIdData[rowid]) {
              return radioReserveRow;
            }
          } else {
            const rowkey = getRowkey($xeTable);
            if (treeConfig) {
              const matchObj = import_xe_utils9.default.findTree(afterFullData, (row) => rowid === import_xe_utils9.default.get(row, rowkey), { children: childrenField });
              if (matchObj) {
                return radioReserveRow;
              }
            } else {
              if (!afterFullData.some((row) => rowid === import_xe_utils9.default.get(row, rowkey))) {
                return radioReserveRow;
              }
            }
          }
        }
        return null;
      },
      clearRadioReserve() {
        internalData.radioReserveRow = null;
        return nextTick();
      },
      /**
       * 获取复选框保留选中的行
       */
      getCheckboxReserveRecords(isFull) {
        const { treeConfig } = props;
        const { afterFullData, fullDataRowIdData, checkboxReserveRowMap } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const reserveSelection = [];
        if (checkboxOpts.reserve) {
          const { handleGetRowId } = createHandleGetRowId($xeTable);
          const afterFullIdMaps = {};
          if (treeConfig) {
            import_xe_utils9.default.eachTree(afterFullData, (row) => {
              afterFullIdMaps[handleGetRowId(row)] = 1;
            }, { children: childrenField });
          } else {
            afterFullData.forEach((row) => {
              afterFullIdMaps[handleGetRowId(row)] = 1;
            });
          }
          import_xe_utils9.default.each(checkboxReserveRowMap, (oldRow, oldRowid) => {
            if (oldRow) {
              if (isFull) {
                if (!fullDataRowIdData[oldRowid]) {
                  reserveSelection.push(oldRow);
                }
              } else {
                if (!afterFullIdMaps[oldRowid]) {
                  reserveSelection.push(oldRow);
                }
              }
            }
          });
        }
        return reserveSelection;
      },
      clearCheckboxReserve() {
        internalData.checkboxReserveRowMap = {};
        return nextTick();
      },
      /**
       * 多选，切换所有行的选中状态
       */
      toggleAllCheckboxRow() {
        handleCheckAllEvent(null, !reactData.isAllSelected);
        return nextTick();
      },
      /**
       * 用于多选行，手动清空用户的选择
       * 清空行为不管是否被禁用还是保留记录，都将彻底清空选中状态
       */
      clearCheckboxRow() {
        const { treeConfig } = props;
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, reserve } = checkboxOpts;
        const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
        if (checkField) {
          const handleClearChecked = (item) => {
            if (treeConfig && indeterminateField) {
              import_xe_utils9.default.set(item, indeterminateField, false);
            }
            import_xe_utils9.default.set(item, checkField, false);
          };
          if (treeConfig) {
            import_xe_utils9.default.eachTree(tableFullData, handleClearChecked, { children: childrenField });
          } else {
            tableFullData.forEach(handleClearChecked);
          }
        }
        if (reserve) {
          tableFullData.forEach((row) => handleCheckboxReserveRow(row, false));
        }
        reactData.isAllSelected = false;
        reactData.isIndeterminate = false;
        internalData.selectCheckboxMaps = {};
        internalData.treeIndeterminateRowMaps = {};
        reactData.updateCheckboxFlag++;
        return nextTick();
      },
      /**
       * 用于当前行，设置某一行为高亮状态
       * @param {Row} row 行对象
       */
      setCurrentRow(row) {
        const rowOpts = computeRowOpts.value;
        const el = refElem.value;
        tableMethods.clearCurrentRow();
        reactData.currentRow = row;
        if (rowOpts.isCurrent || props.highlightCurrentRow) {
          if (el) {
            import_xe_utils9.default.arrayEach(el.querySelectorAll(`[rowid="${getRowid($xeTable, row)}"]`), (elem) => addClass(elem, "row--current"));
          }
        }
        return nextTick();
      },
      isCheckedByRadioRow(row) {
        const { selectRadioRow } = reactData;
        if (row && selectRadioRow) {
          return $xeTable.eqRow(selectRadioRow, row);
        }
        return false;
      },
      isCheckedByRadioRowKey(key) {
        const { selectRadioRow } = reactData;
        if (selectRadioRow) {
          return key === getRowid($xeTable, selectRadioRow);
        }
        return false;
      },
      /**
       * 用于单选行，设置某一行为选中状态
       * @param {Row} row 行对象
       */
      setRadioRow(row) {
        return handleCheckedRadioRow(row, true);
      },
      /**
       * 用于单选行，设置某一行为选中状态
       * @param key 行主键
       */
      setRadioRowKey(rowid) {
        const { fullAllDataRowIdData } = internalData;
        const rowRest = fullAllDataRowIdData[rowid];
        if (rowRest) {
          return handleCheckedRadioRow(rowRest.row, true);
        }
        return nextTick();
      },
      /**
       * 用于当前行，手动清空当前高亮的状态
       */
      clearCurrentRow() {
        const el = refElem.value;
        reactData.currentRow = null;
        internalData.hoverRow = null;
        if (el) {
          import_xe_utils9.default.arrayEach(el.querySelectorAll(".row--current"), (elem) => removeClass(elem, "row--current"));
        }
        return nextTick();
      },
      /**
       * 用于单选行，手动清空用户的选择
       */
      clearRadioRow() {
        reactData.selectRadioRow = null;
        return nextTick();
      },
      /**
       * 用于当前行，获取当前行的数据
       */
      getCurrentRecord() {
        const rowOpts = computeRowOpts.value;
        return rowOpts.isCurrent || props.highlightCurrentRow ? reactData.currentRow : null;
      },
      /**
       * 用于单选行，获取当已选中的数据
       */
      getRadioRecord(isFull) {
        const { fullDataRowIdData, afterFullRowMaps } = internalData;
        const { selectRadioRow } = reactData;
        if (selectRadioRow) {
          const rowid = getRowid($xeTable, selectRadioRow);
          if (isFull) {
            if (fullDataRowIdData[rowid]) {
              return selectRadioRow;
            }
          } else {
            if (afterFullRowMaps[rowid]) {
              return selectRadioRow;
            }
          }
        }
        return null;
      },
      getCurrentColumn() {
        const columnOpts = computeColumnOpts.value;
        return columnOpts.isCurrent || props.highlightCurrentColumn ? reactData.currentColumn : null;
      },
      /**
       * 用于当前列，设置某列行为高亮状态
       */
      setCurrentColumn(fieldOrColumn) {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        const isMouseSelected = mouseConfig && mouseOpts.selected;
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column) {
          $xeTable.clearCurrentColumn();
          reactData.currentColumn = column;
        }
        return nextTick().then(() => {
          if (isMouseSelected) {
            $xeTable.addCellSelectedClass();
          }
        });
      },
      /**
       * 用于当前列，手动清空当前高亮的状态
       */
      clearCurrentColumn() {
        reactData.currentColumn = null;
        return nextTick();
      },
      setPendingRow(rows, status) {
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        const { pendingRowMaps } = internalData;
        if (rows && !import_xe_utils9.default.isArray(rows)) {
          rows = [rows];
        }
        if (status) {
          rows.forEach((row) => {
            const rowid = handleGetRowId(row);
            if (rowid && !pendingRowMaps[rowid]) {
              pendingRowMaps[rowid] = row;
            }
          });
        } else {
          rows.forEach((row) => {
            const rowid = handleGetRowId(row);
            if (rowid && pendingRowMaps[rowid]) {
              delete pendingRowMaps[rowid];
            }
          });
        }
        reactData.pendingRowFlag++;
        return nextTick();
      },
      togglePendingRow(rows) {
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        const { pendingRowMaps } = internalData;
        if (rows && !import_xe_utils9.default.isArray(rows)) {
          rows = [rows];
        }
        rows.forEach((row) => {
          const rowid = handleGetRowId(row);
          if (rowid) {
            if (pendingRowMaps[rowid]) {
              delete pendingRowMaps[rowid];
            } else {
              pendingRowMaps[rowid] = row;
            }
          }
        });
        reactData.pendingRowFlag++;
        return nextTick();
      },
      hasPendingByRow(row) {
        return tableMethods.isPendingByRow(row);
      },
      isPendingByRow(row) {
        const { pendingRowMaps } = internalData;
        const rowid = getRowid($xeTable, row);
        return !!pendingRowMaps[rowid];
      },
      getPendingRecords() {
        const { fullAllDataRowIdData, pendingRowMaps } = internalData;
        const insertRecords = [];
        import_xe_utils9.default.each(pendingRowMaps, (row, rowid) => {
          if (fullAllDataRowIdData[rowid]) {
            insertRecords.push(row);
          }
        });
        return insertRecords;
      },
      clearPendingRow() {
        internalData.pendingRowMaps = {};
        reactData.pendingRowFlag++;
        return nextTick();
      },
      sort(sortConfs, sortOrder) {
        const sortOpts = computeSortOpts.value;
        const { multiple, remote, orders } = sortOpts;
        if (sortConfs) {
          if (import_xe_utils9.default.isString(sortConfs)) {
            sortConfs = [
              { field: sortConfs, order: sortOrder }
            ];
          }
        }
        if (!import_xe_utils9.default.isArray(sortConfs)) {
          sortConfs = [sortConfs];
        }
        if (sortConfs.length) {
          if (!multiple) {
            clearAllSort();
          }
          (multiple ? sortConfs : [sortConfs[0]]).forEach((confs, index) => {
            let { field, order } = confs;
            let column = field;
            if (import_xe_utils9.default.isString(field)) {
              column = tableMethods.getColumnByField(field);
            }
            if (column && column.sortable) {
              if (orders && orders.indexOf(order) === -1) {
                order = getNextSortOrder(column);
              }
              if (column.order !== order) {
                column.order = order;
              }
              column.sortTime = Date.now() + index;
            }
          });
          if (!remote) {
            tablePrivateMethods.handleTableData(true);
          }
          return nextTick().then(() => {
            updateRowOffsetTop();
            tableMethods.updateCellAreas();
            return updateStyle();
          });
        }
        return nextTick();
      },
      setSort(sortConfs, isUpdate) {
        const sortOpts = computeSortOpts.value;
        const { multiple, remote, orders } = sortOpts;
        if (!import_xe_utils9.default.isArray(sortConfs)) {
          sortConfs = [sortConfs];
        }
        if (sortConfs && sortConfs.length) {
          if (!multiple) {
            sortConfs = [sortConfs[0]];
            clearAllSort();
          }
          let firstColumn = null;
          sortConfs.forEach((confs, index) => {
            let { field, order } = confs;
            let column = field;
            if (import_xe_utils9.default.isString(field)) {
              column = tableMethods.getColumnByField(field);
            }
            if (!firstColumn) {
              firstColumn = column;
            }
            if (column && column.sortable) {
              if (orders && orders.indexOf(order) === -1) {
                order = getNextSortOrder(column);
              }
              if (column.order !== order) {
                column.order = order;
              }
              column.sortTime = Date.now() + index;
            }
          });
          if (isUpdate) {
            if (!remote) {
              $xeTable.handleTableData(true);
            }
            $xeTable.handleColumnSortEvent(new Event("click"), firstColumn);
          }
          return nextTick().then(() => {
            updateRowOffsetTop();
            tableMethods.updateCellAreas();
            return updateStyle();
          });
        }
        return nextTick();
      },
      /**
       * 清空指定列的排序条件
       * 如果为空则清空所有列的排序条件
       * @param {String} fieldOrColumn 列或字段名
       */
      clearSort(fieldOrColumn) {
        const sortOpts = computeSortOpts.value;
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xeTable, fieldOrColumn);
          if (column) {
            column.order = null;
          }
        } else {
          clearAllSort();
        }
        if (!sortOpts.remote) {
          $xeTable.handleTableData(true);
        }
        return nextTick().then(() => {
          updateRowOffsetTop();
          return updateStyle();
        });
      },
      isSort(fieldOrColumn) {
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xeTable, fieldOrColumn);
          return column ? column.sortable && !!column.order : false;
        }
        return tableMethods.getSortColumns().length > 0;
      },
      getSortColumns() {
        const sortOpts = computeSortOpts.value;
        const { multiple, chronological } = sortOpts;
        const sortList = [];
        const { tableFullColumn } = internalData;
        tableFullColumn.forEach((column) => {
          const { field, order } = column;
          if (column.sortable && order) {
            sortList.push({ column, field, property: field, order, sortTime: column.sortTime });
          }
        });
        if (multiple && chronological && sortList.length > 1) {
          return import_xe_utils9.default.orderBy(sortList, "sortTime");
        }
        return sortList;
      },
      /**
       * 关闭筛选
       * @param {Event} evnt 事件
       */
      closeFilter() {
        const { filterStore } = reactData;
        const { column, visible } = filterStore;
        filterStore.isAllSelected = false;
        filterStore.isIndeterminate = false;
        filterStore.options = [];
        filterStore.visible = false;
        if (visible) {
          dispatchEvent("filter-visible", {
            column,
            property: column.field,
            field: column.field,
            filterList: () => $xeTable.getCheckedFilters(),
            visible: false
          }, null);
        }
        return nextTick();
      },
      /**
       * 判断指定列是否为筛选状态，如果为空则判断所有列
       * @param {String} fieldOrColumn 字段名
       */
      isActiveFilterByColumn(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column) {
          return column.filters && column.filters.some((option) => option.checked);
        }
        return $xeTable.getCheckedFilters().length > 0;
      },
      isFilter(fieldOrColumn) {
        return tableMethods.isActiveFilterByColumn(fieldOrColumn);
      },
      /**
       * 判断展开行是否懒加载完成
       * @param {Row} row 行对象
       */
      isRowExpandLoaded(row) {
        const { fullAllDataRowIdData } = internalData;
        const rowRest = fullAllDataRowIdData[getRowid($xeTable, row)];
        return rowRest && !!rowRest.expandLoaded;
      },
      clearRowExpandLoaded(row) {
        const { fullAllDataRowIdData, rowExpandLazyLoadedMaps } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { lazy } = expandOpts;
        const rowid = getRowid($xeTable, row);
        const rowRest = fullAllDataRowIdData[rowid];
        if (lazy && rowRest) {
          rowRest.expandLoaded = false;
          delete rowExpandLazyLoadedMaps[rowid];
        }
        reactData.rowExpandedFlag++;
        return nextTick();
      },
      /**
       * 重新懒加载展开行，并展开内容
       * @param {Row} row 行对象
       */
      reloadRowExpand(row) {
        const { rowExpandLazyLoadedMaps } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { lazy } = expandOpts;
        const rowid = getRowid($xeTable, row);
        if (lazy && !rowExpandLazyLoadedMaps[rowid]) {
          $xeTable.clearRowExpandLoaded(row).then(() => handleAsyncRowExpand(row));
        }
        return nextTick();
      },
      reloadExpandContent(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["reloadExpandContent", "reloadRowExpand"]);
        }
        return $xeTable.reloadRowExpand(row);
      },
      /**
       * 切换展开行
       */
      toggleRowExpand(row) {
        return $xeTable.setRowExpand(row, !$xeTable.isRowExpandByRow(row));
      },
      /**
       * 设置所有行的展开与否
       * @param {Boolean} expanded 是否展开
       */
      setAllRowExpand(expanded) {
        const treeOpts = computeTreeOpts.value;
        const { tableFullData, tableFullTreeData } = internalData;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let expandedRows = [];
        if (props.treeConfig) {
          import_xe_utils9.default.eachTree(tableFullTreeData, (row) => {
            expandedRows.push(row);
          }, { children: childrenField });
        } else {
          expandedRows = tableFullData;
        }
        return tableMethods.setRowExpand(expandedRows, expanded);
      },
      /**
       * 设置展开行，二个参数设置这一行展开与否
       * 支持单行
       * 支持多行
       * @param {Array/Row} rows 行数据
       * @param {Boolean} expanded 是否展开
       */
      setRowExpand(rows, expanded) {
        const { expandColumn } = reactData;
        let { fullAllDataRowIdData, rowExpandedMaps, rowExpandLazyLoadedMaps } = internalData;
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        const expandOpts = computeExpandOpts.value;
        const { reserve, lazy, accordion, toggleMethod } = expandOpts;
        const lazyRests = [];
        const columnIndex = expandColumn ? $xeTable.getColumnIndex(expandColumn) : -1;
        const $columnIndex = expandColumn ? $xeTable.getVMColumnIndex(expandColumn) : -1;
        if (rows) {
          if (!import_xe_utils9.default.isArray(rows)) {
            rows = [rows];
          }
          if (accordion) {
            rowExpandedMaps = {};
            internalData.rowExpandedMaps = rowExpandedMaps;
            rows = rows.slice(rows.length - 1, rows.length);
          }
          const validRows = toggleMethod ? rows.filter((row) => toggleMethod({ $table: $xeTable, expanded, column: expandColumn, columnIndex, $columnIndex, row, rowIndex: $xeTable.getRowIndex(row), $rowIndex: $xeTable.getVMRowIndex(row) })) : rows;
          if (expanded) {
            validRows.forEach((row) => {
              const rowid = handleGetRowId(row);
              if (!rowExpandedMaps[rowid]) {
                const rowRest = fullAllDataRowIdData[rowid];
                const isLoad = lazy && !rowRest.expandLoaded && !rowExpandLazyLoadedMaps[rowid];
                if (isLoad) {
                  lazyRests.push(handleAsyncRowExpand(row));
                } else {
                  rowExpandedMaps[rowid] = row;
                }
              }
            });
          } else {
            validRows.forEach((item) => {
              const rowid = handleGetRowId(item);
              if (rowExpandedMaps[rowid]) {
                delete rowExpandedMaps[rowid];
              }
            });
          }
          if (reserve) {
            validRows.forEach((row) => handleRowExpandReserve(row, expanded));
          }
        }
        reactData.rowExpandedFlag++;
        return Promise.all(lazyRests).then(() => nextTick()).then(() => $xeTable.recalculate(true)).then(() => {
          updateRowOffsetTop();
          updateRowExpandStyle();
          handleRowExpandScroll();
          return $xeTable.updateCellAreas();
        });
      },
      /**
       * 判断行是否为展开状态
       * @param {Row} row 行对象
       */
      isRowExpandByRow(row) {
        const { rowExpandedFlag } = reactData;
        const { rowExpandedMaps } = internalData;
        const rowid = getRowid($xeTable, row);
        return !!rowExpandedFlag && !!rowExpandedMaps[rowid];
      },
      isExpandByRow(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["isExpandByRow", "isRowExpandByRow"]);
        }
        return tableMethods.isRowExpandByRow(row);
      },
      /**
       * 手动清空展开行状态，数据会恢复成未展开的状态
       */
      clearRowExpand() {
        const { tableFullData } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { reserve } = expandOpts;
        const expList = $xeTable.getRowExpandRecords();
        internalData.rowExpandedMaps = {};
        reactData.rowExpandedFlag++;
        if (reserve) {
          tableFullData.forEach((row) => handleRowExpandReserve(row, false));
        }
        return nextTick().then(() => {
          if (expList.length) {
            return $xeTable.recalculate(true);
          }
        }).then(() => {
          updateRowOffsetTop();
          updateRowExpandStyle();
          handleRowExpandScroll();
          return $xeTable.updateCellAreas();
        });
      },
      clearRowExpandReserve() {
        internalData.rowExpandedReserveRowMap = {};
        return nextTick();
      },
      getRowExpandRecords() {
        const rest = [];
        import_xe_utils9.default.each(internalData.rowExpandedMaps, (item) => {
          if (item) {
            rest.push(item);
          }
        });
        return rest;
      },
      setRowGroups(fieldOrColumns) {
        const { rowGroupConfig } = props;
        if (!rowGroupConfig) {
          errLog("vxe.error.reqProp", ["row-group-config"]);
          return nextTick();
        }
        if (fieldOrColumns) {
          handleUpdateRowGroup((import_xe_utils9.default.isArray(fieldOrColumns) ? fieldOrColumns : [fieldOrColumns]).map((fieldOrColumn) => {
            return import_xe_utils9.default.isString(fieldOrColumn) ? fieldOrColumn : fieldOrColumn.field;
          }));
          return loadTableData(internalData.tableSynchData, true);
        }
        return nextTick();
      },
      clearRowGroups() {
        const { rowGroupConfig } = props;
        if (!rowGroupConfig) {
          errLog("vxe.error.reqProp", ["row-group-config"]);
          return nextTick();
        }
        handleUpdateRowGroup([]);
        return loadTableData(internalData.tableSynchData, true);
      },
      isRowGroupRecord(row) {
        const { isRowGroupStatus } = reactData;
        return isRowGroupStatus && row.isAggregate;
      },
      isRowGroupExpandByRow(row) {
        const { rowGroupExpandedFlag } = reactData;
        const { rowGroupExpandedMaps } = internalData;
        return !!rowGroupExpandedFlag && !!rowGroupExpandedMaps[getRowid($xeTable, row)];
      },
      setRowGroupExpand(rows, expanded) {
        if (rows) {
          if (!import_xe_utils9.default.isArray(rows)) {
            rows = [rows];
          }
          return handleRowGroupVirtualExpand(rows, expanded);
        }
        return nextTick();
      },
      setAllRowGroupExpand(expanded) {
        const { tableFullGroupData } = internalData;
        const rowGroupOpts = computeRowGroupOpts.value;
        const { mapChildrenField } = rowGroupOpts;
        const rgExpandedMaps = {};
        if (expanded && mapChildrenField) {
          import_xe_utils9.default.eachTree(tableFullGroupData, (row) => {
            if (row[mapChildrenField] && row[mapChildrenField].length) {
              rgExpandedMaps[getRowid($xeTable, row)] = row;
            }
          }, { children: mapChildrenField });
        }
        internalData.rowGroupExpandedMaps = rgExpandedMaps;
        handleVirtualTreeToList();
        reactData.rowGroupExpandedFlag++;
        return $xeTable.handleTableData();
      },
      clearRowGroupExpand() {
        internalData.rowGroupExpandedMaps = {};
        handleVirtualTreeToList();
        reactData.rowGroupExpandedFlag++;
        return $xeTable.handleTableData();
      },
      getTreeExpandRecords() {
        const rest = [];
        import_xe_utils9.default.each(internalData.treeExpandedMaps, (item) => {
          if (item) {
            rest.push(item);
          }
        });
        return rest;
      },
      /**
       * 判断树节点是否懒加载完成
       * @param {Row} row 行对象
       */
      isTreeExpandLoaded(row) {
        const { fullAllDataRowIdData } = internalData;
        const rowRest = fullAllDataRowIdData[getRowid($xeTable, row)];
        return rowRest && !!rowRest.treeLoaded;
      },
      clearTreeExpandLoaded(rows) {
        const { fullAllDataRowIdData, treeExpandedMaps } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform } = treeOpts;
        if (rows) {
          if (!import_xe_utils9.default.isArray(rows)) {
            rows = [rows];
          }
          rows.forEach((row) => {
            const rowid = getRowid($xeTable, row);
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              rowRest.treeLoaded = false;
              if (treeExpandedMaps[rowid]) {
                delete treeExpandedMaps[rowid];
              }
            }
          });
        } else {
          import_xe_utils9.default.each(fullAllDataRowIdData, (rowRest) => {
            rowRest.treeLoaded = false;
          });
        }
        internalData.treeExpandedMaps = {};
        if (transform) {
          handleVirtualTreeToList();
          $xeTable.handleTableData();
        }
        reactData.treeExpandedFlag++;
        return nextTick();
      },
      /**
       * 重新懒加载树节点，并展开该节点
       * @param {Row} row 行对象
       */
      reloadTreeExpand(row) {
        const { treeExpandLazyLoadedMaps } = internalData;
        const treeOpts = computeTreeOpts.value;
        const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
        const { transform, lazy } = treeOpts;
        const rowid = getRowid($xeTable, row);
        if (lazy && row[hasChildField] && !treeExpandLazyLoadedMaps[rowid]) {
          return $xeTable.clearTreeExpandLoaded(row).then(() => {
            return handleAsyncTreeExpandChilds(row);
          }).then(() => {
            if (transform) {
              handleVirtualTreeToList();
              $xeTable.handleTableData();
            }
            reactData.treeExpandedFlag++;
          }).then(() => {
            return $xeTable.recalculate();
          });
        }
        return nextTick();
      },
      reloadTreeChilds(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["reloadTreeChilds", "reloadTreeExpand"]);
        }
        return $xeTable.reloadTreeExpand(row);
      },
      /**
       * 切换/展开树节点
       */
      toggleTreeExpand(row) {
        return $xeTable.setTreeExpand(row, !$xeTable.isTreeExpandByRow(row));
      },
      /**
       * 设置所有树节点的展开与否
       * @param {Boolean} expanded 是否展开
       */
      setAllTreeExpand(expanded) {
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform, lazy } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const expandeds = [];
        import_xe_utils9.default.eachTree(tableFullData, (row) => {
          const rowChildren = row[childrenField];
          if (lazy || rowChildren && rowChildren.length) {
            expandeds.push(row);
          }
        }, { children: childrenField });
        return $xeTable.setTreeExpand(expandeds, expanded).then(() => {
          if (transform) {
            handleVirtualTreeToList();
            reactData.treeExpandedFlag++;
            return $xeTable.recalculate();
          }
        });
      },
      /**
       * 设置展开树形节点，二个参数设置这一行展开与否
       * 支持单行
       * 支持多行
       * @param {Array/Row} rows 行数据
       * @param {Boolean} expanded 是否展开
       */
      setTreeExpand(rows, expanded) {
        const treeOpts = computeTreeOpts.value;
        const { transform } = treeOpts;
        if (rows) {
          if (!import_xe_utils9.default.isArray(rows)) {
            rows = [rows];
          }
          if (rows.length) {
            if (transform) {
              return handleVirtualTreeExpand(rows, expanded);
            } else {
              return handleBaseTreeExpand(rows, expanded);
            }
          }
        }
        return nextTick();
      },
      /**
       * 判断行是否为树形节点展开状态
       * @param {Row} row 行对象
       */
      isTreeExpandByRow(row) {
        const { treeExpandedFlag } = reactData;
        const { treeExpandedMaps } = internalData;
        return !!treeExpandedFlag && !!treeExpandedMaps[getRowid($xeTable, row)];
      },
      /**
       * 手动清空树形节点的展开状态，数据会恢复成未展开的状态
       */
      clearTreeExpand() {
        const { tableFullTreeData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const { transform, reserve } = treeOpts;
        const expList = $xeTable.getTreeExpandRecords();
        internalData.treeExpandedMaps = {};
        if (reserve) {
          import_xe_utils9.default.eachTree(tableFullTreeData, (row) => handleTreeExpandReserve(row, false), { children: childrenField });
        }
        return $xeTable.handleTableData().then(() => {
          if (transform) {
            handleVirtualTreeToList();
            $xeTable.handleTableData();
          }
          reactData.treeExpandedFlag++;
        }).then(() => {
          if (expList.length) {
            return $xeTable.recalculate();
          }
        });
      },
      clearTreeExpandReserve() {
        internalData.treeExpandedReserveRowMap = {};
        return nextTick();
      },
      /**
       * 获取表格的滚动状态
       */
      getScroll() {
        const { scrollXLoad, scrollYLoad } = reactData;
        const { elemStore } = internalData;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        return {
          virtualX: scrollXLoad,
          virtualY: scrollYLoad,
          scrollTop: bodyScrollElem ? bodyScrollElem.scrollTop : 0,
          scrollLeft: bodyScrollElem ? bodyScrollElem.scrollLeft : 0
        };
      },
      /**
       * 如果有滚动条，则滚动到对应的位置
       * @param {Number} scrollLeft 左距离
       * @param {Number} scrollTop 上距离
       */
      scrollTo(scrollLeft, scrollTop) {
        const { elemStore } = internalData;
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
        const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
        const xHandleEl = refScrollXHandleElem.value;
        const yHandleEl = refScrollYHandleElem.value;
        internalData.intoRunScroll = true;
        if (import_xe_utils9.default.isNumber(scrollLeft)) {
          setScrollLeft(xHandleEl, scrollLeft);
          setScrollLeft(bodyScrollElem, scrollLeft);
          setScrollLeft(headerScrollElem, scrollLeft);
          setScrollLeft(footerScrollElem, scrollLeft);
          loadScrollXData();
        }
        if (import_xe_utils9.default.isNumber(scrollTop)) {
          setScrollTop(yHandleEl, scrollTop);
          setScrollTop(bodyScrollElem, scrollTop);
          setScrollTop(leftScrollElem, scrollTop);
          setScrollTop(rightScrollElem, scrollTop);
          loadScrollYData();
        }
        if (reactData.scrollXLoad || reactData.scrollYLoad) {
          return new Promise((resolve) => {
            setTimeout(() => {
              nextTick(() => {
                internalData.intoRunScroll = false;
                resolve();
              });
            }, 30);
          });
        }
        return nextTick();
      },
      /**
       * 如果有滚动条，则滚动到对应的行
       * @param {Row} row 行对象
       * @param {ColumnInfo} fieldOrColumn 列配置
       */
      scrollToRow(row, fieldOrColumn) {
        const { isAllOverflow, scrollYLoad, scrollXLoad } = reactData;
        const rest = [];
        if (row) {
          if (props.treeConfig) {
            rest.push($xeTable.scrollToTreeRow(row));
          } else {
            rest.push(rowToVisible($xeTable, row));
          }
        }
        if (fieldOrColumn) {
          rest.push(handleScrollToRowColumn(fieldOrColumn, row));
        }
        return Promise.all(rest).then(() => {
          if (row) {
            if (!isAllOverflow && (scrollYLoad || scrollXLoad)) {
              calcCellHeight();
              calcCellWidth();
            }
            return nextTick();
          }
        });
      },
      /**
       * 如果有滚动条，则滚动到对应的列
       */
      scrollToColumn(fieldOrColumn) {
        const { fullColumnIdData } = internalData;
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column && fullColumnIdData[column.id]) {
          return colToVisible($xeTable, column);
        }
        return nextTick();
      },
      /**
       * 手动清除滚动相关信息，还原到初始状态
       */
      clearScroll() {
        const { elemStore, scrollXStore, scrollYStore } = internalData;
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
        const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
        const xHandleEl = refScrollXHandleElem.value;
        const yHandleEl = refScrollYHandleElem.value;
        internalData.intoRunScroll = true;
        setScrollLeft(xHandleEl, 0);
        setScrollLeft(bodyScrollElem, 0);
        setScrollLeft(headerScrollElem, 0);
        setScrollLeft(footerScrollElem, 0);
        setScrollTop(yHandleEl, 0);
        setScrollTop(bodyScrollElem, 0);
        setScrollTop(leftScrollElem, 0);
        setScrollTop(rightScrollElem, 0);
        scrollXStore.startIndex = 0;
        scrollXStore.visibleStartIndex = 0;
        scrollXStore.endIndex = scrollXStore.visibleSize;
        scrollXStore.visibleEndIndex = scrollXStore.visibleSize;
        scrollYStore.startIndex = 0;
        scrollYStore.visibleStartIndex = 0;
        scrollYStore.endIndex = scrollYStore.visibleSize;
        scrollYStore.visibleEndIndex = scrollYStore.visibleSize;
        return nextTick().then(() => {
          internalData.intoRunScroll = false;
        });
      },
      /**
       * 更新表尾合计
       */
      updateFooter() {
        const { showFooter, footerData, footerMethod } = props;
        const { visibleColumn, afterFullData } = internalData;
        let footData = [];
        if (showFooter && footerData && footerData.length) {
          footData = footerData.slice(0);
        } else if (showFooter && footerMethod) {
          footData = visibleColumn.length ? footerMethod({ columns: visibleColumn, data: afterFullData, $table: $xeTable, $grid: $xeGrid }) : [];
        }
        reactData.footerTableData = footData;
        $xeTable.handleUpdateFooterMerge();
        return nextTick();
      },
      /**
       * 更新列状态 updateStatus({ row, column }, cellValue)
       * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一列编辑状态
       * 如果单元格配置了校验规则，则会进行校验
       */
      updateStatus(slotParams, cellValue) {
        return nextTick().then(() => {
          const { editRules } = props;
          if (slotParams && editRules) {
            return $xeTable.handleCellRuleUpdateStatus("change", slotParams, cellValue);
          }
        });
      },
      /**
       * 设置合并单元格
       * @param {TableMergeConfig[]} merges { row: Row|number, column: ColumnInfo|number, rowspan: number, colspan: number }
       */
      setMergeCells(merges) {
        if (props.spanMethod) {
          errLog("vxe.error.errConflicts", ["merge-cells", "span-method"]);
        }
        handleBodyMerge(merges);
        $xeTable.handleUpdateBodyMerge();
        return nextTick().then(() => {
          $xeTable.updateCellAreas();
          return updateStyle();
        });
      },
      /**
       * 移除单元格合并
       * @param {TableMergeConfig[]} merges 多个或数组 [{row:Row|number, col:ColumnInfo|number}]
       */
      removeMergeCells(merges) {
        if (props.spanMethod) {
          errLog("vxe.error.errConflicts", ["merge-cells", "span-method"]);
        }
        const rest = removeMerges(merges, internalData.mergeBodyList, internalData.afterFullData);
        return nextTick().then(() => {
          $xeTable.updateCellAreas();
          updateStyle();
          return rest;
        });
      },
      /**
       * 获取所有被合并的单元格
       */
      getMergeCells() {
        return internalData.mergeBodyList.slice(0);
      },
      /**
       * 清除所有单元格合并
       */
      clearMergeCells() {
        internalData.mergeBodyList = [];
        internalData.mergeBodyMaps = {};
        internalData.mergeBodyCellMaps = {};
        return nextTick().then(() => {
          return updateStyle();
        });
      },
      setMergeFooterItems(merges) {
        if (props.footerSpanMethod) {
          errLog("vxe.error.errConflicts", ["merge-footer-items", "footer-span-method"]);
        }
        handleFooterMerge(merges);
        $xeTable.handleUpdateFooterMerge();
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          return updateStyle();
        });
      },
      removeMergeFooterItems(merges) {
        if (props.footerSpanMethod) {
          errLog("vxe.error.errConflicts", ["merge-footer-items", "footer-span-method"]);
        }
        const rest = removeMerges(merges, internalData.mergeFooterList);
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          updateStyle();
          return rest;
        });
      },
      /**
       * 获取所有被合并的表尾
       */
      getMergeFooterItems() {
        return internalData.mergeFooterList.slice(0);
      },
      /**
       * 清除所有表尾合并
       */
      clearMergeFooterItems() {
        internalData.mergeFooterList = [];
        internalData.mergeFooterMaps = {};
        internalData.mergeFooterCellMaps = {};
        return nextTick().then(() => {
          return updateStyle();
        });
      },
      updateCellAreas() {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        if (mouseConfig && mouseOpts.area && $xeTable.handleRecalculateCellAreaEvent) {
          return $xeTable.handleRecalculateCellAreaEvent();
        }
        return nextTick();
      },
      getCustomStoreData() {
        const { id } = props;
        const customOpts = computeCustomOpts.value;
        const { collectColumn } = internalData;
        const { storage, checkMethod } = customOpts;
        const isAllCustom = storage === true;
        const storageOpts = isAllCustom ? {} : Object.assign({}, storage || {});
        const isCustomResizable = isAllCustom || storageOpts.resizable;
        const isCustomVisible = isAllCustom || storageOpts.visible;
        const isCustomFixed = isAllCustom || storageOpts.fixed;
        const isCustomSort = isAllCustom || storageOpts.sort;
        const resizableData = {};
        const sortData = {};
        const visibleData = {};
        const fixedData = {};
        const storeData = {
          resizableData: void 0,
          sortData: void 0,
          visibleData: void 0,
          fixedData: void 0
        };
        if (!id) {
          errLog("vxe.error.reqProp", ["id"]);
          return storeData;
        }
        let hasResizable = 0;
        let hasSort = 0;
        let hasFixed = 0;
        let hasVisible = 0;
        import_xe_utils9.default.eachTree(collectColumn, (column, index, items, path, parentColumn) => {
          const colKey = column.getKey();
          if (!colKey) {
            errLog("vxe.error.reqProp", [`${column.getTitle() || column.type || ""} -> column.field=?`]);
            return;
          }
          if (!parentColumn) {
            if (isCustomSort) {
              hasSort = 1;
              sortData[colKey] = column.renderSortNumber;
            }
            if (isCustomFixed && column.fixed !== column.defaultFixed) {
              hasFixed = 1;
              fixedData[colKey] = column.fixed;
            }
          }
          if (isCustomResizable && column.resizeWidth) {
            hasResizable = 1;
            resizableData[colKey] = column.renderWidth;
          }
          if (isCustomVisible && (!checkMethod || checkMethod({ $table: $xeTable, column }))) {
            if (!column.visible && column.defaultVisible) {
              hasVisible = 1;
              visibleData[colKey] = false;
            } else if (column.visible && !column.defaultVisible) {
              hasVisible = 1;
              visibleData[colKey] = true;
            }
          }
        });
        if (hasResizable) {
          storeData.resizableData = resizableData;
        }
        if (hasSort) {
          storeData.sortData = sortData;
        }
        if (hasFixed) {
          storeData.fixedData = fixedData;
        }
        if (hasVisible) {
          storeData.visibleData = visibleData;
        }
        return storeData;
      },
      focus() {
        internalData.isActivated = true;
        return nextTick();
      },
      blur() {
        internalData.isActivated = false;
        return nextTick();
      },
      /**
       * 连接工具栏
       * @param $toolbar
       */
      connect($toolbar) {
        if ($toolbar) {
          $xeToolbar = $toolbar;
          $xeToolbar.syncUpdate({ collectColumn: internalData.collectColumn, $table: $xeTable });
        } else {
          errLog("vxe.error.barUnableLink");
        }
        return nextTick();
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { editStore, ctxMenuStore, filterStore, customStore } = reactData;
      const { mouseConfig, editRules } = props;
      const el = refElem.value;
      const editOpts = computeEditOpts.value;
      const validOpts = computeValidOpts.value;
      const areaOpts = computeAreaOpts.value;
      const { actived } = editStore;
      const $validTooltip = refValidTooltip.value;
      const tableFilter = refTableFilter.value;
      const tableCustom = refTableCustom.value;
      const tableMenu = refTableMenu.value;
      if (tableFilter) {
        if (getEventTargetNode(evnt, el, "vxe-cell--filter").flag) {
        } else if (getEventTargetNode(evnt, tableFilter.getRefMaps().refElem.value).flag) {
        } else {
          if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
            tablePrivateMethods.preventEvent(evnt, "event.clearFilter", filterStore.args, tableMethods.closeFilter);
          }
        }
      }
      if (tableCustom) {
        if (customStore.btnEl === evnt.target || getEventTargetNode(evnt, document.body, "vxe-toolbar-custom-target").flag) {
        } else if (getEventTargetNode(evnt, tableCustom.$el).flag) {
        } else {
          if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
            tablePrivateMethods.preventEvent(evnt, "event.clearCustom", {}, () => {
              if ($xeTable.closeCustom) {
                $xeTable.closeCustom();
              }
            });
          }
        }
      }
      if (actived.row) {
        if (!(editOpts.autoClear === false)) {
          const cell = actived.args.cell;
          if (!cell || !getEventTargetNode(evnt, cell).flag) {
            if ($validTooltip && getEventTargetNode(evnt, $validTooltip.$el).flag) {
            } else if (!internalData._lastCallTime || internalData._lastCallTime + 50 < Date.now()) {
              if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
                tablePrivateMethods.preventEvent(evnt, "event.clearEdit", actived.args, () => {
                  let isClear;
                  if (editOpts.mode === "row") {
                    const rowTargetNode = getEventTargetNode(evnt, el, "vxe-body--row");
                    const rowNodeRest = rowTargetNode.flag ? tableMethods.getRowNode(rowTargetNode.targetElem) : null;
                    isClear = rowNodeRest ? !$xeTable.eqRow(rowNodeRest.item, actived.args.row) : false;
                  } else {
                    isClear = !getEventTargetNode(evnt, el, "col--edit").flag;
                  }
                  if (!isClear) {
                    isClear = getEventTargetNode(evnt, el, "vxe-header--row").flag;
                  }
                  if (!isClear) {
                    isClear = getEventTargetNode(evnt, el, "vxe-footer--row").flag;
                  }
                  if (!isClear && props.height && !reactData.overflowY) {
                    const bodyWrapperElem = evnt.target;
                    if (hasClass(bodyWrapperElem, "vxe-table--body-wrapper")) {
                      isClear = evnt.offsetY < bodyWrapperElem.clientHeight;
                    }
                  }
                  if (isClear || // 如果点击了当前表格之外
                  !getEventTargetNode(evnt, el).flag) {
                    setTimeout(() => {
                      $xeTable.handleClearEdit(evnt).then(() => {
                        if (!internalData.isActivated && editRules && validOpts.autoClear) {
                          reactData.validErrorMaps = {};
                        }
                      });
                    });
                  }
                });
              }
            }
          }
        }
      } else if (mouseConfig) {
        if (!getEventTargetNode(evnt, el).flag && !($xeGrid && getEventTargetNode(evnt, $xeGrid.getRefMaps().refElem.value).flag) && !(tableMenu && getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) && !($xeToolbar && getEventTargetNode(evnt, $xeToolbar.getRefMaps().refElem.value).flag)) {
          if ($xeTable.clearSelected) {
            $xeTable.clearSelected();
          }
          if (areaOpts.autoClear) {
            if ($xeTable.getCellAreas) {
              const cellAreas = $xeTable.getCellAreas();
              if (cellAreas && cellAreas.length && !getEventTargetNode(evnt, document.body, "vxe-table--ignore-areas-clear").flag) {
                tablePrivateMethods.preventEvent(evnt, "event.clearAreas", {}, () => {
                  $xeTable.clearCellAreas();
                  $xeTable.clearCopyCellArea();
                  dispatchEvent("clear-cell-area-selection", { cellAreas }, evnt);
                });
              }
            }
          }
        }
      }
      if ($xeTable.closeMenu) {
        if (ctxMenuStore.visible && tableMenu && !getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) {
          $xeTable.closeMenu();
        }
      }
      const isActivated = getEventTargetNode(evnt, $xeGrid ? $xeGrid.getRefMaps().refElem.value : el).flag;
      if (!isActivated && editRules && validOpts.autoClear) {
        reactData.validErrorMaps = {};
      }
      internalData.isActivated = isActivated;
    };
    const handleGlobalBlurEvent = () => {
      tableMethods.closeFilter();
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
    };
    const handleGlobalMousewheelEvent = () => {
      tableMethods.closeTooltip();
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
    };
    const keydownEvent = (evnt) => {
      const { mouseConfig, keyboardConfig } = props;
      const { filterStore, ctxMenuStore, editStore } = reactData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      if (isEsc) {
        tablePrivateMethods.preventEvent(evnt, "event.keydown", null, () => {
          dispatchEvent("keydown-start", {}, evnt);
          if (keyboardConfig && mouseConfig && mouseOpts.area && $xeTable.handleKeyboardCellAreaEvent) {
            $xeTable.handleKeyboardCellAreaEvent(evnt);
          } else if (actived.row || filterStore.visible || ctxMenuStore.visible) {
            evnt.stopPropagation();
            if ($xeTable.closeMenu) {
              $xeTable.closeMenu();
            }
            tableMethods.closeFilter();
            if (keyboardConfig && keyboardOpts.isEsc) {
              if (actived.row) {
                const params = actived.args;
                $xeTable.handleClearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick(() => $xeTable.handleSelected(params, evnt));
                }
              }
            }
          }
          dispatchEvent("keydown", {}, evnt);
          dispatchEvent("keydown-end", {}, evnt);
        });
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      if (internalData.isActivated) {
        $xeTable.preventEvent(evnt, "event.keydown", null, () => {
          const { mouseConfig, keyboardConfig, treeConfig, editConfig, highlightCurrentRow, highlightCurrentColumn } = props;
          const { ctxMenuStore, editStore, currentRow } = reactData;
          const { afterFullData } = internalData;
          const isMenu = computeIsMenu.value;
          const bodyMenu = computeBodyMenu.value;
          const keyboardOpts = computeKeyboardOpts.value;
          const mouseOpts = computeMouseOpts.value;
          const editOpts = computeEditOpts.value;
          const treeOpts = computeTreeOpts.value;
          const menuList = computeMenuList.value;
          const rowOpts = computeRowOpts.value;
          const columnOpts = computeColumnOpts.value;
          const { selected, actived } = editStore;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          const keyCode = evnt.keyCode;
          const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
          const hasBackspaceKey = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.BACKSPACE);
          const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
          const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
          const isSpacebar = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR);
          const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
          const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
          const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
          const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
          const hasDeleteKey = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
          const isF2 = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.F2);
          const isContextMenu = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.CONTEXT_MENU);
          const isControlKey = hasControlKey(evnt);
          const hasShiftKey = evnt.shiftKey;
          const isAltKey = evnt.altKey;
          const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
          const operCtxMenu = isMenu && ctxMenuStore.visible && (isEnter || isSpacebar || operArrow);
          const isEditStatus = isEnableConf(editConfig) && actived.column && actived.row;
          const beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;
          if (operCtxMenu) {
            evnt.preventDefault();
            if (ctxMenuStore.showChild && hasChildrenList(ctxMenuStore.selected)) {
              $xeTable.moveCtxMenu(evnt, ctxMenuStore, "selectChild", isLeftArrow, false, ctxMenuStore.selected.children);
            } else {
              $xeTable.moveCtxMenu(evnt, ctxMenuStore, "selected", isRightArrow, true, menuList);
            }
          } else if (keyboardConfig && mouseConfig && mouseOpts.area && $xeTable.handleKeyboardCellAreaEvent) {
            $xeTable.handleKeyboardCellAreaEvent(evnt);
          } else if (isEsc) {
            if ($xeTable.closeMenu) {
              $xeTable.closeMenu();
            }
            $xeTable.closeFilter();
            if (keyboardConfig && keyboardOpts.isEsc) {
              if (actived.row) {
                const params = actived.args;
                $xeTable.handleClearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick(() => $xeTable.handleSelected(params, evnt));
                }
              }
            }
          } else if (isSpacebar && keyboardConfig && keyboardOpts.isChecked && selected.row && selected.column && (selected.column.type === "checkbox" || selected.column.type === "radio")) {
            evnt.preventDefault();
            if (selected.column.type === "checkbox") {
              tablePrivateMethods.handleToggleCheckRowEvent(evnt, selected.args);
            } else {
              tablePrivateMethods.triggerRadioRowEvent(evnt, selected.args);
            }
          } else if (isF2 && isEnableConf(editConfig)) {
            if (!isEditStatus) {
              if (selected.row && selected.column) {
                evnt.preventDefault();
                $xeTable.handleEdit(selected.args, evnt);
              }
            }
          } else if (isContextMenu) {
            internalData._keyCtx = selected.row && selected.column && bodyMenu.length;
            clearTimeout(internalData.keyCtxTimeout);
            internalData.keyCtxTimeout = setTimeout(() => {
              internalData._keyCtx = false;
            }, 1e3);
          } else if (isEnter && !isAltKey && keyboardConfig && keyboardOpts.isEnter && (selected.row || actived.row || treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow)) {
            const { isLastEnterAppendRow, beforeEnterMethod, enterMethod } = keyboardOpts;
            if (isControlKey) {
              if (actived.row) {
                const params = actived.args;
                $xeTable.handleClearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick(() => {
                    $xeTable.handleSelected(params, evnt);
                  });
                }
              }
            } else {
              if (selected.row || actived.row) {
                const activeParams = selected.row ? selected.args : actived.args;
                if (hasShiftKey) {
                  if (keyboardOpts.enterToTab) {
                    $xeTable.moveTabSelected(activeParams, hasShiftKey, evnt);
                  } else {
                    $xeTable.moveEnterSelected(activeParams, isLeftArrow, true, isRightArrow, false, evnt);
                  }
                } else {
                  if (keyboardOpts.enterToTab) {
                    $xeTable.moveTabSelected(activeParams, hasShiftKey, evnt);
                  } else {
                    const activeRow = selected.row || actived.row;
                    const activeColumn = selected.column || actived.column;
                    const _rowIndex = $xeTable.getVTRowIndex(activeRow);
                    const etrParams = {
                      row: activeRow,
                      rowIndex: $xeTable.getRowIndex(activeRow),
                      $rowIndex: $xeTable.getVMRowIndex(activeRow),
                      _rowIndex,
                      column: activeColumn,
                      columnIndex: $xeTable.getColumnIndex(activeColumn),
                      $columnIndex: $xeTable.getVMColumnIndex(activeColumn),
                      _columnIndex: $xeTable.getVTColumnIndex(activeColumn),
                      $table: $xeTable
                    };
                    if (!beforeEnterMethod || beforeEnterMethod(etrParams) !== false) {
                      if (isLastEnterAppendRow) {
                        if (_rowIndex >= afterFullData.length - 1) {
                          $xeTable.insertAt({}, -1).then(({ row: newRow }) => {
                            $xeTable.scrollToRow(newRow, activeColumn);
                            $xeTable.handleSelected(Object.assign(Object.assign({}, activeParams), { row: newRow }), evnt);
                          });
                          $xeTable.dispatchEvent("enter-append-row", etrParams, evnt);
                          return;
                        }
                      }
                      $xeTable.moveEnterSelected(activeParams, isLeftArrow, false, isRightArrow, true, evnt);
                      if (enterMethod) {
                        enterMethod(etrParams);
                      }
                    }
                  }
                }
              } else if (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {
                const childrens = currentRow[childrenField];
                if (childrens && childrens.length) {
                  evnt.preventDefault();
                  const targetRow = childrens[0];
                  const params = {
                    $table: $xeTable,
                    row: targetRow,
                    rowIndex: $xeTable.getRowIndex(targetRow),
                    $rowIndex: $xeTable.getVMRowIndex(targetRow)
                  };
                  $xeTable.setTreeExpand(currentRow, true).then(() => $xeTable.scrollToRow(targetRow)).then(() => $xeTable.triggerCurrentRowEvent(evnt, params));
                }
              }
            }
          } else if (operArrow && keyboardConfig && keyboardOpts.isArrow) {
            if (!isEditStatus) {
              if (mouseOpts.selected && selected.row && selected.column) {
                $xeTable.moveArrowSelected(selected.args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt);
              } else {
                if ((isUpArrow || isDwArrow) && (rowOpts.isCurrent || highlightCurrentRow)) {
                  $xeTable.moveCurrentRow(isUpArrow, isDwArrow, evnt);
                }
                if ((isLeftArrow || isRightArrow) && (columnOpts.isCurrent || highlightCurrentColumn)) {
                  $xeTable.moveCurrentColumn(isLeftArrow, isRightArrow, evnt);
                }
              }
            }
          } else if (isTab && keyboardConfig && keyboardOpts.isTab) {
            if (selected.row || selected.column) {
              $xeTable.moveTabSelected(selected.args, hasShiftKey, evnt);
            } else if (actived.row || actived.column) {
              $xeTable.moveTabSelected(actived.args, hasShiftKey, evnt);
            }
          } else if (keyboardConfig && keyboardOpts.isDel && hasDeleteKey && isEnableConf(editConfig) && (selected.row || selected.column)) {
            if (!isEditStatus) {
              const { delMethod } = keyboardOpts;
              const params = {
                row: selected.row,
                rowIndex: tableMethods.getRowIndex(selected.row),
                column: selected.column,
                columnIndex: tableMethods.getColumnIndex(selected.column),
                $table: $xeTable,
                $grid: $xeGrid
              };
              if (!beforeEditMethod || beforeEditMethod(params)) {
                if (delMethod) {
                  delMethod(params);
                } else {
                  setCellValue(selected.row, selected.column, null);
                }
                tableMethods.updateFooter();
                dispatchEvent("cell-delete-value", params, evnt);
              }
            }
          } else if (hasBackspaceKey && keyboardConfig && keyboardOpts.isBack && isEnableConf(editConfig) && (selected.row || selected.column)) {
            if (!isEditStatus) {
              const { backMethod } = keyboardOpts;
              if (keyboardOpts.isDel && isEnableConf(editConfig) && (selected.row || selected.column)) {
                const params = {
                  row: selected.row,
                  rowIndex: $xeTable.getRowIndex(selected.row),
                  column: selected.column,
                  columnIndex: $xeTable.getColumnIndex(selected.column),
                  $table: $xeTable,
                  $grid: $xeGrid
                };
                if (!beforeEditMethod || beforeEditMethod(params)) {
                  if (backMethod) {
                    backMethod(params);
                  } else {
                    setCellValue(selected.row, selected.column, null);
                    $xeTable.handleEdit(selected.args, evnt);
                  }
                  dispatchEvent("cell-backspace-value", params, evnt);
                }
              }
            }
          } else if (hasBackspaceKey && keyboardConfig && treeConfig && keyboardOpts.isBack && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {
            const { parent: parentRow } = import_xe_utils9.default.findTree(internalData.afterTreeFullData, (item) => item === currentRow, { children: childrenField });
            if (parentRow) {
              evnt.preventDefault();
              const params = {
                row: parentRow,
                rowIndex: $xeTable.getRowIndex(parentRow),
                $rowIndex: $xeTable.getVMRowIndex(parentRow),
                $table: $xeTable,
                $grid: $xeGrid
              };
              $xeTable.setTreeExpand(parentRow, false).then(() => $xeTable.scrollToRow(parentRow)).then(() => $xeTable.triggerCurrentRowEvent(evnt, params));
            }
          } else if (keyboardConfig && isEnableConf(editConfig) && keyboardOpts.isEdit && !isControlKey && (isSpacebar || keyCode >= 48 && keyCode <= 57 || keyCode >= 65 && keyCode <= 90 || keyCode >= 96 && keyCode <= 111 || keyCode >= 186 && keyCode <= 192 || keyCode >= 219 && keyCode <= 222)) {
            const { editMode, editMethod } = keyboardOpts;
            if (selected.column && selected.row && isEnableConf(selected.column.editRender)) {
              const beforeEditMethod2 = editOpts.beforeEditMethod || editOpts.activeMethod;
              const params = {
                row: selected.row,
                rowIndex: $xeTable.getRowIndex(selected.row),
                column: selected.column,
                columnIndex: $xeTable.getColumnIndex(selected.column),
                $table: $xeTable,
                $grid: $xeGrid
              };
              if (!beforeEditMethod2 || beforeEditMethod2(Object.assign(Object.assign({}, selected.args), { $table: $xeTable, $grid: $xeGrid }))) {
                if (editMethod) {
                  editMethod(params);
                } else {
                  if (editMode !== "insert") {
                    setCellValue(selected.row, selected.column, null);
                  }
                  $xeTable.handleEdit(selected.args, evnt);
                }
              }
            }
          }
          dispatchEvent("keydown", {}, evnt);
        });
      }
    };
    const handleGlobalPasteEvent = (evnt) => {
      const { keyboardConfig, mouseConfig } = props;
      const { editStore, filterStore } = reactData;
      const { isActivated } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xeTable.handlePasteCellAreaEvent) {
            $xeTable.handlePasteCellAreaEvent(evnt);
          }
        }
        dispatchEvent("paste", {}, evnt);
      }
    };
    const handleGlobalCopyEvent = (evnt) => {
      const { keyboardConfig, mouseConfig } = props;
      const { editStore, filterStore } = reactData;
      const { isActivated } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xeTable.handleCopyCellAreaEvent) {
            $xeTable.handleCopyCellAreaEvent(evnt);
          }
        }
        dispatchEvent("copy", {}, evnt);
      }
    };
    const handleGlobalCutEvent = (evnt) => {
      const { keyboardConfig, mouseConfig } = props;
      const { editStore, filterStore } = reactData;
      const { isActivated } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xeTable.handleCutCellAreaEvent) {
            $xeTable.handleCutCellAreaEvent(evnt);
          }
        }
        dispatchEvent("cut", {}, evnt);
      }
    };
    const handleGlobalResizeEvent = () => {
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
      const el = refElem.value;
      if (!el || !el.clientWidth) {
        return nextTick();
      }
      tableMethods.recalculate(true);
      tableMethods.updateCellAreas();
    };
    const handleTargetEnterEvent = (isClear) => {
      const $tooltip = refTooltip.value;
      clearTimeout(internalData.tooltipTimeout);
      if (isClear) {
        tableMethods.closeTooltip();
      } else {
        if ($tooltip && $tooltip.setActived) {
          $tooltip.setActived(true);
        }
      }
    };
    const clearDragStatus = () => {
      const { dragRow, dragCol } = reactData;
      if (dragRow || dragCol) {
        clearColDropOrigin();
        clearRowDropOrigin();
        hideDropTip();
        reactData.dragRow = null;
        reactData.dragCol = null;
        reactData.isDragColMove = false;
        reactData.isDragRowMove = false;
      }
    };
    const clearRowDropOrigin = () => {
      const el = refElem.value;
      if (el) {
        const clss = "row--drag-origin";
        import_xe_utils9.default.arrayEach(el.querySelectorAll(`.${clss}`), (elem) => {
          elem.draggable = false;
          removeClass(elem, clss);
        });
      }
    };
    const updateRowDropOrigin = (row) => {
      const el = refElem.value;
      if (el) {
        const clss = "row--drag-origin";
        const rowid = getRowid($xeTable, row);
        import_xe_utils9.default.arrayEach(el.querySelectorAll(`[rowid="${rowid}"]`), (elem) => {
          addClass(elem, clss);
        });
      }
    };
    const updateRowDropTipContent = (tdEl) => {
      const { dragConfig } = props;
      const { dragRow } = reactData;
      const rowDragOpts = computeRowDragOpts.value;
      const { tooltipMethod } = rowDragOpts;
      const rTooltipMethod = tooltipMethod || (dragConfig ? dragConfig.rowTooltipMethod : null);
      let tipContent = "";
      if (rTooltipMethod) {
        const rtParams = {
          $table: $xeTable,
          row: dragRow
        };
        tipContent = `${rTooltipMethod(rtParams) || ""}`;
      } else {
        tipContent = getI18n6("vxe.table.dragTip", [tdEl.textContent || ""]);
      }
      reactData.dragTipText = tipContent;
    };
    const updateColDropOrigin = (column) => {
      const el = refElem.value;
      if (el) {
        const colQuerys = [];
        import_xe_utils9.default.eachTree([column], (item) => {
          colQuerys.push(`[colid="${item.id}"]`);
        });
        const clss = "col--drag-origin";
        import_xe_utils9.default.arrayEach(el.querySelectorAll(colQuerys.join(",")), (elem) => {
          addClass(elem, clss);
        });
      }
    };
    const clearColDropOrigin = () => {
      const el = refElem.value;
      if (el) {
        const clss = "col--drag-origin";
        import_xe_utils9.default.arrayEach(el.querySelectorAll(`.${clss}`), (elem) => {
          elem.draggable = false;
          removeClass(elem, clss);
        });
      }
    };
    const updateColDropTipContent = (tdEl) => {
      const { dragCol } = reactData;
      const columnDragOpts = computeColumnDragOpts.value;
      const { tooltipMethod } = columnDragOpts;
      let tipContent = "";
      if (tooltipMethod) {
        const dtParams = {
          $table: $xeTable,
          column: dragCol
        };
        tipContent = `${tooltipMethod(dtParams) || ""}`;
      } else {
        tipContent = getI18n6("vxe.table.dragTip", [tdEl.textContent || ""]);
      }
      reactData.dragTipText = tipContent;
    };
    const showDropTip = (evnt, trEl, thEl, showLine, dragPos) => {
      const el = refElem.value;
      if (!el) {
        return;
      }
      const { overflowX, scrollbarWidth, overflowY, scrollbarHeight } = reactData;
      const { prevDragToChild } = internalData;
      const wrapperRect = el.getBoundingClientRect();
      const osbWidth = overflowY ? scrollbarWidth : 0;
      const osbHeight = overflowX ? scrollbarHeight : 0;
      const tableWrapperWidth = el.clientWidth;
      const tableWrapperHeight = el.clientHeight;
      if (trEl) {
        const rdLineEl = refDragRowLineElem.value;
        if (rdLineEl) {
          if (showLine) {
            const scrollbarYToLeft = computeScrollbarYToLeft.value;
            const trRect = trEl.getBoundingClientRect();
            let trHeight = trEl.clientHeight;
            const offsetTop = Math.max(1, trRect.y - wrapperRect.y);
            if (offsetTop + trHeight > tableWrapperHeight - osbHeight) {
              trHeight = tableWrapperHeight - offsetTop - osbHeight;
            }
            rdLineEl.style.display = "block";
            rdLineEl.style.left = `${scrollbarYToLeft ? osbWidth : 0}px`;
            rdLineEl.style.top = `${offsetTop}px`;
            rdLineEl.style.height = `${trHeight}px`;
            rdLineEl.style.width = `${tableWrapperWidth - osbWidth}px`;
            rdLineEl.setAttribute("drag-pos", dragPos);
            rdLineEl.setAttribute("drag-to-child", prevDragToChild ? "y" : "n");
          } else {
            rdLineEl.style.display = "";
          }
        }
      } else if (thEl) {
        const cdLineEl = refDragColLineElem.value;
        if (cdLineEl) {
          if (showLine) {
            const scrollbarXToTop = computeScrollbarXToTop.value;
            const leftContainerElem = refLeftContainer.value;
            const leftContainerWidth = leftContainerElem ? leftContainerElem.clientWidth : 0;
            const rightContainerElem = refRightContainer.value;
            const rightContainerWidth = rightContainerElem ? rightContainerElem.clientWidth : 0;
            const thRect = thEl.getBoundingClientRect();
            let thWidth = thEl.clientWidth;
            const offsetTop = Math.max(0, thRect.y - wrapperRect.y);
            const startX = leftContainerWidth;
            let offsetLeft = thRect.x - wrapperRect.x;
            if (offsetLeft < startX) {
              thWidth -= startX - offsetLeft;
              offsetLeft = startX;
            }
            const endX = tableWrapperWidth - rightContainerWidth - (rightContainerWidth ? 0 : osbWidth);
            if (offsetLeft + thWidth > endX) {
              thWidth = endX - offsetLeft;
            }
            cdLineEl.style.display = "block";
            cdLineEl.style.top = `${offsetTop}px`;
            cdLineEl.style.left = `${offsetLeft}px`;
            cdLineEl.style.width = `${thWidth}px`;
            if (prevDragToChild) {
              cdLineEl.style.height = `${thRect.height}px`;
            } else {
              cdLineEl.style.height = `${tableWrapperHeight - offsetTop - (scrollbarXToTop ? 0 : osbHeight)}px`;
            }
            cdLineEl.setAttribute("drag-pos", dragPos);
            cdLineEl.setAttribute("drag-to-child", prevDragToChild ? "y" : "n");
          } else {
            cdLineEl.style.display = "";
          }
        }
      }
      const rdTipEl = refDragTipElem.value;
      if (rdTipEl) {
        rdTipEl.style.display = "block";
        rdTipEl.style.top = `${Math.min(el.clientHeight - el.scrollTop - rdTipEl.clientHeight, evnt.clientY - wrapperRect.y)}px`;
        rdTipEl.style.left = `${Math.min(el.clientWidth - el.scrollLeft - rdTipEl.clientWidth - 16, evnt.clientX - wrapperRect.x)}px`;
        rdTipEl.setAttribute("drag-status", showLine ? prevDragToChild ? "sub" : "normal" : "disabled");
      }
    };
    const hideDropTip = () => {
      const rdTipEl = refDragTipElem.value;
      const rdLineEl = refDragRowLineElem.value;
      const cdLineEl = refDragColLineElem.value;
      if (rdTipEl) {
        rdTipEl.style.display = "";
      }
      if (rdLineEl) {
        rdLineEl.style.display = "";
      }
      if (cdLineEl) {
        cdLineEl.style.display = "";
      }
    };
    const handleTooltip = (evnt, tdEl, overflowElem, tipElem, params) => {
      const tipOverEl = overflowElem || tdEl;
      if (!tipOverEl) {
        return nextTick();
      }
      params.cell = tdEl;
      const { tooltipStore } = reactData;
      const tooltipOpts = computeTooltipOpts.value;
      const { column, row } = params;
      const { showAll, contentMethod } = tooltipOpts;
      const customContent = contentMethod ? contentMethod(params) : null;
      const useCustom = contentMethod && !import_xe_utils9.default.eqNull(customContent);
      const content = useCustom ? customContent : import_xe_utils9.default.toString(column.type === "html" ? tipOverEl.innerText : tipOverEl.textContent).trim();
      const isOver = tipOverEl.scrollWidth > tipOverEl.clientWidth;
      if (content && (showAll || useCustom || isOver)) {
        Object.assign(tooltipStore, {
          row,
          column,
          visible: true,
          currOpts: {}
        });
        nextTick(() => {
          const $tooltip = refTooltip.value;
          if ($tooltip && $tooltip.open) {
            $tooltip.open(isOver ? tipOverEl : tipElem, formatText(content));
          }
        });
      }
      return nextTick();
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if ($xeGrid) {
          return $xeGrid.callSlot(slotFunc, params);
        }
        if (import_xe_utils9.default.isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    tablePrivateMethods = {
      getSetupOptions() {
        return getConfig2();
      },
      updateAfterDataIndex,
      callSlot,
      /**
       * 获取父容器元素
       */
      getParentElem() {
        const el = refElem.value;
        if ($xeGrid) {
          const gridEl = $xeGrid.getRefMaps().refElem.value;
          return gridEl ? gridEl.parentNode : null;
        }
        return el ? el.parentNode : null;
      },
      /**
       * 获取父容器的高度
       */
      getParentHeight() {
        const { height } = props;
        const el = refElem.value;
        if (el) {
          const parentElem = el.parentNode;
          const parentPaddingSize = height === "100%" || height === "auto" ? getPaddingTopBottomSize(parentElem) : 0;
          let parentWrapperHeight = 0;
          if (parentElem) {
            if ($xeGrid && hasClass(parentElem, "vxe-grid--table-wrapper")) {
              parentWrapperHeight = $xeGrid.getParentHeight();
            } else {
              parentWrapperHeight = parentElem.clientHeight;
            }
          }
          return Math.floor(parentWrapperHeight - parentPaddingSize);
        }
        return 0;
      },
      /**
       * 获取需要排除的高度
       * 但渲染表格高度时，需要排除工具栏或分页等相关组件的高度
       * 如果存在表尾合计滚动条，则需要排除滚动条高度
       */
      getExcludeHeight() {
        return $xeGrid ? $xeGrid.getExcludeHeight() : 0;
      },
      /**
       * 定义行数据中的列属性，如果不存在则定义
       * @param {Row} records 行数据
       */
      defineField(records) {
        const { treeConfig } = props;
        const expandOpts = computeExpandOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const rowkey = getRowkey($xeTable);
        if (!import_xe_utils9.default.isArray(records)) {
          records = [records];
        }
        return records.map((record) => {
          internalData.tableFullColumn.forEach((column) => {
            const { field, editRender } = column;
            if (field && !import_xe_utils9.default.has(record, field) && !record[field]) {
              let cellValue = null;
              if (editRender) {
                const { defaultValue } = editRender;
                if (import_xe_utils9.default.isFunction(defaultValue)) {
                  cellValue = defaultValue({ column });
                } else if (!import_xe_utils9.default.isUndefined(defaultValue)) {
                  cellValue = defaultValue;
                }
              }
              import_xe_utils9.default.set(record, field, cellValue);
            }
          });
          const otherFields = [radioOpts.labelField, checkboxOpts.checkField, checkboxOpts.labelField, expandOpts.labelField];
          otherFields.forEach((key) => {
            if (key && eqEmptyValue(import_xe_utils9.default.get(record, key))) {
              import_xe_utils9.default.set(record, key, null);
            }
          });
          if (treeConfig && treeOpts.lazy && import_xe_utils9.default.isUndefined(record[childrenField])) {
            record[childrenField] = null;
          }
          if (eqEmptyValue(import_xe_utils9.default.get(record, rowkey))) {
            import_xe_utils9.default.set(record, rowkey, getRowUniqueId());
          }
          return record;
        });
      },
      handleTableData(force) {
        const { scrollYLoad } = reactData;
        const { scrollYStore, fullDataRowIdData } = internalData;
        let fullList = internalData.afterFullData;
        if (force) {
          updateAfterFullData();
          fullList = handleVirtualTreeToList();
        }
        const tableData = scrollYLoad ? fullList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullList.slice(0);
        const visibleDataRowIdMaps = {};
        tableData.forEach((row, $index) => {
          const rowid = getRowid($xeTable, row);
          const rest = fullDataRowIdData[rowid];
          if (rest) {
            rest.$index = $index;
          }
          visibleDataRowIdMaps[rowid] = row;
        });
        reactData.tableData = tableData;
        internalData.visibleDataRowIdData = visibleDataRowIdMaps;
        return nextTick();
      },
      /**
       * 更新数据行的 Map
       */
      cacheRowMap(isReset) {
        const { treeConfig } = props;
        const { isRowGroupStatus } = reactData;
        const { fullAllDataRowIdData, tableFullData, tableFullTreeData, tableFullGroupData, treeExpandedMaps } = internalData;
        const fullAllDataRowIdMaps = isReset ? {} : Object.assign({}, fullAllDataRowIdData);
        const fullDataRowIdMaps = {};
        const { handleUpdateRowId } = createHandleUpdateRowId($xeTable);
        const handleRowCache = (row, index, items, currIndex, parentRow, rowid, level, seq) => {
          let rowRest = fullAllDataRowIdMaps[rowid];
          if (!rowRest) {
            rowRest = { row, rowid, seq, index: -1, _index: -1, $index: -1, treeIndex: index, items, parent: parentRow, level, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
            fullDataRowIdMaps[rowid] = rowRest;
            fullAllDataRowIdMaps[rowid] = rowRest;
          }
          rowRest.treeLoaded = false;
          rowRest.expandLoaded = false;
          rowRest.row = row;
          rowRest.items = items;
          rowRest.parent = parentRow;
          rowRest.level = level;
          rowRest.index = currIndex;
          rowRest.treeIndex = index;
          fullDataRowIdMaps[rowid] = rowRest;
          fullAllDataRowIdMaps[rowid] = rowRest;
        };
        if (treeConfig) {
          const treeOpts = computeTreeOpts.value;
          const { lazy } = treeOpts;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
          import_xe_utils9.default.eachTree(tableFullTreeData, (row, index, items, path, parentRow, nodes) => {
            const rowid = handleUpdateRowId(row);
            if (treeConfig && lazy) {
              if (row[hasChildField] && row[childrenField] === void 0) {
                row[childrenField] = null;
              }
              if (treeExpandedMaps[rowid]) {
                if (!row[childrenField] || !row[childrenField].length) {
                  delete treeExpandedMaps[rowid];
                }
              }
            }
            handleRowCache(row, index, items, parentRow ? -1 : index, parentRow, rowid, nodes.length - 1, toTreePathSeq(path));
          }, { children: childrenField });
        } else if (isRowGroupStatus) {
          const rowGroupOpts = computeRowGroupOpts.value;
          const { mapChildrenField } = rowGroupOpts;
          import_xe_utils9.default.eachTree(tableFullGroupData, (row, index, items, path, parentRow, nodes) => {
            const rowid = handleUpdateRowId(row);
            handleRowCache(row, index, items, parentRow ? -1 : index, parentRow, rowid, nodes.length - 1, toTreePathSeq(path));
          }, { children: mapChildrenField });
        } else {
          tableFullData.forEach((row, index, items) => {
            handleRowCache(row, index, items, index, null, handleUpdateRowId(row), 0, index + 1);
          });
        }
        internalData.fullDataRowIdData = fullDataRowIdMaps;
        internalData.fullAllDataRowIdData = fullAllDataRowIdMaps;
        reactData.treeExpandedFlag++;
      },
      cacheSourceMap(fullData) {
        const { treeConfig } = props;
        const treeOpts = computeTreeOpts.value;
        const sourceData = import_xe_utils9.default.clone(fullData, true);
        const { handleUpdateRowId } = createHandleUpdateRowId($xeTable);
        const sourceRowIdData = {};
        const handleSourceRow = (row) => {
          const rowid = handleUpdateRowId(row);
          sourceRowIdData[rowid] = row;
        };
        if (treeConfig) {
          const childrenField = treeOpts.children || treeOpts.childrenField;
          import_xe_utils9.default.eachTree(sourceData, handleSourceRow, { children: treeOpts.transform ? treeOpts.mapChildrenField : childrenField });
        } else {
          sourceData.forEach(handleSourceRow);
        }
        internalData.sourceDataRowIdData = sourceRowIdData;
        internalData.tableSourceData = sourceData;
      },
      /**
       * 指定列宽的列进行拆分
       */
      analyColumnWidth() {
        const { tableFullColumn } = internalData;
        const columnOpts = computeColumnOpts.value;
        const { width: defaultWidth, minWidth: defaultMinWidth } = columnOpts;
        const resizeList = [];
        const pxList = [];
        const pxMinList = [];
        const autoMinList = [];
        const scaleList = [];
        const scaleMinList = [];
        const autoList = [];
        const remainList = [];
        tableFullColumn.forEach((column) => {
          if (defaultWidth && !column.width) {
            column.width = defaultWidth;
          }
          if (defaultMinWidth && !column.minWidth) {
            column.minWidth = defaultMinWidth;
          }
          if (column.visible) {
            if (column.resizeWidth) {
              resizeList.push(column);
            } else if (column.width === "auto") {
              autoList.push(column);
            } else if (isPx(column.width)) {
              pxList.push(column);
            } else if (isScale(column.width)) {
              scaleList.push(column);
            } else if (isPx(column.minWidth)) {
              pxMinList.push(column);
            } else if (column.minWidth === "auto") {
              autoMinList.push(column);
            } else if (isScale(column.minWidth)) {
              scaleMinList.push(column);
            } else {
              remainList.push(column);
            }
          }
        });
        Object.assign(reactData.columnStore, { resizeList, pxList, pxMinList, autoMinList, scaleList, scaleMinList, autoList, remainList });
      },
      handleColResizeMousedownEvent(evnt, fixedType, params) {
        evnt.stopPropagation();
        evnt.preventDefault();
        const { column } = params;
        const { overflowX, scrollbarHeight } = reactData;
        const { elemStore, visibleColumn } = internalData;
        const resizableOpts = computeResizableOpts.value;
        const osbHeight = overflowX ? scrollbarHeight : 0;
        const tableEl = refElem.value;
        const leftContainerElem = refLeftContainer.value;
        const rightContainerElem = refRightContainer.value;
        const resizeBarElem = refColResizeBar.value;
        if (!resizeBarElem) {
          return;
        }
        const resizeTipElem = resizeBarElem.firstElementChild;
        const scrollbarXToTop = computeScrollbarXToTop.value;
        const { clientX: dragClientX } = evnt;
        const wrapperElem = refElem.value;
        const dragBtnElem = evnt.target;
        let resizeColumn = column;
        if (column.children && column.children.length) {
          import_xe_utils9.default.eachTree(column.children, (childColumn) => {
            resizeColumn = childColumn;
          });
        }
        const cell = dragBtnElem.parentNode;
        const cellParams = Object.assign(params, { cell });
        let dragLeft = 0;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        if (!bodyScrollElem) {
          return;
        }
        const pos = getOffsetPos(dragBtnElem, wrapperElem);
        const dragBtnWidth = dragBtnElem.clientWidth;
        const dragBtnOffsetWidth = Math.floor(dragBtnWidth / 2);
        const minInterval = getColReMinWidth(cellParams) - dragBtnOffsetWidth;
        let dragMinLeft = pos.left - cell.clientWidth + dragBtnWidth + minInterval;
        let dragPosLeft = pos.left + dragBtnOffsetWidth;
        const isLeftFixed = fixedType === "left";
        const isRightFixed = fixedType === "right";
        let fixedOffsetWidth = 0;
        if (isLeftFixed || isRightFixed) {
          const siblingProp = isLeftFixed ? "nextElementSibling" : "previousElementSibling";
          let tempCellElem = cell[siblingProp];
          while (tempCellElem) {
            if (hasClass(tempCellElem, "fixed--hidden")) {
              break;
            } else if (!hasClass(tempCellElem, "col--group")) {
              fixedOffsetWidth += tempCellElem.offsetWidth;
            }
            tempCellElem = tempCellElem[siblingProp];
          }
          if (isRightFixed && rightContainerElem) {
            dragPosLeft = rightContainerElem.offsetLeft + fixedOffsetWidth;
          }
        }
        const updateEvent = (evnt2) => {
          evnt2.stopPropagation();
          evnt2.preventDefault();
          const tableHeight = tableEl.clientHeight;
          const offsetX = evnt2.clientX - dragClientX;
          let left = dragPosLeft + offsetX;
          const scrollLeft = fixedType ? 0 : bodyScrollElem.scrollLeft;
          if (isLeftFixed) {
            left = Math.min(left, (rightContainerElem ? rightContainerElem.offsetLeft : bodyScrollElem.clientWidth) - fixedOffsetWidth - minInterval);
          } else if (isRightFixed) {
            dragMinLeft = (leftContainerElem ? leftContainerElem.clientWidth : 0) + fixedOffsetWidth + minInterval;
            left = Math.min(left, dragPosLeft + cell.clientWidth - minInterval);
          } else {
            dragMinLeft = Math.max(bodyScrollElem.scrollLeft, dragMinLeft);
          }
          dragLeft = Math.max(left, dragMinLeft);
          const resizeBarLeft = Math.max(1, dragLeft - scrollLeft);
          resizeBarElem.style.left = `${resizeBarLeft}px`;
          resizeBarElem.style.top = `${scrollbarXToTop ? osbHeight : 0}px`;
          resizeBarElem.style.height = `${scrollbarXToTop ? tableHeight - osbHeight : tableHeight}px`;
          if (resizableOpts.showDragTip && resizeTipElem) {
            resizeTipElem.textContent = getI18n6("vxe.table.resizeColTip", [resizeColumn.renderWidth + (isRightFixed ? dragPosLeft - dragLeft : dragLeft - dragPosLeft)]);
            const tableWrapperWidth = tableEl.clientWidth;
            const wrapperRect = wrapperElem.getBoundingClientRect();
            const resizeBarWidth = resizeBarElem.clientWidth;
            const resizeTipWidth = resizeTipElem.clientWidth;
            const resizeTipHeight = resizeTipElem.clientHeight;
            let resizeTipLeft = -resizeTipWidth;
            if (resizeBarLeft < resizeTipWidth + resizeBarWidth) {
              resizeTipLeft = 0;
            } else if (resizeBarLeft > tableWrapperWidth) {
              resizeTipLeft += tableWrapperWidth - resizeBarLeft;
            }
            resizeTipElem.style.left = `${resizeTipLeft}px`;
            resizeTipElem.style.top = `${Math.min(tableHeight - resizeTipHeight, Math.max(0, evnt2.clientY - wrapperRect.y - resizeTipHeight / 2))}px`;
          }
          reactData.isDragResize = true;
        };
        reactData.isDragResize = true;
        addClass(tableEl, "col-drag--resize");
        resizeBarElem.style.display = "block";
        document.onmousemove = updateEvent;
        document.onmouseup = function(evnt2) {
          document.onmousemove = null;
          document.onmouseup = null;
          resizeBarElem.style.display = "none";
          internalData._lastResizeTime = Date.now();
          setTimeout(() => {
            reactData.isDragResize = false;
          }, 50);
          const resizeWidth = resizeColumn.renderWidth + (isRightFixed ? dragPosLeft - dragLeft : dragLeft - dragPosLeft);
          const resizeParams = Object.assign(Object.assign({}, params), { resizeWidth, resizeColumn });
          if (resizableOpts.dragMode === "fixed") {
            visibleColumn.forEach((item) => {
              if (item.id !== resizeColumn.id) {
                if (!item.resizeWidth) {
                  item.resizeWidth = item.renderWidth;
                }
              }
            });
          }
          if ($xeTable.handleColResizeCellAreaEvent) {
            $xeTable.handleColResizeCellAreaEvent(evnt2, resizeParams);
          } else {
            resizeColumn.resizeWidth = resizeWidth;
            handleUpdateColResize(evnt2, resizeParams);
          }
          removeClass(tableEl, "col-drag--resize");
        };
        updateEvent(evnt);
        if ($xeTable.closeMenu) {
          $xeTable.closeMenu();
        }
      },
      handleColResizeDblclickEvent(evnt, params) {
        const resizableOpts = computeResizableOpts.value;
        const { isDblclickAutoWidth } = resizableOpts;
        const el = refElem.value;
        if (isDblclickAutoWidth && el) {
          evnt.stopPropagation();
          evnt.preventDefault();
          const { fullColumnIdData } = internalData;
          const { column } = params;
          let resizeColumn = column;
          if (column.children && column.children.length) {
            import_xe_utils9.default.eachTree(column.children, (childColumn) => {
              resizeColumn = childColumn;
            });
          }
          const colid = resizeColumn.id;
          const colRest = fullColumnIdData[colid];
          const dragBtnElem = evnt.target;
          const cell = dragBtnElem.parentNode;
          const cellParams = Object.assign(params, { cell });
          const colMinWidth = getColReMinWidth(cellParams);
          el.setAttribute("data-calc-col", "Y");
          let resizeWidth = calcColumnAutoWidth(resizeColumn, el);
          el.removeAttribute("data-calc-col");
          if (colRest) {
            resizeWidth = Math.max(resizeWidth, colRest.width);
          }
          resizeWidth = Math.max(colMinWidth, resizeWidth);
          const resizeParams = Object.assign(Object.assign({}, params), { resizeWidth, resizeColumn });
          reactData.isDragResize = false;
          internalData._lastResizeTime = Date.now();
          if ($xeTable.handleColResizeDblclickCellAreaEvent) {
            $xeTable.handleColResizeDblclickCellAreaEvent(evnt, resizeParams);
          } else {
            resizeColumn.resizeWidth = resizeWidth;
            handleUpdateColResize(evnt, resizeParams);
          }
        }
      },
      handleRowResizeMousedownEvent(evnt, params) {
        evnt.stopPropagation();
        evnt.preventDefault();
        const { row } = params;
        const { overflowX, scrollbarWidth, overflowY, scrollbarHeight } = reactData;
        const { elemStore, fullAllDataRowIdData } = internalData;
        const osbWidth = overflowY ? scrollbarWidth : 0;
        const osbHeight = overflowX ? scrollbarHeight : 0;
        const scrollbarYToLeft = computeScrollbarYToLeft.value;
        const resizableOpts = computeResizableOpts.value;
        const rowOpts = computeRowOpts.value;
        const cellOpts = computeCellOpts.value;
        const tableEl = refElem.value;
        const resizeBarElem = refRowResizeBar.value;
        if (!resizeBarElem) {
          return;
        }
        const { clientY: dragClientY } = evnt;
        const resizeTipElem = resizeBarElem.firstElementChild;
        const dragBtnElem = evnt.currentTarget;
        const tdEl = dragBtnElem.parentNode;
        const trEl = tdEl.parentNode;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        if (!bodyScrollElem) {
          return;
        }
        const rowid = getRowid($xeTable, row);
        const rowRest = fullAllDataRowIdData[rowid];
        if (!rowRest) {
          return;
        }
        const defaultRowHeight = computeDefaultRowHeight.value;
        const currCellHeight = rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
        const tableRect = tableEl.getBoundingClientRect();
        const trRect = trEl.getBoundingClientRect();
        const targetOffsetY = dragClientY - trRect.y - trEl.clientHeight;
        let resizeHeight = currCellHeight;
        const cellEl = tdEl.querySelector(".vxe-cell");
        let cellMinHeight = 0;
        if (cellEl) {
          const cellStyle = getComputedStyle(cellEl);
          cellMinHeight = Math.max(1, Math.ceil(import_xe_utils9.default.toNumber(cellStyle.paddingTop) + import_xe_utils9.default.toNumber(cellStyle.paddingBottom)));
        }
        const minTop = trRect.y - tableRect.y + cellMinHeight;
        const updateEvent = (evnt2) => {
          evnt2.stopPropagation();
          evnt2.preventDefault();
          const rtWidth = tableEl.clientWidth - osbWidth;
          const tableHeight = tableEl.clientHeight - osbHeight;
          let dragTop = evnt2.clientY - tableRect.y - targetOffsetY;
          if (dragTop < minTop) {
            dragTop = minTop;
          } else {
            resizeHeight = Math.max(cellMinHeight, currCellHeight + evnt2.clientY - dragClientY);
          }
          resizeBarElem.style.left = `${scrollbarYToLeft ? osbWidth : 0}px`;
          resizeBarElem.style.top = `${dragTop}px`;
          resizeBarElem.style.width = `${rtWidth}px`;
          if (resizableOpts.showDragTip && resizeTipElem) {
            resizeTipElem.textContent = getI18n6("vxe.table.resizeRowTip", [resizeHeight]);
            const resizeTipWidth = resizeTipElem.clientWidth;
            const resizeTipHeight = resizeTipElem.clientHeight;
            let resizeBarLeft = Math.max(2, evnt2.clientX - tableRect.x);
            let resizeBarTop = 0;
            if (resizeBarLeft + resizeTipWidth >= rtWidth - 2) {
              resizeBarLeft = rtWidth - resizeTipWidth - 2;
            }
            if (dragTop + resizeTipHeight >= tableHeight) {
              resizeBarTop = tableHeight - (dragTop + resizeTipHeight);
            }
            resizeTipElem.style.left = `${resizeBarLeft}px`;
            resizeTipElem.style.top = `${resizeBarTop}px`;
          }
          reactData.isDragResize = true;
        };
        reactData.isDragResize = true;
        addClass(tableEl, "row-drag--resize");
        resizeBarElem.style.display = "block";
        document.onmousemove = updateEvent;
        document.onmouseup = function(evnt2) {
          document.onmousemove = null;
          document.onmouseup = null;
          resizeBarElem.style.display = "none";
          internalData._lastResizeTime = Date.now();
          setTimeout(() => {
            reactData.isDragResize = false;
          }, 50);
          if (resizeHeight !== currCellHeight) {
            const resizeParams = Object.assign(Object.assign({}, params), { resizeHeight, resizeRow: row });
            internalData.isResizeCellHeight = true;
            if ($xeTable.handleRowResizeCellAreaEvent) {
              $xeTable.handleRowResizeCellAreaEvent(evnt2, resizeParams);
            } else {
              rowRest.resizeHeight = resizeHeight;
              handleUpdateRowResize(evnt2, resizeParams);
              updateRowOffsetTop();
            }
          }
          removeClass(tableEl, "row-drag--resize");
        };
        updateEvent(evnt);
      },
      handleRowResizeDblclickEvent(evnt, params) {
        const resizableOpts = computeResizableOpts.value;
        const { isDblclickAutoHeight } = resizableOpts;
        const el = refElem.value;
        if (isDblclickAutoHeight && el) {
          evnt.stopPropagation();
          evnt.preventDefault();
          const { editStore } = reactData;
          const { fullAllDataRowIdData } = internalData;
          const { actived } = editStore;
          const { row } = params;
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          if (!rowRest) {
            return;
          }
          const handleRsHeight = () => {
            el.setAttribute("data-calc-row", "Y");
            const resizeHeight = calcCellAutoHeight(rowRest, el);
            el.removeAttribute("data-calc-row");
            const resizeParams = Object.assign(Object.assign({}, params), { resizeHeight, resizeRow: row });
            reactData.isDragResize = false;
            internalData._lastResizeTime = Date.now();
            if ($xeTable.handleRowResizeDblclickCellAreaEvent) {
              $xeTable.handleRowResizeDblclickCellAreaEvent(evnt, resizeParams);
            } else {
              rowRest.resizeHeight = resizeHeight;
              handleUpdateRowResize(evnt, resizeParams);
            }
          };
          if (actived.row || actived.column) {
            $xeTable.clearEdit().then(handleRsHeight);
          } else {
            handleRsHeight();
          }
        }
      },
      saveCustomStore(type) {
        const { customConfig } = props;
        const tableId = computeTableId.value;
        const customOpts = computeCustomOpts.value;
        const { updateStore, storage } = customOpts;
        const isAllCustom = storage === true;
        const storageOpts = isAllCustom ? {} : Object.assign({}, storage || {});
        const isCustomResizable = isAllCustom || storageOpts.resizable;
        const isCustomVisible = isAllCustom || storageOpts.visible;
        const isCustomFixed = isAllCustom || storageOpts.fixed;
        const isCustomSort = isAllCustom || storageOpts.sort;
        if (type !== "reset") {
          reactData.isCustomStatus = true;
        }
        if ((customConfig ? isEnableConf(customOpts) : customOpts.enabled) && (isCustomResizable || isCustomVisible || isCustomFixed || isCustomSort)) {
          if (!tableId) {
            errLog("vxe.error.reqProp", ["id"]);
            return nextTick();
          }
          const storeData = type === "reset" ? {
            resizableData: {},
            sortData: {},
            visibleData: {},
            fixedData: {}
          } : tableMethods.getCustomStoreData();
          if (updateStore) {
            return updateStore({
              $table: $xeTable,
              id: tableId,
              type,
              storeData
            });
          } else {
            setCustomStorageMap(tableId, type === "reset" ? null : storeData);
          }
        }
        return nextTick();
      },
      handleCustom() {
        const { mouseConfig } = props;
        if (mouseConfig) {
          if ($xeTable.clearSelected) {
            $xeTable.clearSelected();
          }
          if ($xeTable.clearCellAreas) {
            $xeTable.clearCellAreas();
            $xeTable.clearCopyCellArea();
          }
        }
        tablePrivateMethods.analyColumnWidth();
        return tableMethods.refreshColumn(true);
      },
      handleUpdateDataQueue() {
        reactData.upDataFlag++;
      },
      handleRefreshColumnQueue() {
        reactData.reColumnFlag++;
      },
      preventEvent(evnt, type, args, next, end) {
        let evntList = interceptor.get(type);
        if (!evntList.length && type === "event.clearEdit") {
          evntList = interceptor.get("event.clearActived");
          if (true) {
            if (evntList.length) {
              warnLog("vxe.error.delEvent", ["event.clearActived", "event.clearEdit"]);
            }
          }
        }
        let rest = null;
        let isStop = false;
        for (let i = 0; i < evntList.length; i++) {
          const func = evntList[i];
          const fnRest = func(Object.assign({ $grid: $xeGrid, $table: $xeTable, $event: evnt }, args));
          if (fnRest === false) {
            isStop = true;
            break;
          } else if (fnRest && fnRest.status === false) {
            rest = fnRest.result;
            isStop = true;
            break;
          }
        }
        if (!isStop) {
          if (next) {
            rest = next();
          }
        }
        if (end) {
          end();
        }
        return rest;
      },
      updateCheckboxStatus() {
        const { treeConfig } = props;
        const { isRowGroupStatus } = reactData;
        const { afterTreeFullData, afterGroupFullData, selectCheckboxMaps, treeIndeterminateRowMaps } = internalData;
        const rowGroupOpts = computeRowGroupOpts.value;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, checkStrictly, checkMethod } = checkboxOpts;
        if (checkStrictly) {
          return;
        }
        if (isRowGroupStatus || treeConfig) {
          const { handleGetRowId } = createHandleGetRowId($xeTable);
          const childRowMaps = {};
          const childRowList = [];
          if (isRowGroupStatus) {
            const mapChildrenField = rowGroupOpts.mapChildrenField;
            if (mapChildrenField) {
              import_xe_utils9.default.eachTree(afterGroupFullData, (row) => {
                const rowid = handleGetRowId(row);
                const childList = row[mapChildrenField];
                if (childList && childList.length && !childRowMaps[rowid]) {
                  childRowMaps[rowid] = 1;
                  childRowList.unshift([row, rowid, childList]);
                }
              }, { children: mapChildrenField });
            }
          } else if (treeConfig) {
            const { transform, mapChildrenField } = treeOpts;
            import_xe_utils9.default.eachTree(afterTreeFullData, (row) => {
              const rowid = handleGetRowId(row);
              const childList = row[transform ? mapChildrenField : childrenField];
              if (childList && childList.length && !childRowMaps[rowid]) {
                childRowMaps[rowid] = 1;
                childRowList.unshift([row, rowid, childList]);
              }
            }, { children: transform ? mapChildrenField : childrenField });
          }
          childRowList.forEach((vals) => {
            const row = vals[0];
            const rowid = vals[1];
            const childList = vals[2];
            let sLen = 0;
            let hLen = 0;
            let vLen = 0;
            childList.forEach(checkMethod ? (item) => {
              const childRowid = handleGetRowId(item);
              const isSelect = checkField ? import_xe_utils9.default.get(item, checkField) : selectCheckboxMaps[childRowid];
              if (checkMethod({ $table: $xeTable, row: item })) {
                if (isSelect) {
                  sLen++;
                } else if (treeIndeterminateRowMaps[childRowid]) {
                  hLen++;
                }
                vLen++;
              } else {
                if (isSelect) {
                  sLen++;
                } else if (treeIndeterminateRowMaps[childRowid]) {
                  hLen++;
                }
              }
            } : (item) => {
              const childRowid = handleGetRowId(item);
              const isSelect = checkField ? import_xe_utils9.default.get(item, checkField) : selectCheckboxMaps[childRowid];
              if (isSelect) {
                sLen++;
              } else if (treeIndeterminateRowMaps[childRowid]) {
                hLen++;
              }
              vLen++;
            });
            const isSelected = sLen >= vLen;
            const halfSelect = !isSelected && (sLen >= 1 || hLen >= 1);
            if (checkField) {
              import_xe_utils9.default.set(row, checkField, isSelected);
            }
            if (isSelected) {
              if (!checkField) {
                selectCheckboxMaps[rowid] = row;
              }
              if (treeIndeterminateRowMaps[rowid]) {
                delete treeIndeterminateRowMaps[rowid];
              }
            } else {
              if (!checkField) {
                if (selectCheckboxMaps[rowid]) {
                  delete selectCheckboxMaps[rowid];
                }
              }
              if (halfSelect) {
                treeIndeterminateRowMaps[rowid] = row;
              } else {
                if (treeIndeterminateRowMaps[rowid]) {
                  delete treeIndeterminateRowMaps[rowid];
                }
              }
            }
          });
        }
        reactData.updateCheckboxFlag++;
      },
      updateAllCheckboxStatus() {
        const { treeConfig } = props;
        const { isRowGroupStatus } = reactData;
        const { afterFullData, afterTreeFullData, afterGroupFullData, checkboxReserveRowMap, selectCheckboxMaps, treeIndeterminateRowMaps } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, checkMethod, showReserveStatus } = checkboxOpts;
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        let sLen = 0;
        let hLen = 0;
        let vLen = 0;
        const rootList = treeConfig ? afterTreeFullData : isRowGroupStatus ? afterGroupFullData : afterFullData;
        rootList.forEach(checkMethod ? (row) => {
          const childRowid = handleGetRowId(row);
          const selected = checkField ? import_xe_utils9.default.get(row, checkField) : selectCheckboxMaps[childRowid];
          if (checkMethod({ $table: $xeTable, row })) {
            if (selected) {
              sLen++;
            } else if (treeIndeterminateRowMaps[childRowid]) {
              hLen++;
            }
            vLen++;
          } else {
            if (selected) {
              sLen++;
            } else if (treeIndeterminateRowMaps[childRowid]) {
              hLen++;
            }
          }
        } : (row) => {
          const childRowid = handleGetRowId(row);
          const selected = checkField ? import_xe_utils9.default.get(row, checkField) : selectCheckboxMaps[childRowid];
          if (selected) {
            sLen++;
          } else if (treeIndeterminateRowMaps[childRowid]) {
            hLen++;
          }
          vLen++;
        });
        const isSelected = rootList.length > 0 ? vLen > 0 ? sLen >= vLen : sLen >= rootList.length : false;
        let halfSelect = !isSelected && (sLen >= 1 || hLen >= 1);
        if (!isSelected && !halfSelect && showReserveStatus) {
          halfSelect = !import_xe_utils9.default.isEmpty(checkboxReserveRowMap);
        }
        reactData.isAllSelected = isSelected;
        reactData.isIndeterminate = halfSelect;
      },
      checkSelectionStatus() {
        $xeTable.updateCheckboxStatus();
        $xeTable.updateAllCheckboxStatus();
      },
      /**
       * 切换选中
       * 多选，行选中事件
       */
      handleBatchSelectRows(rows, checked, isForce) {
        const { treeConfig } = props;
        const { isRowGroupStatus } = reactData;
        const { selectCheckboxMaps } = internalData;
        const rowGroupOpts = computeRowGroupOpts.value;
        const treeOpts = computeTreeOpts.value;
        const { transform, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, checkStrictly, checkMethod } = checkboxOpts;
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
        if (checkField) {
          if ((treeConfig || isRowGroupStatus) && !checkStrictly) {
            import_xe_utils9.default.eachTree(rows, (row) => {
              if (isForce || (!checkMethod || checkMethod({ $table: $xeTable, row }))) {
                import_xe_utils9.default.set(row, checkField, checked);
                if (indeterminateField) {
                  import_xe_utils9.default.set(row, indeterminateField, false);
                }
                handleCheckboxReserveRow(row, checked);
              }
            }, { children: transform ? mapChildrenField : childrenField });
            reactData.updateCheckboxFlag++;
            return;
          }
          rows.forEach((row) => {
            if (isForce || (!checkMethod || checkMethod({ $table: $xeTable, row }))) {
              import_xe_utils9.default.set(row, checkField, checked);
              handleCheckboxReserveRow(row, checked);
            }
          });
          reactData.updateCheckboxFlag++;
          return;
        }
        if (!checkStrictly) {
          if (isRowGroupStatus) {
            import_xe_utils9.default.eachTree(rows, (row) => {
              const rowid = handleGetRowId(row);
              if (isForce || (!checkMethod || checkMethod({ $table: $xeTable, row }))) {
                if (checked) {
                  selectCheckboxMaps[rowid] = row;
                } else {
                  if (selectCheckboxMaps[rowid]) {
                    delete selectCheckboxMaps[rowid];
                  }
                }
                handleCheckboxReserveRow(row, checked);
              }
            }, { children: rowGroupOpts.mapChildrenField });
            reactData.updateCheckboxFlag++;
            return;
          } else if (treeConfig) {
            import_xe_utils9.default.eachTree(rows, (row) => {
              const rowid = handleGetRowId(row);
              if (isForce || (!checkMethod || checkMethod({ $table: $xeTable, row }))) {
                if (checked) {
                  selectCheckboxMaps[rowid] = row;
                } else {
                  if (selectCheckboxMaps[rowid]) {
                    delete selectCheckboxMaps[rowid];
                  }
                }
                handleCheckboxReserveRow(row, checked);
              }
            }, { children: transform ? mapChildrenField : childrenField });
            reactData.updateCheckboxFlag++;
            return;
          }
        }
        rows.forEach((row) => {
          const rowid = handleGetRowId(row);
          if (isForce || (!checkMethod || checkMethod({ $table: $xeTable, row }))) {
            if (checked) {
              if (!selectCheckboxMaps[rowid]) {
                selectCheckboxMaps[rowid] = row;
              }
            } else {
              if (selectCheckboxMaps[rowid]) {
                delete selectCheckboxMaps[rowid];
              }
            }
            handleCheckboxReserveRow(row, checked);
            reactData.updateCheckboxFlag++;
          }
        });
      },
      /**
       * 即将移除
       * @deprecated
       */
      handleSelectRow({ row }, checked, isForce) {
        $xeTable.handleBatchSelectRows([row], checked, isForce);
      },
      /**
       * 处理合并
       */
      handleUpdateBodyMerge() {
        const { mergeBodyList } = internalData;
        internalData.mergeBodyCellMaps = buildMergeData(mergeBodyList);
        reactData.mergeBodyFlag++;
      },
      handleUpdateFooterMerge() {
        const { mergeFooterList } = internalData;
        internalData.mergeFooterCellMaps = buildMergeData(mergeFooterList);
        reactData.mergeFootFlag++;
      },
      triggerHeaderTitleEvent(evnt, iconParams, params) {
        const tipContent = iconParams.content || iconParams.message;
        if (tipContent) {
          const { tooltipStore } = reactData;
          const { column } = params;
          const content = getFuncText(tipContent);
          handleTargetEnterEvent(true);
          tooltipStore.row = null;
          tooltipStore.column = column;
          tooltipStore.visible = true;
          tooltipStore.currOpts = iconParams;
          nextTick(() => {
            const $tooltip = refTooltip.value;
            if ($tooltip && $tooltip.open) {
              $tooltip.open(evnt.currentTarget, content);
            }
          });
        }
      },
      /**
       * 触发表头 tooltip 事件
       */
      triggerHeaderTooltipEvent(evnt, params) {
        const { tooltipStore } = reactData;
        const { column } = params;
        handleTargetEnterEvent(true);
        const titleElem = evnt.currentTarget;
        if (!titleElem) {
          return;
        }
        const cellEl = titleElem.parentElement;
        if (!cellEl) {
          return;
        }
        const thEl = cellEl.parentElement;
        if (!thEl) {
          return;
        }
        if (tooltipStore.column !== column || !tooltipStore.visible) {
          handleTooltip(evnt, thEl, thEl.querySelector(".vxe-cell--wrapper"), thEl.querySelector(".vxe-cell--title") || cellEl, params);
        }
      },
      /**
       * 触发单元格 tooltip 事件
       */
      triggerBodyTooltipEvent(evnt, params) {
        const { editConfig } = props;
        const { editStore } = reactData;
        const { tooltipStore } = reactData;
        const editOpts = computeEditOpts.value;
        const { actived } = editStore;
        const { row, column } = params;
        const tdEl = evnt.currentTarget;
        handleTargetEnterEvent(tooltipStore.column !== column || tooltipStore.row !== row);
        if (column.editRender && isEnableConf(editConfig)) {
          if (editOpts.mode === "row" && actived.row === row) {
            return;
          }
          if (actived.row === row && actived.column === column) {
            return;
          }
        }
        if (tooltipStore.column !== column || tooltipStore.row !== row || !tooltipStore.visible) {
          handleTooltip(evnt, tdEl, tdEl.querySelector(".vxe-cell--wrapper"), tdEl.querySelector(".vxe-cell--label") || tdEl.querySelector(".vxe-cell--wrapper"), params);
        }
      },
      /**
       * 触发表尾 tooltip 事件
       */
      triggerFooterTooltipEvent(evnt, params) {
        const { column } = params;
        const { tooltipStore } = reactData;
        const tdEl = evnt.currentTarget;
        handleTargetEnterEvent(tooltipStore.column !== column || !!tooltipStore.row);
        if (tooltipStore.column !== column || !tooltipStore.visible) {
          handleTooltip(evnt, tdEl, tdEl.querySelector(".vxe-cell--wrapper"), tdEl.querySelector(".vxe-cell--label") || tdEl.querySelector(".vxe-cell--wrapper"), params);
        }
      },
      handleTargetLeaveEvent() {
        const tooltipOpts = computeTooltipOpts.value;
        let $tooltip = refTooltip.value;
        if ($tooltip && $tooltip.setActived) {
          $tooltip.setActived(false);
        }
        if (tooltipOpts.enterable) {
          internalData.tooltipTimeout = setTimeout(() => {
            $tooltip = refTooltip.value;
            if ($tooltip && $tooltip.isActived && !$tooltip.isActived()) {
              $xeTable.closeTooltip();
            }
          }, tooltipOpts.leaveDelay);
        } else {
          $xeTable.closeTooltip();
        }
      },
      triggerHeaderCellClickEvent(evnt, params) {
        const { _lastResizeTime } = internalData;
        const sortOpts = computeSortOpts.value;
        const columnOpts = computeColumnOpts.value;
        const currentColumnOpts = computeCurrentColumnOpts.value;
        const { column } = params;
        const cell = evnt.currentTarget;
        const triggerResizable = _lastResizeTime && _lastResizeTime > Date.now() - 300;
        const triggerSort = getEventTargetNode(evnt, cell, "vxe-cell--sort").flag;
        const triggerFilter = getEventTargetNode(evnt, cell, "vxe-cell--filter").flag;
        if (sortOpts.trigger === "cell" && !(triggerResizable || triggerSort || triggerFilter)) {
          $xeTable.triggerSortEvent(evnt, column, getNextSortOrder(column));
        }
        dispatchEvent("header-cell-click", Object.assign({ triggerResizable, triggerSort, triggerFilter, cell }, params), evnt);
        if ((columnOpts.isCurrent || props.highlightCurrentColumn) && (!currentColumnOpts.trigger || ["header", "default"].includes(currentColumnOpts.trigger))) {
          $xeTable.triggerCurrentColumnEvent(evnt, params);
        }
      },
      triggerHeaderCellDblclickEvent(evnt, params) {
        dispatchEvent("header-cell-dblclick", Object.assign({ cell: evnt.currentTarget }, params), evnt);
      },
      /**
       * 列点击事件
       * 如果是单击模式，则激活为编辑状态
       * 如果是双击模式，则单击后选中状态
       */
      triggerCellClickEvent(evnt, params) {
        const { highlightCurrentRow, highlightCurrentColumn, editConfig } = props;
        const { editStore, isDragResize } = reactData;
        if (isDragResize) {
          return;
        }
        const expandOpts = computeExpandOpts.value;
        const editOpts = computeEditOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const keyboardOpts = computeKeyboardOpts.value;
        const rowGroupOpts = computeRowGroupOpts.value;
        const rowOpts = computeRowOpts.value;
        const columnOpts = computeColumnOpts.value;
        const currentColumnOpts = computeCurrentColumnOpts.value;
        const { actived, focused } = editStore;
        const { row, column } = params;
        const { type, treeNode, rowGroupNode } = column;
        const isRadioType = type === "radio";
        const isCheckboxType = type === "checkbox";
        const isExpandType = type === "expand";
        const cell = evnt.currentTarget;
        const triggerRadio = isRadioType && getEventTargetNode(evnt, cell, "vxe-cell--radio").flag;
        const triggerCheckbox = isCheckboxType && getEventTargetNode(evnt, cell, "vxe-cell--checkbox").flag;
        const triggerTreeNode = treeNode && getEventTargetNode(evnt, cell, "vxe-cell--tree-btn").flag;
        const triggerExpandNode = isExpandType && getEventTargetNode(evnt, cell, "vxe-table--expanded").flag;
        const triggerRowGroupNode = isExpandType && getEventTargetNode(evnt, cell, "vxe-row-group--node-btn").flag;
        params = Object.assign({ cell, triggerRadio, triggerCheckbox, triggerTreeNode, triggerExpandNode }, params);
        if (!triggerCheckbox && !triggerRadio) {
          if (!triggerExpandNode && (expandOpts.trigger === "row" || isExpandType && expandOpts.trigger === "cell")) {
            $xeTable.triggerRowExpandEvent(evnt, params);
          }
          if (treeOpts.trigger === "row" || treeNode && treeOpts.trigger === "cell") {
            $xeTable.triggerTreeExpandEvent(evnt, params);
          }
          if (rowGroupOpts.trigger === "row" || rowGroupNode && rowGroupOpts.trigger === "cell") {
            $xeTable.triggerRowGroupExpandEvent(evnt, params);
          }
        }
        if (!triggerTreeNode) {
          if (!triggerExpandNode && !triggerRowGroupNode) {
            if (rowOpts.isCurrent || highlightCurrentRow) {
              if (!triggerCheckbox && !triggerRadio) {
                $xeTable.triggerCurrentRowEvent(evnt, params);
              }
            }
            if ((columnOpts.isCurrent || highlightCurrentColumn) && (!currentColumnOpts.trigger || ["cell", "default"].includes(currentColumnOpts.trigger))) {
              if (!triggerCheckbox && !triggerRadio) {
                $xeTable.triggerCurrentColumnEvent(evnt, params);
              }
            }
            if (!triggerRadio && (radioOpts.trigger === "row" || isRadioType && radioOpts.trigger === "cell")) {
              $xeTable.triggerRadioRowEvent(evnt, params);
            }
            if (!triggerCheckbox && (checkboxOpts.trigger === "row" || isCheckboxType && checkboxOpts.trigger === "cell")) {
              $xeTable.handleToggleCheckRowEvent(evnt, params);
            }
          }
          if (isEnableConf(editConfig)) {
            if (keyboardOpts.arrowCursorLock && evnt && editOpts.mode === "cell" && evnt.target && /^input|textarea$/i.test(evnt.target.tagName)) {
              focused.column = column;
              focused.row = row;
            }
            if (editOpts.trigger === "manual") {
              if (actived.args && actived.row === row && column !== actived.column) {
                handleChangeCell(evnt, params);
              }
            } else if (!actived.args || row !== actived.row || column !== actived.column) {
              if (editOpts.trigger === "click") {
                handleChangeCell(evnt, params);
              } else if (editOpts.trigger === "dblclick") {
                if (editOpts.mode === "row" && actived.row === row) {
                  handleChangeCell(evnt, params);
                }
              }
            }
          }
        }
        if (isEnableConf(editConfig) && editOpts.trigger === "dblclick") {
          if (actived.row && actived.column) {
            if (editOpts.mode === "row") {
              if (!$xeTable.eqRow(actived.row, row)) {
                $xeTable.handleClearEdit(evnt);
              }
            } else if (editOpts.mode === "cell") {
              if (!$xeTable.eqRow(actived.row, row) || actived.column.id !== column.id) {
                $xeTable.handleClearEdit(evnt);
              }
            }
          }
        }
        dispatchEvent("cell-click", params, evnt);
      },
      /**
       * 列双击点击事件
       * 如果是双击模式，则激活为编辑状态
       */
      triggerCellDblclickEvent(evnt, params) {
        const { editConfig } = props;
        const { editStore, isDragResize } = reactData;
        if (isDragResize) {
          return;
        }
        const editOpts = computeEditOpts.value;
        const { actived } = editStore;
        const cell = evnt.currentTarget;
        params = Object.assign({ cell }, params);
        if (isEnableConf(editConfig) && editOpts.trigger === "dblclick") {
          if (!actived.args || evnt.currentTarget !== actived.args.cell) {
            if (editOpts.mode === "row") {
              checkValidate("blur").catch((e) => e).then(() => {
                $xeTable.handleEdit(params, evnt).then(() => checkValidate("change")).catch((e) => e);
              });
            } else if (editOpts.mode === "cell") {
              $xeTable.handleEdit(params, evnt).then(() => checkValidate("change")).catch((e) => e);
            }
          }
        }
        dispatchEvent("cell-dblclick", params, evnt);
      },
      handleToggleCheckRowEvent(evnt, params) {
        const { selectCheckboxMaps } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, trigger } = checkboxOpts;
        const { row } = params;
        if (trigger === "manual") {
          return;
        }
        let checked = false;
        if (checkField) {
          checked = !import_xe_utils9.default.get(row, checkField);
        } else {
          checked = !selectCheckboxMaps[getRowid($xeTable, row)];
        }
        if (evnt) {
          $xeTable.triggerCheckRowEvent(evnt, params, checked);
        } else {
          $xeTable.handleBatchSelectRows([row], checked);
          $xeTable.checkSelectionStatus();
        }
      },
      triggerCheckRowEvent(evnt, params, checked) {
        const { treeConfig } = props;
        const { row } = params;
        const { isRowGroupStatus } = reactData;
        const { afterFullData } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkMethod, trigger } = checkboxOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        if (checkboxOpts.isShiftKey && evnt.shiftKey && !(treeConfig || isRowGroupStatus)) {
          const checkboxRecords = $xeTable.getCheckboxRecords();
          if (checkboxRecords.length) {
            const firstRow = checkboxRecords[0];
            const _rowIndex = $xeTable.getVTRowIndex(row);
            const _firstRowIndex = $xeTable.getVTRowIndex(firstRow);
            if (_rowIndex !== _firstRowIndex) {
              $xeTable.setAllCheckboxRow(false);
              const rangeRows = _rowIndex < _firstRowIndex ? afterFullData.slice(_rowIndex, _firstRowIndex + 1) : afterFullData.slice(_firstRowIndex, _rowIndex + 1);
              nextTick(() => {
                handleCheckedCheckboxRow(rangeRows, true, false);
              });
              dispatchEvent("checkbox-range-select", Object.assign({ rangeRecords: rangeRows }, params), evnt);
              return;
            }
          }
        }
        if (!checkMethod || checkMethod({ $table: $xeTable, row })) {
          $xeTable.handleBatchSelectRows([row], checked);
          $xeTable.checkSelectionStatus();
          dispatchEvent("checkbox-change", Object.assign({
            records: () => $xeTable.getCheckboxRecords(),
            reserves: () => $xeTable.getCheckboxReserveRecords(),
            indeterminates: () => $xeTable.getCheckboxIndeterminateRecords(),
            checked
          }, params), evnt);
        }
      },
      /**
       * 多选，选中所有事件
       */
      triggerCheckAllEvent(evnt, value) {
        const checkboxOpts = computeCheckboxOpts.value;
        const { trigger } = checkboxOpts;
        if (trigger === "manual") {
          return;
        }
        if (evnt) {
          evnt.stopPropagation();
        }
        handleCheckAllEvent(evnt, value);
      },
      /**
       * 单选，行选中事件
       */
      triggerRadioRowEvent(evnt, params) {
        const { selectRadioRow: oldValue } = reactData;
        const { row } = params;
        const radioOpts = computeRadioOpts.value;
        const { trigger } = radioOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        let newValue = row;
        let isChange = oldValue !== newValue;
        if (isChange) {
          handleCheckedRadioRow(newValue);
        } else if (!radioOpts.strict) {
          isChange = oldValue === newValue;
          if (isChange) {
            newValue = null;
            $xeTable.clearRadioRow();
          }
        }
        if (isChange) {
          dispatchEvent("radio-change", Object.assign({ oldValue, newValue }, params), evnt);
        }
      },
      triggerCurrentColumnEvent(evnt, params) {
        const { currentColumn: oldValue } = reactData;
        const columnOpts = computeColumnOpts.value;
        const currentColumnOpts = computeCurrentColumnOpts.value;
        const beforeRowMethod = currentColumnOpts.beforeSelectMethod || columnOpts.currentMethod;
        const { column: newValue } = params;
        const { trigger } = currentColumnOpts;
        if (trigger === "manual") {
          return;
        }
        const isChange = oldValue !== newValue;
        if (!beforeRowMethod || beforeRowMethod({ column: newValue, $table: $xeTable })) {
          $xeTable.setCurrentColumn(newValue);
          if (isChange) {
            dispatchEvent("current-column-change", Object.assign({ oldValue, newValue }, params), evnt);
          }
        } else {
          dispatchEvent("current-column-disabled", params, evnt);
        }
      },
      triggerCurrentRowEvent(evnt, params) {
        const { currentRow: oldValue } = reactData;
        const rowOpts = computeRowOpts.value;
        const currentRowOpts = computeCurrentRowOpts.value;
        const beforeRowMethod = currentRowOpts.beforeSelectMethod || rowOpts.currentMethod;
        const { row: newValue } = params;
        const { trigger } = currentRowOpts;
        if (trigger === "manual") {
          return;
        }
        const isChange = oldValue !== newValue;
        if (!beforeRowMethod || beforeRowMethod({ row: newValue, $table: $xeTable })) {
          $xeTable.setCurrentRow(newValue);
          if (isChange) {
            dispatchEvent("current-row-change", Object.assign({ oldValue, newValue }, params), evnt);
            dispatchEvent("current-change", Object.assign({ oldValue, newValue }, params), evnt);
          }
        } else {
          dispatchEvent("current-row-disabled", params, evnt);
        }
      },
      /**
       * 展开行事件
       */
      triggerRowExpandEvent(evnt, params) {
        const { expandColumn } = reactData;
        const { rowExpandLazyLoadedMaps } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { row } = params;
        const { lazy, trigger } = expandOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        const rowid = getRowid($xeTable, row);
        if (!lazy || !rowExpandLazyLoadedMaps[rowid]) {
          const expanded = !$xeTable.isRowExpandByRow(row);
          const columnIndex = expandColumn ? $xeTable.getColumnIndex(expandColumn) : -1;
          const $columnIndex = expandColumn ? $xeTable.getVMColumnIndex(expandColumn) : -1;
          $xeTable.setRowExpand(row, expanded);
          dispatchEvent("toggle-row-expand", {
            expanded,
            column: expandColumn,
            columnIndex,
            $columnIndex,
            row,
            rowIndex: $xeTable.getRowIndex(row),
            $rowIndex: $xeTable.getVMRowIndex(row)
          }, evnt);
        }
      },
      /**
       * 行分组事件
       */
      triggerRowGroupExpandEvent(evnt, params) {
        const { rowGroupExpandedMaps } = internalData;
        const rowGroupOpts = computeRowGroupOpts.value;
        const { row, column } = params;
        const { trigger } = rowGroupOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        const rowid = getRowid($xeTable, row);
        const expanded = !rowGroupExpandedMaps[rowid];
        const columnIndex = $xeTable.getColumnIndex(column);
        const $columnIndex = $xeTable.getVMColumnIndex(column);
        $xeTable.setRowGroupExpand(row, expanded);
        dispatchEvent("toggle-row-group-expand", { expanded, column, columnIndex, $columnIndex, row }, evnt);
      },
      /**
       * 展开树节点事件
       */
      triggerTreeExpandEvent(evnt, params) {
        const { treeExpandLazyLoadedMaps, treeEATime } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { row, column } = params;
        const { lazy, trigger, accordion } = treeOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        const rowid = getRowid($xeTable, row);
        if (!lazy || !treeExpandLazyLoadedMaps[rowid]) {
          const expanded = !$xeTable.isTreeExpandByRow(row);
          const columnIndex = $xeTable.getColumnIndex(column);
          const $columnIndex = $xeTable.getVMColumnIndex(column);
          if (treeEATime) {
            clearTimeout(treeEATime);
          }
          $xeTable.setTreeExpand(row, expanded).then(() => {
            if (accordion) {
              internalData.treeEATime = setTimeout(() => {
                internalData.treeEATime = void 0;
                $xeTable.scrollToRow(row);
              }, 30);
            }
          });
          dispatchEvent("toggle-tree-expand", { expanded, column, columnIndex, $columnIndex, row }, evnt);
        }
      },
      handleColumnSortEvent(evnt, column) {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        const { field, sortable } = column;
        if (sortable) {
          const params = { $table: $xeTable, $event: evnt, column, field, property: field, order: column.order, sortList: tableMethods.getSortColumns(), sortTime: column.sortTime };
          if (mouseConfig && mouseOpts.area && $xeTable.handleSortEvent) {
            $xeTable.handleSortEvent(evnt, params);
          }
          dispatchEvent("sort-change", params, evnt);
        }
      },
      /**
       * 点击排序事件
       */
      triggerSortEvent(evnt, column, order) {
        const sortOpts = computeSortOpts.value;
        const { multiple, allowClear } = sortOpts;
        const { field, sortable } = column;
        if (sortable) {
          if (!order || column.order === order) {
            if (allowClear) {
              tableMethods.clearSort(multiple ? column : null);
            }
          } else {
            tableMethods.sort({ field, order });
          }
          $xeTable.handleColumnSortEvent(evnt, column);
        }
      },
      handleCellRuleUpdateStatus(type, cellParams, cellValue) {
        const { validStore } = reactData;
        const { row, column } = cellParams;
        if ($xeTable.hasCellRules) {
          if ($xeTable.hasCellRules(type, row, column)) {
            const cell = $xeTable.getCellElement(row, column);
            if (cell) {
              const customVal = !import_xe_utils9.default.isUndefined(cellValue);
              return $xeTable.validCellRules(type, row, column, cellValue).then(() => {
                if (customVal && validStore.visible) {
                  setCellValue(row, column, cellValue);
                }
                $xeTable.clearValidate(row, column);
              }).catch(({ rule }) => {
                if (customVal) {
                  setCellValue(row, column, cellValue);
                }
                $xeTable.showValidTooltip({ rule, row, column, cell });
              });
            }
          }
        }
        return nextTick();
      },
      /**
       * 表头单元格按下事件
       */
      triggerHeaderCellMousedownEvent(evnt, params) {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        const columnOpts = computeColumnOpts.value;
        const columnDragOpts = computeColumnDragOpts.value;
        const { trigger, isCrossDrag, isPeerDrag, disabledMethod } = columnDragOpts;
        const cell = evnt.currentTarget;
        const triggerInput = cell && cell.tagName && cell.tagName.toLowerCase() === "input";
        const triggerCheckbox = getEventTargetNode(evnt, cell, "vxe-cell--checkbox").flag;
        const triggerSort = getEventTargetNode(evnt, cell, "vxe-cell--sort").flag;
        const triggerFilter = getEventTargetNode(evnt, cell, "vxe-cell--filter").flag;
        let triggerDrag = false;
        const isColDragCell = columnOpts.drag && trigger === "cell";
        if (!(triggerInput || triggerCheckbox || triggerSort || triggerFilter)) {
          const { column } = params;
          if (isColDragCell && !column.fixed && (isCrossDrag || isPeerDrag || !column.parentId) && !(disabledMethod && disabledMethod(params))) {
            triggerDrag = true;
            $xeTable.handleHeaderCellDragMousedownEvent(evnt, params);
          }
        }
        if (!triggerDrag && mouseConfig && mouseOpts.area && $xeTable.handleHeaderCellAreaEvent) {
          $xeTable.handleHeaderCellAreaEvent(evnt, Object.assign({ cell, triggerSort, triggerFilter }, params));
        }
        $xeTable.focus();
        if ($xeTable.closeMenu) {
          $xeTable.closeMenu();
        }
      },
      /**
       * 单元格按下事件
       */
      triggerCellMousedownEvent(evnt, params) {
        const { column } = params;
        const { type, treeNode } = column;
        const isRadioType = type === "radio";
        const isCheckboxType = type === "checkbox";
        const isExpandType = type === "expand";
        const rowOpts = computeRowOpts.value;
        const rowDragOpts = computeRowDragOpts.value;
        const { trigger, isCrossDrag, isPeerDrag, disabledMethod } = rowDragOpts;
        const cell = evnt.currentTarget;
        params.cell = cell;
        const triggerInput = cell && cell.tagName && cell.tagName.toLowerCase() === "input";
        const triggerRadio = isRadioType && getEventTargetNode(evnt, cell, "vxe-cell--radio").flag;
        const triggerCheckbox = isCheckboxType && getEventTargetNode(evnt, cell, "vxe-cell--checkbox").flag;
        const triggerTreeNode = treeNode && getEventTargetNode(evnt, cell, "vxe-cell--tree-btn").flag;
        const triggerExpandNode = isExpandType && getEventTargetNode(evnt, cell, "vxe-table--expanded").flag;
        let isColDragCell = false;
        if (rowOpts.drag) {
          isColDragCell = trigger === "row" || column.dragSort && trigger === "cell";
        }
        let triggerDrag = false;
        if (!(triggerInput || triggerRadio || triggerCheckbox || triggerTreeNode || triggerExpandNode)) {
          if (isColDragCell && (isCrossDrag || isPeerDrag || !params.level) && !(disabledMethod && disabledMethod(params))) {
            triggerDrag = true;
            $xeTable.handleCellDragMousedownEvent(evnt, params);
          }
        }
        if (!triggerDrag && $xeTable.handleCellMousedownEvent) {
          $xeTable.handleCellMousedownEvent(evnt, params);
        }
        $xeTable.focus();
        $xeTable.closeFilter();
        if ($xeTable.closeMenu) {
          $xeTable.closeMenu();
        }
      },
      triggerCellMouseupEvent() {
        clearDragStatus();
      },
      /**
       * 行拖拽
       */
      handleRowDragDragstartEvent(evnt) {
        if (evnt.dataTransfer) {
          evnt.dataTransfer.setDragImage(getTpImg(), 0, 0);
        }
      },
      handleRowDragSwapEvent(evnt, isSyncRow, dragRow, prevDragRow, prevDragPos, prevDragToChild) {
        const { treeConfig, dragConfig } = props;
        const rowDragOpts = computeRowDragOpts.value;
        const { afterFullData, tableFullData, fullAllDataRowIdData } = internalData;
        const { isPeerDrag, isCrossDrag, isSelfToChildDrag, dragEndMethod, dragToChildMethod } = rowDragOpts;
        const treeOpts = computeTreeOpts.value;
        const { transform, rowField, mapChildrenField, parentField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const dEndMethod = dragEndMethod || (dragConfig ? dragConfig.dragEndMethod : null);
        const dragOffsetIndex = prevDragPos === "bottom" ? 1 : 0;
        const errRest = {
          status: false
        };
        if (prevDragRow && dragRow) {
          if (prevDragRow !== dragRow) {
            const dragParams = {
              oldRow: dragRow,
              newRow: prevDragRow,
              dragRow,
              dragPos: prevDragPos,
              dragToChild: !!prevDragToChild,
              offsetIndex: dragOffsetIndex
            };
            const isDragToChildFlag = isSelfToChildDrag && dragToChildMethod ? dragToChildMethod(dragParams) : prevDragToChild;
            return Promise.resolve(dEndMethod ? dEndMethod(dragParams) : true).then((status) => {
              if (!status) {
                return errRest;
              }
              let oafIndex = -1;
              let nafIndex = -1;
              if (treeConfig) {
                if (transform) {
                  const oldRowid = getRowid($xeTable, dragRow);
                  const oldRest = fullAllDataRowIdData[oldRowid];
                  const newRowid = getRowid($xeTable, prevDragRow);
                  const newRest = fullAllDataRowIdData[newRowid];
                  if (oldRest && newRest) {
                    const { level: oldLevel } = oldRest;
                    const { level: newLevel } = newRest;
                    const oldAllMaps = {};
                    import_xe_utils9.default.eachTree([dragRow], (item) => {
                      oldAllMaps[getRowid($xeTable, item)] = item;
                    }, { children: mapChildrenField });
                    let isSelfToChildStatus = false;
                    if (oldLevel && newLevel) {
                      if (isPeerDrag && !isCrossDrag) {
                        if (oldRest.row[parentField] !== newRest.row[parentField]) {
                          return errRest;
                        }
                      } else {
                        if (!isCrossDrag) {
                          return errRest;
                        }
                        if (oldAllMaps[newRowid]) {
                          isSelfToChildStatus = true;
                          if (!(isCrossDrag && isSelfToChildDrag)) {
                            if (VxeUI.modal) {
                              VxeUI.modal.message({
                                status: "error",
                                content: getI18n6("vxe.error.treeDragChild")
                              });
                            }
                            return errRest;
                          }
                        }
                      }
                    } else if (oldLevel) {
                      if (!isCrossDrag) {
                        return errRest;
                      }
                    } else if (newLevel) {
                      if (!isCrossDrag) {
                        return errRest;
                      }
                      if (oldAllMaps[newRowid]) {
                        isSelfToChildStatus = true;
                        if (!(isCrossDrag && isSelfToChildDrag)) {
                          if (VxeUI.modal) {
                            VxeUI.modal.message({
                              status: "error",
                              content: getI18n6("vxe.error.treeDragChild")
                            });
                          }
                          return errRest;
                        }
                      }
                    } else {
                    }
                    const fullList = import_xe_utils9.default.toTreeArray(internalData.afterTreeFullData, {
                      key: rowField,
                      parentKey: parentField,
                      children: mapChildrenField
                    });
                    const otfIndex = $xeTable.findRowIndexOf(fullList, dragRow);
                    fullList.splice(otfIndex, 1);
                    const ptfIndex = $xeTable.findRowIndexOf(fullList, prevDragRow);
                    const ntfIndex = ptfIndex + dragOffsetIndex;
                    fullList.splice(ntfIndex, 0, dragRow);
                    if (isSelfToChildStatus && (isCrossDrag && isSelfToChildDrag)) {
                      import_xe_utils9.default.each(dragRow[childrenField], (childRow) => {
                        childRow[parentField] = dragRow[parentField];
                      });
                    }
                    dragRow[parentField] = isDragToChildFlag ? prevDragRow[rowField] : prevDragRow[parentField];
                    internalData.tableFullTreeData = import_xe_utils9.default.toArrayTree(fullList, {
                      key: rowField,
                      parentKey: parentField,
                      children: childrenField,
                      mapChildren: mapChildrenField
                    });
                  }
                }
              } else {
                oafIndex = $xeTable.findRowIndexOf(afterFullData, dragRow);
                const otfIndex = $xeTable.findRowIndexOf(tableFullData, dragRow);
                afterFullData.splice(oafIndex, 1);
                tableFullData.splice(otfIndex, 1);
                const pafIndex = $xeTable.findRowIndexOf(afterFullData, prevDragRow);
                const ptfIndex = $xeTable.findRowIndexOf(tableFullData, prevDragRow);
                nafIndex = pafIndex + dragOffsetIndex;
                const ntfIndex = ptfIndex + dragOffsetIndex;
                afterFullData.splice(nafIndex, 0, dragRow);
                tableFullData.splice(ntfIndex, 0, dragRow);
              }
              reactData.isDragRowMove = true;
              $xeTable.handleTableData(treeConfig && transform);
              $xeTable.cacheRowMap(false);
              updateScrollYStatus();
              if (!(treeConfig && transform)) {
                $xeTable.updateAfterDataIndex();
              }
              $xeTable.checkSelectionStatus();
              if (reactData.scrollYLoad) {
                $xeTable.updateScrollYSpace();
              }
              if (evnt) {
                dispatchEvent("row-dragend", {
                  oldRow: dragRow,
                  newRow: prevDragRow,
                  dragRow,
                  dragPos: prevDragPos,
                  dragToChild: isDragToChildFlag,
                  offsetIndex: dragOffsetIndex,
                  _index: {
                    newIndex: nafIndex,
                    oldIndex: oafIndex
                  }
                }, evnt);
              }
              return nextTick().then(() => {
                $xeTable.updateCellAreas();
                $xeTable.recalculate();
              }).then(() => {
                return {
                  status: true
                };
              });
            }).catch(() => {
              return errRest;
            });
          }
        }
        return Promise.resolve(errRest);
      },
      handleRowDragDragendEvent(evnt) {
        const { treeConfig } = props;
        const { fullAllDataRowIdData, prevDragToChild } = internalData;
        const { dragRow } = reactData;
        const treeOpts = computeTreeOpts.value;
        const { lazy } = treeOpts;
        const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
        const { prevDragRow, prevDragPos } = internalData;
        if (treeConfig && lazy && prevDragToChild) {
          const newRowid = getRowid($xeTable, prevDragRow);
          const rowRest = fullAllDataRowIdData[newRowid];
          if (prevDragRow[hasChildField]) {
            if (rowRest && rowRest.treeLoaded) {
              $xeTable.handleRowDragSwapEvent(evnt, true, dragRow, prevDragRow, prevDragPos, prevDragToChild);
            }
          } else {
            $xeTable.handleRowDragSwapEvent(evnt, true, dragRow, prevDragRow, prevDragPos, prevDragToChild);
          }
        } else {
          $xeTable.handleRowDragSwapEvent(evnt, true, dragRow, prevDragRow, prevDragPos, prevDragToChild);
        }
        hideDropTip();
        clearRowDropOrigin();
        internalData.prevDragToChild = false;
        reactData.dragRow = null;
        reactData.dragCol = null;
        setTimeout(() => {
          reactData.isDragRowMove = false;
        }, 500);
      },
      handleRowDragDragoverEvent(evnt) {
        const { treeConfig } = props;
        const { fullAllDataRowIdData } = internalData;
        const { dragRow } = reactData;
        const treeOpts = computeTreeOpts.value;
        const { lazy, transform, parentField } = treeOpts;
        const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
        const rowDragOpts = computeRowDragOpts.value;
        const { isPeerDrag, isCrossDrag, isToChildDrag } = rowDragOpts;
        if (!dragRow) {
          evnt.preventDefault();
          return;
        }
        const isControlKey = hasControlKey(evnt);
        const trEl = evnt.currentTarget;
        const rowid = trEl.getAttribute("rowid") || "";
        const rest = fullAllDataRowIdData[rowid];
        if (rest) {
          const row = rest.row;
          const rowid2 = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid2];
          evnt.preventDefault();
          const { dragRow: dragRow2 } = reactData;
          const offsetY = evnt.clientY - trEl.getBoundingClientRect().y;
          const dragPos = offsetY < trEl.clientHeight / 2 ? "top" : "bottom";
          internalData.prevDragToChild = !!(treeConfig && transform && (isCrossDrag && isToChildDrag) && isControlKey);
          internalData.prevDragRow = row;
          internalData.prevDragPos = dragPos;
          if ($xeTable.eqRow(dragRow2, row) || isControlKey && treeConfig && lazy && row[hasChildField] && rowRest && !rowRest.treeLoaded || !isCrossDrag && treeConfig && transform && (isPeerDrag ? dragRow2[parentField] !== row[parentField] : rest.level)) {
            showDropTip(evnt, trEl, null, false, dragPos);
            return;
          }
          showDropTip(evnt, trEl, null, true, dragPos);
          dispatchEvent("row-dragover", {
            oldRow: dragRow2,
            targetRow: row,
            dragPos
          }, evnt);
        }
      },
      handleCellDragMousedownEvent(evnt, params) {
        var _a;
        evnt.stopPropagation();
        const { dragConfig } = props;
        const rowDragOpts = computeRowDragOpts.value;
        const { trigger, dragStartMethod } = rowDragOpts;
        const { row } = params;
        const dragEl = evnt.currentTarget;
        const tdEl = trigger === "cell" || trigger === "row" ? dragEl : (_a = dragEl.parentElement) === null || _a === void 0 ? void 0 : _a.parentElement;
        const trEl = tdEl.parentElement;
        const dStartMethod = dragStartMethod || (dragConfig ? dragConfig.dragStartMethod : null);
        clearRowDropOrigin();
        if (dStartMethod && !dStartMethod(params)) {
          trEl.draggable = false;
          reactData.dragRow = null;
          reactData.dragCol = null;
          hideDropTip();
          return;
        }
        reactData.dragRow = row;
        reactData.dragCol = null;
        trEl.draggable = true;
        updateRowDropOrigin(row);
        updateRowDropTipContent(tdEl);
        dispatchEvent("row-dragstart", params, evnt);
      },
      handleCellDragMouseupEvent() {
        clearDragStatus();
      },
      /**
       * 列拖拽
       */
      handleHeaderCellDragDragstartEvent(evnt) {
        if (evnt.dataTransfer) {
          evnt.dataTransfer.setDragImage(getTpImg(), 0, 0);
        }
      },
      handleColDragSwapColumn() {
        handleUpdateColumn();
        parseColumns(false).then(() => {
          $xeTable.updateCellAreas();
          $xeTable.saveCustomStore("update:sort");
        });
      },
      handleColDragSwapEvent(evnt, isSyncColumn, dragCol, prevDragCol, prevDragPos, prevDragToChild) {
        const { mouseConfig } = props;
        const columnDragOpts = computeColumnDragOpts.value;
        const { isPeerDrag, isCrossDrag, isSelfToChildDrag, isToChildDrag, dragEndMethod, dragToChildMethod } = columnDragOpts;
        const { collectColumn } = internalData;
        const dragOffsetIndex = prevDragPos === "right" ? 1 : 0;
        const errRest = {
          status: false
        };
        if (prevDragCol && dragCol) {
          if (prevDragCol !== dragCol) {
            const dragColumn = dragCol;
            const newColumn = prevDragCol;
            const dragParams = {
              oldColumn: dragColumn,
              newColumn,
              dragColumn,
              dragPos: prevDragPos,
              dragToChild: !!prevDragToChild,
              offsetIndex: dragOffsetIndex
            };
            const isDragToChildFlag = isSelfToChildDrag && dragToChildMethod ? dragToChildMethod(dragParams) : prevDragToChild;
            return Promise.resolve(dragEndMethod ? dragEndMethod(dragParams) : true).then((status) => {
              if (!status) {
                return errRest;
              }
              let oafIndex = -1;
              let nafIndex = -1;
              const oldAllMaps = {};
              import_xe_utils9.default.eachTree([dragColumn], (column) => {
                oldAllMaps[column.id] = column;
              });
              let isSelfToChildStatus = false;
              if (dragColumn.parentId && newColumn.parentId) {
                if (isPeerDrag && !isCrossDrag) {
                  if (dragColumn.parentId !== newColumn.parentId) {
                    return errRest;
                  }
                } else {
                  if (!isCrossDrag) {
                    return errRest;
                  }
                  if (oldAllMaps[newColumn.id]) {
                    isSelfToChildStatus = true;
                    if (!(isCrossDrag && isSelfToChildDrag)) {
                      if (VxeUI.modal) {
                        VxeUI.modal.message({
                          status: "error",
                          content: getI18n6("vxe.error.treeDragChild")
                        });
                      }
                      return errRest;
                    }
                  }
                }
              } else if (dragColumn.parentId) {
                if (!isCrossDrag) {
                  return errRest;
                }
              } else if (newColumn.parentId) {
                if (!isCrossDrag) {
                  return errRest;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!(isCrossDrag && isSelfToChildDrag)) {
                    if (VxeUI.modal) {
                      VxeUI.modal.message({
                        status: "error",
                        content: getI18n6("vxe.error.treeDragChild")
                      });
                    }
                    return errRest;
                  }
                }
              } else {
              }
              const oldewMatchRest = import_xe_utils9.default.findTree(collectColumn, (item) => item.id === dragColumn.id);
              if (isSelfToChildStatus && (isCrossDrag && isSelfToChildDrag)) {
                if (oldewMatchRest) {
                  const { items: oCols, index: oIndex } = oldewMatchRest;
                  const childList = dragColumn.children || [];
                  childList.forEach((column) => {
                    column.parentId = dragColumn.parentId;
                  });
                  oCols.splice(oIndex, 1, ...childList);
                  dragColumn.children = [];
                }
              } else {
                if (oldewMatchRest) {
                  const { items: oCols, index: oIndex, parent: oParent } = oldewMatchRest;
                  oCols.splice(oIndex, 1);
                  if (!oParent) {
                    oafIndex = oIndex;
                  }
                }
              }
              const newMatchRest = import_xe_utils9.default.findTree(collectColumn, (item) => item.id === newColumn.id);
              if (newMatchRest) {
                const { items: nCols, index: nIndex, parent: nParent } = newMatchRest;
                if (isCrossDrag && isToChildDrag && isDragToChildFlag) {
                  dragColumn.parentId = newColumn.id;
                  newColumn.children = (newColumn.children || []).concat([dragColumn]);
                } else {
                  dragColumn.parentId = newColumn.parentId;
                  nCols.splice(nIndex + dragOffsetIndex, 0, dragColumn);
                }
                if (!nParent) {
                  nafIndex = nIndex;
                }
              }
              import_xe_utils9.default.eachTree(collectColumn, (column, index, items, path, parentColumn) => {
                if (!parentColumn) {
                  const sortIndex = index + 1;
                  column.renderSortNumber = sortIndex;
                }
              });
              reactData.isDragColMove = true;
              if (mouseConfig) {
                if ($xeTable.clearSelected) {
                  $xeTable.clearSelected();
                }
                if ($xeTable.clearCellAreas) {
                  $xeTable.clearCellAreas();
                  $xeTable.clearCopyCellArea();
                }
              }
              if (evnt) {
                dispatchEvent("column-dragend", {
                  oldColumn: dragColumn,
                  newColumn,
                  dragColumn,
                  dragPos: prevDragPos,
                  dragToChild: isDragToChildFlag,
                  offsetIndex: dragOffsetIndex,
                  _index: {
                    newIndex: nafIndex,
                    oldIndex: oafIndex
                  }
                }, evnt);
              }
              if (isSyncColumn) {
                $xeTable.handleColDragSwapColumn();
              }
              return {
                status: true
              };
            }).catch(() => {
              return errRest;
            });
          }
        }
        return Promise.resolve(errRest);
      },
      handleHeaderCellDragDragendEvent(evnt) {
        const { dragCol } = reactData;
        const { prevDragCol, prevDragPos, prevDragToChild } = internalData;
        $xeTable.handleColDragSwapEvent(evnt, true, dragCol, prevDragCol, prevDragPos, prevDragToChild);
        hideDropTip();
        clearColDropOrigin();
        internalData.prevDragToChild = false;
        reactData.dragRow = null;
        reactData.dragCol = null;
        setTimeout(() => {
          reactData.isDragColMove = false;
          $xeTable.recalculate().then(() => {
            loadScrollXData();
          });
        }, 500);
      },
      handleHeaderCellDragDragoverEvent(evnt) {
        const { dragCol } = reactData;
        const columnDragOpts = computeColumnDragOpts.value;
        const { isToChildDrag, isPeerDrag, isCrossDrag } = columnDragOpts;
        if (!dragCol) {
          evnt.preventDefault();
          return;
        }
        const isControlKey = hasControlKey(evnt);
        const thEl = evnt.currentTarget;
        const colid = thEl.getAttribute("colid");
        const column = $xeTable.getColumnById(colid);
        if (column) {
          evnt.preventDefault();
          const { clientX } = evnt;
          const offsetX = clientX - thEl.getBoundingClientRect().x;
          const dragPos = offsetX < thEl.clientWidth / 2 ? "left" : "right";
          internalData.prevDragToChild = !!(isCrossDrag && isToChildDrag && isControlKey);
          internalData.prevDragCol = column;
          internalData.prevDragPos = dragPos;
          if (column.fixed || dragCol && dragCol.id === column.id || !isCrossDrag && (isPeerDrag ? dragCol.parentId !== column.parentId : column.parentId)) {
            showDropTip(evnt, null, thEl, false, dragPos);
            return;
          }
          showDropTip(evnt, null, thEl, true, dragPos);
          dispatchEvent("column-dragover", {
            oldColumn: dragCol,
            targetColumn: column,
            dragPos
          }, evnt);
          const el = refElem.value;
          if (!el) {
            return;
          }
          const xHandleEl = refScrollXHandleElem.value;
          const tableBody = refTableBody.value;
          const tableBodyElem = tableBody ? tableBody.$el : null;
          const scrollTargetEl = xHandleEl || tableBodyElem;
          if (scrollTargetEl) {
            const wrapperRect = el.getBoundingClientRect();
            const tableWrapperWidth = el.clientWidth;
            const leftContainerElem = refLeftContainer.value;
            const leftContainerWidth = leftContainerElem ? leftContainerElem.clientWidth : 0;
            const rightContainerElem = refRightContainer.value;
            const rightContainerWidth = rightContainerElem ? rightContainerElem.clientWidth : 0;
            const srartX = wrapperRect.x + leftContainerWidth;
            const endX = wrapperRect.x + tableWrapperWidth - rightContainerWidth;
            const distSize = 28;
            const startDistSize = clientX - srartX;
            const endDistSize = endX - clientX;
            if (startDistSize > 0 && startDistSize <= distSize) {
              const scrollRatio = Math.floor(tableWrapperWidth / (startDistSize > distSize / 2 ? 240 : 120));
              scrollTargetEl.scrollLeft -= scrollRatio * (distSize - startDistSize);
            } else if (endDistSize > 0 && endDistSize <= distSize) {
              const scrollRatio = Math.floor(tableWrapperWidth / (endDistSize > distSize / 2 ? 240 : 120));
              scrollTargetEl.scrollLeft += scrollRatio * (distSize - endDistSize);
            }
          }
        }
      },
      handleHeaderCellDragMousedownEvent(evnt, params) {
        var _a;
        evnt.stopPropagation();
        const columnDragOpts = computeColumnDragOpts.value;
        const { trigger, dragStartMethod } = columnDragOpts;
        const { column } = params;
        const dragEl = evnt.currentTarget;
        const thEl = trigger === "cell" ? dragEl : (_a = dragEl.parentElement) === null || _a === void 0 ? void 0 : _a.parentElement;
        reactData.isDragColMove = false;
        clearColDropOrigin();
        if (dragStartMethod && !dragStartMethod(params)) {
          thEl.draggable = false;
          reactData.dragRow = null;
          reactData.dragCol = null;
          hideDropTip();
          return;
        }
        reactData.dragCol = column;
        reactData.dragRow = null;
        thEl.draggable = true;
        updateColDropOrigin(column);
        updateColDropTipContent(thEl);
        dispatchEvent("column-dragstart", params, evnt);
      },
      handleHeaderCellDragMouseupEvent() {
        clearColDropOrigin();
        hideDropTip();
        reactData.dragRow = null;
        reactData.dragCol = null;
        reactData.isDragColMove = false;
      },
      handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, params) {
        const { highlightHoverRow } = props;
        const { lastScrollLeft, lastScrollTop } = internalData;
        const xHandleEl = refScrollXHandleElem.value;
        const yHandleEl = refScrollYHandleElem.value;
        if (!xHandleEl || !yHandleEl) {
          return;
        }
        const rowOpts = computeRowOpts.value;
        const validTip = refValidTooltip.value;
        const tooltip = refTooltip.value;
        const bodyHeight = yHandleEl.clientHeight;
        const bodyWidth = xHandleEl.clientWidth;
        const scrollHeight = yHandleEl.scrollHeight;
        const scrollWidth = xHandleEl.scrollWidth;
        let isTop = false;
        let isBottom = false;
        let isLeft = false;
        let isRight = false;
        let direction = "";
        let isTopBoundary = false;
        let isBottomBoundary = false;
        let isLeftBoundary = false;
        let isRightBoundary = false;
        if (isRollX) {
          const xThreshold = computeScrollXThreshold.value;
          isLeft = scrollLeft <= 0;
          if (!isLeft) {
            isRight = scrollLeft + bodyWidth >= scrollWidth;
          }
          if (scrollLeft > lastScrollLeft) {
            direction = "right";
            if (scrollLeft + bodyWidth >= scrollWidth - xThreshold) {
              isRightBoundary = true;
            }
          } else {
            direction = "left";
            if (scrollLeft <= xThreshold) {
              isLeftBoundary = true;
            }
          }
          $xeTable.checkScrolling();
          internalData.lastScrollLeft = scrollLeft;
        }
        if (isRollY) {
          const yThreshold = computeScrollYThreshold.value;
          isTop = scrollTop <= 0;
          if (!isTop) {
            isBottom = scrollTop + bodyHeight >= scrollHeight;
          }
          if (scrollTop > lastScrollTop) {
            direction = "bottom";
            if (scrollTop + bodyHeight >= scrollHeight - yThreshold) {
              isBottomBoundary = true;
            }
          } else {
            direction = "top";
            if (scrollTop <= yThreshold) {
              isTopBoundary = true;
            }
          }
          internalData.lastScrollTop = scrollTop;
        }
        reactData.isDragColMove = false;
        reactData.isDragRowMove = false;
        reactData.lastScrollTime = Date.now();
        const evntParams = Object.assign({
          scrollTop,
          scrollLeft,
          bodyHeight,
          bodyWidth,
          scrollHeight,
          scrollWidth,
          isX: isRollX,
          isY: isRollY,
          isTop,
          isBottom,
          isLeft,
          isRight,
          direction
        }, params);
        updateRowExpandStyle();
        checkLastSyncScroll(isRollX, isRollY);
        if (isRollX) {
          $xeTable.closeFilter();
        }
        if (rowOpts.isHover || highlightHoverRow) {
          $xeTable.clearHoverRow();
        }
        if (validTip && validTip.reactData.visible) {
          validTip.close();
        }
        if (tooltip && tooltip.reactData.visible) {
          tooltip.close();
        }
        if (isBottomBoundary || isTopBoundary || isRightBoundary || isLeftBoundary) {
          dispatchEvent("scroll-boundary", evntParams, evnt);
        }
        dispatchEvent("scroll", evntParams, evnt);
      },
      /**
       * 横向 X 可视渲染事件处理
       */
      triggerScrollXEvent() {
        const virtualXOpts = computeVirtualXOpts.value;
        if (virtualXOpts.immediate) {
          loadScrollXData();
        } else {
          lazyScrollXData();
        }
      },
      /**
       * 纵向 Y 可视渲染事件处理
       */
      triggerScrollYEvent() {
        const virtualYOpts = computeVirtualYOpts.value;
        if (virtualYOpts.immediate) {
          loadScrollYData();
        } else {
          lazyScrollYData();
        }
      },
      triggerBodyScrollEvent(evnt, fixedType) {
        const { scrollYLoad, scrollXLoad } = reactData;
        const { elemStore, intoRunScroll, lastScrollTop, lastScrollLeft, inWheelScroll, inVirtualScroll, inHeaderScroll, inBodyScroll, scrollRenderType, inFooterScroll } = internalData;
        if (inWheelScroll || inVirtualScroll || inHeaderScroll || inFooterScroll) {
          return;
        }
        const xHandleEl = refScrollXHandleElem.value;
        const yHandleEl = refScrollYHandleElem.value;
        const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        const rowExpandEl = refRowExpandElem.value;
        if (intoRunScroll) {
          return;
        }
        if (!bodyScrollElem) {
          return;
        }
        if (!xHandleEl) {
          return;
        }
        if (!yHandleEl) {
          return;
        }
        if (inBodyScroll) {
          if (scrollRenderType !== fixedType) {
            return;
          }
        }
        let scrollTop = yHandleEl.scrollTop;
        let scrollLeft = xHandleEl.scrollLeft;
        if (leftScrollElem && fixedType === "left") {
          scrollTop = leftScrollElem.scrollTop;
        } else if (rightScrollElem && fixedType === "right") {
          scrollTop = rightScrollElem.scrollTop;
        } else {
          scrollTop = bodyScrollElem.scrollTop;
          scrollLeft = bodyScrollElem.scrollLeft;
        }
        const isRollX = scrollLeft !== lastScrollLeft;
        const isRollY = scrollTop !== lastScrollTop;
        internalData.inBodyScroll = true;
        internalData.scrollRenderType = fixedType;
        if (isRollY) {
          if (fixedType === "left") {
            setScrollTop(bodyScrollElem, scrollTop);
            setScrollTop(rightScrollElem, scrollTop);
          } else if (fixedType === "right") {
            setScrollTop(bodyScrollElem, scrollTop);
            setScrollTop(leftScrollElem, scrollTop);
          } else {
            setScrollTop(leftScrollElem, scrollTop);
            setScrollTop(rightScrollElem, scrollTop);
          }
          setScrollTop(yHandleEl, scrollTop);
          setScrollTop(rowExpandEl, scrollTop);
          if (scrollYLoad) {
            $xeTable.triggerScrollYEvent(evnt);
          }
        }
        if (isRollX) {
          setScrollLeft(xHandleEl, scrollLeft);
          setScrollLeft(headerScrollElem, scrollLeft);
          setScrollLeft(footerScrollElem, scrollLeft);
          if (scrollXLoad) {
            $xeTable.triggerScrollXEvent(evnt);
          }
        }
        $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
          type: "body",
          fixed: fixedType
        });
      },
      triggerHeaderScrollEvent(evnt, fixedType) {
        const { scrollXLoad } = reactData;
        const { elemStore, intoRunScroll, inWheelScroll, inVirtualScroll, inBodyScroll, inFooterScroll } = internalData;
        if (inWheelScroll || inVirtualScroll || inBodyScroll || inFooterScroll) {
          return;
        }
        const yHandleEl = refScrollYHandleElem.value;
        const xHandleEl = refScrollXHandleElem.value;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        if (intoRunScroll) {
          return;
        }
        if (!headerScrollElem) {
          return;
        }
        if (!xHandleEl) {
          return;
        }
        if (!yHandleEl) {
          return;
        }
        const scrollTop = yHandleEl.scrollTop;
        const scrollLeft = headerScrollElem.scrollLeft;
        const isRollX = true;
        const isRollY = false;
        internalData.inHeaderScroll = true;
        setScrollLeft(xHandleEl, scrollLeft);
        setScrollLeft(footerScrollElem, scrollLeft);
        setScrollLeft(bodyScrollElem, scrollLeft);
        if (scrollXLoad) {
          $xeTable.triggerScrollXEvent(evnt);
        }
        $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
          type: "header",
          fixed: fixedType
        });
      },
      triggerFooterScrollEvent(evnt, fixedType) {
        const { scrollXLoad } = reactData;
        const { elemStore, intoRunScroll, inWheelScroll, inVirtualScroll, inHeaderScroll, inBodyScroll } = internalData;
        if (inWheelScroll || inVirtualScroll || inHeaderScroll || inBodyScroll) {
          return;
        }
        const yHandleEl = refScrollYHandleElem.value;
        const xHandleEl = refScrollXHandleElem.value;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        if (intoRunScroll) {
          return;
        }
        if (!footerScrollElem) {
          return;
        }
        if (!xHandleEl) {
          return;
        }
        if (!yHandleEl) {
          return;
        }
        const scrollTop = yHandleEl.scrollTop;
        const scrollLeft = footerScrollElem.scrollLeft;
        const isRollX = true;
        const isRollY = false;
        internalData.inFooterScroll = true;
        setScrollLeft(xHandleEl, scrollLeft);
        setScrollLeft(headerScrollElem, scrollLeft);
        setScrollLeft(bodyScrollElem, scrollLeft);
        if (scrollXLoad) {
          $xeTable.triggerScrollXEvent(evnt);
        }
        $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
          type: "footer",
          fixed: fixedType
        });
      },
      triggerBodyWheelEvent(evnt) {
        const { target, deltaY, deltaX, shiftKey } = evnt;
        if (target && /^textarea$/i.test(target.tagName)) {
          return;
        }
        const { highlightHoverRow } = props_default;
        const { scrollXLoad, scrollYLoad, expandColumn } = reactData;
        const leftFixedWidth = computeLeftFixedWidth.value;
        const rightFixedWidth = computeRightFixedWidth.value;
        if (!(leftFixedWidth || rightFixedWidth || expandColumn)) {
          return;
        }
        const { elemStore, lastScrollTop, lastScrollLeft } = internalData;
        const rowOpts = computeRowOpts.value;
        const xHandleEl = refScrollXHandleElem.value;
        const yHandleEl = refScrollYHandleElem.value;
        const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
        const rowExpandEl = refRowExpandElem.value;
        if (!xHandleEl) {
          return;
        }
        if (!yHandleEl) {
          return;
        }
        if (!bodyScrollElem) {
          return;
        }
        const wheelSpeed = getWheelSpeed(reactData.lastScrollTime);
        const deltaTop = shiftKey ? 0 : Math.ceil(deltaY * wheelSpeed);
        const deltaLeft = shiftKey ? Math.ceil((shiftKey ? deltaY || deltaX : deltaX) * wheelSpeed) : 0;
        const isTopWheel = deltaTop < 0;
        const currScrollTop = bodyScrollElem.scrollTop;
        if (isTopWheel ? currScrollTop <= 0 : currScrollTop >= bodyScrollElem.scrollHeight - bodyScrollElem.clientHeight) {
          return;
        }
        const scrollTop = currScrollTop + deltaTop;
        const scrollLeft = bodyScrollElem.scrollLeft + deltaLeft;
        const isRollX = scrollLeft !== lastScrollLeft;
        const isRollY = scrollTop !== lastScrollTop;
        if (rowOpts.isHover || highlightHoverRow) {
          $xeTable.clearHoverRow();
        }
        if (isRollX) {
          evnt.preventDefault();
          internalData.inWheelScroll = true;
          if (browseObj.firefox || browseObj.safari) {
            const currLeftNum = scrollLeft;
            setScrollLeft(xHandleEl, currLeftNum);
            setScrollLeft(bodyScrollElem, currLeftNum);
            setScrollLeft(headerScrollElem, currLeftNum);
            setScrollLeft(footerScrollElem, currLeftNum);
            if (scrollXLoad) {
              $xeTable.triggerScrollXEvent(evnt);
            }
            $xeTable.handleScrollEvent(evnt, isRollY, isRollX, bodyScrollElem.scrollTop, currLeftNum, {
              type: "table",
              fixed: ""
            });
          } else {
            wheelScrollLeftTo(scrollLeft, (offsetLeft) => {
              internalData.inWheelScroll = true;
              const currLeftNum = offsetLeft;
              setScrollLeft(xHandleEl, currLeftNum);
              setScrollLeft(bodyScrollElem, currLeftNum);
              setScrollLeft(headerScrollElem, currLeftNum);
              setScrollLeft(footerScrollElem, currLeftNum);
              if (scrollXLoad) {
                $xeTable.triggerScrollXEvent(evnt);
              }
              $xeTable.handleScrollEvent(evnt, isRollY, isRollX, bodyScrollElem.scrollTop, currLeftNum, {
                type: "table",
                fixed: ""
              });
            });
          }
        }
        if (isRollY) {
          evnt.preventDefault();
          internalData.inWheelScroll = true;
          if (browseObj.firefox || browseObj.safari) {
            const currTopNum = scrollTop;
            setScrollTop(yHandleEl, currTopNum);
            setScrollTop(bodyScrollElem, currTopNum);
            setScrollTop(leftScrollElem, currTopNum);
            setScrollTop(rightScrollElem, currTopNum);
            setScrollTop(rowExpandEl, currTopNum);
            if (scrollYLoad) {
              $xeTable.triggerScrollYEvent(evnt);
            }
            $xeTable.handleScrollEvent(evnt, isRollY, isRollX, currTopNum, bodyScrollElem.scrollLeft, {
              type: "table",
              fixed: ""
            });
          } else {
            wheelScrollTopTo(scrollTop - currScrollTop, (offsetTop) => {
              internalData.inWheelScroll = true;
              const currTopNum = bodyScrollElem.scrollTop + offsetTop;
              setScrollTop(yHandleEl, currTopNum);
              setScrollTop(bodyScrollElem, currTopNum);
              setScrollTop(leftScrollElem, currTopNum);
              setScrollTop(rightScrollElem, currTopNum);
              setScrollTop(rowExpandEl, currTopNum);
              if (scrollYLoad) {
                $xeTable.triggerScrollYEvent(evnt);
              }
              $xeTable.handleScrollEvent(evnt, isRollY, isRollX, currTopNum, bodyScrollElem.scrollLeft, {
                type: "table",
                fixed: ""
              });
            });
          }
        }
      },
      triggerVirtualScrollXEvent(evnt) {
        const { scrollXLoad } = reactData;
        const { elemStore, inWheelScroll, lastScrollTop, inHeaderScroll, inBodyScroll, inFooterScroll } = internalData;
        if (inHeaderScroll || inBodyScroll || inFooterScroll) {
          return;
        }
        if (inWheelScroll) {
          return;
        }
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        const yHandleEl = refScrollYHandleElem.value;
        const wrapperEl = evnt.currentTarget;
        const { scrollLeft } = wrapperEl;
        const yBodyEl = yHandleEl || bodyScrollElem;
        let scrollTop = 0;
        if (yBodyEl) {
          scrollTop = yBodyEl.scrollTop;
        }
        const isRollX = true;
        const isRollY = scrollTop !== lastScrollTop;
        internalData.inVirtualScroll = true;
        setScrollLeft(bodyScrollElem, scrollLeft);
        setScrollLeft(headerScrollElem, scrollLeft);
        setScrollLeft(footerScrollElem, scrollLeft);
        if (scrollXLoad) {
          $xeTable.triggerScrollXEvent(evnt);
        }
        $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
          type: "table",
          fixed: ""
        });
      },
      triggerVirtualScrollYEvent(evnt) {
        const { scrollYLoad } = reactData;
        const { elemStore, inWheelScroll, lastScrollLeft, inHeaderScroll, inBodyScroll, inFooterScroll } = internalData;
        if (inHeaderScroll || inBodyScroll || inFooterScroll) {
          return;
        }
        if (inWheelScroll) {
          return;
        }
        const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
        const rowExpandEl = refRowExpandElem.value;
        const xHandleEl = refScrollXHandleElem.value;
        const wrapperEl = evnt.currentTarget;
        const { scrollTop } = wrapperEl;
        const xBodyEl = xHandleEl || bodyScrollElem;
        let scrollLeft = 0;
        if (xBodyEl) {
          scrollLeft = xBodyEl.scrollLeft;
        }
        const isRollX = scrollLeft !== lastScrollLeft;
        const isRollY = true;
        internalData.inVirtualScroll = true;
        setScrollTop(bodyScrollElem, scrollTop);
        setScrollTop(leftScrollElem, scrollTop);
        setScrollTop(rightScrollElem, scrollTop);
        setScrollTop(rowExpandEl, scrollTop);
        if (scrollYLoad) {
          $xeTable.triggerScrollYEvent(evnt);
        }
        $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
          type: "table",
          fixed: ""
        });
      },
      /**
       * 对于树形结构中，可以直接滚动到指定深层节点中
       * 对于某些特定的场景可能会用到，比如定位到某一节点
       * @param {Row} row 行对象
       */
      scrollToTreeRow(row) {
        const { treeConfig } = props;
        const { isRowGroupStatus } = reactData;
        const { tableFullData } = internalData;
        const rests = [];
        if (treeConfig || isRowGroupStatus) {
          const rowGroupOpts = computeRowGroupOpts.value;
          const treeOpts = computeTreeOpts.value;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          const matchObj = import_xe_utils9.default.findTree(tableFullData, (item) => $xeTable.eqRow(item, row), { children: isRowGroupStatus ? rowGroupOpts.mapChildrenField : childrenField });
          if (matchObj) {
            const nodes = matchObj.nodes;
            nodes.forEach((row2, index) => {
              if (index < nodes.length - 1 && !$xeTable.isTreeExpandByRow(row2)) {
                rests.push($xeTable.setTreeExpand(row2, true));
              }
            });
          }
        }
        return Promise.all(rests).then(() => rowToVisible($xeTable, row));
      },
      updateScrollYStatus,
      // 更新横向 X 可视渲染上下剩余空间大小
      updateScrollXSpace() {
        const { scrollXLoad, overflowX, scrollXWidth } = reactData;
        const { visibleColumn, scrollXStore, elemStore, fullColumnIdData } = internalData;
        const mouseOpts = computeMouseOpts.value;
        const tableBody = refTableBody.value;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        if (tableBodyElem) {
          const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
          const bodyTableElem = getRefElem(elemStore["main-body-table"]);
          const headerTableElem = getRefElem(elemStore["main-header-table"]);
          const footerTableElem = getRefElem(elemStore["main-footer-table"]);
          let xSpaceLeft = 0;
          const firstColumn = visibleColumn[scrollXStore.startIndex];
          if (firstColumn) {
            const colRest = fullColumnIdData[firstColumn.id] || {};
            xSpaceLeft = colRest.oLeft;
          }
          let clientWidth = 0;
          if (bodyScrollElem) {
            clientWidth = bodyScrollElem.clientWidth;
          }
          let isScrollXBig = false;
          let ySpaceWidth = scrollXWidth;
          if (scrollXWidth > maxXWidth) {
            if (bodyScrollElem && bodyTableElem && bodyScrollElem.scrollLeft + clientWidth >= maxXWidth) {
              xSpaceLeft = maxXWidth - bodyTableElem.clientWidth;
            } else {
              xSpaceLeft = (maxXWidth - clientWidth) * (xSpaceLeft / (scrollXWidth - clientWidth));
            }
            ySpaceWidth = maxXWidth;
            isScrollXBig = true;
          }
          if (!(scrollXLoad && overflowX)) {
            xSpaceLeft = 0;
          }
          if (headerTableElem) {
            headerTableElem.style.transform = headerTableElem.getAttribute("xvm") ? `translate(${xSpaceLeft}px, 0px)` : "";
          }
          if (bodyTableElem) {
            bodyTableElem.style.transform = `translate(${xSpaceLeft}px, ${reactData.scrollYTop || 0}px)`;
          }
          if (footerTableElem) {
            footerTableElem.style.transform = footerTableElem.getAttribute("xvm") ? `translate(${xSpaceLeft}px, 0px)` : "";
          }
          const containerList = ["main"];
          containerList.forEach((name) => {
            const layoutList = ["header", "body", "footer"];
            layoutList.forEach((layout) => {
              const xSpaceElem = getRefElem(elemStore[`${name}-${layout}-xSpace`]);
              if (xSpaceElem) {
                xSpaceElem.style.width = scrollXLoad ? `${ySpaceWidth}px` : "";
              }
            });
          });
          reactData.scrollXLeft = xSpaceLeft;
          reactData.scrollXWidth = ySpaceWidth;
          reactData.isScrollXBig = isScrollXBig;
          const scrollXSpaceEl = refScrollXSpaceElem.value;
          if (scrollXSpaceEl) {
            scrollXSpaceEl.style.width = `${ySpaceWidth}px`;
          }
          if (isScrollXBig && mouseOpts.area) {
            errLog("vxe.error.notProp", ["mouse-config.area"]);
          }
          calcScrollbar();
          return nextTick().then(() => {
            updateStyle();
          });
        }
      },
      // 更新纵向 Y 可视渲染上下剩余空间大小
      updateScrollYSpace() {
        const { isAllOverflow, overflowY, scrollYLoad, expandColumn } = reactData;
        const { scrollYStore, elemStore, isResizeCellHeight, afterFullData, fullAllDataRowIdData, rowExpandedMaps } = internalData;
        const { startIndex } = scrollYStore;
        const mouseOpts = computeMouseOpts.value;
        const expandOpts = computeExpandOpts.value;
        const rowOpts = computeRowOpts.value;
        const cellOpts = computeCellOpts.value;
        const defaultRowHeight = computeDefaultRowHeight.value;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const bodyTableElem = getRefElem(elemStore["main-body-table"]);
        const leftBodyTableElem = getRefElem(elemStore["left-body-table"]);
        const rightbodyTableElem = getRefElem(elemStore["right-body-table"]);
        const containerList = ["main", "left", "right"];
        let ySpaceTop = 0;
        let scrollYHeight = 0;
        let isScrollYBig = false;
        if (scrollYLoad) {
          const isCustomCellHeight = isResizeCellHeight || cellOpts.height || rowOpts.height;
          if (!isCustomCellHeight && !expandColumn && isAllOverflow) {
            scrollYHeight = afterFullData.length * defaultRowHeight;
            if (scrollYHeight > maxYHeight) {
              isScrollYBig = true;
            }
            ySpaceTop = Math.max(0, startIndex * defaultRowHeight);
          } else {
            const firstRow = afterFullData[startIndex];
            let rowid = getRowid($xeTable, firstRow);
            let rowRest = fullAllDataRowIdData[rowid] || {};
            ySpaceTop = rowRest.oTop || 0;
            const lastRow = afterFullData[afterFullData.length - 1];
            rowid = getRowid($xeTable, lastRow);
            rowRest = fullAllDataRowIdData[rowid] || {};
            scrollYHeight = (rowRest.oTop || 0) + (rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight);
            if (expandColumn && rowExpandedMaps[rowid]) {
              scrollYHeight += rowRest.expandHeight || expandOpts.height || 0;
            }
            if (scrollYHeight > maxYHeight) {
              isScrollYBig = true;
            }
          }
        } else {
          if (bodyTableElem) {
            scrollYHeight = bodyTableElem.clientHeight;
          }
        }
        let clientHeight = 0;
        if (bodyScrollElem) {
          clientHeight = bodyScrollElem.clientHeight;
        }
        let ySpaceHeight = scrollYHeight;
        let scrollYTop = ySpaceTop;
        if (isScrollYBig) {
          if (bodyScrollElem && bodyTableElem && bodyScrollElem.scrollTop + clientHeight >= maxYHeight) {
            scrollYTop = maxYHeight - bodyTableElem.clientHeight;
          } else {
            scrollYTop = (maxYHeight - clientHeight) * (ySpaceTop / (scrollYHeight - clientHeight));
          }
          ySpaceHeight = maxYHeight;
        }
        if (!(scrollYLoad && overflowY)) {
          scrollYTop = 0;
        }
        if (leftBodyTableElem) {
          leftBodyTableElem.style.transform = `translate(0px, ${scrollYTop}px)`;
        }
        if (bodyTableElem) {
          bodyTableElem.style.transform = `translate(${reactData.scrollXLeft || 0}px, ${scrollYTop}px)`;
        }
        if (rightbodyTableElem) {
          rightbodyTableElem.style.transform = `translate(0px, ${scrollYTop}px)`;
        }
        containerList.forEach((name) => {
          const layoutList = ["header", "body", "footer"];
          layoutList.forEach((layout) => {
            const ySpaceElem = getRefElem(elemStore[`${name}-${layout}-ySpace`]);
            if (ySpaceElem) {
              ySpaceElem.style.height = ySpaceHeight ? `${ySpaceHeight}px` : "";
            }
          });
        });
        const scrollYSpaceEl = refScrollYSpaceElem.value;
        if (scrollYSpaceEl) {
          scrollYSpaceEl.style.height = ySpaceHeight ? `${ySpaceHeight}px` : "";
        }
        const rowExpandYSpaceEl = refRowExpandYSpaceElem.value;
        if (rowExpandYSpaceEl) {
          rowExpandYSpaceEl.style.height = ySpaceHeight ? `${ySpaceHeight}px` : "";
        }
        reactData.scrollYTop = scrollYTop;
        reactData.scrollYHeight = scrollYHeight;
        reactData.isScrollYBig = isScrollYBig;
        if (isScrollYBig && mouseOpts.area) {
          errLog("vxe.error.notProp", ["mouse-config.area"]);
        }
        calcScrollbar();
        return nextTick().then(() => {
          updateStyle();
        });
      },
      updateScrollXData() {
        const { isAllOverflow } = reactData;
        handleTableColumn();
        $xeTable.updateScrollXSpace();
        return nextTick().then(() => {
          handleTableColumn();
          $xeTable.updateScrollXSpace();
          if (!isAllOverflow) {
            $xeTable.updateScrollYSpace();
          }
        });
      },
      updateScrollYData() {
        $xeTable.handleTableData();
        $xeTable.updateScrollYSpace();
        return nextTick().then(() => {
          $xeTable.handleTableData();
          $xeTable.updateScrollYSpace();
        });
      },
      /**
       * 处理固定列的显示状态
       */
      checkScrolling() {
        const { elemStore } = internalData;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const leftContainerElem = refLeftContainer.value;
        const rightContainerElem = refRightContainer.value;
        const xHandleEl = refScrollXHandleElem.value;
        const bodtTargetEl = xHandleEl || bodyScrollElem;
        if (bodtTargetEl) {
          if (leftContainerElem) {
            if (bodtTargetEl.scrollLeft > 0) {
              addClass(leftContainerElem, "scrolling--middle");
            } else {
              removeClass(leftContainerElem, "scrolling--middle");
            }
          }
          if (rightContainerElem) {
            if (bodtTargetEl.clientWidth < bodtTargetEl.scrollWidth - Math.ceil(bodtTargetEl.scrollLeft)) {
              addClass(rightContainerElem, "scrolling--middle");
            } else {
              removeClass(rightContainerElem, "scrolling--middle");
            }
          }
        }
      },
      updateZindex() {
        if (props.zIndex) {
          internalData.tZindex = props.zIndex;
        } else if (internalData.tZindex < getLastZIndex()) {
          internalData.tZindex = nextZIndex();
        }
      },
      handleCheckedCheckboxRow,
      /**
       * 行 hover 事件
       */
      triggerHoverEvent(evnt, { row }) {
        tablePrivateMethods.setHoverRow(row);
      },
      setHoverRow(row) {
        const rowid = getRowid($xeTable, row);
        const el = refElem.value;
        tablePrivateMethods.clearHoverRow();
        if (el) {
          import_xe_utils9.default.arrayEach(el.querySelectorAll(`.vxe-body--row[rowid="${rowid}"]`), (elem) => addClass(elem, "row--hover"));
        }
        internalData.hoverRow = row;
      },
      clearHoverRow() {
        const el = refElem.value;
        if (el) {
          import_xe_utils9.default.arrayEach(el.querySelectorAll(".vxe-body--row.row--hover"), (elem) => removeClass(elem, "row--hover"));
        }
        internalData.hoverRow = null;
      },
      /**
       * 已废弃，被 getCellElement 替换
       * @deprecated
       */
      getCell(row, column) {
        return tableMethods.getCellElement(row, column);
      },
      findRowIndexOf(list, row) {
        return row ? import_xe_utils9.default.findIndexOf(list, (item) => $xeTable.eqRow(item, row)) : -1;
      },
      eqRow(row1, row2) {
        if (row1 && row2) {
          if (row1 === row2) {
            return true;
          }
          return getRowid($xeTable, row1) === getRowid($xeTable, row2);
        }
        return false;
      }
    };
    "openExport,openPrint,exportData,openImport,importData,saveFile,readFile,importByFile,print".split(",").forEach((name) => {
      $xeTable[name] = function() {
        errLog("vxe.error.reqModule", ["VxeTableExportModule"]);
      };
    });
    "clearValidate,fullValidate,validate".split(",").forEach((name) => {
      $xeTable[name] = function() {
        errLog("vxe.error.reqModule", ["VxeTableValidatorModule"]);
      };
    });
    Object.assign($xeTable, tableMethods, tablePrivateMethods);
    const renderFixed = (fixedType) => {
      const { showHeader, showFooter } = props;
      const { tableData, tableColumn, tableGroupColumn, columnStore, footerTableData } = reactData;
      const isFixedLeft = fixedType === "left";
      const fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;
      return h("div", {
        ref: isFixedLeft ? refLeftContainer : refRightContainer,
        class: `vxe-table--fixed-${fixedType}-wrapper`
      }, [
        showHeader ? h(header_default, {
          ref: isFixedLeft ? refTableLeftHeader : refTableRightHeader,
          fixedType,
          tableData,
          tableColumn,
          tableGroupColumn,
          fixedColumn
        }) : renderEmptyElement5($xeTable),
        h(body_default, {
          ref: isFixedLeft ? refTableLeftBody : refTableRightBody,
          fixedType,
          tableData,
          tableColumn,
          fixedColumn
        }),
        showFooter ? h(footer_default, {
          ref: isFixedLeft ? refTableLeftFooter : refTableRightFooter,
          footerTableData,
          tableColumn,
          fixedColumn,
          fixedType
        }) : renderEmptyElement5($xeTable)
      ]);
    };
    const renderEmptyBody = () => {
      const emptyOpts = computeEmptyOpts.value;
      const params = { $table: $xeTable };
      if (slots.empty) {
        return slots.empty(params);
      } else {
        const compConf = emptyOpts.name ? renderer5.get(emptyOpts.name) : null;
        const rtEmptyView = compConf ? compConf.renderTableEmpty || compConf.renderTableEmptyView || compConf.renderEmpty : null;
        if (rtEmptyView) {
          return getSlotVNs(rtEmptyView(emptyOpts, params));
        }
      }
      return getFuncText(props.emptyText) || getI18n6("vxe.table.emptyText");
    };
    const renderDragTipContents = () => {
      const { dragConfig } = props;
      const { dragRow, dragCol, dragTipText } = reactData;
      const columnDragOpts = computeColumnDragOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      const rowDragSlots = rowDragOpts.slots || {};
      const rTipSlot = rowDragSlots.tip || (dragConfig && dragConfig.slots ? dragConfig.slots.rowTip : null);
      const columnDragSlots = columnDragOpts.slots || {};
      const cTipSlot = columnDragSlots.tip;
      if (dragRow && rTipSlot) {
        return callSlot(rTipSlot, { row: dragRow });
      }
      if (dragCol && cTipSlot) {
        return callSlot(cTipSlot, { column: dragCol });
      }
      return [h("span", dragTipText)];
    };
    const renderDragTip = () => {
      const { dragRow, dragCol } = reactData;
      const rowOpts = computeRowOpts.value;
      const columnOpts = computeColumnOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      if (rowOpts.drag || columnOpts.drag) {
        return h("div", {
          class: "vxe-table--drag-wrapper"
        }, [
          h("div", {
            ref: refDragRowLineElem,
            class: ["vxe-table--drag-row-line", {
              "is--guides": rowDragOpts.showGuidesStatus
            }]
          }),
          h("div", {
            ref: refDragColLineElem,
            class: ["vxe-table--drag-col-line", {
              "is--guides": columnDragOpts.showGuidesStatus
            }]
          }),
          dragRow && rowDragOpts.showDragTip || dragCol && columnDragOpts.showDragTip ? h("div", {
            ref: refDragTipElem,
            class: "vxe-table--drag-sort-tip"
          }, [
            h("div", {
              class: "vxe-table--drag-sort-tip-wrapper"
            }, [
              h("div", {
                class: "vxe-table--drag-sort-tip-status"
              }, [
                h("span", {
                  class: ["vxe-table--drag-sort-tip-normal-status", dragRow ? getIcon6().TABLE_DRAG_STATUS_ROW : getIcon6().TABLE_DRAG_STATUS_COLUMN]
                }),
                h("span", {
                  class: ["vxe-table--drag-sort-tip-sub-status", getIcon6().TABLE_DRAG_STATUS_SUB_ROW]
                }),
                h("span", {
                  class: ["vxe-table--drag-sort-tip-disabled-status", getIcon6().TABLE_DRAG_DISABLED]
                })
              ]),
              h("div", {
                class: "vxe-table--drag-sort-tip-content"
              }, renderDragTipContents())
            ])
          ]) : renderEmptyElement5($xeTable)
        ]);
      }
      return renderEmptyElement5($xeTable);
    };
    const renderRowExpandedVNs = () => {
      const { treeConfig } = props;
      const { expandColumn, isRowGroupStatus } = reactData;
      const tableRowExpandedList = computeTableRowExpandedList.value;
      const expandOpts = computeExpandOpts.value;
      const { mode } = expandOpts;
      if (mode !== "fixed") {
        return renderEmptyElement5($xeTable);
      }
      const expandVNs = [
        h("div", {
          key: "repY",
          ref: refRowExpandYSpaceElem
        })
      ];
      if (expandColumn) {
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        tableRowExpandedList.forEach((row) => {
          const expandOpts2 = computeExpandOpts.value;
          const { height: expandHeight, padding, indent } = expandOpts2;
          const { fullAllDataRowIdData, fullColumnIdData } = internalData;
          const treeOpts = computeTreeOpts.value;
          const { transform, seqMode } = treeOpts;
          const cellStyle = {};
          const rowid = handleGetRowId(row);
          const rowRest = fullAllDataRowIdData[rowid];
          const colid = expandColumn.id;
          const colRest = fullColumnIdData[colid] || {};
          let rowLevel = 0;
          let seq = -1;
          let _rowIndex = -1;
          let rowIndex = -1;
          let $rowIndex = -1;
          if (rowRest) {
            rowLevel = rowRest.level;
            if (isRowGroupStatus || treeConfig && transform && seqMode === "increasing") {
              seq = rowRest._index + 1;
            } else {
              seq = rowRest.seq;
            }
            rowIndex = rowRest.index;
            $rowIndex = rowRest.$index;
            _rowIndex = rowRest._index;
          }
          if (expandHeight) {
            cellStyle.height = `${expandHeight}px`;
          }
          if (isRowGroupStatus || treeConfig) {
            cellStyle.paddingLeft = `${rowLevel * (import_xe_utils9.default.isNumber(indent) ? indent : treeOpts.indent) + 30}px`;
          }
          let columnIndex = -1;
          let $columnIndex = -1;
          let _columnIndex = -1;
          if (colRest) {
            columnIndex = colRest.index;
            $columnIndex = colRest.$index;
            _columnIndex = colRest._index;
          }
          const expandParams = {
            $grid: $xeGrid,
            $table: $xeTable,
            seq,
            column: expandColumn,
            columnIndex,
            $columnIndex,
            _columnIndex,
            fixed: "",
            type: "body",
            level: rowLevel,
            rowid,
            row,
            rowIndex,
            $rowIndex,
            _rowIndex,
            isHidden: false,
            isEdit: false,
            visibleData: [],
            data: [],
            items: []
          };
          expandVNs.push(h("div", {
            key: rowid,
            class: ["vxe-body--row-expanded-cell", {
              "is--padding": padding,
              "is--ellipsis": expandHeight
            }],
            rowid,
            style: cellStyle
          }, expandColumn.renderData(expandParams)));
        });
      }
      return h("div", {
        ref: refRowExpandElem,
        class: "vxe-table--row-expanded-wrapper"
      }, expandVNs);
    };
    const renderScrollX = () => {
      return h("div", {
        key: "vsx",
        ref: refScrollXVirtualElem,
        class: "vxe-table--scroll-x-virtual"
      }, [
        h("div", {
          ref: refScrollXLeftCornerElem,
          class: "vxe-table--scroll-x-left-corner"
        }),
        h("div", {
          ref: refScrollXWrapperElem,
          class: "vxe-table--scroll-x-wrapper"
        }, [
          h("div", {
            ref: refScrollXHandleElem,
            class: "vxe-table--scroll-x-handle",
            onScroll: $xeTable.triggerVirtualScrollXEvent
          }, [
            h("div", {
              ref: refScrollXSpaceElem,
              class: "vxe-table--scroll-x-space"
            })
          ])
        ]),
        h("div", {
          ref: refScrollXRightCornerElem,
          class: "vxe-table--scroll-x-right-corner"
        })
      ]);
    };
    const renderScrollY = () => {
      return h("div", {
        ref: refScrollYVirtualElem,
        class: "vxe-table--scroll-y-virtual"
      }, [
        h("div", {
          ref: refScrollYTopCornerElem,
          class: "vxe-table--scroll-y-top-corner"
        }),
        h("div", {
          ref: refScrollYWrapperElem,
          class: "vxe-table--scroll-y-wrapper"
        }, [
          h("div", {
            ref: refScrollYHandleElem,
            class: "vxe-table--scroll-y-handle",
            onScroll: $xeTable.triggerVirtualScrollYEvent
          }, [
            h("div", {
              ref: refScrollYSpaceElem,
              class: "vxe-table--scroll-y-space"
            })
          ])
        ]),
        h("div", {
          ref: refScrollYBottomCornerElem,
          class: "vxe-table--scroll-y-bottom-corner"
        })
      ]);
    };
    const renderViewport = () => {
      const { showHeader, showFooter } = props;
      const { overflowX, tableData, tableColumn, tableGroupColumn, footerTableData, columnStore } = reactData;
      const { leftList, rightList } = columnStore;
      return h("div", {
        ref: refTableViewportElem,
        class: "vxe-table--viewport-wrapper"
      }, [
        h("div", {
          class: "vxe-table--main-wrapper"
        }, [
          /**
           * 表头
           */
          showHeader ? h(header_default, {
            ref: refTableHeader,
            tableData,
            tableColumn,
            tableGroupColumn
          }) : renderEmptyElement5($xeTable),
          /**
           * 表体
           */
          h(body_default, {
            ref: refTableBody,
            tableData,
            tableColumn
          }),
          /**
           * 表尾
           */
          showFooter ? h(footer_default, {
            ref: refTableFooter,
            footerTableData,
            tableColumn
          }) : renderEmptyElement5($xeTable)
        ]),
        h("div", {
          class: "vxe-table--fixed-wrapper"
        }, [
          leftList && leftList.length && overflowX ? renderFixed("left") : renderEmptyElement5($xeTable),
          rightList && rightList.length && overflowX ? renderFixed("right") : renderEmptyElement5($xeTable)
        ]),
        renderRowExpandedVNs()
      ]);
    };
    const renderBody = () => {
      const scrollbarYToLeft = computeScrollbarYToLeft.value;
      return h("div", {
        class: "vxe-table--layout-wrapper"
      }, scrollbarYToLeft ? [
        renderScrollY(),
        renderViewport()
      ] : [
        renderViewport(),
        renderScrollY()
      ]);
    };
    const renderVN = () => {
      const { loading, stripe, showHeader, height, treeConfig, mouseConfig, showFooter, highlightCell, highlightHoverRow, highlightHoverColumn, editConfig, editRules } = props;
      const { isGroup, overflowX, overflowY, scrollXLoad, scrollYLoad, tableData, initStore, isRowGroupStatus, columnStore, filterStore, customStore } = reactData;
      const { leftList, rightList } = columnStore;
      const loadingSlot = slots.loading;
      const tableTipConfig = computeTableTipConfig.value;
      const validTipConfig = computeValidTipConfig.value;
      const validOpts = computeValidOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const treeOpts = computeTreeOpts.value;
      const rowOpts = computeRowOpts.value;
      const columnOpts = computeColumnOpts.value;
      const vSize = computeSize.value;
      const tableBorder = computeTableBorder.value;
      const mouseOpts = computeMouseOpts.value;
      const areaOpts = computeAreaOpts.value;
      const loadingOpts = computeLoadingOpts.value;
      const isMenu = computeIsMenu.value;
      const currLoading = reactData.isColLoading || reactData.isRowLoading || loading;
      const resizableOpts = computeResizableOpts.value;
      const isArea = mouseConfig && mouseOpts.area;
      const columnDragOpts = computeColumnDragOpts.value;
      const scrollbarXToTop = computeScrollbarXToTop.value;
      const scrollbarYToLeft = computeScrollbarYToLeft.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-table", "vxe-table--render-default", `tid_${xID}`, `border--${tableBorder}`, `sx-pos--${scrollbarXToTop ? "top" : "bottom"}`, `sy-pos--${scrollbarYToLeft ? "left" : "right"}`, {
          [`size--${vSize}`]: vSize,
          [`valid-msg--${validOpts.msgMode}`]: !!editRules,
          "vxe-editable": !!editConfig,
          "old-cell-valid": editRules && getConfig2().cellVaildMode === "obsolete",
          "cell--highlight": highlightCell,
          "cell--selected": mouseConfig && mouseOpts.selected,
          "cell--area": isArea,
          "header-cell--area": isArea && areaOpts.selectCellByHeader,
          "body-cell--area": isArea && areaOpts.selectCellByBody,
          "row--highlight": rowOpts.isHover || highlightHoverRow,
          "column--highlight": columnOpts.isHover || highlightHoverColumn,
          "checkbox--range": checkboxOpts.range,
          "col--drag-cell": columnOpts.drag && columnDragOpts.trigger === "cell",
          "is--header": showHeader,
          "is--footer": showFooter,
          "is--group": isGroup,
          "is-row-group": isRowGroupStatus,
          "is--tree-line": treeConfig && (treeOpts.showLine || treeOpts.line),
          "is--fixed-left": leftList.length,
          "is--fixed-right": rightList.length,
          "is--animat": !!props.animat,
          "is--round": props.round,
          "is--stripe": !treeConfig && stripe,
          "is--loading": currLoading,
          "is--empty": !currLoading && !tableData.length,
          "is--scroll-y": overflowY,
          "is--scroll-x": overflowX,
          "is--virtual-x": scrollXLoad,
          "is--virtual-y": scrollYLoad
        }],
        spellcheck: false,
        onKeydown: keydownEvent
      }, [
        /**
         * 隐藏列
         */
        h("div", {
          class: "vxe-table-slots"
        }, slots.default ? slots.default({}) : []),
        h("div", {
          ref: refVarElem,
          class: "vxe-table-vars"
        }, [
          h("div", {
            class: "vxe-table-var-default"
          }),
          h("div", {
            class: "vxe-table-var-medium"
          }),
          h("div", {
            class: "vxe-table-var-small"
          }),
          h("div", {
            class: "vxe-table-var-mini"
          })
        ]),
        h("div", {
          key: "tw",
          class: "vxe-table--render-wrapper"
        }, scrollbarXToTop ? [
          renderScrollX(),
          renderBody()
        ] : [
          renderBody(),
          renderScrollX()
        ]),
        /**
         * 空数据
         */
        h("div", {
          key: "tn",
          ref: refEmptyPlaceholder,
          class: "vxe-table--empty-placeholder"
        }, [
          h("div", {
            class: "vxe-table--empty-content"
          }, renderEmptyBody())
        ]),
        /**
         * 边框线
         */
        h("div", {
          key: "tl",
          class: "vxe-table--border-line"
        }),
        /**
         * 列宽线
         */
        h("div", {
          key: "tcl",
          ref: refColResizeBar,
          class: "vxe-table--resizable-col-bar"
        }, resizableOpts.showDragTip ? [
          h("div", {
            class: "vxe-table--resizable-number-tip"
          })
        ] : []),
        /**
         * 行高线
         */
        h("div", {
          key: "trl",
          ref: refRowResizeBar,
          class: "vxe-table--resizable-row-bar"
        }, resizableOpts.showDragTip ? [
          h("div", {
            class: "vxe-table--resizable-number-tip"
          })
        ] : []),
        /**
         * 加载中
         */
        VxeUILoadingComponent ? h(VxeUILoadingComponent, {
          key: "lg",
          class: "vxe-table--loading",
          modelValue: currLoading,
          icon: loadingOpts.icon,
          text: loadingOpts.text
        }, loadingSlot ? {
          default: () => callSlot(loadingSlot, { $table: $xeTable, $grid: $xeGrid, loading: currLoading })
        } : {}) : loadingSlot ? h("div", {
          class: ["vxe-loading--custom-wrapper", {
            "is--visible": currLoading
          }]
        }, callSlot(loadingSlot, { $table: $xeTable, $grid: $xeGrid, loading: currLoading })) : renderEmptyElement5($xeTable),
        /**
         * 自定义列
         */
        initStore.custom ? h(panel_default, {
          key: "cs",
          ref: refTableCustom,
          customStore
        }) : renderEmptyElement5($xeTable),
        /**
         * 筛选
         */
        initStore.filter ? h(panel_default2, {
          key: "tf",
          ref: refTableFilter,
          filterStore
        }) : renderEmptyElement5($xeTable),
        /**
         * 导入
         */
        initStore.import && props.importConfig ? h(import_panel_default, {
          key: "it",
          defaultOptions: reactData.importParams,
          storeData: reactData.importStore
        }) : renderEmptyElement5($xeTable),
        /**
         * 导出
         */
        initStore.export && (props.exportConfig || props.printConfig) ? h(export_panel_default, {
          key: "et",
          defaultOptions: reactData.exportParams,
          storeData: reactData.exportStore
        }) : renderEmptyElement5($xeTable),
        /**
         * 快捷菜单
         */
        isMenu ? h(panel_default3, {
          key: "tm",
          ref: refTableMenu
        }) : renderEmptyElement5($xeTable),
        /**
         * 拖拽排序提示
         */
        renderDragTip(),
        /**
         * 提示相关
         */
        VxeUITooltipComponent ? h("div", {}, [
          /**
           * 通用提示
           */
          h(VxeUITooltipComponent, {
            key: "ctp",
            ref: refCommTooltip,
            isArrow: false,
            enterable: false
          }),
          /**
            * 工具提示
            */
          h(VxeUITooltipComponent, {
            key: "btp",
            ref: refTooltip,
            theme: tableTipConfig.theme,
            enterable: tableTipConfig.enterable,
            enterDelay: tableTipConfig.enterDelay,
            leaveDelay: tableTipConfig.leaveDelay,
            useHTML: tableTipConfig.useHTML
          }),
          /**
            * 校验提示
            */
          props.editRules && validOpts.showMessage && (validOpts.message === "default" ? !height : validOpts.message === "tooltip") ? h(VxeUITooltipComponent, {
            key: "vtp",
            ref: refValidTooltip,
            class: [{
              "old-cell-valid": editRules && getConfig2().cellVaildMode === "obsolete"
            }, "vxe-table--valid-error"],
            theme: validTipConfig.theme,
            enterable: validTipConfig.enterable,
            enterDelay: validTipConfig.enterDelay,
            leaveDelay: validTipConfig.leaveDelay
          }) : renderEmptyElement5($xeTable)
        ]) : renderEmptyElement5($xeTable)
      ]);
    };
    const dataFlag = ref(0);
    watch(() => props.data ? props.data.length : -1, () => {
      dataFlag.value++;
    });
    watch(() => props.data, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      const { initStatus } = internalData;
      const value = props.data || [];
      if (value && value.length >= 5e4) {
        warnLog("vxe.error.errLargeData", ["loadData(data), reloadData(data)"]);
      }
      loadTableData(value, false).then(() => {
        const { scrollXLoad, scrollYLoad, expandColumn } = reactData;
        const expandOpts = computeExpandOpts.value;
        internalData.inited = true;
        internalData.initStatus = true;
        if (!initStatus) {
          handleLoadDefaults();
        }
        if ((scrollXLoad || scrollYLoad) && (expandColumn && expandOpts.mode !== "fixed")) {
          warnLog("vxe.error.scrollErrProp", ["column.type=expand"]);
        }
        return tableMethods.recalculate();
      });
    });
    const staticColumnFlag = ref(0);
    watch(() => reactData.staticColumns.length, () => {
      staticColumnFlag.value++;
    });
    watch(() => reactData.staticColumns, () => {
      staticColumnFlag.value++;
    });
    watch(staticColumnFlag, () => {
      handleColumn(import_xe_utils9.default.clone(reactData.staticColumns));
    });
    const tableColumnFlag = ref(0);
    watch(() => reactData.tableColumn.length, () => {
      tableColumnFlag.value++;
    });
    watch(() => reactData.tableColumn, () => {
      tableColumnFlag.value++;
    });
    watch(tableColumnFlag, () => {
      tablePrivateMethods.analyColumnWidth();
    });
    watch(() => reactData.upDataFlag, () => {
      nextTick(() => {
        tableMethods.updateData();
      });
    });
    watch(() => reactData.reColumnFlag, () => {
      nextTick(() => {
        tableMethods.refreshColumn();
      });
    });
    const reScrollFlag = ref(0);
    watch(computeSize, () => {
      reScrollFlag.value++;
    });
    watch(() => props.showHeader, () => {
      reScrollFlag.value++;
    });
    watch(() => props.showFooter, () => {
      reScrollFlag.value++;
    });
    watch(() => reactData.overflowX, () => {
      reScrollFlag.value++;
    });
    watch(() => reactData.overflowY, () => {
      reScrollFlag.value++;
    });
    watch(reScrollFlag, () => {
      nextTick(() => {
        tableMethods.recalculate(true).then(() => tableMethods.refreshScroll());
      });
    });
    const reLayoutFlag = ref(0);
    watch(() => props.height, () => {
      reLayoutFlag.value++;
    });
    watch(() => props.maxHeight, () => {
      reLayoutFlag.value++;
    });
    watch(computeScrollbarXToTop, () => {
      reLayoutFlag.value++;
    });
    watch(computeScrollbarYToLeft, () => {
      reLayoutFlag.value++;
    });
    watch(() => VxeUI.getLanguage(), () => {
      reLayoutFlag.value++;
    });
    watch(reLayoutFlag, () => {
      nextTick(() => tableMethods.recalculate(true));
    });
    const footFlag = ref(0);
    watch(() => props.footerData ? props.footerData.length : -1, () => {
      footFlag.value++;
    });
    watch(() => props.footerData, () => {
      footFlag.value++;
    });
    watch(footFlag, () => {
      tableMethods.updateFooter();
    });
    watch(() => props.syncResize, (value) => {
      if (value) {
        handleUpdateResize();
        nextTick(() => {
          handleUpdateResize();
          setTimeout(() => handleUpdateResize());
        });
      }
    });
    const mergeCellFlag = ref(0);
    watch(() => props.mergeCells ? props.mergeCells.length : -1, () => {
      mergeCellFlag.value++;
    });
    watch(() => props.mergeCells, () => {
      mergeCellFlag.value++;
    });
    watch(mergeCellFlag, () => {
      tableMethods.clearMergeCells();
      nextTick(() => {
        if (props.mergeCells) {
          tableMethods.setMergeCells(props.mergeCells);
        }
      });
    });
    const mergeFooterItemFlag = ref(0);
    watch(() => props.mergeFooterItems ? props.mergeFooterItems.length : -1, () => {
      mergeFooterItemFlag.value++;
    });
    watch(() => props.mergeFooterItems, () => {
      mergeFooterItemFlag.value++;
    });
    watch(mergeFooterItemFlag, () => {
      tableMethods.clearMergeFooterItems();
      nextTick(() => {
        if (props.mergeFooterItems) {
          tableMethods.setMergeFooterItems(props.mergeFooterItems);
        }
      });
    });
    watch(computeRowGroupFields, (val) => {
      handleUpdateRowGroup(val);
    });
    if ($xeTabs) {
      watch(() => $xeTabs ? $xeTabs.reactData.resizeFlag : null, () => {
        handleGlobalResizeEvent();
      });
    }
    hooks.forEach((options) => {
      const { setupTable } = options;
      if (setupTable) {
        const hookRest = setupTable($xeTable);
        if (hookRest && import_xe_utils9.default.isObject(hookRest)) {
          Object.assign($xeTable, hookRest);
        }
      }
    });
    tablePrivateMethods.preventEvent(null, "created", { $table: $xeTable });
    let resizeObserver;
    onActivated(() => {
      tableMethods.recalculate().then(() => tableMethods.refreshScroll());
      tablePrivateMethods.preventEvent(null, "activated", { $table: $xeTable });
    });
    onDeactivated(() => {
      internalData.isActivated = false;
      tablePrivateMethods.preventEvent(null, "deactivated", { $table: $xeTable });
    });
    onMounted(() => {
      const columnOpts = computeColumnOpts.value;
      const rowOpts = computeRowOpts.value;
      const customOpts = computeCustomOpts.value;
      const rowGroupOpts = computeRowGroupOpts.value;
      const { groupFields } = rowGroupOpts;
      if (columnOpts.drag || rowOpts.drag || customOpts.allowSort) {
        initTpImg();
      }
      handleUpdateRowGroup(groupFields);
      nextTick(() => {
        const { data, exportConfig, importConfig, treeConfig, showOverflow, highlightCurrentRow, highlightCurrentColumn } = props;
        const { scrollXStore, scrollYStore } = internalData;
        const editOpts = computeEditOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const expandOpts = computeExpandOpts.value;
        const rowOpts2 = computeRowOpts.value;
        const customOpts2 = computeCustomOpts.value;
        const mouseOpts = computeMouseOpts.value;
        const exportOpts = computeExportOpts.value;
        const importOpts = computeImportOpts.value;
        const currentRowOpts = computeCurrentRowOpts.value;
        const currentColumnOpts = computeCurrentColumnOpts.value;
        const keyboardOpts = computeKeyboardOpts.value;
        if (props.rowId) {
          warnLog("vxe.error.delProp", ["row-id", "row-config.keyField"]);
        }
        if (props.rowKey) {
          warnLog("vxe.error.delProp", ["row-key", "row-config.useKey"]);
        }
        if (props.columnKey) {
          warnLog("vxe.error.delProp", ["column-id", "column-config.useKey"]);
        }
        if (!(props.rowId || rowOpts2.keyField) && (checkboxOpts.reserve || checkboxOpts.checkRowKeys || radioOpts.reserve || radioOpts.checkRowKey || expandOpts.expandRowKeys || treeOpts.expandRowKeys)) {
          warnLog("vxe.error.reqProp", ["row-config.keyField"]);
        }
        if (props.editConfig && (editOpts.showStatus || editOpts.showUpdateStatus || editOpts.showInsertStatus) && !props.keepSource) {
          warnLog("vxe.error.reqProp", ["keep-source"]);
        }
        if (treeConfig && (treeOpts.showLine || treeOpts.line) && (!(props.rowKey || rowOpts2.useKey) || !showOverflow)) {
          warnLog("vxe.error.reqProp", ["row-config.useKey | show-overflow"]);
        }
        if (treeConfig && !treeOpts.transform && props.stripe) {
          warnLog("vxe.error.noTree", ["stripe"]);
        }
        if (props.showFooter && !(props.footerMethod || props.footerData)) {
          warnLog("vxe.error.reqProp", ["footer-data | footer-method"]);
        }
        if (rowOpts2.height) {
          warnLog("vxe.error.delProp", ["row-config.height", "cell-config.height"]);
        }
        if (props.highlightCurrentRow) {
          warnLog("vxe.error.delProp", ["highlight-current-row", "row-config.isCurrent"]);
        }
        if (props.highlightHoverRow) {
          warnLog("vxe.error.delProp", ["highlight-hover-row", "row-config.isHover"]);
        }
        if (props.highlightCurrentColumn) {
          warnLog("vxe.error.delProp", ["highlight-current-column", "column-config.isCurrent"]);
        }
        if (props.highlightHoverColumn) {
          warnLog("vxe.error.delProp", ["highlight-hover-column", "column-config.isHover"]);
        }
        if (props.resizable) {
          warnLog("vxe.error.delProp", ["resizable", "column-config.resizable"]);
        }
        if (importConfig && importOpts.types && !importOpts.importMethod && !import_xe_utils9.default.includeArrays(import_xe_utils9.default.keys(importOpts._typeMaps), importOpts.types)) {
          warnLog("vxe.error.errProp", [`export-config.types=${importOpts.types.join(",")}`, importOpts.types.filter((type) => import_xe_utils9.default.includes(import_xe_utils9.default.keys(importOpts._typeMaps), type)).join(",") || import_xe_utils9.default.keys(importOpts._typeMaps).join(",")]);
        }
        if (exportConfig && exportOpts.types && !exportOpts.exportMethod && !import_xe_utils9.default.includeArrays(import_xe_utils9.default.keys(exportOpts._typeMaps), exportOpts.types)) {
          warnLog("vxe.error.errProp", [`export-config.types=${exportOpts.types.join(",")}`, exportOpts.types.filter((type) => import_xe_utils9.default.includes(import_xe_utils9.default.keys(exportOpts._typeMaps), type)).join(",") || import_xe_utils9.default.keys(exportOpts._typeMaps).join(",")]);
        }
        if (!props.id) {
          if ((props.customConfig ? isEnableConf(customOpts2) : customOpts2.enabled) && customOpts2.storage) {
            errLog("vxe.error.reqProp", ["id"]);
          }
        }
        if (props.treeConfig && checkboxOpts.range) {
          errLog("vxe.error.noTree", ["checkbox-config.range"]);
        }
        if (rowOpts2.height && !props.showOverflow) {
          warnLog("vxe.error.notProp", ["table.show-overflow"]);
        }
        if (!$xeTable.triggerCellAreaMousedownEvent) {
          if (props.areaConfig) {
            warnLog("vxe.error.notProp", ["area-config"]);
          }
          if (props.clipConfig) {
            warnLog("vxe.error.notProp", ["clip-config"]);
          }
          if (props.fnrConfig) {
            warnLog("vxe.error.notProp", ["fnr-config"]);
          }
          if (mouseOpts.area) {
            errLog("vxe.error.notProp", ["mouse-config.area"]);
            return;
          }
        }
        if (treeConfig && rowOpts2.drag && !treeOpts.transform) {
          errLog("vxe.error.notSupportProp", ["column-config.drag", "tree-config.transform=false", "tree-config.transform=true"]);
        }
        if (props.dragConfig) {
          warnLog("vxe.error.delProp", ["drag-config", "row-drag-config"]);
        }
        if (props.treeConfig && treeOpts.children) {
          warnLog("vxe.error.delProp", ["tree-config.children", "tree-config.childrenField"]);
        }
        if (props.treeConfig && treeOpts.line) {
          warnLog("vxe.error.delProp", ["tree-config.line", "tree-config.showLine"]);
        }
        if (mouseOpts.area && mouseOpts.selected) {
          warnLog("vxe.error.errConflicts", ["mouse-config.area", "mouse-config.selected"]);
        }
        if (mouseOpts.area && (props.treeConfig && !treeOpts.transform)) {
          errLog("vxe.error.noTree", ["mouse-config.area"]);
        }
        if (props.editConfig && editOpts.activeMethod) {
          warnLog("vxe.error.delProp", ["edit-config.activeMethod", "edit-config.beforeEditMethod"]);
        }
        if (props.treeConfig && checkboxOpts.isShiftKey) {
          errLog("vxe.error.errConflicts", ["tree-config", "checkbox-config.isShiftKey"]);
        }
        if (checkboxOpts.halfField) {
          warnLog("vxe.error.delProp", ["checkbox-config.halfField", "checkbox-config.indeterminateField"]);
        }
        if (rowOpts2.currentMethod) {
          warnLog("vxe.error.delProp", ["row-config.currentMethod", "current-row-config.beforeSelectMethod"]);
        }
        if (columnOpts.currentMethod) {
          warnLog("vxe.error.delProp", ["row-config.currentMethod", "current-column-config.beforeSelectMethod"]);
        }
        if ((rowOpts2.isCurrent || highlightCurrentRow) && props.keyboardConfig && keyboardOpts.isArrow && !import_xe_utils9.default.isBoolean(currentRowOpts.isFollowSelected)) {
          warnLog("vxe.error.notConflictProp", ["row-config.isCurrent", "current-row-config.isFollowSelected"]);
        }
        if ((columnOpts.isCurrent || highlightCurrentColumn) && props.keyboardConfig && keyboardOpts.isArrow && !import_xe_utils9.default.isBoolean(currentColumnOpts.isFollowSelected)) {
          warnLog("vxe.error.notConflictProp", ["column-config.isCurrent", "current-column-config.isFollowSelected"]);
        }
        if (props.editConfig && !$xeTable.insert) {
          errLog("vxe.error.reqModule", ["Edit"]);
        }
        if (props.editRules && !$xeTable.validate) {
          errLog("vxe.error.reqModule", ["Validator"]);
        }
        if ((checkboxOpts.range || props.keyboardConfig || props.mouseConfig) && !$xeTable.handleCellMousedownEvent) {
          errLog("vxe.error.reqModule", ["Keyboard"]);
        }
        if ((props.printConfig || props.importConfig || props.exportConfig) && !$xeTable.exportData) {
          errLog("vxe.error.reqModule", ["Export"]);
        }
        Object.assign(scrollYStore, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0
        });
        Object.assign(scrollXStore, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0
        });
        loadTableData(data || [], true).then(() => {
          if (data && data.length) {
            internalData.inited = true;
            internalData.initStatus = true;
            handleLoadDefaults();
          }
          handleInitDefaults();
          updateStyle();
        });
        if (props.autoResize) {
          const el = refElem.value;
          const parentEl = tablePrivateMethods.getParentElem();
          resizeObserver = globalResize.create(() => {
            if (props.autoResize) {
              tableMethods.recalculate(true);
            }
          });
          if (el) {
            resizeObserver.observe(el);
          }
          if (parentEl) {
            resizeObserver.observe(parentEl);
          }
        }
      });
      const tableViewportEl = refTableViewportElem.value;
      if (tableViewportEl) {
        tableViewportEl.addEventListener("wheel", $xeTable.triggerBodyWheelEvent, { passive: false });
      }
      globalEvents.on($xeTable, "paste", handleGlobalPasteEvent);
      globalEvents.on($xeTable, "copy", handleGlobalCopyEvent);
      globalEvents.on($xeTable, "cut", handleGlobalCutEvent);
      globalEvents.on($xeTable, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeTable, "blur", handleGlobalBlurEvent);
      globalEvents.on($xeTable, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeTable, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeTable, "resize", handleGlobalResizeEvent);
      globalEvents.on($xeTable, "contextmenu", $xeTable.handleGlobalContextmenuEvent);
      tablePrivateMethods.preventEvent(null, "mounted", { $table: $xeTable });
    });
    onBeforeUnmount(() => {
      const tableViewportEl = refTableViewportElem.value;
      if (tableViewportEl) {
        tableViewportEl.removeEventListener("wheel", $xeTable.triggerBodyWheelEvent);
      }
      internalData.cvCacheMaps = {};
      internalData.prevDragRow = null;
      internalData.prevDragCol = null;
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      tableMethods.closeFilter();
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
      tablePrivateMethods.preventEvent(null, "beforeUnmount", { $table: $xeTable });
    });
    onUnmounted(() => {
      globalEvents.off($xeTable, "paste");
      globalEvents.off($xeTable, "copy");
      globalEvents.off($xeTable, "cut");
      globalEvents.off($xeTable, "mousedown");
      globalEvents.off($xeTable, "blur");
      globalEvents.off($xeTable, "mousewheel");
      globalEvents.off($xeTable, "keydown");
      globalEvents.off($xeTable, "resize");
      globalEvents.off($xeTable, "contextmenu");
      tablePrivateMethods.preventEvent(null, "unmounted", { $table: $xeTable });
    });
    nextTick(() => {
      if (props.loading) {
        if (!VxeUILoadingComponent && !slots.loading) {
          errLog("vxe.error.reqComp", ["vxe-loading"]);
        }
      }
      if (props.showOverflow === true || props.showOverflow === "tooltip" || (props.showHeaderOverflow === true || props.showHeaderOverflow === "tooltip") || (props.showFooterOverflow === true || props.showFooterOverflow === "tooltip") || props.tooltipConfig || props.editRules) {
        if (!VxeUITooltipComponent) {
          errLog("vxe.error.reqComp", ["vxe-tooltip"]);
        }
      }
    });
    provide("$xeColgroup", null);
    provide("$xeTable", $xeTable);
    $xeTable.renderVN = renderVN;
    return $xeTable;
  },
  render() {
    return this.renderVN();
  }
});

export {
  props_default,
  emits_default,
  table_default
};
//# sourceMappingURL=chunk-AXFW5UEN.js.map
