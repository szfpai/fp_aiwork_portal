{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/markdown-it-mark@4.0.0/node_modules/markdown-it-mark/index.mjs"],
  "sourcesContent": ["export default function ins_plugin (md) {\n  // Insert each marker as a separate text token, and add it to delimiter list\n  //\n  function tokenize (state, silent) {\n    const start = state.pos\n    const marker = state.src.charCodeAt(start)\n\n    if (silent) { return false }\n\n    if (marker !== 0x3D/* = */) { return false }\n\n    const scanned = state.scanDelims(state.pos, true)\n    let len = scanned.length\n    const ch = String.fromCharCode(marker)\n\n    if (len < 2) { return false }\n\n    if (len % 2) {\n      const token = state.push('text', '', 0)\n      token.content = ch\n      len--\n    }\n\n    for (let i = 0; i < len; i += 2) {\n      const token = state.push('text', '', 0)\n      token.content = ch + ch\n\n      if (!scanned.can_open && !scanned.can_close) { continue }\n\n      state.delimiters.push({\n        marker,\n        length: 0,     // disable \"rule of 3\" length checks meant for emphasis\n        jump: i / 2, // 1 delimiter = 2 characters\n        token: state.tokens.length - 1,\n        end: -1,\n        open: scanned.can_open,\n        close: scanned.can_close\n      })\n    }\n\n    state.pos += scanned.length\n\n    return true\n  }\n\n  // Walk through delimiter list and replace text tokens with tags\n  //\n  function postProcess (state, delimiters) {\n    const loneMarkers = []\n    const max = delimiters.length\n\n    for (let i = 0; i < max; i++) {\n      const startDelim = delimiters[i]\n\n      if (startDelim.marker !== 0x3D/* = */) {\n        continue\n      }\n\n      if (startDelim.end === -1) {\n        continue\n      }\n\n      const endDelim = delimiters[startDelim.end]\n\n      const token_o = state.tokens[startDelim.token]\n      token_o.type = 'mark_open'\n      token_o.tag = 'mark'\n      token_o.nesting = 1\n      token_o.markup = '=='\n      token_o.content = ''\n\n      const token_c = state.tokens[endDelim.token]\n      token_c.type = 'mark_close'\n      token_c.tag = 'mark'\n      token_c.nesting = -1\n      token_c.markup = '=='\n      token_c.content = ''\n\n      if (state.tokens[endDelim.token - 1].type === 'text' &&\n          state.tokens[endDelim.token - 1].content === '=') {\n        loneMarkers.push(endDelim.token - 1)\n      }\n    }\n\n    // If a marker sequence has an odd number of characters, it's splitted\n    // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n    // start of the sequence.\n    //\n    // So, we have to move all those markers after subsequent s_close tags.\n    //\n    while (loneMarkers.length) {\n      const i = loneMarkers.pop()\n      let j = i + 1\n\n      while (j < state.tokens.length && state.tokens[j].type === 'mark_close') {\n        j++\n      }\n\n      j--\n\n      if (i !== j) {\n        const token = state.tokens[j]\n        state.tokens[j] = state.tokens[i]\n        state.tokens[i] = token\n      }\n    }\n  }\n\n  md.inline.ruler.before('emphasis', 'mark', tokenize)\n  md.inline.ruler2.before('emphasis', 'mark', function (state) {\n    let curr\n    const tokens_meta = state.tokens_meta\n    const max = (state.tokens_meta || []).length\n\n    postProcess(state, state.delimiters)\n\n    for (curr = 0; curr < max; curr++) {\n      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n        postProcess(state, tokens_meta[curr].delimiters)\n      }\n    }\n  })\n};\n"],
  "mappings": "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",
  "names": []
}
