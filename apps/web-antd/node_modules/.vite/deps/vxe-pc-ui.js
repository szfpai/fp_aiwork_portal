import {
  RadioGroup,
  VxeRadioGroup,
  button_default as button_default3,
  group_default,
  radio_default,
  radio_group_default
} from "./chunk-2IIE7WF4.js";
import {
  Select,
  VxeSelect,
  select_default as select_default2
} from "./chunk-NE5QRRZE.js";
import {
  Tooltip,
  VxeTooltip,
  tooltip_default as tooltip_default2
} from "./chunk-AWZCZ3SP.js";
import {
  Upload,
  VxeUpload,
  readLocalFile,
  saveLocalFile,
  upload_default,
  upload_default2
} from "./chunk-UMKZBCOZ.js";
import {
  Button,
  VxeButton,
  button_default as button_default2
} from "./chunk-KRLQ6QVQ.js";
import {
  Checkbox,
  VxeCheckbox,
  checkbox_default,
  checkbox_default2
} from "./chunk-2PZFHU7R.js";
import {
  Icon,
  VxeIcon,
  icon_default,
  icon_default2
} from "./chunk-SBNY5AIY.js";
import {
  Input,
  VxeInput,
  input_default as input_default2
} from "./chunk-GG6IQIIN.js";
import {
  Modal,
  ModalController,
  VxeModal,
  modal_default,
  modal_default2
} from "./chunk-EN3J2IAW.js";
import {
  button_default
} from "./chunk-PM5GFKYL.js";
import {
  tooltip_default
} from "./chunk-LTYBMX5R.js";
import {
  Loading,
  LoadingController,
  VxeLoading,
  loading_default,
  loading_default2
} from "./chunk-WYUFE5VA.js";
import {
  NumberInput,
  VxeNumberInput,
  number_input_default,
  number_input_default2
} from "./chunk-OBO37DFC.js";
import {
  Pager,
  VxePager,
  pager_default
} from "./chunk-MWLGBB6H.js";
import {
  select_default
} from "./chunk-ZBBUWXBO.js";
import {
  getDateQuarter,
  input_default,
  toStringTimeDate
} from "./chunk-FCLEUY2B.js";
import "./chunk-BJAA2TNS.js";
import {
  addClass,
  getAbsolutePos,
  getDomNode,
  getEventTargetNode,
  getOffsetPos,
  hasControlKey,
  isScale,
  removeClass,
  scrollToView,
  toCssUnit
} from "./chunk-CXJ2DZ5N.js";
import {
  eqEmptyValue,
  getFuncText,
  getGlobalDefaultConfig,
  getLastZIndex,
  isEnableConf,
  nextZIndex
} from "./chunk-JYUMM3AF.js";
import {
  getChangeEvent,
  getModelEvent,
  getOnName,
  getSlotVNs
} from "./chunk-5CFWPPS7.js";
import {
  checkDynamic,
  config,
  dynamicApp,
  dynamicStore,
  errLog,
  setup,
  version,
  warnLog
} from "./chunk-KBOOGFHS.js";
import {
  GLOBAL_EVENT_KEYS,
  VxeCore,
  VxeUI,
  clipboard,
  commands,
  component,
  coreVersion,
  createEvent,
  formats,
  getComponent,
  getConfig,
  getI18n,
  getIcon,
  getLanguage,
  getTheme,
  globalEvents,
  globalResize,
  globalStore,
  handleCheckInfo,
  hasLanguage,
  hooks,
  interceptor,
  log,
  menus,
  permission,
  renderEmptyElement,
  renderer,
  require_xe_utils,
  setConfig,
  setI18n,
  setIcon,
  setLanguage,
  setTheme,
  use,
  useFns,
  usePermission,
  useSize,
  validators
} from "./chunk-HLJGUNZZ.js";
import "./chunk-TUFRKHWE.js";
import {
  Teleport,
  TransitionGroup,
  computed,
  createCommentVNode,
  defineComponent,
  h,
  inject,
  nextTick,
  onActivated,
  onBeforeUnmount,
  onMounted,
  onUnmounted,
  provide,
  reactive,
  ref,
  resolveComponent,
  watch
} from "./chunk-RWBQDMGA.js";
import "./chunk-R3UZ5GKO.js";
import {
  __export,
  __toESM
} from "./chunk-DBU5TJLK.js";

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/components.js
var components_exports = {};
__export(components_exports, {
  Alert: () => Alert,
  Anchor: () => Anchor,
  AnchorLink: () => AnchorLink,
  Avatar: () => Avatar,
  Badge: () => Badge,
  Breadcrumb: () => Breadcrumb,
  BreadcrumbItem: () => BreadcrumbItem,
  Button: () => Button,
  ButtonGroup: () => ButtonGroup,
  Calendar: () => Calendar,
  Card: () => Card,
  Carousel: () => Carousel,
  CarouselItem: () => CarouselItem,
  Checkbox: () => Checkbox,
  CheckboxGroup: () => CheckboxGroup,
  Col: () => Col,
  Collapse: () => Collapse,
  CollapsePane: () => CollapsePane,
  ColorPicker: () => ColorPicker,
  Countdown: () => Countdown,
  DatePicker: () => DatePicker,
  Drawer: () => Drawer,
  DrawerController: () => DrawerController,
  Empty: () => Empty,
  Form: () => Form,
  FormDesign: () => FormDesign,
  FormGather: () => FormGather,
  FormGroup: () => FormGroup,
  FormItem: () => FormItem,
  FormView: () => FormView,
  GLOBAL_EVENT_KEYS: () => GLOBAL_EVENT_KEYS,
  Icon: () => Icon,
  IconPicker: () => IconPicker,
  Image: () => Image,
  ImageGroup: () => ImageGroup,
  ImagePreview: () => ImagePreview,
  Input: () => Input,
  LayoutAside: () => LayoutAside,
  LayoutBody: () => LayoutBody,
  LayoutContainer: () => LayoutContainer,
  LayoutFooter: () => LayoutFooter,
  LayoutHeader: () => LayoutHeader,
  Link: () => Link,
  List: () => List,
  ListDesign: () => ListDesign,
  ListView: () => ListView,
  Loading: () => Loading,
  LoadingController: () => LoadingController,
  Menu: () => Menu,
  Modal: () => Modal,
  ModalController: () => ModalController,
  NoticeBar: () => NoticeBar,
  NumberInput: () => NumberInput,
  Optgroup: () => Optgroup,
  Option: () => Option,
  Pager: () => Pager,
  PasswordInput: () => PasswordInput,
  Print: () => Print,
  PrintPageBreak: () => PrintPageBreak,
  Pulldown: () => Pulldown,
  Radio: () => Radio,
  RadioButton: () => RadioButton,
  RadioGroup: () => RadioGroup,
  Rate: () => Rate,
  Result: () => Result,
  Row: () => Row,
  Select: () => Select,
  Slider: () => Slider,
  Split: () => Split,
  SplitPane: () => SplitPane,
  Steps: () => Steps,
  Switch: () => Switch,
  TabPane: () => TabPane,
  TableSelect: () => TableSelect,
  Tabs: () => Tabs,
  Tag: () => Tag,
  Text: () => Text,
  TextEllipsis: () => TextEllipsis,
  Textarea: () => Textarea,
  Tip: () => Tip,
  Tips: () => Tips,
  Tooltip: () => Tooltip,
  Tree: () => Tree,
  TreeSelect: () => TreeSelect,
  Upload: () => Upload,
  VxeAlert: () => VxeAlert,
  VxeAnchor: () => VxeAnchor,
  VxeAnchorLink: () => VxeAnchorLink,
  VxeAvatar: () => VxeAvatar,
  VxeBadge: () => VxeBadge,
  VxeBreadcrumb: () => VxeBreadcrumb,
  VxeBreadcrumbItem: () => VxeBreadcrumbItem,
  VxeButton: () => VxeButton,
  VxeButtonGroup: () => VxeButtonGroup,
  VxeCalendar: () => VxeCalendar,
  VxeCard: () => VxeCard,
  VxeCarousel: () => VxeCarousel,
  VxeCarouselItem: () => VxeCarouselItem,
  VxeCheckbox: () => VxeCheckbox,
  VxeCheckboxGroup: () => VxeCheckboxGroup,
  VxeCol: () => VxeCol,
  VxeCollapse: () => VxeCollapse,
  VxeCollapsePane: () => VxeCollapsePane,
  VxeColorPicker: () => VxeColorPicker,
  VxeCore: () => VxeCore,
  VxeCountdown: () => VxeCountdown,
  VxeDatePicker: () => VxeDatePicker,
  VxeDrawer: () => VxeDrawer,
  VxeEmpty: () => VxeEmpty,
  VxeForm: () => VxeForm,
  VxeFormDesign: () => VxeFormDesign,
  VxeFormGather: () => VxeFormGather,
  VxeFormGroup: () => VxeFormGroup,
  VxeFormItem: () => VxeFormItem,
  VxeFormView: () => VxeFormView,
  VxeIcon: () => VxeIcon,
  VxeIconPicker: () => VxeIconPicker,
  VxeImage: () => VxeImage,
  VxeImageGroup: () => VxeImageGroup,
  VxeImagePreview: () => VxeImagePreview,
  VxeInput: () => VxeInput,
  VxeLayoutAside: () => VxeLayoutAside,
  VxeLayoutBody: () => VxeLayoutBody,
  VxeLayoutContainer: () => VxeLayoutContainer,
  VxeLayoutFooter: () => VxeLayoutFooter,
  VxeLayoutHeader: () => VxeLayoutHeader,
  VxeLink: () => VxeLink,
  VxeList: () => VxeList,
  VxeListDesign: () => VxeListDesign,
  VxeListView: () => VxeListView,
  VxeLoading: () => VxeLoading,
  VxeMenu: () => VxeMenu,
  VxeModal: () => VxeModal,
  VxeNoticeBar: () => VxeNoticeBar,
  VxeNumberInput: () => VxeNumberInput,
  VxeOptgroup: () => VxeOptgroup,
  VxeOption: () => VxeOption,
  VxePager: () => VxePager,
  VxePasswordInput: () => VxePasswordInput,
  VxePrint: () => VxePrint,
  VxePrintPageBreak: () => VxePrintPageBreak,
  VxePulldown: () => VxePulldown,
  VxeRadio: () => VxeRadio,
  VxeRadioButton: () => VxeRadioButton,
  VxeRadioGroup: () => VxeRadioGroup,
  VxeRate: () => VxeRate,
  VxeResult: () => VxeResult,
  VxeRow: () => VxeRow,
  VxeSelect: () => VxeSelect,
  VxeSlider: () => VxeSlider,
  VxeSplit: () => VxeSplit,
  VxeSplitPane: () => VxeSplitPane,
  VxeSteps: () => VxeSteps,
  VxeSwitch: () => VxeSwitch,
  VxeTabPane: () => VxeTabPane,
  VxeTableSelect: () => VxeTableSelect,
  VxeTabs: () => VxeTabs,
  VxeTag: () => VxeTag,
  VxeText: () => VxeText,
  VxeTextEllipsis: () => VxeTextEllipsis,
  VxeTextarea: () => VxeTextarea,
  VxeTip: () => VxeTip,
  VxeTooltip: () => VxeTooltip,
  VxeTree: () => VxeTree,
  VxeTreeSelect: () => VxeTreeSelect,
  VxeUI: () => VxeUI,
  VxeUpload: () => VxeUpload,
  VxeWatermark: () => VxeWatermark,
  Watermark: () => Watermark,
  WatermarkController: () => WatermarkController,
  clipboard: () => clipboard,
  commands: () => commands,
  component: () => component,
  config: () => config,
  coreVersion: () => coreVersion,
  createEvent: () => createEvent,
  drawer: () => drawer,
  formats: () => formats,
  getComponent: () => getComponent,
  getConfig: () => getConfig,
  getI18n: () => getI18n,
  getIcon: () => getIcon,
  getLanguage: () => getLanguage,
  getTheme: () => getTheme,
  globalEvents: () => globalEvents,
  globalResize: () => globalResize,
  globalStore: () => globalStore,
  handleCheckInfo: () => handleCheckInfo,
  hasLanguage: () => hasLanguage,
  hooks: () => hooks,
  install: () => install,
  interceptor: () => interceptor,
  loading: () => loading,
  log: () => log,
  menus: () => menus,
  modal: () => modal,
  permission: () => permission,
  print: () => print,
  readFile: () => readFile,
  renderEmptyElement: () => renderEmptyElement,
  renderer: () => renderer,
  saveFile: () => saveFile,
  setConfig: () => setConfig,
  setI18n: () => setI18n,
  setIcon: () => setIcon,
  setLanguage: () => setLanguage,
  setTheme: () => setTheme,
  setup: () => setup,
  use: () => use,
  useFns: () => useFns,
  usePermission: () => usePermission,
  useSize: () => useSize,
  validators: () => validators,
  version: () => version,
  watermark: () => watermark
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/language/zh-CN.js
var zh_CN_default = {
  vxe: {
    base: {
      pleaseInput: "请输入",
      pleaseSelect: "请选择",
      comma: "，",
      fullStop: "。"
    },
    loading: {
      text: "加载中..."
    },
    error: {
      downErr: "下载失败",
      errLargeData: "当绑定的数据量过大时，应该请使用 {0}，否则可能会出现卡顿",
      groupFixed: "如果使用分组表头，冻结列必须按组设置",
      groupMouseRange: '分组表头与 "{0}" 不能同时使用，这可能会出现错误',
      groupTag: '分组列头应该使用 "{0}" 而不是 "{1}"，这可能会出现错误',
      scrollErrProp: '启用虚拟滚动后不支持该参数 "{0}"',
      errConflicts: '参数 "{0}" 与 "{1}" 有冲突',
      notSupportProp: '当启用参数 "{0}" 时不支持 "{1}"，应该为 "{2}"，否则将会出现错误',
      notConflictProp: '当使用 "{0}" 时，应该设置 "{1}"，否则可能会存在功能冲突',
      unableInsert: "无法插入到指定位置，请检查参数是否正确",
      useErr: '安装 "{0}" 模块时发生错误，可能顺序不正确，依赖的模块需要在 Table 之前安装',
      barUnableLink: "工具栏无法关联表格",
      expandContent: '展开行的插槽应该是 "content"，请检查是否正确',
      reqComp: '缺少 "{0}" 组件，请检查是否正确安装。 https://vxeui.com/#/start/useGlobal',
      reqModule: '缺少 "{0}" 模块',
      reqProp: '缺少必要的 "{0}" 参数，这可能会导致出现错误',
      emptyProp: '参数 "{0}" 不允许为空',
      errProp: '不支持的参数 "{0}"，可能为 "{1}"',
      colRepet: 'column.{0}="{1}" 重复了，这可能会导致某些功能无法使用',
      notFunc: '方法 "{0}" 不存在',
      errFunc: '参数 "{0}" 不是一个方法',
      notValidators: '全局校验 "{0}" 不存在',
      notFormats: '全局格式化 "{0}" 不存在',
      notCommands: '全局指令 "{0}" 不存在',
      notSlot: '插槽 "{0}" 不存在',
      noTree: '树结构不支持 "{0}"',
      notProp: '不支持的参数 "{0}"',
      checkProp: '当数据量过大时可能会导致复选框卡顿，建议设置参数 "{0}" 提升渲染速度',
      coverProp: '"{0}" 的参数 "{1}" 重复定义，这可能会出现错误',
      uniField: '字段名 "{0}" 重复定义，这可能会出现错误',
      repeatKey: '主键重复 {0}="{1}"，这可能会出现错误',
      delFunc: '方法 "{0}" 已废弃，请使用 "{1}"',
      delProp: '参数 "{0}" 已废弃，请使用 "{1}"',
      delEvent: '事件 "{0}" 已废弃，请使用 "{1}"',
      removeProp: '参数 "{0}" 已废弃，不建议使用，这可能会导致出现错误',
      errFormat: '全局的格式化内容应该使用 "VXETable.formats" 定义，挂载 "formatter={0}" 的方式已不建议使用',
      notType: '不支持的文件类型 "{0}"',
      notExp: "该浏览器不支持导入/导出功能",
      impFields: "导入失败，请检查字段名和数据格式是否正确",
      treeNotImp: "树表格不支持导入",
      treeCrossDrag: "只能拖拽第一层级",
      treeDragChild: "父级不能拖拽到自己的子级中",
      reqPlugin: '扩展插件未安装 "{1}" https://vxeui.com/other{0}/#/{1}/install',
      errMaxRow: "超过支持的最大数据量 {0} 行，这可能会导致出现错误"
    },
    table: {
      emptyText: "暂无数据",
      allTitle: "全选/取消",
      seqTitle: "序号",
      actionTitle: "操作",
      confirmFilter: "筛选",
      resetFilter: "重置",
      allFilter: "全部",
      sortAsc: "升序：最低到最高",
      sortDesc: "降序：最高到最低",
      filter: "对所选的列启用筛选",
      impSuccess: "成功导入 {0} 条记录",
      expLoading: "正在导出中",
      expSuccess: "导出成功",
      expError: "导出失败",
      expFilename: "导出_{0}",
      expOriginFilename: "导出_源_{0}",
      customTitle: "列设置",
      customAll: "全部",
      customConfirm: "确认",
      customClose: "关闭",
      customCancel: "取消",
      customRestore: "恢复默认",
      maxFixedCol: "最大冻结列的数量不能超过 {0} 个",
      dragTip: "移动：{0}",
      resizeColTip: "宽：{0} 像素",
      resizeRowTip: "高：{0} 像素",
      rowGroupContentTotal: "{0}（{1}）"
    },
    grid: {
      selectOneRecord: "请至少选择一条记录！",
      deleteSelectRecord: "您确定要删除所选记录吗？",
      removeSelectRecord: "您确定要移除所选记录吗？",
      dataUnchanged: "数据未改动！",
      delSuccess: "成功删除所选记录！",
      saveSuccess: "保存成功！",
      operError: "发生错误，操作失败！"
    },
    select: {
      search: "搜索",
      loadingText: "加载中",
      emptyText: "暂无数据"
    },
    pager: {
      goto: "前往",
      gotoTitle: "页数",
      pagesize: "{0}条/页",
      total: "共 {0} 条记录",
      pageClassifier: "页",
      homePage: "首页",
      homePageTitle: "首页",
      prevPage: "上一页",
      prevPageTitle: "上一页",
      nextPage: "下一页",
      nextPageTitle: "下一页",
      prevJump: "向上跳页",
      prevJumpTitle: "向上跳页",
      nextJump: "向下跳页",
      nextJumpTitle: "向下跳页",
      endPage: "末页",
      endPageTitle: "末页"
    },
    alert: {
      title: "系统提示"
    },
    button: {
      confirm: "确认",
      cancel: "取消",
      clear: "清除"
    },
    filter: {
      search: "搜索"
    },
    custom: {
      cstmTitle: "列设置",
      cstmRestore: "恢复默认",
      cstmCancel: "取消",
      cstmConfirm: "确定",
      cstmConfirmRestore: "请确认是否恢复成默认列配置？",
      cstmDragTarget: "移动：{0}",
      setting: {
        colSort: "排序",
        sortHelpTip: "点击并拖动图标可以调整列的排序",
        colTitle: "列标题",
        colResizable: "列宽（像素）",
        colVisible: "是否显示",
        colFixed: "冻结列",
        colFixedMax: "冻结列（最多 {0} 列）",
        fixedLeft: "左侧",
        fixedUnset: "不设置",
        fixedRight: "右侧"
      }
    },
    import: {
      modes: {
        covering: "覆盖方式（直接覆盖表格数据）",
        insert: "底部追加（在表格的底部追加新数据）",
        insertTop: "顶部追加（在表格的顶部追加新数据）",
        insertBottom: "底部追加（在表格的底部追加新数据）"
      },
      impTitle: "导入数据",
      impFile: "文件名",
      impSelect: "选择文件",
      impType: "文件类型",
      impOpts: "参数设置",
      impMode: "导入模式",
      impConfirm: "导入",
      impCancel: "取消"
    },
    export: {
      types: {
        csv: "CSV (逗号分隔)(*.csv)",
        html: "网页(*.html)",
        xml: "XML 数据(*.xml)",
        txt: "文本文件(制表符分隔)(*.txt)",
        xls: "Excel 97-2003 工作簿(*.xls)",
        xlsx: "Excel 工作簿(*.xlsx)",
        pdf: "PDF (*.pdf)"
      },
      modes: {
        empty: "空数据",
        current: "当前数据（当前页的数据）",
        selected: "选中数据（当前页选中的数据）",
        all: "全量数据（包括所有分页的数据）"
      },
      printTitle: "打印数据",
      expTitle: "导出数据",
      expName: "文件名",
      expNamePlaceholder: "请输入文件名",
      expSheetName: "标题",
      expSheetNamePlaceholder: "请输入标题",
      expType: "保存类型",
      expMode: "选择数据",
      expCurrentColumn: "全部字段",
      expColumn: "选择字段",
      expOpts: "参数设置",
      expOptHeader: "表头",
      expHeaderTitle: "是否需要表头",
      expOptFooter: "表尾",
      expFooterTitle: "是否需要表尾",
      expOptColgroup: "分组表头",
      expOptTitle: "列标题",
      expTitleTitle: "是否为列标题，否则显示为列的字段名",
      expColgroupTitle: "如果存在，则支持带有分组结构的表头",
      expOptMerge: "合并",
      expMergeTitle: "如果存在，则支持带有合并结构的单元格",
      expOptAllExpand: "展开树",
      expAllExpandTitle: "如果存在，则支持将带有层级结构的数据全部展开",
      expOptUseStyle: "样式",
      expUseStyleTitle: "如果存在，则支持带样式的单元格",
      expOptOriginal: "源数据",
      expOriginalTitle: "如果为源数据，则支持导入到表格中",
      expPrint: "打印",
      expConfirm: "导出",
      expCancel: "取消"
    },
    modal: {
      errTitle: "错误提示",
      zoomMin: "最小化",
      zoomIn: "最大化",
      zoomOut: "还原",
      close: "关闭",
      miniMaxSize: "最小化窗口的数量不能超过 {0} 个",
      footPropErr: "show-footer 仅用于启用表尾，需配合 show-confirm-button | show-cancel-button | 插槽使用"
    },
    drawer: {
      close: "关闭"
    },
    form: {
      folding: "收起",
      unfolding: "展开"
    },
    toolbar: {
      import: "导入",
      export: "导出",
      print: "打印",
      refresh: "刷新",
      zoomIn: "全屏",
      zoomOut: "还原",
      custom: "列设置",
      customAll: "全部",
      customConfirm: "确认",
      customRestore: "重置",
      fixedLeft: "冻结在左侧",
      fixedRight: "冻结在右侧",
      cancelFixed: "取消冻结列"
    },
    datePicker: {
      yearTitle: "{0} 年"
    },
    input: {
      date: {
        m1: "01 月",
        m2: "02 月",
        m3: "03 月",
        m4: "04 月",
        m5: "05 月",
        m6: "06 月",
        m7: "07 月",
        m8: "08 月",
        m9: "09 月",
        m10: "10 月",
        m11: "11 月",
        m12: "12 月",
        quarterLabel: "{0} 年",
        monthLabel: "{0} 年",
        dayLabel: "{0} 年 {1}",
        labelFormat: {
          date: "yyyy-MM-dd",
          time: "HH:mm:ss",
          datetime: "yyyy-MM-dd HH:mm:ss",
          week: "yyyy 年第 WW 周",
          month: "yyyy-MM",
          quarter: "yyyy 年第 q 季度",
          year: "yyyy"
        },
        weeks: {
          w: "周",
          w0: "周日",
          w1: "周一",
          w2: "周二",
          w3: "周三",
          w4: "周四",
          w5: "周五",
          w6: "周六"
        },
        months: {
          m0: "一月",
          m1: "二月",
          m2: "三月",
          m3: "四月",
          m4: "五月",
          m5: "六月",
          m6: "七月",
          m7: "八月",
          m8: "九月",
          m9: "十月",
          m10: "十一月",
          m11: "十二月"
        },
        quarters: {
          q1: "第一季度",
          q2: "第二季度",
          q3: "第三季度",
          q4: "第四季度"
        }
      }
    },
    numberInput: {
      currencySymbol: "¥"
    },
    imagePreview: {
      popupTitle: "预览",
      operBtn: {
        zoomOut: "缩小",
        zoomIn: "放大",
        pctFull: "等比例缩放",
        pct11: "显示原始尺寸",
        rotateLeft: "向左旋转",
        rotateRight: "向右旋转",
        print: "点击打印图片",
        download: "点击下载图片"
      }
    },
    upload: {
      fileBtnText: "点击或拖拽上传",
      imgBtnText: "点击或拖拽上传",
      dragPlaceholder: "请把文件拖放到这个区域即可上传",
      imgSizeHint: "单张{0}",
      imgCountHint: "最多{0}张",
      fileTypeHint: "支持 {0} 文件类型",
      fileSizeHint: "单个文件大小不超过{0}",
      fileCountHint: "最多可上传{0}个文件",
      uploadTypeErr: "文件类型不匹配！",
      overCountErr: "最多只能选择{0}个文件！",
      overCountExtraErr: "已超出最大数量{0}个，超出的{1}个文件将被忽略！",
      overSizeErr: "文件大小最大不能超过{0}！",
      reUpload: "重新上传",
      uploadProgress: "上传中 {0}%",
      uploadErr: "上传失败",
      uploadSuccess: "上传成功",
      moreBtnText: "更多（{0}）",
      viewItemTitle: "点击查看",
      morePopup: {
        readTitle: "查看列表",
        imageTitle: "上传图片",
        fileTitle: "上传文件"
      }
    },
    empty: {
      defText: "暂无数据"
    },
    colorPicker: {
      clear: "清除",
      confirm: "确认",
      copySuccess: "已复制到剪贴板：{0}"
    },
    formDesign: {
      formName: "表单名称",
      defFormTitle: "未命名的表单",
      widgetPropTab: "控件属性",
      widgetFormTab: "表单属性",
      error: {
        wdFormUni: "该类型的控件在表单中只允许添加一个",
        wdSubUni: "该类型的控件在子表中只允许添加一个"
      },
      styleSetting: {
        btn: "样式设置",
        title: "表单的样式设置",
        layoutTitle: "控件布局",
        verticalLayout: "上下布局",
        horizontalLayout: "横向布局",
        styleTitle: "标题样式",
        boldTitle: "标题加粗",
        fontBold: "加粗",
        fontNormal: "常规",
        colonTitle: "显示冒号",
        colonVisible: "显示",
        colonHidden: "隐藏",
        alignTitle: "对齐方式",
        widthTitle: "标题宽度",
        alignLeft: "居左",
        alignRight: "居右",
        unitPx: "像素",
        unitPct: "百分比"
      },
      widget: {
        group: {
          base: "基础控件",
          layout: "布局控件",
          system: "系统控件",
          module: "模块控件",
          chart: "图表控件",
          advanced: "高级控件"
        },
        copyTitle: "副本_{0}",
        component: {
          input: "输入框",
          textarea: "文本域",
          select: "下拉选择",
          row: "一行多列",
          title: "标题",
          text: "文本",
          subtable: "子表",
          VxeSwitch: "是/否",
          VxeInput: "输入框",
          VxeNumberInput: "数字",
          VxeDatePicker: "日期",
          VxeTextarea: "文本域",
          VxeSelect: "下拉选择",
          VxeTreeSelect: "树形选择",
          VxeRadioGroup: "单选框",
          VxeCheckboxGroup: "复选框",
          VxeUploadFile: "文件",
          VxeUploadImage: "图片",
          VxeRate: "评分",
          VxeSlider: "滑块"
        }
      },
      widgetProp: {
        name: "控件名称",
        placeholder: "提示语",
        required: "必填校验",
        multiple: "允许多选",
        displaySetting: {
          name: "显示设置",
          pc: "电脑端",
          mobile: "手机端",
          visible: "显示",
          hidden: "隐藏"
        },
        dataSource: {
          name: "数据源",
          defValue: "选项{0}",
          addOption: "添加选项",
          batchEditOption: "批量编辑",
          batchEditTip: "每行对应一个选项，支持从表格、Excel、WPS 中直接复制粘贴。",
          batchEditSubTip: "每行对应一个选项，如果是分组，子项可以是空格或制表键开头，支持从表格、Excel、WPS 中直接复制粘贴。",
          buildOption: "生成选项"
        },
        rowProp: {
          colSize: "列数",
          col2: "两列",
          col3: "三列",
          col4: "四列",
          col6: "六列",
          layout: "布局"
        },
        textProp: {
          name: "内容",
          alignTitle: "对齐方式",
          alignLeft: "居左",
          alignCenter: "居中",
          alignRight: "居右",
          colorTitle: "字体颜色",
          sizeTitle: "字体大小",
          boldTitle: "字体加粗",
          fontNormal: "常规",
          fontBold: "加粗"
        },
        subtableProp: {
          seqTitle: "序号",
          showSeq: "显示序号",
          showCheckbox: "允许多选",
          errSubDrag: "子表不支持该控件，请使用其他控件",
          colPlace: "将控件拖拽进来"
        },
        uploadProp: {
          limitFileCount: "文件数量限制",
          limitFileSize: "文件大小限制",
          multiFile: "允许上传多个文件",
          limitImgCount: "图片数量限制",
          limitImgSize: "图片大小限制",
          multiImg: "允许上传多张图片"
        }
      }
    },
    listDesign: {
      fieldSettingTab: "字段设置",
      listSettingTab: "参数设置",
      searchTitle: "查询条件",
      listTitle: "列表字段",
      searchField: "查询字段",
      listField: "列表字段",
      activeBtn: {
        ActionButtonUpdate: "编辑",
        ActionButtonDelete: "删除"
      },
      search: {
        addBtn: "编辑",
        emptyText: "未配置查询条件",
        editPopupTitle: "编辑查询字段"
      },
      searchPopup: {
        colTitle: "标题",
        saveBtn: "保存"
      }
    },
    text: {
      copySuccess: "已复制到剪贴板",
      copyError: "当前环境不支持该操作"
    },
    countdown: {
      formats: {
        yyyy: "年",
        MM: "月",
        dd: "天",
        HH: "时",
        mm: "分",
        ss: "秒"
      }
    },
    plugins: {
      extendCellArea: {
        area: {
          mergeErr: "无法对合并单元格进行该操作",
          multiErr: "无法对多重选择区域进行该操作",
          selectErr: "无法操作指定区域的单元格",
          extendErr: "如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同",
          pasteMultiErr: "无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作",
          cpInvalidErr: "该操作无法进行，您选择的区域中存在被禁止的列（{0}）"
        },
        fnr: {
          title: "查找和替换",
          findLabel: "查找",
          replaceLabel: "替换",
          findTitle: "查找内容：",
          replaceTitle: "替换为：",
          tabs: {
            find: "查找",
            replace: "替换"
          },
          filter: {
            re: "正则表达式",
            whole: "全词匹配",
            sensitive: "区分大小写"
          },
          btns: {
            findNext: "查找下一个",
            findAll: "查找全部",
            replace: "替换",
            replaceAll: "替换全部",
            cancel: "取消"
          },
          header: {
            seq: "#",
            cell: "单元格",
            value: "值"
          },
          body: {
            row: "行：{0}",
            col: "列：{0}"
          },
          empty: "(空值)",
          reError: "无效的正则表达式",
          recordCount: "已找到 {0} 个单元格",
          notCell: "找不到匹配的单元格",
          replaceSuccess: "成功替换 {0} 个单元格"
        }
      },
      filterComplexInput: {
        menus: {
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结左侧",
          fixedRight: "冻结右侧"
        },
        cases: {
          equal: "等于",
          gt: "大于",
          lt: "小于",
          begin: "开头是",
          endin: "结尾是",
          include: "包含",
          isSensitive: "区分大小写"
        }
      },
      filterCombination: {
        menus: {
          sort: "排序",
          clearSort: "清除排序",
          sortAsc: "升序",
          sortDesc: "降序",
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结左侧",
          fixedRight: "冻结右侧",
          clearFilter: "清除筛选",
          textOption: "文本筛选",
          numberOption: "数值筛选"
        },
        popup: {
          title: "自定义筛选的方式",
          currColumnTitle: "当前列：",
          and: "与",
          or: "或",
          describeHtml: "可用 ? 代表单个字符<br/>用 * 代表任意多个字符"
        },
        cases: {
          equal: "等于",
          unequal: "不等于",
          gt: "大于",
          ge: "大于或等于",
          lt: "小于",
          le: "小于或等于",
          begin: "开头是",
          notbegin: "开头不是",
          endin: "结尾是",
          notendin: "结尾不是",
          include: "包含",
          exclude: "不包含",
          between: "介于",
          custom: "自定义筛选",
          insensitive: "不区分大小写",
          isSensitive: "区分大小写"
        },
        empty: "(空白)",
        notData: "无匹配项"
      }
    },
    pro: {
      area: {
        mergeErr: "无法对合并单元格进行该操作",
        multiErr: "无法对多重选择区域进行该操作",
        extendErr: "如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同",
        pasteMultiErr: "无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作"
      },
      fnr: {
        title: "查找和替换",
        findLabel: "查找",
        replaceLabel: "替换",
        findTitle: "查找内容：",
        replaceTitle: "替换为：",
        tabs: {
          find: "查找",
          replace: "替换"
        },
        filter: {
          re: "正则表达式",
          whole: "全词匹配",
          sensitive: "区分大小写"
        },
        btns: {
          findNext: "查找下一个",
          findAll: "查找全部",
          replace: "替换",
          replaceAll: "替换全部",
          cancel: "取消"
        },
        header: {
          seq: "#",
          cell: "单元格",
          value: "值"
        },
        empty: "(空值)",
        reError: "无效的正则表达式",
        recordCount: "已找到 {0} 个单元格",
        notCell: "找不到匹配的单元格",
        replaceSuccess: "成功替换 {0} 个单元格"
      }
    },
    renderer: {
      search: "搜索",
      cases: {
        equal: "等于",
        unequal: "不等于",
        gt: "大于",
        ge: "大于或等于",
        lt: "小于",
        le: "小于或等于",
        begin: "开头是",
        notbegin: "开头不是",
        endin: "结尾是",
        notendin: "结尾不是",
        include: "包含",
        exclude: "不包含",
        between: "介于",
        custom: "自定义筛选",
        insensitive: "不区分大小写",
        isSensitive: "区分大小写"
      },
      combination: {
        menus: {
          sort: "排序",
          clearSort: "清除排序",
          sortAsc: "升序",
          sortDesc: "降序",
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结到左侧",
          fixedRight: "冻结到右侧",
          clearFilter: "清除筛选",
          textOption: "文本筛选",
          numberOption: "数值筛选"
        },
        popup: {
          title: "自定义筛选的方式",
          currColumnTitle: "当前列：",
          and: "与",
          or: "或",
          describeHtml: "可用 ? 代表单个字符<br/>用 * 代表任意多个字符"
        },
        empty: "(空白)",
        notData: "无匹配项"
      }
    }
  }
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/alert/src/alert.js
var import_xe_utils = __toESM(require_xe_utils());
var alert_default = defineComponent({
  name: "VxeAlert",
  props: {
    title: {
      type: [String, Number],
      default: () => getConfig().alert.title
    },
    content: [String, Number],
    status: String,
    showIcon: Boolean,
    showClose: Boolean,
    icon: {
      type: String,
      default: () => getConfig().alert.icon
    }
  },
  emits: [
    "close"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeAlert = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const alertMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $alert: $xeAlert }, params));
      }
    };
    const closeEvent = (evnt) => {
      alertMethods.dispatchEvent("close", {}, evnt);
    };
    const alertPrivateMethods = {};
    Object.assign($xeAlert, alertMethods, alertPrivateMethods);
    const renderVN = () => {
      const { status, content, icon, title, showIcon, showClose } = props;
      const defaultSlot = slots.default;
      const titleSlot = slots.title;
      const iconSlot = slots.icon;
      return h("div", {
        ref: refElem,
        class: ["vxe-alert", {
          [`theme--${status}`]: status
        }]
      }, [
        iconSlot || showIcon && status || icon ? h("div", {
          class: "vxe-alert--icon"
        }, iconSlot ? getSlotVNs(iconSlot({})) : [
          h("i", {
            class: icon || getIcon()[`ALERT_${status === null || status === void 0 ? void 0 : status.toUpperCase()}`]
          })
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-alert--body"
        }, [
          titleSlot || title ? h("div", {
            class: "vxe-alert--title"
          }, titleSlot ? getSlotVNs(titleSlot({})) : import_xe_utils.default.toValueString(title)) : createCommentVNode(),
          h("div", {
            class: "vxe-alert--content"
          }, defaultSlot ? getSlotVNs(defaultSlot({})) : import_xe_utils.default.toValueString(content))
        ]),
        showClose ? h("div", {
          class: "vxe-alert--close-btn",
          onClick: closeEvent
        }, [
          h("i", {
            class: getIcon().ALERT_CLOSE
          })
        ]) : createCommentVNode()
      ]);
    };
    $xeAlert.renderVN = renderVN;
    return $xeAlert;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/alert/index.js
var VxeAlert = Object.assign({}, alert_default, {
  install(app) {
    app.component(alert_default.name, alert_default);
  }
});
dynamicApp.use(VxeAlert);
VxeUI.component(alert_default);
var Alert = VxeAlert;
var alert_default2 = VxeAlert;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/anchor/src/anchor.js
var import_xe_utils4 = __toESM(require_xe_utils());

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/anchor/src/anchor-link.js
var import_xe_utils3 = __toESM(require_xe_utils());

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/anchor/src/util.js
var import_xe_utils2 = __toESM(require_xe_utils());
function assembleAnchorLink($xeAnchor, elem, linkConfig, $xeParentAnchorLink) {
  const staticLinks = $xeAnchor.reactData.staticLinks;
  const parentElem = elem.parentNode;
  const parentLinkConfig = $xeParentAnchorLink ? $xeParentAnchorLink.linkConfig : null;
  const parentLinks = parentLinkConfig ? parentLinkConfig.children : staticLinks;
  if (parentElem && parentLinks) {
    parentLinks.splice(import_xe_utils2.default.arrayIndexOf(parentElem.children, elem), 0, linkConfig);
    $xeAnchor.reactData.staticLinks = staticLinks.slice(0);
  }
}
function destroyAnchorLink($xeAnchor, linkConfig) {
  const staticLinks = $xeAnchor.reactData.staticLinks;
  const matchObj = import_xe_utils2.default.findTree(staticLinks, (item) => item.id === linkConfig.id, { children: "children" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeAnchor.reactData.staticLinks = staticLinks.slice(0);
}

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/anchor/src/anchor-link.js
var anchor_link_default = defineComponent({
  name: "VxeAnchorLink",
  props: {
    content: [String, Number],
    title: [String, Number],
    href: String
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const $xeAnchor = inject("$xeAnchor", null);
    const $xeParentAnchorLink = inject("$xeAnchorLink", null);
    const xID = import_xe_utils3.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const linkConfig = reactive({
      id: xID,
      href: props.href,
      children: []
    });
    const refMaps = {
      refElem
    };
    const computeIsActive = computed(() => {
      const { href } = props;
      if ($xeAnchor) {
        return $xeAnchor.reactData.activeHref === href;
      }
      return null;
    });
    const computeMaps = {};
    const $xeAnchorLink = {
      xID,
      props,
      context,
      reactData,
      linkConfig,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const clickEvent = (event) => {
      const { href } = props;
      if ($xeAnchor) {
        $xeAnchor.handleClickLink(event, href);
      }
    };
    watch(() => props.href, (val) => {
      linkConfig.href = val;
    });
    onMounted(() => {
      const elem = refElem.value;
      if ($xeAnchor && elem) {
        assembleAnchorLink($xeAnchor, elem, linkConfig, $xeParentAnchorLink);
      }
    });
    onUnmounted(() => {
      if ($xeAnchor) {
        destroyAnchorLink($xeAnchor, linkConfig);
      }
    });
    const renderVN = () => {
      const { href, content, title } = props;
      const defaultSlot = slots.default;
      const subSlot = slots.sub;
      const isActive = computeIsActive.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-anchor-link", {
          "is--active": isActive
        }]
      }, [
        h("a", {
          class: "vxe-anchor-link--item",
          href,
          title,
          onClick: clickEvent
        }, defaultSlot ? defaultSlot({}) : import_xe_utils3.default.toValueString(content)),
        subSlot ? h("div", {
          class: "vxe-anchor-link--sub-items"
        }, subSlot({})) : createCommentVNode()
      ]);
    };
    provide("$xeAnchorLink", $xeAnchorLink);
    $xeAnchorLink.renderVN = renderVN;
    return $xeAnchorLink;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/anchor/src/anchor.js
var anchor_default = defineComponent({
  name: "VxeAnchor",
  props: {
    modelValue: String,
    options: Array,
    container: [String, Object, Function],
    showMarker: {
      type: Boolean,
      default: true
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils4.default.uniqueId();
    const refElem = ref();
    const refMarkerElem = ref();
    const reactData = reactive({
      activeHref: null,
      staticLinks: [],
      containerElem: null
    });
    const refMaps = {
      refElem
    };
    const computeAllHrefList = computed(() => {
      const list = [];
      import_xe_utils4.default.eachTree(reactData.staticLinks, (item) => {
        list.push(item.href || "");
      }, { children: "children" });
      return list;
    });
    const computeMaps = {};
    const $xeAnchor = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const anchorMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $anchor: $xeAnchor }, params));
      }
    };
    const getContainerElem = () => {
      const { container } = props;
      if (container) {
        if (import_xe_utils4.default.isElement(container)) {
          return container;
        }
        if (import_xe_utils4.default.isString(container)) {
          return document.querySelector(container);
        }
        if (import_xe_utils4.default.isFunction(container)) {
          return container({ $anchor: $xeAnchor });
        }
      }
      return null;
    };
    const emitEvent = (value) => {
      reactData.activeHref = value;
      emit("update:modelValue", value);
    };
    const handleContainerScrollEvent = () => {
      const allHrefList = computeAllHrefList.value;
      const { containerElem } = reactData;
      if (containerElem) {
        const wrapperElList = containerElem.querySelectorAll(allHrefList.map((href) => `${href}`).join(","));
        for (let i = 0; i < wrapperElList.length; i++) {
          const wrapperEl = wrapperElList[i];
          const wrapperRect = wrapperEl.getBoundingClientRect();
          if (wrapperRect.top > 0) {
            const href = wrapperEl.id;
            reactData.activeHref = `#${href}`;
            break;
          }
        }
      }
    };
    const removeContainerElemScroll = () => {
      const { containerElem } = reactData;
      if (containerElem) {
        containerElem.removeEventListener("scroll", handleContainerScrollEvent);
      }
    };
    const updateContainerElem = () => {
      const containerElem = getContainerElem();
      reactData.containerElem = containerElem;
      if (containerElem) {
        containerElem.addEventListener("scroll", handleContainerScrollEvent, {
          passive: false
        });
      }
    };
    const updateMarkerPos = () => {
      nextTick(() => {
        const { activeHref } = reactData;
        const elem = refElem.value;
        const markerEl = refMarkerElem.value;
        if (elem && markerEl) {
          if (activeHref) {
            const linkEl = elem.querySelector(`[href="${activeHref}"]`);
            if (linkEl) {
              const { top } = getOffsetPos(linkEl, elem);
              markerEl.style.top = `${top}px`;
            }
          }
        }
      });
    };
    const anchorPrivateMethods = {
      handleClickLink(evnt, href) {
        evnt.preventDefault();
        const targetEl = document.getElementById(`${href}`.replace("#", ""));
        if (targetEl) {
          targetEl.scrollIntoView({
            behavior: "smooth"
          });
        }
        emitEvent(href);
        anchorMethods.dispatchEvent("click", { href }, evnt);
      }
    };
    Object.assign($xeAnchor, anchorMethods, anchorPrivateMethods);
    const renderSubItems = (options) => {
      const itemVNs = [];
      if (options) {
        options.forEach((item) => {
          const subItems = item.children;
          if (subItems && subItems.length) {
            itemVNs.push(h(anchor_link_default, {
              content: item.content,
              title: item.title,
              href: item.href
            }, {
              sub: () => renderSubItems(subItems)
            }));
          } else {
            itemVNs.push(h(anchor_link_default, {
              content: item.content,
              title: item.title,
              href: item.href
            }));
          }
        });
      }
      return itemVNs;
    };
    const renderVN = () => {
      const { options, showMarker } = props;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-anchor", {
          "is--marker": showMarker
        }]
      }, [
        h("div", {
          class: "vxe-anchor--list"
        }, defaultSlot ? defaultSlot({}) : renderSubItems(options)),
        showMarker ? h("div", {
          ref: refMarkerElem,
          class: "vxe-anchor--marker"
        }) : createCommentVNode()
      ]);
    };
    watch(() => props.modelValue, (val) => {
      reactData.activeHref = val;
    });
    watch(() => reactData.activeHref, () => {
      updateMarkerPos();
    });
    watch(() => props.container, () => {
      removeContainerElemScroll();
      updateContainerElem();
    });
    onMounted(() => {
      nextTick(() => {
        updateContainerElem();
      });
    });
    onBeforeUnmount(() => {
      removeContainerElemScroll();
    });
    provide("$xeAnchor", $xeAnchor);
    $xeAnchor.renderVN = renderVN;
    return $xeAnchor;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/anchor/index.js
var VxeAnchor = Object.assign({}, anchor_default, {
  install(app) {
    app.component(anchor_default.name, anchor_default);
  }
});
dynamicApp.use(VxeAnchor);
VxeUI.component(anchor_default);
var Anchor = VxeAnchor;
var anchor_default2 = VxeAnchor;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/anchor-link/index.js
var VxeAnchorLink = Object.assign({}, anchor_link_default, {
  install(app) {
    app.component(anchor_link_default.name, anchor_link_default);
  }
});
dynamicApp.use(VxeAnchorLink);
VxeUI.component(anchor_link_default);
var AnchorLink = VxeAnchorLink;
var anchor_link_default2 = VxeAnchorLink;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/avatar/src/avatar.js
var import_xe_utils5 = __toESM(require_xe_utils());
var avatar_default = defineComponent({
  name: "VxeAvatar",
  props: {
    count: [String, Number],
    dot: Boolean,
    content: [String, Number],
    icon: String,
    src: String,
    width: [String, Number],
    height: [String, Number],
    circle: {
      type: Boolean,
      default: () => getConfig().avatar.circle
    },
    status: {
      type: String,
      default: () => getConfig().avatar.status
    },
    size: {
      type: String,
      default: () => getConfig().avatar.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils5.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeAvatarStyle = computed(() => {
      const { width, height } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeCountNum = computed(() => {
      const { count } = props;
      return count ? import_xe_utils5.default.toNumber(count) : 0;
    });
    const computeMaps = {};
    const $xeAvatar = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $avatar: $xeAvatar }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeAvatar, collapsePaneMethods, collapsePanePrivateMethods);
    const renderContent = () => {
      const { icon, content, src } = props;
      if (icon) {
        return h("span", {
          class: "vxe-avatar--icon"
        }, [
          h("i", {
            class: icon
          })
        ]);
      }
      if (content) {
        return h("span", {
          class: "vxe-avatar--content"
        }, `${content}`);
      }
      if (src) {
        return h("img", {
          class: "vxe-avatar--img",
          src
        });
      }
      return renderEmptyElement($xeAvatar);
    };
    const renderVN = () => {
      const { circle, dot, status } = props;
      const vSize = computeSize.value;
      const countNum = computeCountNum.value;
      const avatarStyle = computeAvatarStyle.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-avatar", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--circle": circle,
          "is--dot": dot
        }],
        style: avatarStyle
      }, [
        renderContent(),
        countNum ? h("span", {
          class: "vxe-avatar--count"
        }, countNum > 99 ? "99+" : `${countNum}`) : renderEmptyElement($xeAvatar)
      ]);
    };
    $xeAvatar.renderVN = renderVN;
    return $xeAvatar;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/avatar/index.js
var VxeAvatar = Object.assign({}, avatar_default, {
  install(app) {
    app.component(avatar_default.name, avatar_default);
  }
});
dynamicApp.use(VxeAvatar);
VxeUI.component(avatar_default);
var Avatar = VxeAvatar;
var avatar_default2 = VxeAvatar;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/badge/src/badge.js
var import_xe_utils6 = __toESM(require_xe_utils());
var badge_default = defineComponent({
  name: "VxeBadge",
  props: {
    count: [String, Number],
    dot: Boolean,
    content: [String, Number],
    size: {
      type: String,
      default: () => getConfig().badge.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils6.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeCountNum = computed(() => {
      const { count } = props;
      return count ? import_xe_utils6.default.toNumber(count) : 0;
    });
    const computeMaps = {};
    const $xeBadge = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $badge: $xeBadge }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeBadge, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const { dot, content } = props;
      const vSize = computeSize.value;
      const countNum = computeCountNum.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-badge", {
          [`size--${vSize}`]: vSize,
          "is--dot": dot
        }]
      }, [
        defaultSlot || content ? h("div", {
          class: "vxe-badge--content"
        }, defaultSlot ? defaultSlot({}) : `${content || ""}`) : [],
        countNum ? h("span", {
          class: "vxe-badge--count"
        }, countNum > 99 ? "99+" : `${countNum}`) : renderEmptyElement($xeBadge)
      ]);
    };
    $xeBadge.renderVN = renderVN;
    return $xeBadge;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/badge/index.js
var VxeBadge = Object.assign({}, badge_default, {
  install(app) {
    app.component(badge_default.name, badge_default);
  }
});
dynamicApp.use(VxeBadge);
VxeUI.component(badge_default);
var Badge = VxeBadge;
var badge_default2 = VxeBadge;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/breadcrumb/src/breadcrumb.js
var import_xe_utils8 = __toESM(require_xe_utils());

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/breadcrumb/src/breadcrumb-item.js
var import_xe_utils7 = __toESM(require_xe_utils());
var breadcrumb_item_default = defineComponent({
  name: "VxeBreadcrumbItem",
  props: {
    title: String,
    routerLink: Object
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils7.default.uniqueId();
    const refElem = ref();
    const $xeBreadcrumb = inject("$xeBreadcrumb", null);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeSeparator = computed(() => {
      if ($xeBreadcrumb) {
        return $xeBreadcrumb.props.separator;
      }
      return "";
    });
    const clickEvent = (evnt) => {
      if ($xeBreadcrumb) {
        const item = {
          title: props.title,
          routerLink: props.routerLink
        };
        $xeBreadcrumb.handleClickLink(evnt, item);
      }
    };
    const computeMaps = {};
    const $xeBreadcrumbItem = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const { title, routerLink } = props;
      const separator = computeSeparator.value;
      const defaultSlot = slots.default;
      return h("span", {
        ref: refElem,
        class: "vxe-breadcrumb-item",
        onClick: clickEvent
      }, [
        h("span", {
          class: "vxe-breadcrumb-item--content"
        }, [
          routerLink ? h(resolveComponent("router-link"), {
            class: "vxe-breadcrumb-item--content-link",
            title,
            to: routerLink
          }, {
            default() {
              return h("span", {
                class: "vxe-breadcrumb-item--content-text"
              }, defaultSlot ? defaultSlot({}) : `${title || ""}`);
            }
          }) : h("span", {
            class: "vxe-breadcrumb-item--content-text"
          }, defaultSlot ? defaultSlot({}) : `${title || ""}`)
        ]),
        separator ? h("span", {
          class: "vxe-breadcrumb-item--separator"
        }, `${separator}`) : createCommentVNode()
      ]);
    };
    $xeBreadcrumbItem.renderVN = renderVN;
    return $xeBreadcrumbItem;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/breadcrumb/src/breadcrumb.js
var breadcrumb_default = defineComponent({
  name: "VxeBreadcrumb",
  props: {
    separator: {
      type: String,
      default: () => getConfig().breadcrumb.separator
    },
    options: Array
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils8.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeBreadcrumb = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const breadcrumbMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $breadcrumb: $xeBreadcrumb }, params));
      }
    };
    const breadcrumbPrivateMethods = {
      handleClickLink(evnt, option) {
        breadcrumbMethods.dispatchEvent("click", { option }, evnt);
      }
    };
    Object.assign($xeBreadcrumb, breadcrumbMethods, breadcrumbPrivateMethods);
    const renderItems = () => {
      const { options } = props;
      if (options && options.length) {
        return options.map((item) => {
          return h(breadcrumb_item_default, {
            title: item.title,
            routerLink: item.routerLink
          });
        });
      }
      return [];
    };
    const renderVN = () => {
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: "vxe-breadcrumb"
      }, defaultSlot ? defaultSlot({}) : renderItems());
    };
    provide("$xeBreadcrumb", $xeBreadcrumb);
    $xeBreadcrumb.renderVN = renderVN;
    return $xeBreadcrumb;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/breadcrumb/index.js
var VxeBreadcrumb = Object.assign({}, breadcrumb_default, {
  install(app) {
    app.component(breadcrumb_default.name, breadcrumb_default);
  }
});
dynamicApp.use(VxeBreadcrumb);
VxeUI.component(breadcrumb_default);
var Breadcrumb = VxeBreadcrumb;
var breadcrumb_default2 = VxeBreadcrumb;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/breadcrumb-item/index.js
var VxeBreadcrumbItem = Object.assign({}, breadcrumb_item_default, {
  install(app) {
    app.component(breadcrumb_item_default.name, breadcrumb_item_default);
  }
});
dynamicApp.use(VxeBreadcrumbItem);
VxeUI.component(breadcrumb_item_default);
var BreadcrumbItem = VxeBreadcrumbItem;
var breadcrumb_item_default2 = VxeBreadcrumbItem;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/button/src/button-group.js
var import_xe_utils9 = __toESM(require_xe_utils());
var button_group_default = defineComponent({
  name: "VxeButtonGroup",
  props: {
    options: Array,
    mode: String,
    status: String,
    round: Boolean,
    vertical: Boolean,
    circle: Boolean,
    align: String,
    className: [String, Function],
    disabled: Boolean,
    permissionCode: [String, Number],
    size: {
      type: String,
      default: () => getConfig().buttonGroup.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils9.default.uniqueId();
    const reactData = reactive({});
    const computeMaps = {};
    const $xeButtonGroup = {
      xID,
      props,
      context,
      reactData,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const { computePermissionInfo } = usePermission(props);
    const buttonGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $buttonGroup: $xeButtonGroup }, params));
      }
    };
    const buttonGroupPrivateMethods = {
      handleClick(params, evnt) {
        const { options } = props;
        const { name } = params;
        const option = options ? options.find((item) => item.name === name) : null;
        buttonGroupMethods.dispatchEvent("click", Object.assign(Object.assign({}, params), { option }), evnt);
      }
    };
    Object.assign($xeButtonGroup, buttonGroupMethods, buttonGroupPrivateMethods);
    const renderVN = () => {
      const { className, options, vertical } = props;
      const permissionInfo = computePermissionInfo.value;
      const defaultSlot = slots.default;
      if (!permissionInfo.visible) {
        return createCommentVNode();
      }
      return h("div", {
        class: ["vxe-button-group", className ? import_xe_utils9.default.isFunction(className) ? className({ $buttonGroup: $xeButtonGroup }) : className : "", {
          "is--vertical": vertical
        }]
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item, index) => {
        return h(button_default, Object.assign({ key: index }, item));
      }) : []);
    };
    $xeButtonGroup.renderVN = renderVN;
    provide("$xeButtonGroup", $xeButtonGroup);
    return $xeButtonGroup;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/button-group/index.js
var VxeButtonGroup = Object.assign({}, button_group_default, {
  install(app) {
    app.component(button_group_default.name, button_group_default);
  }
});
dynamicApp.use(VxeButtonGroup);
VxeUI.component(button_group_default);
var ButtonGroup = VxeButtonGroup;
var button_group_default2 = VxeButtonGroup;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/calendar/src/calendar.js
var import_xe_utils10 = __toESM(require_xe_utils());
var calendar_default = defineComponent({
  name: "VxeCalendar",
  props: {
    modelValue: [String, Number, Date],
    type: {
      type: String,
      default: "date"
    },
    className: String,
    size: {
      type: String,
      default: () => getConfig().calendar.size || getConfig().size
    },
    multiple: Boolean,
    width: [String, Number],
    height: [String, Number],
    // date、week、month、quarter、year
    minDate: {
      type: [String, Number, Date],
      default: () => getConfig().calendar.minDate
    },
    maxDate: {
      type: [String, Number, Date],
      default: () => getConfig().calendar.maxDate
    },
    startDay: {
      type: [String, Number],
      default: () => getConfig().calendar.startDay
    },
    labelFormat: String,
    valueFormat: String,
    festivalMethod: {
      type: Function,
      default: () => getConfig().calendar.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().calendar.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().calendar.selectDay
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "click",
    "date-prev",
    "date-today",
    "date-next",
    "view-change"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils10.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      selectValue: props.modelValue,
      inputValue: props.modelValue,
      datePanelValue: null,
      datePanelLabel: "",
      datePanelType: "day",
      selectMonth: null,
      currentDate: null
    });
    const internalData = {
      yearSize: 12,
      monthSize: 20,
      quarterSize: 8
    };
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xeCalendar = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const computeCalendarStyle = computed(() => {
      const { height, width } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeIsDisabled = computed(() => {
      return false;
    });
    const computeIsCalendarType = computed(() => {
      return ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeDateStartTime = computed(() => {
      return props.minDate ? import_xe_utils10.default.toStringDate(props.minDate) : null;
    });
    const computeDateEndTime = computed(() => {
      return props.maxDate ? import_xe_utils10.default.toStringDate(props.maxDate) : null;
    });
    const computeSupportMultiples = computed(() => {
      return ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeDateListValue = computed(() => {
      const { multiple } = props;
      const { selectValue } = reactData;
      const isCalendarType = computeIsCalendarType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && selectValue && isCalendarType) {
        return import_xe_utils10.default.toValueString(selectValue).split(",").map((item) => {
          const date = parseDate(item, dateValueFormat);
          if (import_xe_utils10.default.isValidDate(date)) {
            return date;
          }
          return null;
        });
      }
      return [];
    });
    const computeDateMultipleValue = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map((date) => import_xe_utils10.default.toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map((date) => import_xe_utils10.default.toDateString(date, dateLabelFormat)).join(", ");
    });
    const computeDateValueFormat = computed(() => {
      const { valueFormat } = props;
      if (valueFormat) {
        return valueFormat;
      }
      return "yyyy-MM-dd";
    });
    const computeDateValue = computed(() => {
      const { selectValue } = reactData;
      const isCalendarType = computeIsCalendarType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (selectValue && isCalendarType) {
        const date = parseDate(selectValue, dateValueFormat);
        if (import_xe_utils10.default.isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = computed(() => {
      const dateStartTime = computeDateStartTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = computed(() => {
      const dateEndTime = computeDateEndTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    const computeDateHMSTime = computed(() => {
      const dateValue = computeDateValue.value;
      return dateValue ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1e3 : 0;
    });
    const computeDateLabelFormat = computed(() => {
      const { labelFormat } = props;
      const isCalendarType = computeIsCalendarType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (isCalendarType) {
        return labelFormat || dateValueFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return null;
    });
    const computeYearList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const { yearSize } = internalData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index = -4; index < yearSize + 4; index++) {
          const date = import_xe_utils10.default.getWhatYear(startYearDate, index, "first");
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelObj = computed(() => {
      const isCalendarType = computeIsCalendarType.value;
      let y = "";
      let m = "";
      if (isCalendarType) {
        const { datePanelType, selectMonth } = reactData;
        const yearList = computeYearList.value;
        let year = "";
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === "quarter" || datePanelType === "month") {
          y = `${year}`;
        } else if (datePanelType === "year") {
          y = yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : "";
        } else {
          y = `${year}`;
          m = month ? getI18n(`vxe.input.date.m${month}`) : "-";
        }
      }
      return {
        y,
        m
      };
    });
    const computeFirstDayOfWeek = computed(() => {
      const { startDay } = props;
      return import_xe_utils10.default.toNumber(startDay);
    });
    const computeWeekDatas = computed(() => {
      const weeks = [];
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index = 0; index < 6; index++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = computed(() => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map((day) => {
          return {
            value: day,
            label: getI18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = computed(() => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        const dateHeaders = computeDateHeaders.value;
        return [{ label: getI18n("vxe.input.date.weeks.w") }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = computed(() => {
      const yearList = computeYearList.value;
      return import_xe_utils10.default.chunk(yearList, 4);
    });
    const computeQuarterList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const { quarterSize } = internalData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = import_xe_utils10.default.getWhatYear(selectMonth, 0, "first");
        const selFullYear = firstYear.getFullYear();
        for (let index = -2; index < quarterSize - 2; index++) {
          const date = import_xe_utils10.default.getWhatQuarter(firstYear, index);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = computed(() => {
      const quarterList = computeQuarterList.value;
      return import_xe_utils10.default.chunk(quarterList, 2);
    });
    const computeMonthList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const { monthSize } = internalData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = import_xe_utils10.default.getWhatYear(selectMonth, 0, "first").getFullYear();
        for (let index = -4; index < monthSize - 4; index++) {
          const date = import_xe_utils10.default.getWhatYear(selectMonth, 0, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = computed(() => {
      const monthList = computeMonthList.value;
      return import_xe_utils10.default.chunk(monthList, 4);
    });
    const computeDayList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(import_xe_utils10.default.getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index = 0; index < 42; index++) {
          const date = import_xe_utils10.default.getWhatDay(startDayDate, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = computed(() => {
      const dayList = computeDayList.value;
      return import_xe_utils10.default.chunk(dayList, 7);
    });
    const computeWeekDates = computed(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map((list) => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: import_xe_utils10.default.getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const parseDate = (value, format) => {
      return import_xe_utils10.default.toStringDate(value, format);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      if (import_xe_utils10.default.toValueString(props.modelValue) !== value) {
        dispatchEvent("change", { value }, evnt);
      }
    };
    const dateParseValue = (value) => {
      const { type } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let dValue = null;
      let dLabel = "";
      if (value) {
        dValue = parseDate(value, dateValueFormat);
      }
      if (import_xe_utils10.default.isValidDate(dValue)) {
        dLabel = import_xe_utils10.default.toDateString(dValue, dateLabelFormat, { firstDay: firstDayOfWeek });
        if (dateLabelFormat && type === "week") {
          const firstWeekDate = import_xe_utils10.default.getWhatWeek(dValue, 0, firstDayOfWeek, firstDayOfWeek);
          if (firstWeekDate.getFullYear() < dValue.getFullYear()) {
            const yyIndex = dateLabelFormat.indexOf("yyyy");
            if (yyIndex > -1) {
              const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace(`${yyNum}`, `${yyNum - 1}`);
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    const changeValue = () => {
      const isCalendarType = computeIsCalendarType.value;
      const { inputValue } = reactData;
      if (isCalendarType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    const initValue = () => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        changeValue();
      }
    };
    const dateCheckMonth = (date) => {
      const month = import_xe_utils10.default.getWhatMonth(date, 0, "first");
      if (!import_xe_utils10.default.isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = (date) => {
      const { modelValue, multiple } = props;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === "week") {
        const sWeek = import_xe_utils10.default.toNumber(props.selectDay);
        date = import_xe_utils10.default.getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      }
      const inpVal = import_xe_utils10.default.toDateString(date, dateValueFormat, { firstDay: firstDayOfWeek });
      dateCheckMonth(date);
      reactData.selectValue = date;
      if (multiple) {
        const dateMultipleValue = computeDateMultipleValue.value;
        if (dateMultipleValue.some((val) => import_xe_utils10.default.isEqual(val, inpVal))) {
          handleChange(dateMultipleValue.filter((val) => !import_xe_utils10.default.isEqual(val, inpVal)).join(","), { type: "update" });
        } else {
          handleChange(dateMultipleValue.concat([inpVal]).join(","), { type: "update" });
        }
      } else {
        if (!import_xe_utils10.default.isEqual(modelValue, inpVal)) {
          handleChange(inpVal, { type: "update" });
        }
      }
    };
    const dateMonthHandle = (date, offsetMonth) => {
      reactData.selectMonth = import_xe_utils10.default.getWhatMonth(date, offsetMonth, "first");
    };
    const dateNowHandle = () => {
      const currentDate = import_xe_utils10.default.getWhatDay(Date.now(), 0, "first");
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleYearTypeEvent = () => {
      reactData.datePanelType = "year";
    };
    const dateToggleMonthTypeEvent = (evnt) => {
      let { datePanelType } = reactData;
      if (datePanelType === "month" || datePanelType === "quarter") {
        datePanelType = "year";
      } else {
        datePanelType = "month";
      }
      reactData.datePanelType = datePanelType;
      changeViewEvent(evnt);
    };
    const datePrevEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth } = reactData;
      const { yearSize } = internalData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        if (type === "year") {
          reactData.selectMonth = import_xe_utils10.default.getWhatYear(selectMonth, -yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils10.default.getWhatYear(selectMonth, -yearSize, "first");
          } else {
            reactData.selectMonth = import_xe_utils10.default.getWhatYear(selectMonth, -1, "first");
          }
        } else {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils10.default.getWhatYear(selectMonth, -yearSize, "first");
          } else if (datePanelType === "month") {
            reactData.selectMonth = import_xe_utils10.default.getWhatYear(selectMonth, -1, "first");
          } else {
            reactData.selectMonth = import_xe_utils10.default.getWhatMonth(selectMonth, -1, "first");
          }
        }
        dispatchEvent("date-prev", { type }, evnt);
        changeViewEvent(evnt);
      }
    };
    const dateTodayMonthEvent = (evnt) => {
      dateNowHandle();
      if (!props.multiple) {
        dateChange(reactData.currentDate);
      }
      dispatchEvent("date-today", { type: props.type }, evnt);
      changeViewEvent(evnt);
    };
    const dateNextEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth } = reactData;
      const { yearSize } = internalData;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        if (type === "year") {
          reactData.selectMonth = import_xe_utils10.default.getWhatYear(selectMonth, yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils10.default.getWhatYear(selectMonth, yearSize, "first");
          } else {
            reactData.selectMonth = import_xe_utils10.default.getWhatYear(selectMonth, 1, "first");
          }
        } else {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils10.default.getWhatYear(selectMonth, yearSize, "first");
          } else if (datePanelType === "month") {
            reactData.selectMonth = import_xe_utils10.default.getWhatYear(selectMonth, 1, "first");
          } else {
            reactData.selectMonth = import_xe_utils10.default.getWhatMonth(selectMonth, 1, "first");
          }
        }
        dispatchEvent("date-next", { type }, evnt);
        changeViewEvent(evnt);
      }
    };
    const isDateDisabled = (item) => {
      const { disabledMethod } = props;
      const { datePanelType } = reactData;
      return disabledMethod && disabledMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $calendar: $xeCalendar });
    };
    const changeViewEvent = (evnt) => {
      const { datePanelType } = reactData;
      const yearDatas = computeYearDatas.value;
      const quarterDatas = computeQuarterDatas.value;
      const monthDatas = computeMonthDatas.value;
      const weekDates = computeWeekDates.value;
      const dayDatas = computeDayDatas.value;
      const viewDates = [];
      let dataList = [];
      switch (datePanelType) {
        case "year":
          dataList = yearDatas;
          break;
        case "quarter":
          dataList = quarterDatas;
          break;
        case "month":
          dataList = monthDatas;
          break;
        case "week":
          dataList = weekDates;
          break;
        case "day":
          dataList = dayDatas;
          break;
      }
      dataList.forEach((rows) => {
        rows.forEach((item) => {
          viewDates.push(item.date);
        });
      });
      dispatchEvent("view-change", { viewType: datePanelType, viewDates }, evnt);
    };
    const dateSelectItem = (date) => {
      const { type } = props;
      const { datePanelType } = reactData;
      if (type === "month") {
        if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
          changeViewEvent(null);
        } else {
          dateChange(date);
        }
      } else if (type === "year") {
        dateChange(date);
      } else if (type === "quarter") {
        if (datePanelType === "year") {
          reactData.datePanelType = "quarter";
          dateCheckMonth(date);
          changeViewEvent(null);
        } else {
          dateChange(date);
        }
      } else {
        if (datePanelType === "month") {
          reactData.datePanelType = type === "week" ? type : "day";
          dateCheckMonth(date);
          changeViewEvent(null);
        } else if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
          changeViewEvent(null);
        } else {
          dateChange(date);
        }
      }
    };
    const dateSelectEvent = (item) => {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = (offsetDay) => {
      if (!isDateDisabled({ date: offsetDay })) {
        const dayList = computeDayList.value;
        if (!dayList.some((item) => import_xe_utils10.default.isDateSame(item.date, offsetDay, "yyyyMMdd"))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = (offsetYear) => {
      if (!isDateDisabled({ date: offsetYear })) {
        const yearList = computeYearList.value;
        if (!yearList.some((item) => import_xe_utils10.default.isDateSame(item.date, offsetYear, "yyyy"))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = (offsetQuarter) => {
      if (!isDateDisabled({ date: offsetQuarter })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some((item) => import_xe_utils10.default.isDateSame(item.date, offsetQuarter, "yyyyq"))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = (offsetMonth) => {
      if (!isDateDisabled({ date: offsetMonth })) {
        const monthList = computeMonthList.value;
        if (!monthList.some((item) => import_xe_utils10.default.isDateSame(item.date, offsetMonth, "yyyyMM"))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = (item) => {
      if (!isDateDisabled(item)) {
        const { datePanelType } = reactData;
        if (datePanelType === "month") {
          dateMoveMonth(item.date);
        } else if (datePanelType === "quarter") {
          dateMoveQuarter(item.date);
        } else if (datePanelType === "year") {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const dateConfirmEvent = () => {
    };
    const dateOpenPanel = () => {
      const { type } = props;
      const dateValue = computeDateValue.value;
      if (["year", "quarter", "month", "week"].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = "day";
      }
      reactData.currentDate = import_xe_utils10.default.getWhatDay(Date.now(), 0, "first");
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
    };
    const renderDateLabel = (item, label) => {
      const { festivalMethod } = props;
      if (festivalMethod) {
        const { datePanelType } = reactData;
        const festivalRest = festivalMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $calendar: $xeCalendar });
        const festivalItem = festivalRest ? import_xe_utils10.default.isString(festivalRest) ? { label: festivalRest } : festivalRest : {};
        const extraItem = festivalItem.extra ? import_xe_utils10.default.isString(festivalItem.extra) ? { label: festivalItem.extra } : festivalItem.extra : null;
        const labels = [
          h("span", {
            class: ["vxe-calendar--date-label", {
              "is-notice": festivalItem.notice
            }]
          }, extraItem && extraItem.label ? [
            h("span", `${label || ""}`),
            h("span", {
              class: ["vxe-calendar--date-label--extra", extraItem.important ? "is-important" : "", extraItem.className],
              style: extraItem.style
            }, import_xe_utils10.default.toValueString(extraItem.label))
          ] : [`${label || ""}`])
        ];
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          const festivalLabels = import_xe_utils10.default.toValueString(festivalLabel).split(",");
          labels.push(h("span", {
            class: ["vxe-calendar--date-festival", festivalItem.important ? "is-important" : "", festivalItem.className],
            style: festivalItem.style
          }, [
            festivalLabels.length > 1 ? h("span", {
              class: ["vxe-calendar--date-festival--overlap", `overlap--${festivalLabels.length}`]
            }, festivalLabels.map((label2) => h("span", label2.substring(0, 3)))) : h("span", {
              class: "vxe-calendar--date-festival--label"
            }, festivalLabels[0].substring(0, 3))
          ]));
        }
        return labels;
      }
      return `${label || ""}`;
    };
    const renderDateDayTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-calendar--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tr", dateHeaders.map((item) => {
            return h("th", {
              class: "vxe-calendar--view-th"
            }, item.label);
          })),
          ...dayDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: ["vxe-calendar--view-td", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils10.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils10.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils10.default.isDateSame(datePanelValue, item.date, matchFormat)
                }],
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          })
        ])
      ];
    };
    const renderDateWeekTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-calendar--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tr", weekHeaders.map((item) => {
            return h("td", {
              class: "vxe-calendar--view-th"
            }, item.label);
          })),
          ...weekDates.map((rows) => {
            const isSelected = multiple ? rows.some((item) => dateListValue.some((val) => import_xe_utils10.default.isDateSame(val, item.date, matchFormat))) : rows.some((item) => import_xe_utils10.default.isDateSame(dateValue, item.date, matchFormat));
            const isHover = rows.some((item) => import_xe_utils10.default.isDateSame(datePanelValue, item.date, matchFormat));
            return h("tr", rows.map((item) => {
              return h("td", {
                class: ["vxe-calendar--view-td", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--hover": isHover
                }],
                // event
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          })
        ])
      ];
    };
    const renderDateMonthTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMM";
      return [
        h("table", {
          class: `vxe-calendar--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", monthDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: ["vxe-calendar--view-td", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils10.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils10.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils10.default.isDateSame(datePanelValue, item.date, matchFormat)
                }],
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.months.m${item.month}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateQuarterTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyq";
      return [
        h("table", {
          class: `vxe-calendar--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", quarterDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: ["vxe-calendar--view-td", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils10.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils10.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils10.default.isDateSame(datePanelValue, item.date, matchFormat)
                }],
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.quarters.q${item.quarter}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateYearTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyy";
      return [
        h("table", {
          class: `vxe-calendar--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", yearDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: ["vxe-calendar--view-td", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils10.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils10.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils10.default.isDateSame(datePanelValue, item.date, matchFormat)
                }],
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.year));
            }));
          }))
        ])
      ];
    };
    const renderDateTable = () => {
      const { datePanelType } = reactData;
      switch (datePanelType) {
        case "week":
          return renderDateWeekTable();
        case "month":
          return renderDateMonthTable();
        case "quarter":
          return renderDateQuarterTable();
        case "year":
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const { multiple } = props;
      const { datePanelType } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelObj = computeSelectDatePanelObj.value;
      return [
        h("div", {
          class: "vxe-calendar--header"
        }, [
          h("div", {
            class: "vxe-calendar--type-wrapper"
          }, [
            datePanelType === "year" ? h(button_default, {
              class: "vxe-calendar--date-picker-label",
              disabled: datePanelType === "year",
              content: selectDatePanelObj.y
            }) : h("span", {
              class: "vxe-calendar--date-picker-btns"
            }, [
              h(button_default, {
                class: "vxe-calendar--date-picker-btn",
                content: selectDatePanelObj.y,
                onClick: dateToggleYearTypeEvent
              }),
              selectDatePanelObj.m ? h(button_default, {
                class: "vxe-calendar--date-picker-btn",
                content: selectDatePanelObj.m,
                onClick: dateToggleMonthTypeEvent
              }) : renderEmptyElement($xeCalendar)
            ])
          ]),
          h("div", {
            class: "vxe-calendar--btn-wrapper"
          }, [
            h(button_default, {
              disabled: isDisabledPrevDateBtn,
              icon: "vxe-icon-caret-left",
              onClick: datePrevEvent
            }),
            h(button_default, {
              icon: "vxe-icon-dot",
              onClick: dateTodayMonthEvent
            }),
            h(button_default, {
              disabled: isDisabledNextDateBtn,
              icon: "vxe-icon-caret-right",
              onClick: dateNextEvent
            }),
            multiple && computeSupportMultiples.value ? h("span", {
              class: "vxe-calendar--btn vxe-calendar--confirm-btn"
            }, [
              h("button", {
                class: "vxe-calendar--confirm",
                type: "button",
                onClick: dateConfirmEvent
              }, getI18n("vxe.button.confirm"))
            ]) : null
          ])
        ]),
        h("div", {
          class: "vxe-calendar--body"
        }, renderDateTable())
      ];
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $input: $xeCalendar }, params));
    };
    const calendarMethods = {
      dispatchEvent
    };
    Object.assign($xeCalendar, calendarMethods);
    const renderVN = () => {
      const { className, type } = props;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const calendarStyle = computeCalendarStyle.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-calendar", `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          "is--disabled": isDisabled
        }],
        style: calendarStyle
      }, [
        renderDatePanel()
      ]);
    };
    $xeCalendar.renderVN = renderVN;
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
      changeValue();
    });
    watch(() => props.type, () => {
      Object.assign(reactData, {
        selectValue: null,
        inputValue: null,
        datePanelValue: null,
        datePanelLabel: "",
        datePanelType: "day",
        selectMonth: null,
        currentDate: null
      });
      initValue();
      dateOpenPanel();
    });
    watch(computeDateLabelFormat, () => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    onMounted(() => {
      dateOpenPanel();
    });
    initValue();
    return $xeCalendar;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/calendar/index.js
var VxeCalendar = Object.assign({}, calendar_default, {
  install(app) {
    app.component(calendar_default.name, calendar_default);
  }
});
dynamicApp.use(VxeCalendar);
VxeUI.component(calendar_default);
var Calendar = VxeCalendar;
var calendar_default2 = VxeCalendar;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/card/src/card.js
var import_xe_utils11 = __toESM(require_xe_utils());
var card_default = defineComponent({
  name: "VxeCard",
  props: {
    title: String,
    showTitleOverflow: {
      type: Boolean,
      default: () => getConfig().card.showTitleOverflow
    },
    width: [String, Number],
    height: [String, Number],
    border: {
      type: Boolean,
      default: () => getConfig().card.border
    },
    loading: Boolean,
    shadow: {
      type: Boolean,
      default: () => getConfig().card.shadow
    },
    padding: {
      type: Boolean,
      default: () => getConfig().card.padding
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils11.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeCardStyle = computed(() => {
      const { height, width } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeMaps = {};
    const $xeCard = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $card: $xeCard }, params));
    };
    const cardMethods = {
      dispatchEvent
    };
    const cardPrivateMethods = {};
    Object.assign($xeCard, cardMethods, cardPrivateMethods);
    const renderVN = () => {
      const { title, border, shadow, padding, loading: loading2, showTitleOverflow } = props;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const titleSlot = slots.title;
      const extraSlot = slots.extra;
      const footerSlot = slots.footer;
      const leftSlot = slots.left;
      const rightSlot = slots.right;
      const cardStyle = computeCardStyle.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-card", {
          "is--border": border,
          "is--shadow": shadow,
          "is--padding": padding
        }],
        style: cardStyle
      }, [
        title || titleSlot || headerSlot ? h("div", {
          class: "vxe-card--header"
        }, headerSlot ? getSlotVNs(headerSlot({})) : [
          h("div", {
            class: ["vxe-card--header-title", {
              "is--ellipsis": showTitleOverflow
            }]
          }, titleSlot ? getSlotVNs(titleSlot({})) : `${title || ""}`),
          extraSlot ? h("div", {
            class: "vxe-card--header-extra"
          }, getSlotVNs(extraSlot({}))) : createCommentVNode()
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-card--body"
        }, [
          leftSlot ? h("div", {
            class: "vxe-card--body-left"
          }, getSlotVNs(leftSlot({}))) : createCommentVNode(),
          h("div", {
            class: "vxe-card--body-content"
          }, defaultSlot ? getSlotVNs(defaultSlot({})) : []),
          rightSlot ? h("div", {
            class: "vxe-card--body-right"
          }, getSlotVNs(rightSlot({}))) : createCommentVNode()
        ]),
        footerSlot ? h("div", {
          class: "vxe-card--footer"
        }, getSlotVNs(footerSlot({}))) : createCommentVNode(),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-card--loading",
          modelValue: loading2
        })
      ]);
    };
    $xeCard.renderVN = renderVN;
    return $xeCard;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/card/index.js
var VxeCard = Object.assign({}, card_default, {
  install(app) {
    app.component(card_default.name, card_default);
  }
});
dynamicApp.use(VxeCard);
VxeUI.component(card_default);
var Card = VxeCard;
var card_default2 = VxeCard;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/carousel/src/carousel.js
var import_xe_utils12 = __toESM(require_xe_utils());
var carousel_default = defineComponent({
  name: "VxeCarousel",
  props: {
    modelValue: [String, Number],
    options: Array,
    loading: Boolean,
    height: {
      type: [Number, String],
      default: () => getConfig().carousel.height
    },
    width: {
      type: [Number, String],
      default: () => getConfig().carousel.width
    },
    autoPlay: {
      type: Boolean,
      default: () => getConfig().carousel.autoPlay
    },
    interval: {
      type: [Number, String],
      default: () => getConfig().carousel.interval
    },
    loop: {
      type: Boolean,
      default: () => getConfig().carousel.loop
    },
    vertical: {
      type: Boolean,
      default: () => getConfig().carousel.vertical
    },
    showIndicators: {
      type: Boolean,
      default: () => getConfig().carousel.showIndicators
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils12.default.uniqueId();
    const refElem = ref();
    const refWrapperElem = ref();
    const reactData = reactive({
      activeName: "",
      staticItems: [],
      itemWidth: 0,
      itemHeight: 0
    });
    const internalData = {
      apTimeout: void 0,
      stopFlag: false
    };
    const refMaps = {
      refElem
    };
    const computeListStyle = computed(() => {
      const { vertical, options } = props;
      const { activeName, itemWidth, itemHeight, staticItems } = reactData;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      const activeIndex = Math.max(0, import_xe_utils12.default.findIndexOf(list, (item) => item.name === activeName));
      const stys = {};
      if (vertical) {
        stys.transform = `translateY(-${activeIndex * itemHeight}px)`;
      } else {
        stys.width = `${itemWidth * list.length}px`;
        stys.transform = `translateX(-${activeIndex * itemWidth}px)`;
      }
      return stys;
    });
    const computeMaps = {};
    const $xeCarousel = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const updateStyle = () => {
      nextTick(() => {
        const wrapperElem = refWrapperElem.value;
        if (wrapperElem) {
          reactData.itemWidth = wrapperElem.clientWidth;
          reactData.itemHeight = wrapperElem.clientHeight;
        }
      });
    };
    const clickItemEvent = (evnt, item) => {
      const value = item.name;
      reactData.activeName = item.name;
      emit("update:modelValue", value);
      emit("change", { value }, evnt);
      updateStyle();
    };
    const initDefaultActive = (list) => {
      let activeName = null;
      if (list && list.length) {
        let validVal = false;
        activeName = props.modelValue;
        list.forEach((item) => {
          if (activeName === item.name) {
            validVal = true;
          }
        });
        if (!validVal) {
          activeName = list[0].name;
          emit("update:modelValue", activeName);
        }
      }
      reactData.activeName = activeName;
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $carousel: $xeCarousel }, params));
    };
    const handlePrevNext = (isNext) => {
      const { options, loop } = props;
      const { activeName, staticItems } = reactData;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      const index = Math.max(0, import_xe_utils12.default.findIndexOf(list, (item) => item.name === activeName));
      if (index > -1) {
        let item = null;
        if (isNext) {
          if (index < list.length - 1) {
            item = list[index + 1];
          } else {
            if (loop) {
              item = list[0];
            }
          }
        } else {
          if (index > 0) {
            item = list[index - 1];
          } else {
            if (loop) {
              item = list[list.length - 1];
            }
          }
        }
        if (item) {
          const name = item.name;
          const value = name;
          reactData.activeName = name;
          emit("update:modelValue", value);
          return true;
        }
      }
      return false;
    };
    const carouselMethods = {
      dispatchEvent,
      prev() {
        if (handlePrevNext(false)) {
          handleAutoPlay();
        }
        return nextTick();
      },
      next() {
        if (handlePrevNext(true)) {
          handleAutoPlay();
        }
        return nextTick();
      }
    };
    const prevEvent = (evnt) => {
      if (handlePrevNext(false)) {
        const value = reactData.activeName;
        emit("change", { value }, evnt);
      }
    };
    const nextEvent = (evnt) => {
      if (handlePrevNext(true)) {
        const value = reactData.activeName;
        emit("change", { value }, evnt);
      }
    };
    const stopAutoPlay = () => {
      const { apTimeout } = internalData;
      internalData.stopFlag = true;
      if (apTimeout) {
        clearTimeout(apTimeout);
        internalData.apTimeout = void 0;
      }
    };
    const handleAutoPlay = () => {
      const { autoPlay, interval } = props;
      const { stopFlag } = internalData;
      stopAutoPlay();
      if (autoPlay) {
        internalData.stopFlag = false;
        internalData.apTimeout = setTimeout(() => {
          if (!stopFlag) {
            handlePrevNext(true);
          }
        }, import_xe_utils12.default.toNumber(interval) || 300);
      }
    };
    const mouseenterEvent = () => {
      stopAutoPlay();
    };
    const mouseleaveEvent = () => {
      handleAutoPlay();
    };
    const carouselPrivateMethods = {};
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils12.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils12.default.isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    Object.assign($xeCarousel, carouselMethods, carouselPrivateMethods);
    const renderItemWrapper = (list) => {
      const { height } = props;
      const { activeName } = reactData;
      const listStyle = computeListStyle.value;
      return h("div", {
        class: "vxe-carousel--list",
        style: listStyle
      }, list.map((item) => {
        const { name, url, slots: slots2 } = item;
        const defaultSlot = slots2 ? slots2.default : null;
        return h("div", {
          key: `${name}`,
          class: ["vxe-carousel--item-inner", {
            "is--active": activeName === name
          }],
          style: height ? {
            height: toCssUnit(height)
          } : null
        }, defaultSlot ? callSlot(defaultSlot, {}) : [
          h("img", {
            class: "vxe-carousel--item-img",
            src: url
          })
        ]);
      }));
    };
    const renderIndicators = (list) => {
      const { activeName } = reactData;
      return h("div", {
        class: "vxe-carousel--indicators"
      }, list.map((item) => {
        const { name } = item;
        return h("div", {
          key: `${name}`,
          class: ["vxe-carousel--indicators-item", {
            "is--active": activeName === name
          }],
          onClick(evnt) {
            clickItemEvent(evnt, item);
          }
        });
      }));
    };
    const renderVN = () => {
      const { loading: loading2, height, width, showIndicators, vertical, options } = props;
      const { staticItems } = reactData;
      const defaultSlot = slots.default;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      return h("div", {
        ref: refElem,
        class: ["vxe-carousel", `is--${vertical ? "vertical" : "horizontal"}`],
        style: width ? {
          width: toCssUnit(width)
        } : null,
        onMouseenter: mouseenterEvent,
        onMouseleave: mouseleaveEvent
      }, [
        h("div", {
          class: "vxe-carousel--slots"
        }, defaultSlot ? defaultSlot({}) : []),
        h("div", {
          ref: refWrapperElem,
          class: "vxe-carousel--item-wrapper",
          style: height ? {
            height: toCssUnit(height)
          } : null
        }, [
          renderItemWrapper(list)
        ]),
        showIndicators ? renderIndicators(list) : createCommentVNode(),
        h("div", {
          class: "vxe-carousel--btn-wrapper"
        }, [
          h("div", {
            class: "vxe-carousel--previous-btn",
            onClick: prevEvent
          }, [
            h("i", {
              class: vertical ? getIcon().CAROUSEL_VERTICAL_PREVIOUS : getIcon().CAROUSEL_HORIZONTAL_PREVIOUS
            })
          ]),
          h("div", {
            class: "vxe-carousel--next-btn",
            onClick: nextEvent
          }, [
            h("i", {
              class: vertical ? getIcon().CAROUSEL_VERTICAL_NEXT : getIcon().CAROUSEL_HORIZONTAL_NEXT
            })
          ])
        ]),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-carousel--loading",
          modelValue: loading2
        })
      ]);
    };
    const optsFlag = ref(0);
    watch(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    watch(() => props.options, () => {
      optsFlag.value++;
    });
    watch(optsFlag, () => {
      initDefaultActive(props.options);
    });
    const stFlag = ref(0);
    watch(() => reactData.staticItems ? reactData.staticItems.length : -1, () => {
      stFlag.value++;
    });
    watch(() => reactData.staticItems, () => {
      stFlag.value++;
    });
    watch(stFlag, () => {
      initDefaultActive(reactData.staticItems);
    });
    watch(() => props.autoPlay, () => {
      handleAutoPlay();
    });
    initDefaultActive(reactData.staticItems.length ? reactData.staticItems : props.options);
    onMounted(() => {
      handleAutoPlay();
      updateStyle();
    });
    onUnmounted(() => {
      stopAutoPlay();
    });
    provide("$xeCarousel", $xeCarousel);
    $xeCarousel.renderVN = renderVN;
    return $xeCarousel;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/carousel/index.js
var VxeCarousel = Object.assign({}, carousel_default, {
  install(app) {
    app.component(carousel_default.name, carousel_default);
  }
});
dynamicApp.use(VxeCarousel);
VxeUI.component(carousel_default);
var Carousel = VxeCarousel;
var carousel_default2 = VxeCarousel;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/carousel/src/util.js
var import_xe_utils13 = __toESM(require_xe_utils());
function assembleCarouselItem($xeCarousel, elem, itemConfig) {
  const staticItems = $xeCarousel.reactData.staticItems;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticItems.splice(import_xe_utils13.default.arrayIndexOf(parentElem.children, elem), 0, itemConfig);
  }
  $xeCarousel.reactData.staticItems = staticItems.slice(0);
}
function destroyCarouselItem($xeCarousel, itemConfig) {
  const staticItems = $xeCarousel.reactData.staticItems;
  const index = import_xe_utils13.default.findIndexOf(staticItems, (item) => item.id === itemConfig.id);
  if (index > -1) {
    staticItems.splice(index, 1);
  }
  $xeCarousel.reactData.staticItems = staticItems.slice(0);
}

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/carousel/src/carousel-item.js
var import_xe_utils14 = __toESM(require_xe_utils());
var carousel_item_default = defineComponent({
  name: "VxeCarouselItem",
  props: {
    name: [String, Number],
    className: String,
    url: String
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeCarousel = inject("$xeCarousel", null);
    const xID = import_xe_utils14.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const itemConfig = reactive({
      id: xID,
      name: props.name,
      url: props.url,
      className: props.className,
      slots
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeCarouselItem = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $carouselItem: $xeCarouselItem }, params));
    };
    const carouselItemMethods = {
      dispatchEvent
    };
    const carouselItemPrivateMethods = {};
    Object.assign($xeCarouselItem, carouselItemMethods, carouselItemPrivateMethods);
    const renderVN = () => {
      return h("div", {
        ref: refElem
      });
    };
    watch(() => props.name, (val) => {
      itemConfig.name = val;
    });
    watch(() => props.url, (val) => {
      itemConfig.url = val;
    });
    onMounted(() => {
      const elem = refElem.value;
      if ($xeCarousel && elem) {
        assembleCarouselItem($xeCarousel, elem, itemConfig);
      }
    });
    onUnmounted(() => {
      if ($xeCarousel) {
        destroyCarouselItem($xeCarousel, itemConfig);
      }
    });
    $xeCarouselItem.renderVN = renderVN;
    return $xeCarouselItem;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/carousel-item/index.js
var VxeCarouselItem = Object.assign({}, carousel_item_default, {
  install(app) {
    app.component(carousel_item_default.name, carousel_item_default);
  }
});
dynamicApp.use(VxeCarouselItem);
VxeUI.component(carousel_item_default);
var CarouselItem = VxeCarouselItem;
var carousel_item_default2 = VxeCarouselItem;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/checkbox/src/group.js
var import_xe_utils15 = __toESM(require_xe_utils());
var group_default2 = defineComponent({
  name: "VxeCheckboxGroup",
  props: {
    modelValue: Array,
    options: Array,
    optionProps: Object,
    disabled: {
      type: Boolean,
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().checkboxGroup.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils15.default.uniqueId();
    const reactData = reactive({});
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsMaximize = computed(() => {
      const { modelValue, max } = props;
      if (max) {
        return (modelValue ? modelValue.length : 0) >= import_xe_utils15.default.toNumber(max);
      }
      return false;
    });
    const computePropsOpts = computed(() => {
      return Object.assign({}, props.optionProps);
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeDisabledField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.disabled || "disabled";
    });
    const computeMaps = {
      computeIsMaximize,
      computeIsDisabled
    };
    const $xeCheckboxGroup = {
      xID,
      props,
      context,
      reactData,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $checkboxGroup: $xeCheckboxGroup }, params));
    };
    const checkboxGroupMethods = {
      dispatchEvent
    };
    const checkboxGroupPrivateMethods = {
      handleChecked(params, evnt) {
        const { checked, label } = params;
        const checklist = props.modelValue || [];
        const checkIndex = checklist.indexOf(label);
        if (checked) {
          if (checkIndex === -1) {
            checklist.push(label);
          }
        } else {
          checklist.splice(checkIndex, 1);
        }
        emit("update:modelValue", checklist);
        $xeCheckboxGroup.dispatchEvent("change", Object.assign({ checklist }, params), evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, checklist);
        }
      }
    };
    Object.assign($xeCheckboxGroup, checkboxGroupMethods, checkboxGroupPrivateMethods);
    const renderVN = () => {
      const { options } = props;
      const defaultSlot = slots.default;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const disabledField = computeDisabledField.value;
      return h("div", {
        class: "vxe-checkbox-group"
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item) => {
        return h(checkbox_default, {
          key: item[valueField],
          label: item[valueField],
          content: item[labelField],
          disabled: item[disabledField]
        });
      }) : []);
    };
    provide("$xeCheckboxGroup", $xeCheckboxGroup);
    $xeCheckboxGroup.renderVN = renderVN;
    return renderVN;
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/checkbox-group/index.js
var VxeCheckboxGroup = Object.assign(group_default2, {
  install(app) {
    app.component(group_default2.name, group_default2);
  }
});
dynamicApp.use(VxeCheckboxGroup);
VxeUI.component(group_default2);
var CheckboxGroup = VxeCheckboxGroup;
var checkbox_group_default = VxeCheckboxGroup;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/row/src/col.js
var import_xe_utils16 = __toESM(require_xe_utils());
var col_default = defineComponent({
  name: "VxeCol",
  props: {
    span: [Number, String],
    align: String,
    width: [Number, String],
    fill: Boolean,
    ellipsis: Boolean,
    size: {
      type: String,
      default: () => getConfig().col.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils16.default.uniqueId();
    useSize(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const $xeRow = inject("$xeRow", null);
    const computeRowGutter = computed(() => {
      if ($xeRow) {
        return $xeRow.props.gutter;
      }
      return null;
    });
    const computeRowVertical = computed(() => {
      if ($xeRow) {
        return $xeRow.props.vertical;
      }
      return null;
    });
    const computeColStyle = computed(() => {
      const { width } = props;
      const rowGutter = computeRowGutter.value;
      const rowVertical = computeRowVertical.value;
      const style = {};
      if (rowGutter) {
        let [lrGutter, tbGutter] = import_xe_utils16.default.isArray(rowGutter) ? rowGutter : [rowGutter];
        if (rowVertical) {
          tbGutter = lrGutter;
          lrGutter = "";
        }
        if (lrGutter) {
          const padding = import_xe_utils16.default.isNumber(lrGutter) ? toCssUnit(lrGutter / 2) : `calc(${toCssUnit(lrGutter)} / 2)`;
          style.paddingLeft = padding;
          style.paddingRight = padding;
        }
        if (tbGutter) {
          const padding = import_xe_utils16.default.isNumber(tbGutter) ? toCssUnit(tbGutter / 2) : `calc(${toCssUnit(tbGutter)} / 2)`;
          style.paddingTop = padding;
          style.paddingBottom = padding;
        }
      }
      if (width) {
        style.width = toCssUnit(width);
      }
      return style;
    });
    const computeMaps = {};
    const $xeCol = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $col: $xeCol }, params));
    };
    const colMethods = {
      dispatchEvent
    };
    const colPrivateMethods = {};
    Object.assign($xeCol, colMethods, colPrivateMethods);
    const renderVN = () => {
      const { span, fill, align, width, ellipsis } = props;
      const colStyle = computeColStyle.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-col", span ? `span${span}` : "", align ? `align--${align}` : "", {
          "is--span": !!span,
          "is--width": !!width,
          "is--fill": fill,
          "is--ellipsis": ellipsis
        }],
        style: colStyle
      }, [
        h("div", {
          class: "vxe-col--inner"
        }, defaultSlot ? defaultSlot({}) : [])
      ]);
    };
    $xeCol.renderVN = renderVN;
    return $xeCol;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/col/index.js
var VxeCol = Object.assign({}, col_default, {
  install(app) {
    app.component(col_default.name, col_default);
  }
});
dynamicApp.use(VxeCol);
VxeUI.component(col_default);
var Col = VxeCol;
var col_default2 = VxeCol;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/collapse/src/collapse.js
var import_xe_utils17 = __toESM(require_xe_utils());
var collapse_default = defineComponent({
  name: "VxeCollapse",
  props: {
    modelValue: Array,
    options: Array,
    padding: {
      type: Boolean,
      default: () => getConfig().collapse.padding
    },
    expandConfig: Object,
    size: {
      type: String,
      default: () => getConfig().collapse.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "load",
    "change",
    "toggle-expand"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils17.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({
      staticPanes: [],
      activeNames: [],
      initNames: [],
      cachePaneMaps: {}
    });
    const refMaps = {
      refElem
    };
    const computeItemOptions = computed(() => {
      const { options } = props;
      return (options || []).filter((item) => handleFilterItem(item));
    });
    const computeItemStaticOptions = computed(() => {
      const { staticPanes } = reactData;
      return staticPanes.filter((item) => handleFilterItem(item));
    });
    const computeExpandOpts = computed(() => {
      return Object.assign({}, getConfig().collapse.expandConfig, props.expandConfig);
    });
    const computeMaps = {};
    const $xeCollapse = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const handleFilterItem = (item) => {
      const { permissionCode } = item;
      if (permissionCode) {
        if (!permission.checkVisible(permissionCode)) {
          return false;
        }
      }
      return true;
    };
    const addInitName = (name) => {
      const { initNames } = reactData;
      if (name && !initNames.includes(name)) {
        initNames.push(name);
        dispatchEvent("load", { name }, null);
        return true;
      }
      return false;
    };
    const initDefaultName = (list) => {
      const { activeNames } = reactData;
      const nameMaps = {};
      if (list && list.length) {
        list.forEach((item) => {
          const { name, preload } = item || {};
          if (name) {
            const isActive = activeNames.includes(name);
            nameMaps[`${name}`] = {
              loading: false
            };
            if (isActive) {
              addInitName(name);
            }
            if (preload) {
              if (!isActive) {
                activeNames.push(name);
              }
            }
          }
        });
      }
      reactData.activeNames = activeNames ? activeNames.slice(0) : [];
      reactData.cachePaneMaps = nameMaps;
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $collapse: $xeCollapse }, params));
    };
    const collapseMethods = {
      dispatchEvent
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils17.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils17.default.isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const handleClickEvent = (evnt, item) => {
      const { activeNames } = reactData;
      const { name } = item;
      if (name) {
        const aIndex = activeNames.indexOf(name);
        let expanded = false;
        if (aIndex === -1) {
          expanded = true;
          activeNames.push(name);
        } else {
          activeNames.splice(aIndex, 1);
        }
        addInitName(name);
        dispatchEvent("change", { value: activeNames, name }, evnt);
        dispatchEvent("toggle-expand", { value: activeNames, name, expanded }, evnt);
      }
    };
    const collapsePrivateMethods = {};
    Object.assign($xeCollapse, collapseMethods, collapsePrivateMethods);
    const renderList = (itemList) => {
      const { activeNames, initNames } = reactData;
      const expandOpts = computeExpandOpts.value;
      return itemList.map((item) => {
        const { icon, name, title, slots: slots2 } = item;
        const titleSlot = slots2 ? slots2.title : null;
        const defaultSlot = slots2 ? slots2.default : null;
        const isActive = name && activeNames.includes(name);
        return h("div", {
          class: "vxe-collapse-item"
        }, [
          h("div", {
            class: "vxe-collapse--item-header",
            onClick(evnt) {
              handleClickEvent(evnt, item);
            }
          }, [
            expandOpts.showIcon ? h("span", {
              class: "vxe-collapse--item-switch"
            }, [
              h("i", {
                class: isActive ? getIcon().COLLAPSE_OPEN : getIcon().COLLAPSE_CLOSE
              })
            ]) : renderEmptyElement($xeCollapse),
            icon ? h("span", {
              class: "vxe-collapse--item-icon"
            }, [
              h("i", {
                class: icon
              })
            ]) : renderEmptyElement($xeCollapse),
            h("span", {
              class: "vxe-collapse--item-name"
            }, titleSlot ? callSlot(titleSlot, { name, title }) : `${title}`)
          ]),
          h("div", {
            class: ["vxe-collapse--item-content", {
              "is--visible": isActive
            }]
          }, [
            name && initNames.includes(name) ? h("div", {
              class: "vxe-collapse--item-inner"
            }, [
              defaultSlot ? callSlot(defaultSlot, { name, title }) : ""
            ]) : renderEmptyElement($xeCollapse)
          ])
        ]);
      });
    };
    const renderVN = () => {
      const { padding } = props;
      const vSize = computeSize.value;
      const itemOptions = computeItemOptions.value;
      const itemStaticOptions = computeItemStaticOptions.value;
      const defaultSlot = slots.default;
      const itemList = defaultSlot ? itemStaticOptions : itemOptions;
      return h("div", {
        ref: refElem,
        class: ["vxe-collapse", {
          [`size--${vSize}`]: vSize,
          "is--padding": padding
        }]
      }, [
        h("div", {
          class: "vxe-collapse-slots"
        }, defaultSlot ? defaultSlot({}) : []),
        renderList(itemList)
      ]);
    };
    watch(() => props.modelValue, (val) => {
      reactData.activeNames = val || [];
    });
    const optsFlag = ref(0);
    watch(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    watch(() => props.options, () => {
      optsFlag.value++;
    });
    watch(optsFlag, () => {
      initDefaultName(props.options);
    });
    const stFlag = ref(0);
    watch(() => reactData.staticPanes ? reactData.staticPanes.length : -1, () => {
      stFlag.value++;
    });
    watch(() => reactData.staticPanes, () => {
      stFlag.value++;
    });
    watch(stFlag, () => {
      initDefaultName(reactData.staticPanes);
    });
    reactData.activeNames = props.modelValue || [];
    initDefaultName(reactData.staticPanes.length ? reactData.staticPanes : props.options);
    provide("$xeCollapse", $xeCollapse);
    $xeCollapse.renderVN = renderVN;
    return $xeCollapse;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/collapse/index.js
var VxeCollapse = Object.assign({}, collapse_default, {
  install(app) {
    app.component(collapse_default.name, collapse_default);
  }
});
dynamicApp.use(VxeCollapse);
VxeUI.component(collapse_default);
var Collapse = VxeCollapse;
var collapse_default2 = VxeCollapse;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/collapse/src/collapse-pane.js
var import_xe_utils19 = __toESM(require_xe_utils());

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/collapse/src/util.js
var import_xe_utils18 = __toESM(require_xe_utils());
function assembleCollapseItem($xeCollapse, elem, collapseConfig) {
  const staticPanes = $xeCollapse.reactData.staticPanes;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticPanes.splice(import_xe_utils18.default.arrayIndexOf(parentElem.children, elem), 0, collapseConfig);
    $xeCollapse.reactData.staticPanes = staticPanes.slice(0);
  }
}
function destroyCollapseItem($xeCollapse, collapseConfig) {
  const staticPanes = $xeCollapse.reactData.staticPanes;
  const matchObj = import_xe_utils18.default.findTree(staticPanes, (item) => item.id === collapseConfig.id, { children: "children" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeCollapse.reactData.staticPanes = staticPanes.slice(0);
}

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/collapse/src/collapse-pane.js
var collapse_pane_default = defineComponent({
  name: "VxeCollapsePane",
  props: {
    title: [String, Number],
    name: [String, Number],
    icon: String,
    preload: Boolean,
    permissionCode: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils19.default.uniqueId();
    const $xeCollapse = inject("$xeCollapse", null);
    const refElem = ref();
    const reactData = reactive({});
    const collapseConfig = reactive({
      id: xID,
      title: props.title,
      name: props.name,
      icon: props.icon,
      preload: props.preload,
      permissionCode: props.permissionCode,
      slots
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeCollapsePane = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $collapsePane: $xeCollapsePane }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeCollapsePane, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      return h("div", {
        ref: refElem
      }, []);
    };
    watch(() => props.title, (val) => {
      collapseConfig.title = val;
    });
    watch(() => props.name, (val) => {
      collapseConfig.name = val;
    });
    watch(() => props.icon, (val) => {
      collapseConfig.icon = val;
    });
    watch(() => props.permissionCode, (val) => {
      collapseConfig.permissionCode = val;
    });
    onMounted(() => {
      const elem = refElem.value;
      if ($xeCollapse && elem) {
        assembleCollapseItem($xeCollapse, elem, collapseConfig);
      }
    });
    onUnmounted(() => {
      if ($xeCollapse) {
        destroyCollapseItem($xeCollapse, collapseConfig);
      }
    });
    $xeCollapsePane.renderVN = renderVN;
    return $xeCollapsePane;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/collapse-pane/index.js
var VxeCollapsePane = Object.assign({}, collapse_pane_default, {
  install(app) {
    app.component(collapse_pane_default.name, collapse_pane_default);
  }
});
dynamicApp.use(VxeCollapsePane);
VxeUI.component(collapse_pane_default);
var CollapsePane = VxeCollapsePane;
var collapse_pane_default2 = VxeCollapsePane;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/color-picker/src/color-picker.js
var import_xe_utils21 = __toESM(require_xe_utils());

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/color-picker/src/util.js
var import_xe_utils20 = __toESM(require_xe_utils());
var hexAlphaKeyMaps = {};
var hexAlphaNumMaps = {};
"FF,FC,FA,F7,F5,F2,F0,ED,EB,E8,E6,E3,E0,DE,DB,D9,D6,D4,D1,CF,CC,C9,C7,C4,C2,BF,BD,BA,B8,B5,B3,B0,AD,AB,A8,A6,A3,A1,9E,9C,99,96,94,91,8F,8C,8A,87,85,82,80,7D,7A,78,75,73,70,6E,6B,69,66,63,61,5E,5C,59,57,54,52,4F,4D,4A,47,45,42,40,3D,3B,38,36,33,30,2E,2B,29,26,24,21,1F,1C,1A,17,14,12,0F,0D,0A,08,05,03,00".split(",").forEach((key, i) => {
  const num = (100 - i) / 100;
  hexAlphaKeyMaps[key] = num;
  hexAlphaNumMaps[num] = key;
});
var rgbRE = /^rgb(a?)\((\d{1,3})[,\s]+(\d{1,3})[,\s]+(\d{1,3})([,//\s]+([0-9.]{1,4})(%?))?\)$/;
var hexRE = /^(#?)([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;
function parseColor(value) {
  const rest = {
    value: "",
    type: "",
    hex: "",
    hexV: "",
    hexA: "",
    r: 0,
    g: 0,
    b: 0,
    a: 1
  };
  if (value) {
    const hexRest = value.match(hexRE);
    if (hexRest) {
      rest.value = value;
      rest.type = "hex";
      rest.hex = value;
      rest.hexV = hexRest[2];
      rest.hexA = hexRest[3] || "";
      rest.a = (hexRest[3] ? hexAlphaKeyMaps[hexRest[3].toUpperCase()] : 1) || 1;
    }
    const rgbRest = value.match(rgbRE);
    if (rgbRest) {
      rest.value = value;
      rest.type = rgbRest[6] ? "rgba" : "rgb";
      rest.r = parseInt(rgbRest[2]);
      rest.g = parseInt(rgbRest[3]);
      rest.b = parseInt(rgbRest[4]);
      rest.a = rgbRest[7] ? parseInt(rgbRest[6]) / 100 : rgbRest[6] ? parseFloat(rgbRest[6]) : 1;
    }
  }
  return rest;
}
function updateColorAlpha(value, alpha = 1) {
  const colorRest = parseColor(value);
  const { type, hexV, r, g, b } = colorRest;
  if (type === "rgb" || type === "rgba") {
    return toRgb(r, g, b, alpha);
  }
  if (type === "hex") {
    return `#${hexV}${alpha === 1 ? "" : hexAlphaNumMaps[alpha] || ""}`;
  }
  return "";
}
function toRgb(r, g, b, a) {
  if (import_xe_utils20.default.eqNull(a)) {
    return `rgb(${r},${g},${b})`;
  }
  return `rgba(${r},${g},${b},${a})`;
}
function rgbToHex(rgbRest) {
  if (!rgbRest) {
    return "";
  }
  const { r, g, b, a = 1 } = rgbRest;
  const hexR = r.toString(16).padStart(2, "0");
  const hexG = g.toString(16).padStart(2, "0");
  const hexB = b.toString(16).padStart(2, "0");
  const hexA = a === 1 ? "" : hexAlphaNumMaps[a] || "";
  return `#${hexR}${hexG}${hexB}${hexA}`.toUpperCase();
}
function rgbToHsv(rgbRest) {
  if (!rgbRest) {
    return null;
  }
  const { r, g, b } = rgbRest;
  const rAbs = r / 255;
  const gAbs = g / 255;
  const bAbs = b / 255;
  let h2 = 0;
  let s = 0;
  const val = Math.max(rAbs, gAbs, bAbs);
  const num = val - Math.min(rAbs, gAbs, bAbs);
  const handleDiff = (c) => (val - c) / 6 / num + 1 / 2;
  if (num === 0) {
    h2 = s = 0;
  } else {
    s = num / val;
    const rr = handleDiff(rAbs);
    const gg = handleDiff(gAbs);
    const bb = handleDiff(bAbs);
    if (rAbs === val) {
      h2 = bb - gg;
    } else if (gAbs === val) {
      h2 = 1 / 3 + rr - bb;
    } else if (bAbs === val) {
      h2 = 2 / 3 + gg - rr;
    }
    if (h2 < 0) {
      h2 += 1;
    } else if (h2 > 1) {
      h2 -= 1;
    }
  }
  return {
    h: Math.round(h2 * 360),
    s: import_xe_utils20.default.round(s, 2),
    v: import_xe_utils20.default.round(val, 2)
  };
}
function hsvToRgb(h2, s, v) {
  let r = 0;
  let g = 0;
  let b = 0;
  const i = Math.floor(h2 / 60);
  const f = h2 / 60 - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  switch (i) {
    case 0:
      r = v;
      g = t;
      b = p;
      break;
    case 1:
      r = q;
      g = v;
      b = p;
      break;
    case 2:
      r = p;
      g = v;
      b = t;
      break;
    case 3:
      r = p;
      g = q;
      b = v;
      break;
    case 4:
      r = t;
      g = p;
      b = v;
      break;
    case 5:
      r = v;
      g = p;
      b = q;
      break;
  }
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
}
function hexToHsv(str) {
  const rgbRest = hexToRgb(str);
  if (rgbRest) {
    return rgbToHsv(rgbRest);
  }
  return null;
}
function hexToRgb(str) {
  if (str) {
    const rests = str.match(/^(#?)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})?$/);
    if (rests) {
      return {
        r: parseInt(rests[2], 16),
        g: parseInt(rests[3], 16),
        b: parseInt(rests[4], 16),
        a: (rests[5] ? hexAlphaKeyMaps[rests[5].toUpperCase()] : 1) || 1
      };
    }
  }
  return null;
}

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/color-picker/src/color-picker.js
var color_picker_default = defineComponent({
  name: "VxeColorPicker",
  props: {
    modelValue: String,
    placeholder: String,
    clearable: {
      type: Boolean,
      default: () => getConfig().colorPicker.clearable
    },
    type: {
      type: String,
      default: () => getConfig().colorPicker.type
    },
    size: {
      type: String,
      default: () => getConfig().colorPicker.size || getConfig().size
    },
    className: [String, Function],
    popupClassName: [String, Function],
    colors: {
      type: Array,
      default: () => import_xe_utils21.default.clone(getConfig().colorPicker.colors, true) || []
    },
    showAlpha: {
      type: Boolean,
      default: () => getConfig().colorPicker.showAlpha
    },
    showEyeDropper: {
      type: Boolean,
      default: () => getConfig().colorPicker.showEyeDropper
    },
    showColorExtractor: {
      type: Boolean,
      default: () => getConfig().colorPicker.showColorExtractor
    },
    showQuick: {
      type: Boolean,
      default: () => getConfig().colorPicker.showQuick
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    clickToCopy: {
      type: Boolean,
      default: () => getConfig().colorPicker.clickToCopy
    },
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const WinEyeDropper = typeof window !== "undefined" ? window.EyeDropper : null;
    const xID = import_xe_utils21.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refInput = ref();
    const refOptionPanel = ref();
    const refHueSliderElem = ref();
    const refHueSliderBtnElem = ref();
    const refAlphaSliderElem = ref();
    const refAlphaSliderBtnElem = ref();
    const refColorPanelElem = ref();
    const refColorActiveElem = ref();
    const reactData = reactive({
      initialized: false,
      selectColor: `${props.modelValue || ""}`,
      panelColor: "",
      hexValue: "",
      rValue: 0,
      gValue: 0,
      bValue: 0,
      aValue: 0,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      // hpTimeout: undefined
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().colorPicker.transfer;
        if (import_xe_utils21.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeColorList = computed(() => {
      const { colors } = props;
      if (colors) {
        return colors.map((item) => {
          if (import_xe_utils21.default.isString(item)) {
            return {
              label: item,
              value: item
            };
          }
          return {
            label: import_xe_utils21.default.eqNull(item.label) ? item.value : item.label,
            value: item.value
          };
        });
      }
      return [];
    });
    const computeValueType = computed(() => {
      const { type } = props;
      if (type === "rgb" || type === "rgba") {
        return "rgb";
      }
      return "hex";
    });
    const computeIsRgb = computed(() => {
      const valueType = computeValueType.value;
      return valueType === "rgb";
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeColorPicker = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const updateMode = () => {
      const { modelValue } = props;
      reactData.selectColor = import_xe_utils21.default.toValueString(modelValue);
      updateModelColor();
    };
    const updateModelColor = () => {
      const { selectColor, isAniVisible } = reactData;
      const isRgb = computeIsRgb.value;
      const hueSliderEl = refHueSliderElem.value;
      const alphaSliderEl = refAlphaSliderElem.value;
      const colorRest = parseColor(selectColor);
      reactData.hexValue = colorRest.hex;
      reactData.rValue = colorRest.r;
      reactData.gValue = colorRest.g;
      reactData.bValue = colorRest.b;
      reactData.aValue = colorRest.a;
      if (colorRest.value) {
        if (isRgb) {
          if (colorRest.type === "hex") {
            const rgbRest = hexToRgb(colorRest.hex);
            if (rgbRest) {
              reactData.rValue = rgbRest.r;
              reactData.gValue = rgbRest.g;
              reactData.bValue = rgbRest.b;
              reactData.aValue = rgbRest.a;
            }
          }
        } else {
          if (colorRest.type !== "hex") {
            reactData.hexValue = rgbToHex(colorRest);
          }
        }
      }
      if (isAniVisible) {
        const hsvRest = colorRest.type === "hex" ? hexToHsv(colorRest.hex) : rgbToHsv(colorRest);
        const colorPanelEl = refColorPanelElem.value;
        if (hsvRest) {
          if (colorPanelEl) {
            const offsetTop = colorPanelEl.clientHeight * (1 - hsvRest.v);
            const offsetLeft = colorPanelEl.clientWidth * hsvRest.s;
            handlePanelColor(offsetLeft, offsetTop);
          }
          if (hueSliderEl) {
            handleHueColor(import_xe_utils21.default.ceil((1 - hsvRest.h / 360) * hueSliderEl.clientWidth));
          }
        }
        if (alphaSliderEl) {
          handleAlphaColor(alphaSliderEl.clientWidth * colorRest.a);
        }
      }
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (panelElem && el) {
          const targetHeight = el.offsetHeight;
          const targetWidth = el.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(el);
          let panelPlacement = "bottom";
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showOptionPanel = () => {
      const { hpTimeout } = internalData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (hpTimeout) {
          clearTimeout(hpTimeout);
          internalData.hpTimeout = void 0;
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(() => {
          updateModelColor();
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      internalData.hpTimeout = setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, value) => {
      reactData.selectColor = value;
      if (value !== props.modelValue) {
        emitModel(value);
        dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue);
      dispatchEvent("clear", { value: selectValue }, evnt);
    };
    const focusEvent = () => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
      }
    };
    const blurEvent = () => {
      reactData.isActivated = false;
    };
    const clearEvent = (evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const confirmEvent = (evnt) => {
      const { selectColor } = reactData;
      changeEvent(evnt, selectColor);
      hideOptionPanel();
    };
    const togglePanelEvent = (evnt) => {
      evnt.preventDefault();
      if (reactData.visiblePanel) {
        hideOptionPanel();
      } else {
        showOptionPanel();
      }
    };
    const clickEvent = (evnt) => {
      togglePanelEvent(evnt);
      dispatchEvent("click", {}, evnt);
    };
    const handleHueColor = (offsetLeft) => {
      const hueSliderEl = refHueSliderElem.value;
      const hueSliderBtnEl = refHueSliderBtnElem.value;
      if (hueSliderEl && hueSliderBtnEl) {
        if (offsetLeft < 0) {
          offsetLeft = 0;
        }
        const barWidth = import_xe_utils21.default.toInteger(hueSliderEl.clientWidth);
        const itemNum = 255;
        const countNum = itemNum * 6;
        const offsetX = import_xe_utils21.default.ceil(countNum / barWidth * offsetLeft);
        const offsetNum = offsetX % itemNum;
        let rNum = 0;
        let gNum = 0;
        let bNum = 0;
        switch (Math.ceil(offsetX / itemNum)) {
          case 1:
            rNum = itemNum;
            bNum = offsetNum;
            break;
          case 2:
            rNum = itemNum - offsetNum;
            bNum = itemNum;
            break;
          case 3:
            gNum = offsetNum;
            bNum = itemNum;
            break;
          case 4:
            gNum = itemNum;
            bNum = itemNum - offsetNum;
            break;
          case 5:
            rNum = offsetNum;
            gNum = itemNum;
            break;
          case 6:
            rNum = itemNum;
            gNum = itemNum - offsetNum;
            break;
        }
        reactData.panelColor = toRgb(rNum, gNum, bNum);
        hueSliderBtnEl.style.left = toCssUnit(offsetLeft);
      }
    };
    const handleHueBarEvent = (evnt) => {
      const hueSliderEl = refHueSliderElem.value;
      const hueSliderBtnEl = refHueSliderBtnElem.value;
      if (hueSliderEl && hueSliderBtnEl) {
        const hueSliderRect = hueSliderEl.getBoundingClientRect();
        const barWidth = import_xe_utils21.default.toInteger(hueSliderEl.clientWidth);
        const offsetLeft = import_xe_utils21.default.ceil(Math.min(barWidth - 1, Math.max(1, evnt.clientX - hueSliderRect.x)));
        handleHueColor(offsetLeft);
      }
    };
    const handleHueSliderMousedownEvent = (evnt) => {
      evnt.preventDefault();
      document.onmousemove = (evnt2) => {
        evnt2.preventDefault();
        handleHueBarEvent(evnt2);
      };
      document.onmouseup = (evnt2) => {
        document.onmousemove = null;
        document.onmouseup = null;
        handleHueBarEvent(evnt2);
      };
    };
    const handleAlphaColor = (offsetLeft) => {
      const { selectColor } = reactData;
      const alphaSliderEl = refAlphaSliderElem.value;
      const alphaSliderBtnEl = refAlphaSliderBtnElem.value;
      if (alphaSliderEl && alphaSliderBtnEl) {
        const alphaSliderRect = alphaSliderEl.getBoundingClientRect();
        const barWidth = alphaSliderRect.width;
        if (offsetLeft < 0) {
          offsetLeft = 0;
        }
        if (offsetLeft > barWidth) {
          offsetLeft = barWidth;
        }
        const alpha = import_xe_utils21.default.ceil(100 / barWidth * offsetLeft / 100, 2);
        reactData.aValue = alpha;
        alphaSliderBtnEl.style.left = toCssUnit(offsetLeft);
        reactData.selectColor = updateColorAlpha(selectColor, alpha);
      }
    };
    const handleAlphaBarEvent = (evnt) => {
      const alphaSliderEl = refAlphaSliderElem.value;
      const alphaSliderBtnEl = refAlphaSliderBtnElem.value;
      if (alphaSliderEl && alphaSliderBtnEl) {
        const alphaSliderRect = alphaSliderEl.getBoundingClientRect();
        const barWidth = alphaSliderRect.width;
        const offsetLeft = Math.min(barWidth, Math.max(0, evnt.clientX - alphaSliderRect.x));
        handleAlphaColor(offsetLeft);
        updateModelColor();
      }
    };
    const handleAlphaSliderMousedownEvent = (evnt) => {
      evnt.preventDefault();
      document.onmousemove = (evnt2) => {
        evnt2.preventDefault();
        handleAlphaBarEvent(evnt2);
      };
      document.onmouseup = (evnt2) => {
        document.onmousemove = null;
        document.onmouseup = null;
        handleAlphaBarEvent(evnt2);
      };
    };
    const handleInputRgbEvent = () => {
      const { rValue, gValue, bValue, aValue } = reactData;
      reactData.selectColor = toRgb(rValue, gValue, bValue, aValue);
      updateModelColor();
    };
    const handleInputAlphaEvent = () => {
      const { aValue } = reactData;
      const alphaSliderEl = refAlphaSliderElem.value;
      const alphaSliderBtnEl = refAlphaSliderBtnElem.value;
      if (alphaSliderEl && alphaSliderBtnEl) {
        const alphaSliderRect = alphaSliderEl.getBoundingClientRect();
        const barWidth = alphaSliderRect.width;
        const offsetLeft = barWidth * aValue;
        handleAlphaColor(offsetLeft);
      }
    };
    const handleQuickEvent = (evnt, item) => {
      const value = item.value;
      reactData.selectColor = value;
      updateModelColor();
    };
    const handlePanelColor = (offsetLeft, offsetTop) => {
      const colorActiveEl = refColorActiveElem.value;
      if (colorActiveEl) {
        colorActiveEl.style.top = toCssUnit(offsetTop);
        colorActiveEl.style.left = toCssUnit(offsetLeft);
      }
    };
    const handleEyeDropperEvent = () => {
      if (WinEyeDropper) {
        try {
          const eyeDropper = new WinEyeDropper();
          eyeDropper.open().then((rest) => {
            if (rest && rest.sRGBHex) {
              reactData.selectColor = rest.sRGBHex;
              updateModelColor();
            }
          }).catch(() => {
          });
        } catch (e) {
        }
      }
    };
    const handleSelectColorMousedownEvent = (evnt) => {
      const { showAlpha } = props;
      const { panelColor, aValue } = reactData;
      const colorPanelEl = refColorPanelElem.value;
      const colorActiveEl = refColorActiveElem.value;
      if (colorPanelEl && colorActiveEl) {
        const colorPanelRect = colorPanelEl.getBoundingClientRect();
        const offsetTop = evnt.clientY - colorPanelRect.y;
        const offsetLeft = evnt.clientX - colorPanelRect.x;
        const colorRest = parseColor(panelColor);
        if (colorRest) {
          const hsvRest = colorRest.type === "hex" ? hexToHsv(colorRest.hex) : rgbToHsv(colorRest);
          if (hsvRest) {
            const ragRest = hsvToRgb(hsvRest.h, offsetLeft / colorPanelEl.clientWidth, 1 - offsetTop / colorPanelEl.clientHeight);
            reactData.selectColor = toRgb(ragRest.r, ragRest.g, ragRest.b, showAlpha ? aValue : null);
            handlePanelColor(offsetLeft, offsetTop);
            updateModelColor();
          }
        }
      }
    };
    const handleCopyColorEvent = () => {
      const { selectColor } = reactData;
      if (selectColor) {
        if (VxeUI.clipboard.copy(selectColor)) {
          if (VxeUI.modal) {
            VxeUI.modal.message({
              content: getI18n("vxe.colorPicker.copySuccess", [selectColor]),
              status: "success"
            });
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      hideOptionPanel();
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $colorPicker: $xeColorPicker }, params));
    };
    const colorPickerMethods = {
      dispatchEvent
    };
    const colorPickerPrivateMethods = {};
    Object.assign($xeColorPicker, colorPickerMethods, colorPickerPrivateMethods);
    const renderColorWrapper = () => {
      const { showColorExtractor } = props;
      const { panelColor } = reactData;
      if (showColorExtractor) {
        return h("div", {
          ref: refColorPanelElem,
          class: "vxe-color-picker--color-wrapper",
          onMousedown: handleSelectColorMousedownEvent
        }, [
          h("div", {
            class: "vxe-color-picker--color-bg",
            style: {
              backgroundColor: panelColor
            }
          }),
          h("div", {
            class: "vxe-color-picker--white-bg"
          }),
          h("div", {
            class: "vxe-color-picker--black-bg"
          }),
          h("div", {
            ref: refColorActiveElem,
            class: "vxe-color-picker--color-active"
          })
        ]);
      }
      return renderEmptyElement($xeColorPicker);
    };
    const renderColorBar = () => {
      const { showAlpha, clickToCopy, showEyeDropper } = props;
      const { hexValue, rValue, gValue, bValue, aValue, selectColor, panelColor } = reactData;
      const valueType = computeValueType.value;
      const isRgb = computeIsRgb.value;
      return h("div", {
        class: "vxe-color-picker--bar-wrapper"
      }, [
        h("div", {
          class: "vxe-color-picker--slider-wrapper"
        }, [
          showEyeDropper && WinEyeDropper ? h("div", {
            class: "vxe-color-picker--color-dropper"
          }, [
            h("span", {
              class: "vxe-color-picker--color-dropper-btn",
              onClick: handleEyeDropperEvent
            }, [
              h("i", {
                class: getIcon().EYE_DROPPER
              })
            ])
          ]) : renderEmptyElement($xeColorPicker),
          h("div", {
            class: "vxe-color-picker--slider-preview"
          }, [
            h("div", {
              class: "vxe-color-picker--preview-btn"
            }, [
              h("div", {
                class: "vxe-color-picker--preview-color",
                style: {
                  backgroundColor: selectColor
                }
              }, clickToCopy ? [
                h("span", {
                  class: "vxe-color-picker--preview-copy-btn",
                  onClick: handleCopyColorEvent
                }, [
                  h("i", {
                    class: getIcon().COLOR_COPY
                  })
                ])
              ] : [])
            ])
          ]),
          h("div", {
            class: "vxe-color-picker--slider-handle"
          }, [
            h("div", {
              ref: refHueSliderElem,
              class: "vxe-color-picker--bar-hue-slider",
              onClick: handleHueBarEvent
            }, [
              h("div", {
                ref: refHueSliderBtnElem,
                class: "vxe-color-picker--bar-hue-btn",
                onMousedown: handleHueSliderMousedownEvent
              })
            ]),
            showAlpha ? h("div", {
              ref: refAlphaSliderElem,
              class: "vxe-color-picker--bar-alpha-slider",
              onClick: handleAlphaBarEvent
            }, [
              h("div", {
                class: "vxe-color-picker--bar-alpha-bg",
                style: {
                  background: `linear-gradient(to right, rgba(0, 0, 0, 0), ${panelColor})`
                }
              }),
              h("div", {
                ref: refAlphaSliderBtnElem,
                class: "vxe-color-picker--bar-alpha-btn",
                onMousedown: handleAlphaSliderMousedownEvent
              })
            ]) : renderEmptyElement($xeColorPicker)
          ])
        ]),
        h("div", {
          class: `vxe-color-picker--${valueType}-wrapper`
        }, isRgb ? [
          h("div", {
            class: "vxe-color-picker--input-wrapper"
          }, [
            h(input_default, {
              type: "integer",
              size: "mini",
              align: "center",
              min: 0,
              max: 255,
              maxLength: 3,
              placeholder: "",
              modelValue: rValue,
              "onUpdate:modelValue"(val) {
                reactData.rValue = val;
              },
              onChange: handleInputRgbEvent
            }),
            h(input_default, {
              type: "integer",
              size: "mini",
              align: "center",
              min: 0,
              max: 255,
              maxLength: 3,
              placeholder: "",
              modelValue: gValue,
              "onUpdate:modelValue"(val) {
                reactData.gValue = val;
              },
              onChange: handleInputRgbEvent
            }),
            h(input_default, {
              type: "integer",
              size: "mini",
              align: "center",
              min: 0,
              max: 255,
              maxLength: 3,
              placeholder: "",
              modelValue: bValue,
              "onUpdate:modelValue"(val) {
                reactData.bValue = val;
              },
              onChange: handleInputRgbEvent
            }),
            h(input_default, {
              type: "number",
              size: "mini",
              align: "center",
              min: 0,
              max: 1,
              step: 0.01,
              maxLength: 4,
              placeholder: "",
              modelValue: aValue,
              "onUpdate:modelValue"(val) {
                reactData.aValue = val;
              },
              onChange: handleInputAlphaEvent
            })
          ]),
          h("div", {
            class: "vxe-color-picker--input-title"
          }, [
            h("span", "R"),
            h("span", "G"),
            h("span", "B"),
            h("span", "A")
          ])
        ] : [
          h("div", {
            class: "vxe-color-picker--input-title"
          }, "HEX"),
          h("div", {
            class: "vxe-color-picker--input-wrapper"
          }, [
            h(input_default, {
              type: "text",
              size: "mini",
              align: "center",
              maxLength: 9,
              placeholder: "",
              modelValue: hexValue,
              "onUpdate:modelValue"(val) {
                reactData.hexValue = val;
              },
              onChange() {
                const colorRest = parseColor(reactData.hexValue);
                if (colorRest) {
                  if (colorRest.value) {
                    reactData.selectColor = colorRest.value;
                    updateModelColor();
                  }
                }
              }
            })
          ])
        ])
      ]);
    };
    const renderQuickWrapper = () => {
      const { showQuick } = props;
      const colorList = computeColorList.value;
      if (showQuick && colorList.length) {
        return h("div", {
          class: "vxe-color-picker--quick-wrapper"
        }, colorList.map((item, i) => {
          return h("div", {
            key: i,
            class: "vxe-color-picker--quick-item",
            title: item.label || "",
            style: {
              backgroundColor: item.value
            },
            onClick(evnt) {
              handleQuickEvent(evnt, item);
            }
          });
        }));
      }
      return renderEmptyElement($xeColorPicker);
    };
    const renderVN = () => {
      const { className, popupClassName, clearable, modelValue } = props;
      const { initialized, isActivated, isAniVisible, visiblePanel } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-color-picker--readonly", className]
        }, [
          h("div", {
            class: "vxe-color-picker--readonly-color",
            style: {
              backgroundColor: modelValue
            }
          })
        ]);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-color-picker", className ? import_xe_utils21.default.isFunction(className) ? className({ $colorPicker: $xeColorPicker }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--selected": !!modelValue,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--active": isActivated
        }]
      }, [
        h("input", {
          ref: refInput,
          class: "vxe-color-picker--input",
          onFocus: focusEvent,
          onBlur: blurEvent
        }),
        h("div", {
          class: "vxe-color-picker--inner",
          onClick: clickEvent
        }, [
          h("div", {
            class: "vxe-color-picker--inner-color",
            style: {
              backgroundColor: modelValue
            }
          })
        ]),
        h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-color-picker--panel", popupClassName ? import_xe_utils21.default.isFunction(popupClassName) ? popupClassName({ $colorPicker: $xeColorPicker }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": isAniVisible,
              "ani--enter": visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, [
            initialized && (visiblePanel || isAniVisible) ? h("div", {
              class: "vxe-color-picker--panel-wrapper"
            }, [
              renderColorWrapper(),
              renderColorBar(),
              renderQuickWrapper(),
              h("div", {
                class: "vxe-color-picker--footer-wrapper"
              }, [
                clearable ? h(button_default, {
                  content: getI18n("vxe.colorPicker.clear"),
                  size: "mini",
                  onClick: clearEvent
                }) : renderEmptyElement($xeColorPicker),
                h(button_default, {
                  content: getI18n("vxe.colorPicker.confirm"),
                  size: "mini",
                  status: "primary",
                  onClick: confirmEvent
                })
              ])
            ]) : renderEmptyElement($xeColorPicker)
          ])
        ])
      ]);
    };
    watch(() => props.modelValue, () => {
      updateMode();
    });
    onMounted(() => {
      globalEvents.on($xeColorPicker, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeColorPicker, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeColorPicker, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeColorPicker, "mousewheel");
      globalEvents.off($xeColorPicker, "mousedown");
      globalEvents.off($xeColorPicker, "blur");
    });
    updateMode();
    provide("$xeColorPicker", $xeColorPicker);
    $xeColorPicker.renderVN = renderVN;
    return $xeColorPicker;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/color-picker/index.js
var VxeColorPicker = Object.assign({}, color_picker_default, {
  install(app) {
    app.component(color_picker_default.name, color_picker_default);
  }
});
dynamicApp.use(VxeColorPicker);
VxeUI.component(color_picker_default);
var ColorPicker = VxeColorPicker;
var color_picker_default2 = VxeColorPicker;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/text/src/text.js
var import_xe_utils22 = __toESM(require_xe_utils());
var text_default = defineComponent({
  name: "VxeText",
  props: {
    status: String,
    title: [String, Number],
    icon: String,
    loading: Boolean,
    content: [String, Number],
    clickToCopy: Boolean,
    size: {
      type: String,
      default: () => getConfig().text.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils22.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refContentElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const clickIconEvent = () => {
      const { content, clickToCopy } = props;
      if (clickToCopy) {
        const contentEl = refContentElem.value;
        const copyVal = (contentEl ? contentEl.textContent : "") || content;
        if (copyVal) {
          if (VxeUI.clipboard.copy(copyVal)) {
            if (VxeUI.modal) {
              VxeUI.modal.message({
                content: getI18n("vxe.text.copySuccess"),
                status: "success"
              });
            }
          } else {
            if (VxeUI.modal) {
              VxeUI.modal.message({
                content: getI18n("vxe.text.copyError"),
                status: "error"
              });
            }
          }
        }
      }
    };
    const $xeText = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $text: $xeText }, params));
    };
    const textMethods = {
      dispatchEvent
    };
    const clickEvent = (evnt) => {
      const { loading: loading2 } = props;
      if (!loading2) {
        dispatchEvent("click", {}, evnt);
      }
    };
    const textPrivateMethods = {};
    Object.assign($xeText, textMethods, textPrivateMethods);
    const renderContent = () => {
      const { loading: loading2, icon, content, clickToCopy } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      return [
        loading2 ? h("span", {
          class: "vxe-text--loading"
        }, [
          h("i", {
            class: getIcon().TEXT_LOADING
          })
        ]) : iconSlot || icon || clickToCopy ? h("span", {
          class: "vxe-text--icon",
          onClick: clickIconEvent
        }, iconSlot ? getSlotVNs(iconSlot({})) : [
          h("i", {
            class: icon || getIcon().TEXT_COPY
          })
        ]) : createCommentVNode(),
        h("span", {
          ref: refContentElem,
          class: "vxe-text--content"
        }, defaultSlot ? defaultSlot({}) : import_xe_utils22.default.toValueString(content))
      ];
    };
    const renderVN = () => {
      const { loading: loading2, status, title, clickToCopy } = props;
      const vSize = computeSize.value;
      return h("span", {
        ref: refElem,
        title,
        class: ["vxe-text", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--copy": clickToCopy,
          "is--loading": loading2
        }],
        onClick: clickEvent
      }, renderContent());
    };
    $xeText.renderVN = renderVN;
    return $xeText;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/countdown/src/countdown.js
var import_xe_utils23 = __toESM(require_xe_utils());
var countdown_default = defineComponent({
  name: "VxeCountdown",
  props: {
    modelValue: [Number, String],
    format: String,
    prefixConfig: Object,
    suffixConfig: Object,
    size: {
      type: String,
      default: () => getConfig().countdown.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "start",
    "end"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils23.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      currNum: 0,
      secondNum: 0
    });
    const internalData = {
      dnTimeout: void 0
    };
    const refMaps = {
      refElem
    };
    const computeTimeFormats = computed(() => {
      const { secondNum } = reactData;
      if (secondNum >= 316224e5) {
        return ["yyyy", "MM", "dd", "HH", "mm", "ss"];
      }
      if (secondNum >= 26784e5) {
        return ["MM", "dd", "HH", "mm", "ss"];
      }
      if (secondNum >= 864e5) {
        return ["dd", "HH", "mm", "ss"];
      }
      if (secondNum >= 36e5) {
        return ["HH", "mm", "ss"];
      }
      if (secondNum >= 6e4) {
        return ["mm", "ss"];
      }
      return ["ss"];
    });
    const computeDiffConf = computed(() => {
      const { currNum } = reactData;
      return import_xe_utils23.default.getDateDiff(Date.now(), Date.now() + currNum);
    });
    const computeFormatLabel = computed(() => {
      const { format } = props;
      const diffConf = computeDiffConf.value;
      let rest = "";
      if (format) {
        rest = `${format}`;
        import_xe_utils23.default.each(diffConf, (val, key) => {
          rest = rest.replace(new RegExp(key, "g"), import_xe_utils23.default.padStart(val, key.length, "0"));
        });
        return rest;
      }
      return rest;
    });
    const computePrefixOpts = computed(() => {
      return Object.assign({}, props.prefixConfig, getConfig().countdown.prefixConfig);
    });
    const computeSuffixOpts = computed(() => {
      return Object.assign({}, props.suffixConfig, getConfig().countdown.suffixConfig);
    });
    const computeMaps = {
      computeSize
    };
    const $xeCountdown = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $carousel: $xeCountdown }, params));
    };
    const updateCount = () => {
      const secondNum = import_xe_utils23.default.toNumber(props.modelValue || 0);
      reactData.secondNum = secondNum;
      reactData.currNum = secondNum;
    };
    const handleTime = () => {
      const { currNum } = reactData;
      if (currNum > 1e3) {
        reactData.currNum -= 1e3;
        internalData.dnTimeout = setTimeout(() => {
          handleTime();
        }, 1e3);
      } else {
        reactData.currNum = 0;
        handleStop();
      }
    };
    const countdownMethods = {
      dispatchEvent
    };
    const handleStart = () => {
      dispatchEvent("start", {}, null);
      handleTime();
    };
    const handleStop = () => {
      const { dnTimeout } = internalData;
      if (dnTimeout) {
        clearTimeout(dnTimeout);
        internalData.dnTimeout = void 0;
        dispatchEvent("end", {}, null);
      }
    };
    const countdownPrivateMethods = {};
    Object.assign($xeCountdown, countdownMethods, countdownPrivateMethods);
    const renderDefaultContentVNs = () => {
      const { format } = props;
      const timeFormats = computeTimeFormats.value;
      const diffConf = computeDiffConf.value;
      const formatLabel = computeFormatLabel.value;
      if (format) {
        return [
          h("div", {
            key: "format",
            class: "vxe-countdown--content-format"
          }, formatLabel)
        ];
      }
      return timeFormats.map((key, index) => {
        return h("div", {
          key: index,
          class: "vxe-countdown--content-item"
        }, [
          h("div", {
            class: "vxe-countdown--content-num"
          }, `${diffConf[key] || 0}`),
          h("div", {
            class: "vxe-countdown--content-unit"
          }, getI18n(`vxe.countdown.formats.${key}`))
        ]);
      });
    };
    const renderVN = () => {
      const { prefixConfig, suffixConfig } = props;
      const { currNum } = reactData;
      const vSize = computeSize.value;
      const diffConf = computeDiffConf.value;
      const prefixOpts = computePrefixOpts.value;
      const suffixOpts = computeSuffixOpts.value;
      const prefixSlot = slots.prefix;
      const suffixSlot = slots.suffix;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-countdown", diffConf.done ? "is--progress" : "is-end", {
          [`size--${vSize}`]: vSize
        }]
      }, [
        prefixSlot || prefixConfig ? h("div", {
          class: "vxe-countdown--prefix"
        }, prefixSlot ? getSlotVNs(prefixSlot({ currentValue: currNum, diffConf })) : [
          h(text_default, {
            content: prefixOpts.content,
            icon: prefixOpts.icon,
            status: prefixOpts.status
          })
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-countdown--content"
        }, defaultSlot ? getSlotVNs(defaultSlot({ currentValue: currNum, diffConf })) : renderDefaultContentVNs()),
        suffixSlot || suffixConfig ? h("div", {
          class: "vxe-countdown--suffix"
        }, suffixSlot ? getSlotVNs(suffixSlot({ currentValue: currNum, diffConf })) : [
          h(text_default, {
            content: suffixOpts.content,
            icon: suffixOpts.icon,
            status: suffixOpts.status
          })
        ]) : createCommentVNode()
      ]);
    };
    watch(() => props.modelValue, () => {
      updateCount();
      handleStop();
      handleStart();
    });
    onUnmounted(() => {
      handleStop();
    });
    onMounted(() => {
      handleStart();
    });
    updateCount();
    $xeCountdown.renderVN = renderVN;
    return $xeCountdown;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/countdown/index.js
var VxeCountdown = Object.assign({}, countdown_default, {
  install(app) {
    app.component(countdown_default.name, countdown_default);
  }
});
dynamicApp.use(VxeCountdown);
VxeUI.component(countdown_default);
var Countdown = VxeCountdown;
var countdown_default2 = VxeCountdown;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/date-picker/src/date-picker.js
var import_xe_utils24 = __toESM(require_xe_utils());
var date_picker_default = defineComponent({
  name: "VxeDatePicker",
  props: {
    modelValue: [String, Number, Date],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    type: {
      type: String,
      default: "date"
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().datePicker.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    autoComplete: {
      type: String,
      default: "off"
    },
    align: String,
    form: String,
    className: String,
    size: {
      type: String,
      default: () => getConfig().datePicker.size || getConfig().size
    },
    multiple: Boolean,
    limitCount: {
      type: [String, Number],
      default: () => getConfig().upload.limitCount
    },
    // date、week、month、quarter、year
    startDate: {
      type: [String, Number, Date],
      default: () => getConfig().datePicker.startDate
    },
    endDate: {
      type: [String, Number, Date],
      default: () => getConfig().datePicker.endDate
    },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    startDay: {
      type: [String, Number],
      default: () => getConfig().datePicker.startDay
    },
    labelFormat: String,
    valueFormat: String,
    editable: {
      type: Boolean,
      default: true
    },
    festivalMethod: {
      type: Function,
      default: () => getConfig().datePicker.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().datePicker.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().datePicker.selectDay
    },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    },
    shortcutConfig: Object,
    // 已废弃 startWeek，被 startDay 替换
    startWeek: Number,
    // 已废弃
    maxlength: [String, Number],
    // 已废弃
    autocomplete: String
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "keydown",
    "keyup",
    "click",
    "focus",
    "blur",
    "clear",
    "prefix-click",
    "suffix-click",
    "date-prev",
    "date-today",
    "date-next",
    "shortcut-click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils24.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      panelIndex: 0,
      visiblePanel: false,
      isAniVisible: false,
      panelStyle: {},
      panelPlacement: "",
      isActivated: false,
      inputValue: "",
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: "",
      datePanelType: "day",
      selectMonth: null,
      currentDate: null
    });
    const internalData = {
      yearSize: 12,
      monthSize: 20,
      quarterSize: 8,
      hpTimeout: void 0
    };
    const refElem = ref();
    const refInputTarget = ref();
    const refInputPanel = ref();
    const refPanelWrapper = ref();
    const refInputTimeBody = ref();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeDatePicker = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let datePickerMethods = {};
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().datePicker.transfer;
        if (import_xe_utils24.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsDateTimeType = computed(() => {
      const { type } = props;
      return type === "time" || type === "datetime";
    });
    const computeIsDatePickerType = computed(() => {
      const isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeIsClearable = computed(() => {
      return props.clearable;
    });
    const computeDateStartTime = computed(() => {
      return props.startDate ? import_xe_utils24.default.toStringDate(props.startDate) : null;
    });
    const computeDateEndTime = computed(() => {
      return props.endDate ? import_xe_utils24.default.toStringDate(props.endDate) : null;
    });
    const computeSupportMultiples = computed(() => {
      return ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeDateListValue = computed(() => {
      const { modelValue, multiple } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && modelValue && isDatePickerType) {
        return import_xe_utils24.default.toValueString(modelValue).split(",").map((item) => {
          const date = parseDate(item, dateValueFormat);
          if (import_xe_utils24.default.isValidDate(date)) {
            return date;
          }
          return date;
        });
      }
      return [];
    });
    const computeDateMultipleValue = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map((date) => import_xe_utils24.default.toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map((date) => import_xe_utils24.default.toDateString(date, dateLabelFormat)).join(", ");
    });
    const computeLimitMaxCount = computed(() => {
      return props.multiple ? import_xe_utils24.default.toNumber(props.limitCount) : 0;
    });
    const computeOverCount = computed(() => {
      const { multiple } = props;
      const limitMaxCount = computeLimitMaxCount.value;
      const dateMultipleValue = computeDateMultipleValue.value;
      if (multiple && limitMaxCount) {
        return dateMultipleValue.length >= limitMaxCount;
      }
      return false;
    });
    const computeDateValueFormat = computed(() => {
      const { type, valueFormat } = props;
      if (valueFormat) {
        return valueFormat;
      }
      if (type === "time") {
        return "HH:mm:ss";
      }
      if (type === "datetime") {
        return "yyyy-MM-dd HH:mm:ss";
      }
      return "yyyy-MM-dd";
    });
    const computeDateValue = computed(() => {
      const { modelValue } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (modelValue && isDatePickerType) {
        const date = parseDate(modelValue, dateValueFormat);
        if (import_xe_utils24.default.isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = computed(() => {
      const dateStartTime = computeDateStartTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = computed(() => {
      const dateEndTime = computeDateEndTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    const computeDateTimeLabel = computed(() => {
      const { datetimePanelValue } = reactData;
      const hasTimeSecond = computeHasTimeSecond.value;
      if (datetimePanelValue) {
        return import_xe_utils24.default.toDateString(datetimePanelValue, hasTimeSecond ? "HH:mm:ss" : "HH:mm");
      }
      return "";
    });
    const computeDateHMSTime = computed(() => {
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      return dateValue && isDateTimeType ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1e3 : 0;
    });
    const computeDateLabelFormat = computed(() => {
      const { labelFormat } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        return labelFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return null;
    });
    const computeYearList = computed(() => {
      const { yearSize } = internalData;
      const { selectMonth, currentDate } = reactData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index = -4; index < yearSize + 4; index++) {
          const date = import_xe_utils24.default.getWhatYear(startYearDate, index, "first");
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelObj = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      let y = "";
      let m = "";
      if (isDatePickerType) {
        const { datePanelType, selectMonth } = reactData;
        const yearList = computeYearList.value;
        let year = "";
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === "quarter" || datePanelType === "month") {
          y = getI18n("vxe.datePicker.yearTitle", [year]);
        } else if (datePanelType === "year") {
          y = yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : "";
        } else {
          y = getI18n("vxe.datePicker.yearTitle", [year]);
          m = month ? getI18n(`vxe.input.date.m${month}`) : "-";
        }
      }
      return {
        y,
        m
      };
    });
    const computeFirstDayOfWeek = computed(() => {
      const { startDay, startWeek } = props;
      return import_xe_utils24.default.toNumber(import_xe_utils24.default.isNumber(startDay) || import_xe_utils24.default.isString(startDay) ? startDay : startWeek);
    });
    const computeWeekDatas = computed(() => {
      const weeks = [];
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index = 0; index < 6; index++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map((day) => {
          return {
            value: day,
            label: getI18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const dateHeaders = computeDateHeaders.value;
        return [{ label: getI18n("vxe.input.date.weeks.w") }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = computed(() => {
      const yearList = computeYearList.value;
      return import_xe_utils24.default.chunk(yearList, 4);
    });
    const computeQuarterList = computed(() => {
      const { quarterSize } = internalData;
      const { selectMonth, currentDate } = reactData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = import_xe_utils24.default.getWhatYear(selectMonth, 0, "first");
        const selFullYear = firstYear.getFullYear();
        for (let index = -2; index < quarterSize - 2; index++) {
          const date = import_xe_utils24.default.getWhatQuarter(firstYear, index);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = computed(() => {
      const quarterList = computeQuarterList.value;
      return import_xe_utils24.default.chunk(quarterList, 2);
    });
    const computeMonthList = computed(() => {
      const { monthSize } = internalData;
      const { selectMonth, currentDate } = reactData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = import_xe_utils24.default.getWhatYear(selectMonth, 0, "first").getFullYear();
        for (let index = -4; index < monthSize - 4; index++) {
          const date = import_xe_utils24.default.getWhatYear(selectMonth, 0, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = computed(() => {
      const monthList = computeMonthList.value;
      return import_xe_utils24.default.chunk(monthList, 4);
    });
    const computeDayList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(import_xe_utils24.default.getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index = 0; index < 42; index++) {
          const date = import_xe_utils24.default.getWhatDay(startDayDate, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = computed(() => {
      const dayList = computeDayList.value;
      return import_xe_utils24.default.chunk(dayList, 7);
    });
    const computeWeekDates = computed(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map((list) => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: import_xe_utils24.default.getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const computeHourList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 24; index++) {
          list.push({
            value: index,
            label: ("" + index).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeMinuteList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 60; index++) {
          list.push({
            value: index,
            label: ("" + index).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeHasTimeMinute = computed(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /mm/.test(dateValueFormat);
    });
    const computeHasTimeSecond = computed(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /ss/.test(dateValueFormat);
    });
    const computeSecondList = computed(() => {
      const minuteList = computeMinuteList.value;
      return minuteList;
    });
    const computeInputReadonly = computed(() => {
      const { type, editable, multiple } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || multiple || !editable || type === "week" || type === "quarter";
    });
    const computeDatePickerType = computed(() => {
      return "text";
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().datePicker.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseSelect");
    });
    const computeInpImmediate = computed(() => {
      const { immediate } = props;
      return immediate;
    });
    const computeShortcutOpts = computed(() => {
      return Object.assign({}, getConfig().datePicker.shortcutConfig, props.shortcutConfig);
    });
    const updateModelValue = (modelValue) => {
      const { isActivated, visiblePanel } = reactData;
      let val = "";
      if (modelValue) {
        if (import_xe_utils24.default.isNumber(modelValue) && /^[0-9]{11,15}$/.test(`${modelValue}`)) {
          val = new Date(modelValue);
        } else {
          val = modelValue;
        }
      }
      reactData.inputValue = val;
      if (isActivated && visiblePanel) {
        dateOpenPanel();
      }
    };
    const parseDate = (value, format) => {
      const { type, multiple } = props;
      if (type === "time") {
        return toStringTimeDate(value);
      }
      if (import_xe_utils24.default.isArray(value)) {
        return import_xe_utils24.default.toStringDate(value[0], format);
      }
      if (import_xe_utils24.default.isString(value)) {
        return import_xe_utils24.default.toStringDate(multiple ? import_xe_utils24.default.last(value.split(",")) : value, format);
      }
      return import_xe_utils24.default.toStringDate(value, format);
    };
    const triggerEvent = (evnt) => {
      const { inputValue } = reactData;
      dispatchEvent(evnt.type, { value: inputValue }, evnt);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      if (import_xe_utils24.default.toValueString(props.modelValue) !== value) {
        dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const inputEvent = (evnt) => {
      const isDatePickerType = computeIsDatePickerType.value;
      const inpImmediate = computeInpImmediate.value;
      const inputElem = evnt.target;
      const value = inputElem.value;
      reactData.inputValue = value;
      if (!isDatePickerType) {
        if (inpImmediate) {
          handleChange(value, evnt);
        } else {
          dispatchEvent("input", { value }, evnt);
        }
      }
    };
    const changeEvent = (evnt) => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent(evnt);
      }
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        datePickerOpenEvent(evnt);
      }
      triggerEvent(evnt);
    };
    const clickPrefixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        dispatchEvent("prefix-click", { value: inputValue }, evnt);
      }
    };
    const hidePanel = () => {
      return new Promise((resolve) => {
        reactData.visiblePanel = false;
        internalData.hpTimeout = setTimeout(() => {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    };
    const clearValueEvent = (evnt, value) => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      handleChange("", evnt);
      dispatchEvent("clear", { value }, evnt);
    };
    const clickSuffixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        dispatchEvent("suffix-click", { value: inputValue }, evnt);
      }
    };
    const dateParseValue = (value) => {
      const { type } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let dValue = null;
      let dLabel = "";
      if (value) {
        dValue = parseDate(value, dateValueFormat);
      }
      if (import_xe_utils24.default.isValidDate(dValue)) {
        dLabel = import_xe_utils24.default.toDateString(dValue, dateLabelFormat, { firstDay: firstDayOfWeek });
        if (dateLabelFormat && type === "week") {
          const weekNum = import_xe_utils24.default.getYearWeek(dValue, firstDayOfWeek);
          const weekDate = import_xe_utils24.default.getWhatWeek(dValue, 0, weekNum === 1 ? (6 + firstDayOfWeek) % 7 : firstDayOfWeek, firstDayOfWeek);
          const weekFullYear = weekDate.getFullYear();
          if (weekFullYear !== dValue.getFullYear()) {
            const yyIndex = dateLabelFormat.indexOf("yyyy");
            if (yyIndex > -1) {
              const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace(`${yyNum}`, `${weekFullYear}`);
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    const changeValue = () => {
      const isDatePickerType = computeIsDatePickerType.value;
      const { inputValue } = reactData;
      if (isDatePickerType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    const initValue = () => {
      const isDatePickerType = computeIsDatePickerType.value;
      updateModelValue(props.modelValue);
      if (isDatePickerType) {
        changeValue();
      }
    };
    const dateRevert = () => {
      reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
    };
    const dateCheckMonth = (date) => {
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const weekNum = import_xe_utils24.default.getYearWeek(date, firstDayOfWeek);
      const weekStartDate = import_xe_utils24.default.getWhatWeek(date, 0, firstDayOfWeek, firstDayOfWeek);
      const month = import_xe_utils24.default.getWhatMonth(weekNum === 1 ? import_xe_utils24.default.getWhatDay(weekStartDate, 6) : date, 0, "first");
      if (!import_xe_utils24.default.isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = (date, isReload) => {
      const { modelValue, multiple } = props;
      const { datetimePanelValue } = reactData;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === "week") {
        const sWeek = import_xe_utils24.default.toNumber(props.selectDay);
        date = import_xe_utils24.default.getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      } else if (isDateTimeType) {
        if (datetimePanelValue) {
          date.setHours(datetimePanelValue.getHours());
          date.setMinutes(datetimePanelValue.getMinutes());
          date.setSeconds(datetimePanelValue.getSeconds());
        }
      }
      const inpVal = import_xe_utils24.default.toDateString(date, dateValueFormat, { firstDay: firstDayOfWeek });
      dateCheckMonth(date);
      if (multiple) {
        const overCount = computeOverCount.value;
        if (isDateTimeType) {
          const dateListValue = isReload ? [] : [...computeDateListValue.value];
          const datetimeRest = [];
          const eqIndex = import_xe_utils24.default.findIndexOf(dateListValue, (val) => import_xe_utils24.default.isDateSame(date, val, "yyyyMMdd"));
          if (eqIndex === -1) {
            if (overCount) {
              return;
            }
            dateListValue.push(date);
          } else {
            dateListValue.splice(eqIndex, 1);
          }
          dateListValue.forEach((item) => {
            if (item) {
              if (datetimePanelValue) {
                item.setHours(datetimePanelValue.getHours());
                item.setMinutes(datetimePanelValue.getMinutes());
                item.setSeconds(datetimePanelValue.getSeconds());
              }
              datetimeRest.push(item);
            }
          });
          handleChange(datetimeRest.map((date2) => import_xe_utils24.default.toDateString(date2, dateValueFormat)).join(","), { type: "update" });
        } else {
          const dateMultipleValue = isReload ? [] : computeDateMultipleValue.value;
          if (dateMultipleValue.some((val) => import_xe_utils24.default.isEqual(val, inpVal))) {
            handleChange(dateMultipleValue.filter((val) => !import_xe_utils24.default.isEqual(val, inpVal)).join(","), { type: "update" });
          } else {
            if (overCount) {
              return;
            }
            handleChange(dateMultipleValue.concat([inpVal]).join(","), { type: "update" });
          }
        }
      } else {
        if (!import_xe_utils24.default.isEqual(modelValue, inpVal)) {
          handleChange(inpVal, { type: "update" });
        }
      }
    };
    const afterCheckValue = () => {
      const { type } = props;
      const { inputValue, datetimePanelValue } = reactData;
      const dateLabelFormat = computeDateLabelFormat.value;
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        if (inputValue) {
          let inpDateVal = parseDate(inputValue, dateLabelFormat);
          if (import_xe_utils24.default.isValidDate(inpDateVal)) {
            if (type === "time") {
              inpDateVal = import_xe_utils24.default.toDateString(inpDateVal, dateLabelFormat);
              if (inputValue !== inpDateVal) {
                handleChange(inpDateVal, { type: "check" });
              }
              reactData.inputValue = inpDateVal;
            } else {
              let isChange = false;
              const firstDayOfWeek = computeFirstDayOfWeek.value;
              if (type === "datetime") {
                const dateValue = computeDateValue.value;
                if (inputValue !== import_xe_utils24.default.toDateString(dateValue, dateLabelFormat) || inputValue !== import_xe_utils24.default.toDateString(inpDateVal, dateLabelFormat)) {
                  isChange = true;
                  if (datetimePanelValue) {
                    datetimePanelValue.setHours(inpDateVal.getHours());
                    datetimePanelValue.setMinutes(inpDateVal.getMinutes());
                    datetimePanelValue.setSeconds(inpDateVal.getSeconds());
                  }
                }
              } else {
                isChange = true;
              }
              reactData.inputValue = import_xe_utils24.default.toDateString(inpDateVal, dateLabelFormat, { firstDay: firstDayOfWeek });
              if (isChange) {
                dateChange(inpDateVal);
              }
            }
          } else {
            dateRevert();
          }
        } else {
          handleChange("", { type: "check" });
        }
      }
    };
    const blurEvent = (evnt) => {
      const { inputValue } = reactData;
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue;
      if (!inpImmediate) {
        handleChange(value, evnt);
      }
      afterCheckValue();
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
      }
      dispatchEvent("blur", { value }, evnt);
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const keydownEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const keyupEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const dateMonthHandle = (date, offsetMonth) => {
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const weekNum = import_xe_utils24.default.getYearWeek(date, firstDayOfWeek);
      const weekStartDate = import_xe_utils24.default.getWhatWeek(date, 0, firstDayOfWeek, firstDayOfWeek);
      const month = import_xe_utils24.default.getWhatMonth(weekNum === 1 ? import_xe_utils24.default.getWhatDay(weekStartDate, 6) : date, offsetMonth, "first");
      reactData.selectMonth = month;
    };
    const dateNowHandle = () => {
      const { type } = props;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let currentDate = /* @__PURE__ */ new Date();
      switch (type) {
        case "week":
          currentDate = import_xe_utils24.default.getWhatWeek(currentDate, 0, firstDayOfWeek);
          break;
        case "datetime":
          currentDate = /* @__PURE__ */ new Date();
          reactData.datetimePanelValue = /* @__PURE__ */ new Date();
          break;
        default:
          currentDate = import_xe_utils24.default.getWhatDay(Date.now(), 0, "first");
          break;
      }
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleYearTypeEvent = () => {
      reactData.datePanelType = "year";
    };
    const dateToggleMonthTypeEvent = () => {
      let { datePanelType } = reactData;
      if (datePanelType === "month" || datePanelType === "quarter") {
        datePanelType = "year";
      } else {
        datePanelType = "month";
      }
      reactData.datePanelType = datePanelType;
    };
    const datePrevEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth, inputValue } = reactData;
      const { yearSize } = internalData;
      const value = inputValue;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        let viewDate;
        if (type === "year") {
          viewDate = import_xe_utils24.default.getWhatYear(selectMonth, -yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            viewDate = import_xe_utils24.default.getWhatYear(selectMonth, -yearSize, "first");
          } else {
            viewDate = import_xe_utils24.default.getWhatYear(selectMonth, -1, "first");
          }
        } else {
          if (datePanelType === "year") {
            viewDate = import_xe_utils24.default.getWhatYear(selectMonth, -yearSize, "first");
          } else if (datePanelType === "month") {
            viewDate = import_xe_utils24.default.getWhatYear(selectMonth, -1, "first");
          } else {
            viewDate = import_xe_utils24.default.getWhatMonth(selectMonth, -1, "first");
          }
        }
        reactData.selectMonth = viewDate;
        dispatchEvent("date-prev", { viewType: datePanelType, viewDate, value, type }, evnt);
      }
    };
    const dateTodayMonthEvent = (evnt) => {
      dateNowHandle();
      dateChange(reactData.currentDate, true);
      if (!props.multiple) {
        hidePanel();
      }
      dispatchEvent("date-today", { type: props.type }, evnt);
    };
    const dateNextEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth, inputValue } = reactData;
      const { yearSize } = internalData;
      const value = inputValue;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        let viewDate;
        if (type === "year") {
          viewDate = import_xe_utils24.default.getWhatYear(selectMonth, yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            viewDate = import_xe_utils24.default.getWhatYear(selectMonth, yearSize, "first");
          } else {
            viewDate = import_xe_utils24.default.getWhatYear(selectMonth, 1, "first");
          }
        } else {
          if (datePanelType === "year") {
            viewDate = import_xe_utils24.default.getWhatYear(selectMonth, yearSize, "first");
          } else if (datePanelType === "month") {
            viewDate = import_xe_utils24.default.getWhatYear(selectMonth, 1, "first");
          } else {
            viewDate = import_xe_utils24.default.getWhatMonth(selectMonth, 1, "first");
          }
        }
        reactData.selectMonth = viewDate;
        dispatchEvent("date-next", { viewType: datePanelType, value, type }, evnt);
      }
    };
    const isDateDisabled = (item) => {
      const { disabledMethod } = props;
      const { datePanelType } = reactData;
      const dateStartTime = computeDateStartTime.value;
      const dateEndTime = computeDateEndTime.value;
      const { date } = item;
      if (dateStartTime && dateStartTime.getTime() > date.getTime()) {
        return true;
      }
      if (dateEndTime && dateEndTime.getTime() < date.getTime()) {
        return true;
      }
      if (disabledMethod) {
        return disabledMethod({ type: datePanelType, viewType: datePanelType, date, $datePicker: $xeDatePicker });
      }
      return false;
    };
    const dateSelectItem = (date) => {
      const { type, multiple } = props;
      const { datePanelType } = reactData;
      if (type === "month") {
        if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else if (type === "year") {
        dateChange(date);
        if (!multiple) {
          hidePanel();
        }
      } else if (type === "quarter") {
        if (datePanelType === "year") {
          reactData.datePanelType = "quarter";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else {
        if (datePanelType === "month") {
          reactData.datePanelType = type === "week" ? type : "day";
          dateCheckMonth(date);
        } else if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (type === "datetime") {
          } else {
            if (!multiple) {
              hidePanel();
            }
          }
        }
      }
    };
    const dateSelectEvent = (item) => {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = (offsetDay) => {
      if (!isDateDisabled({ date: offsetDay })) {
        const dayList = computeDayList.value;
        if (!dayList.some((item) => import_xe_utils24.default.isDateSame(item.date, offsetDay, "yyyyMMdd"))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = (offsetYear) => {
      if (!isDateDisabled({ date: offsetYear })) {
        const yearList = computeYearList.value;
        if (!yearList.some((item) => import_xe_utils24.default.isDateSame(item.date, offsetYear, "yyyy"))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = (offsetQuarter) => {
      if (!isDateDisabled({ date: offsetQuarter })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some((item) => import_xe_utils24.default.isDateSame(item.date, offsetQuarter, "yyyyq"))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = (offsetMonth) => {
      if (!isDateDisabled({ date: offsetMonth })) {
        const monthList = computeMonthList.value;
        if (!monthList.some((item) => import_xe_utils24.default.isDateSame(item.date, offsetMonth, "yyyyMM"))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = (item) => {
      if (!isDateDisabled(item)) {
        const { datePanelType } = reactData;
        if (datePanelType === "month") {
          dateMoveMonth(item.date);
        } else if (datePanelType === "quarter") {
          dateMoveQuarter(item.date);
        } else if (datePanelType === "year") {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const updateTimePos = (liElem) => {
      if (liElem) {
        const height = liElem.offsetHeight;
        const ulElem = liElem.parentNode;
        ulElem.scrollTop = liElem.offsetTop - height * 4;
      }
    };
    const dateTimeChangeEvent = (evnt) => {
      const { datetimePanelValue } = reactData;
      reactData.datetimePanelValue = datetimePanelValue ? new Date(datetimePanelValue.getTime()) : /* @__PURE__ */ new Date();
      updateTimePos(evnt.currentTarget);
    };
    const dateHourEvent = (evnt, item) => {
      const { datetimePanelValue } = reactData;
      if (datetimePanelValue) {
        datetimePanelValue.setHours(item.value);
      }
      dateTimeChangeEvent(evnt);
    };
    const dateConfirmEvent = () => {
      const { multiple } = props;
      const { datetimePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        const dateValueFormat = computeDateValueFormat.value;
        if (multiple) {
          const dateMultipleValue = computeDateMultipleValue.value;
          if (isDateTimeType) {
            const dateListValue = [...computeDateListValue.value];
            const datetimeRest = [];
            dateListValue.forEach((item) => {
              if (item) {
                if (datetimePanelValue) {
                  item.setHours(datetimePanelValue.getHours());
                  item.setMinutes(datetimePanelValue.getMinutes());
                  item.setSeconds(datetimePanelValue.getSeconds());
                }
                datetimeRest.push(item);
              }
            });
            handleChange(datetimeRest.map((date) => import_xe_utils24.default.toDateString(date, dateValueFormat)).join(","), { type: "update" });
          } else {
            handleChange(dateMultipleValue.join(","), { type: "update" });
          }
        } else {
          dateChange(dateValue || reactData.currentDate);
        }
      }
      hidePanel();
    };
    const dateMinuteEvent = (evnt, item) => {
      const { datetimePanelValue } = reactData;
      if (datetimePanelValue) {
        datetimePanelValue.setMinutes(item.value);
      }
      dateTimeChangeEvent(evnt);
    };
    const dateSecondEvent = (evnt, item) => {
      const { datetimePanelValue } = reactData;
      if (datetimePanelValue) {
        datetimePanelValue.setSeconds(item.value);
      }
      dateTimeChangeEvent(evnt);
    };
    const dateOffsetEvent = (evnt) => {
      const { isActivated, datePanelValue, datePanelType } = reactData;
      if (isActivated) {
        evnt.preventDefault();
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        if (datePanelType === "year") {
          let offsetYear = import_xe_utils24.default.getWhatYear(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetYear = import_xe_utils24.default.getWhatYear(offsetYear, -1);
          } else if (isUpArrow) {
            offsetYear = import_xe_utils24.default.getWhatYear(offsetYear, -4);
          } else if (isRightArrow) {
            offsetYear = import_xe_utils24.default.getWhatYear(offsetYear, 1);
          } else if (isDwArrow) {
            offsetYear = import_xe_utils24.default.getWhatYear(offsetYear, 4);
          }
          dateMoveYear(offsetYear);
        } else if (datePanelType === "quarter") {
          let offsetQuarter = import_xe_utils24.default.getWhatQuarter(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetQuarter = import_xe_utils24.default.getWhatQuarter(offsetQuarter, -1);
          } else if (isUpArrow) {
            offsetQuarter = import_xe_utils24.default.getWhatQuarter(offsetQuarter, -2);
          } else if (isRightArrow) {
            offsetQuarter = import_xe_utils24.default.getWhatQuarter(offsetQuarter, 1);
          } else if (isDwArrow) {
            offsetQuarter = import_xe_utils24.default.getWhatQuarter(offsetQuarter, 2);
          }
          dateMoveQuarter(offsetQuarter);
        } else if (datePanelType === "month") {
          let offsetMonth = import_xe_utils24.default.getWhatMonth(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetMonth = import_xe_utils24.default.getWhatMonth(offsetMonth, -1);
          } else if (isUpArrow) {
            offsetMonth = import_xe_utils24.default.getWhatMonth(offsetMonth, -4);
          } else if (isRightArrow) {
            offsetMonth = import_xe_utils24.default.getWhatMonth(offsetMonth, 1);
          } else if (isDwArrow) {
            offsetMonth = import_xe_utils24.default.getWhatMonth(offsetMonth, 4);
          }
          dateMoveMonth(offsetMonth);
        } else if (datePanelType === "week") {
          let offsetDay = datePanelValue || import_xe_utils24.default.getWhatDay(Date.now(), 0, "first");
          const firstDayOfWeek = computeFirstDayOfWeek.value;
          if (isUpArrow) {
            offsetDay = import_xe_utils24.default.getWhatWeek(offsetDay, -1, firstDayOfWeek);
          } else if (isDwArrow) {
            offsetDay = import_xe_utils24.default.getWhatWeek(offsetDay, 1, firstDayOfWeek);
          }
          dateMoveDay(offsetDay);
        } else {
          let offsetDay = datePanelValue || import_xe_utils24.default.getWhatDay(Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetDay = import_xe_utils24.default.getWhatDay(offsetDay, -1);
          } else if (isUpArrow) {
            offsetDay = import_xe_utils24.default.getWhatWeek(offsetDay, -1, offsetDay.getDay());
          } else if (isRightArrow) {
            offsetDay = import_xe_utils24.default.getWhatDay(offsetDay, 1);
          } else if (isDwArrow) {
            offsetDay = import_xe_utils24.default.getWhatWeek(offsetDay, 1, offsetDay.getDay());
          }
          dateMoveDay(offsetDay);
        }
      }
    };
    const datePgOffsetEvent = (evnt) => {
      const { isActivated } = reactData;
      if (isActivated) {
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        evnt.preventDefault();
        if (isPgUp) {
          datePrevEvent(evnt);
        } else {
          dateNextEvent(evnt);
        }
      }
    };
    const dateOpenPanel = () => {
      const { type } = props;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValue = computeDateValue.value;
      if (["year", "quarter", "month", "week"].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = "day";
      }
      reactData.currentDate = import_xe_utils24.default.getWhatDay(Date.now(), 0, "first");
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
      if (isDateTimeType) {
        reactData.datetimePanelValue = reactData.datePanelValue || import_xe_utils24.default.getWhatDay(Date.now(), 0, "first");
        nextTick(() => {
          const timeBodyElem = refInputTimeBody.value;
          import_xe_utils24.default.arrayEach(timeBodyElem.querySelectorAll("li.is--selected"), (elem) => {
            updateTimePos(elem);
          });
        });
      }
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const targetElem = refInputTarget.value;
        const panelElem = refInputPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (targetElem && panelElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(targetElem);
          let panelPlacement = "bottom";
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              panelStyle.top = `${targetHeight}px`;
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.top = "";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showPanel = () => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!isDisabled && !visiblePanel) {
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        if (internalData.hpTimeout) {
          clearTimeout(internalData.hpTimeout);
          internalData.hpTimeout = void 0;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (isDatePickerType) {
          dateOpenPanel();
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return nextTick();
    };
    const datePickerOpenEvent = (evnt) => {
      const formReadonly = computeFormReadonly.value;
      if (!formReadonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    const clickEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const handleShortcutEvent = ({ option, $event }) => {
      const shortcutOpts = computeShortcutOpts.value;
      const { autoClose } = shortcutOpts;
      const clickMethod = option.clickMethod || shortcutOpts.clickMethod;
      const shortcutParams = {
        $datePicker: $xeDatePicker,
        option
      };
      if (clickMethod) {
        clickMethod(shortcutParams);
      }
      if (autoClose) {
        hidePanel();
      }
      dispatchEvent("shortcut-click", shortcutParams, $event);
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel, isActivated } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const el = refElem.value;
      const panelWrapperElem = refPanelWrapper.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelWrapperElem).flag;
        if (!reactData.isActivated) {
          if (isDatePickerType) {
            if (visiblePanel) {
              hidePanel();
              afterCheckValue();
            }
          } else {
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable } = props;
      const { visiblePanel } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        const isPgDn = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_DOWN);
        const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        } else if (operArrow) {
          if (isDatePickerType) {
            if (isActivated) {
              if (visiblePanel) {
                dateOffsetEvent(evnt);
              } else if (isUpArrow || isDwArrow) {
                datePickerOpenEvent(evnt);
              }
            }
          }
        } else if (isEnter) {
          if (isDatePickerType) {
            if (visiblePanel) {
              if (reactData.datePanelValue) {
                dateSelectItem(reactData.datePanelValue);
              } else {
                hidePanel();
              }
            } else if (isActivated) {
              datePickerOpenEvent(evnt);
            }
          }
        } else if (isPgUp || isPgDn) {
          if (isDatePickerType) {
            if (isActivated) {
              datePgOffsetEvent(evnt);
            }
          }
        }
        if (isTab || isEsc) {
          if (visiblePanel) {
            hidePanel();
          }
        } else if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelWrapperElem = refPanelWrapper.value;
          if (getEventTargetNode(evnt, panelWrapperElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const { isActivated, visiblePanel } = reactData;
      if (visiblePanel) {
        hidePanel();
        afterCheckValue();
      } else if (isActivated) {
        afterCheckValue();
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $datePicker: $xeDatePicker }, params));
    };
    datePickerMethods = {
      dispatchEvent,
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return nextTick();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return nextTick();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeDatePicker, datePickerMethods);
    const renderDateLabel = (item, label) => {
      const { festivalMethod } = props;
      if (festivalMethod) {
        const { datePanelType } = reactData;
        const festivalRest = festivalMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $datePicker: $xeDatePicker });
        const festivalItem = festivalRest ? import_xe_utils24.default.isString(festivalRest) ? { label: festivalRest } : festivalRest : {};
        const extraItem = festivalItem.extra ? import_xe_utils24.default.isString(festivalItem.extra) ? { label: festivalItem.extra } : festivalItem.extra : null;
        const labels = [
          h("span", {
            class: ["vxe-date-picker--date-label", {
              "is-notice": festivalItem.notice
            }]
          }, extraItem && extraItem.label ? [
            h("span", `${label}`),
            h("span", {
              class: ["vxe-date-picker--date-label--extra", extraItem.important ? "is-important" : "", extraItem.className],
              style: extraItem.style
            }, import_xe_utils24.default.toValueString(extraItem.label))
          ] : `${label}`)
        ];
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          const festivalLabels = import_xe_utils24.default.toValueString(festivalLabel).split(",");
          labels.push(h("span", {
            class: ["vxe-date-picker--date-festival", festivalItem.important ? "is-important" : "", festivalItem.className],
            style: festivalItem.style
          }, [
            festivalLabels.length > 1 ? h("span", {
              class: ["vxe-date-picker--date-festival--overlap", `overlap--${festivalLabels.length}`]
            }, festivalLabels.map((label2) => h("span", label2.substring(0, 3)))) : h("span", {
              class: "vxe-date-picker--date-festival--label"
            }, festivalLabels[0].substring(0, 3))
          ]));
        }
        return labels;
      }
      return label;
    };
    const renderDateDayTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const overCount = computeOverCount.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-date-picker--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("thead", [
            h("tr", dateHeaders.map((item) => {
              return h("th", item.label);
            }))
          ]),
          h("tbody", dayDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              const isSelected = multiple ? dateListValue.some((val) => import_xe_utils24.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils24.default.isDateSame(dateValue, item.date, matchFormat);
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--over": overCount && !isSelected,
                  "is--hover": !overCount && import_xe_utils24.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    const renderDateWeekTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const overCount = computeOverCount.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-date-picker--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("thead", [
            h("tr", weekHeaders.map((item) => {
              return h("th", item.label);
            }))
          ]),
          h("tbody", weekDates.map((rows) => {
            const isSelected = multiple ? rows.some((item) => dateListValue.some((val) => import_xe_utils24.default.isDateSame(val, item.date, matchFormat))) : rows.some((item) => import_xe_utils24.default.isDateSame(dateValue, item.date, matchFormat));
            const isHover = rows.some((item) => import_xe_utils24.default.isDateSame(datePanelValue, item.date, matchFormat));
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--over": overCount && !isSelected,
                  "is--hover": !overCount && isHover
                },
                // event
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    const renderDateMonthTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const overCount = computeOverCount.value;
      const matchFormat = "yyyyMM";
      return [
        h("table", {
          class: `vxe-date-picker--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", monthDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              const isSelected = multiple ? dateListValue.some((val) => import_xe_utils24.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils24.default.isDateSame(dateValue, item.date, matchFormat);
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--over": overCount && !isSelected,
                  "is--hover": !overCount && import_xe_utils24.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.months.m${item.month}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateQuarterTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const overCount = computeOverCount.value;
      const matchFormat = "yyyyq";
      return [
        h("table", {
          class: `vxe-date-picker--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", quarterDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              const isSelected = multiple ? dateListValue.some((val) => import_xe_utils24.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils24.default.isDateSame(dateValue, item.date, matchFormat);
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--over": overCount && !isSelected,
                  "is--hover": !overCount && import_xe_utils24.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.quarters.q${item.quarter}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateYearTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const overCount = computeOverCount.value;
      const matchFormat = "yyyy";
      return [
        h("table", {
          class: `vxe-date-picker--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", yearDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              const isSelected = multiple ? dateListValue.some((val) => import_xe_utils24.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils24.default.isDateSame(dateValue, item.date, matchFormat);
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--over": overCount && !isSelected,
                  "is--hover": !overCount && import_xe_utils24.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.year));
            }));
          }))
        ])
      ];
    };
    const renderDateTable = () => {
      const { datePanelType } = reactData;
      switch (datePanelType) {
        case "week":
          return renderDateWeekTable();
        case "month":
          return renderDateMonthTable();
        case "quarter":
          return renderDateQuarterTable();
        case "year":
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const { multiple } = props;
      const { datePanelType } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelObj = computeSelectDatePanelObj.value;
      const supportMultiples = computeSupportMultiples.value;
      return [
        h("div", {
          class: "vxe-date-picker--date-picker-header"
        }, [
          h("div", {
            class: "vxe-date-picker--date-picker-type-wrapper"
          }, [
            datePanelType === "year" ? h("span", {
              class: "vxe-date-picker--date-picker-label"
            }, selectDatePanelObj.y) : h("span", {
              class: "vxe-date-picker--date-picker-btns"
            }, [
              h("span", {
                class: "vxe-date-picker--date-picker-btn",
                onClick: dateToggleYearTypeEvent
              }, selectDatePanelObj.y),
              selectDatePanelObj.m ? h("span", {
                class: "vxe-date-picker--date-picker-btn",
                onClick: dateToggleMonthTypeEvent
              }, selectDatePanelObj.m) : renderEmptyElement($xeDatePicker)
            ])
          ]),
          h("div", {
            class: "vxe-date-picker--date-picker-btn-wrapper"
          }, [
            h("span", {
              class: ["vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-prev-btn", {
                "is--disabled": isDisabledPrevDateBtn
              }],
              onClick: datePrevEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-left"
              })
            ]),
            h("span", {
              class: "vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-current-btn",
              onClick: dateTodayMonthEvent
            }, [
              h("i", {
                class: "vxe-icon-dot"
              })
            ]),
            h("span", {
              class: ["vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-next-btn", {
                "is--disabled": isDisabledNextDateBtn
              }],
              onClick: dateNextEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-right"
              })
            ]),
            multiple && supportMultiples ? h("span", {
              class: "vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-confirm-btn"
            }, [
              h("button", {
                class: "vxe-date-picker--date-picker-confirm",
                type: "button",
                onClick: dateConfirmEvent
              }, getI18n("vxe.button.confirm"))
            ]) : null
          ])
        ]),
        h("div", {
          class: "vxe-date-picker--date-picker-body"
        }, renderDateTable())
      ];
    };
    const renderTimePanel = () => {
      const { datetimePanelValue } = reactData;
      const dateTimeLabel = computeDateTimeLabel.value;
      const hourList = computeHourList.value;
      const hasTimeMinute = computeHasTimeMinute.value;
      const minuteList = computeMinuteList.value;
      const hasTimeSecond = computeHasTimeSecond.value;
      const secondList = computeSecondList.value;
      return [
        h("div", {
          class: "vxe-date-picker--time-picker-header"
        }, [
          hasTimeMinute ? h("div", {
            class: "vxe-date-picker--time-picker-title"
          }, dateTimeLabel) : createCommentVNode(),
          h("div", {
            class: "vxe-date-picker--time-picker-btn"
          }, [
            h("button", {
              class: "vxe-date-picker--time-picker-confirm",
              type: "button",
              onClick: dateConfirmEvent
            }, getI18n("vxe.button.confirm"))
          ])
        ]),
        h("div", {
          ref: refInputTimeBody,
          class: "vxe-date-picker--time-picker-body"
        }, [
          h("ul", {
            class: "vxe-date-picker--time-picker-hour-list"
          }, hourList.map((item, index) => {
            return h("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getHours() === item.value
              },
              onClick: (evnt) => dateHourEvent(evnt, item)
            }, item.label);
          })),
          hasTimeMinute ? h("ul", {
            class: "vxe-date-picker--time-picker-minute-list"
          }, minuteList.map((item, index) => {
            return h("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getMinutes() === item.value
              },
              onClick: (evnt) => dateMinuteEvent(evnt, item)
            }, item.label);
          })) : createCommentVNode(),
          hasTimeMinute && hasTimeSecond ? h("ul", {
            class: "vxe-date-picker--time-picker-second-list"
          }, secondList.map((item, index) => {
            return h("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getSeconds() === item.value
              },
              onClick: (evnt) => dateSecondEvent(evnt, item)
            }, item.label);
          })) : createCommentVNode()
        ])
      ];
    };
    const renderShortcutBtn = (pos, isVertical) => {
      const shortcutOpts = computeShortcutOpts.value;
      const { options, position, align, mode } = shortcutOpts;
      if (isEnableConf(shortcutOpts) && options && options.length && (position || "left") === pos) {
        return h("div", {
          class: `vxe-date-picker--panel-${pos}-wrapper`
        }, [
          h(button_group_default, {
            options,
            mode,
            align,
            vertical: isVertical,
            onClick: handleShortcutEvent
          })
        ]);
      }
      return renderEmptyElement($xeDatePicker);
    };
    const renderPickerPanel = () => {
      const { type } = props;
      if (type === "datetime") {
        return h("div", {
          key: type,
          ref: refPanelWrapper,
          class: "vxe-date-picker--panel-datetime-layout-wrapper"
        }, [
          h("div", {
            class: "vxe-date-picker--panel-datetime-left-wrapper"
          }, renderDatePanel()),
          h("div", {
            class: "vxe-date-picker--panel-datetime-right-wrapper"
          }, renderTimePanel())
        ]);
      } else if (type === "time") {
        return h("div", {
          key: type,
          ref: refPanelWrapper,
          class: "vxe-date-picker--panel-wrapper"
        }, renderTimePanel());
      }
      return h("div", {
        key: type || "default",
        ref: refPanelWrapper,
        class: "vxe-date-picker--panel-wrapper"
      }, renderDatePanel());
    };
    const renderPanel = () => {
      const { type } = props;
      const { initialized, isAniVisible, visiblePanel, panelPlacement, panelStyle } = reactData;
      const vSize = computeSize.value;
      const btnTransfer = computeBtnTransfer.value;
      const shortcutOpts = computeShortcutOpts.value;
      const { options, position } = shortcutOpts;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const leftSlot = slots.left;
      const rightSlot = slots.right;
      const hasShortcutBtn = options && options.length;
      return h(Teleport, {
        to: "body",
        disabled: btnTransfer ? !initialized : true
      }, [
        h("div", {
          ref: refInputPanel,
          class: ["vxe-table--ignore-clear vxe-date-picker--panel", `type--${type}`, {
            [`size--${vSize}`]: vSize,
            "is--transfer": btnTransfer,
            "ani--leave": isAniVisible,
            "ani--enter": visiblePanel,
            "show--top": !!(topSlot || headerSlot || hasShortcutBtn && (position === "top" || position === "header")),
            "show--bottom": !!(bottomSlot || footerSlot || hasShortcutBtn && (position === "bottom" || position === "footer")),
            "show--left": !!(leftSlot || hasShortcutBtn && position === "left"),
            "show--right": !!(rightSlot || hasShortcutBtn && position === "right")
          }],
          placement: panelPlacement,
          style: panelStyle
        }, initialized && (visiblePanel || isAniVisible) ? [
          h("div", {
            class: "vxe-date-picker--panel-layout-wrapper"
          }, [
            topSlot ? h("div", {
              class: "vxe-date-picker--panel-top-wrapper"
            }, topSlot({})) : renderShortcutBtn("top"),
            h("div", {
              class: "vxe-date-picker--panel-body-layout-wrapper"
            }, [
              leftSlot ? h("div", {
                class: "vxe-date-picker--panel-left-wrapper"
              }, leftSlot({})) : renderShortcutBtn("left", true),
              h("div", {
                class: "vxe-date-picker--panel-body-content-wrapper"
              }, [
                headerSlot ? h("div", {
                  class: "vxe-date-picker--panel-header-wrapper"
                }, headerSlot({})) : renderShortcutBtn("header"),
                h("div", {
                  class: "vxe-date-picker--panel-body-wrapper"
                }, [
                  renderPickerPanel()
                ]),
                footerSlot ? h("div", {
                  class: "vxe-date-picker--panel-footer-wrapper"
                }, footerSlot({})) : renderShortcutBtn("footer")
              ]),
              rightSlot ? h("div", {
                class: "vxe-date-picker--panel-right-wrapper"
              }, rightSlot({})) : renderShortcutBtn("right", true)
            ]),
            bottomSlot ? h("div", {
              class: "vxe-date-picker--panel-bottom-wrapper"
            }, bottomSlot({})) : renderShortcutBtn("bottom")
          ])
        ] : [])
      ]);
    };
    const renderPrefixIcon2 = () => {
      const { prefixIcon } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? h("div", {
        class: "vxe-date-picker--prefix",
        onClick: clickPrefixEvent
      }, [
        h("div", {
          class: "vxe-date-picker--prefix-icon"
        }, prefixSlot ? getSlotVNs(prefixSlot({})) : [
          h("i", {
            class: prefixIcon
          })
        ])
      ]) : null;
    };
    const renderSuffixIcon2 = () => {
      const { suffixIcon } = props;
      const { inputValue } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isClearable = computeIsClearable.value;
      return h("div", {
        class: ["vxe-date-picker--suffix", {
          "is--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils24.default.eqNull(inputValue))
        }]
      }, [
        isClearable ? h("div", {
          class: "vxe-date-picker--clear-icon",
          onClick: clearValueEvent
        }, [
          h("i", {
            class: getIcon().INPUT_CLEAR
          })
        ]) : createCommentVNode(),
        renderExtraSuffixIcon(),
        suffixSlot || suffixIcon ? h("div", {
          class: "vxe-date-picker--suffix-icon",
          onClick: clickSuffixEvent
        }, suffixSlot ? getSlotVNs(suffixSlot({})) : [
          h("i", {
            class: suffixIcon
          })
        ]) : createCommentVNode()
      ]);
    };
    const renderExtraSuffixIcon = () => {
      return h("div", {
        class: "vxe-date-picker--control-icon",
        onClick: datePickerOpenEvent
      }, [
        h("i", {
          class: ["vxe-date-picker--date-picker-icon", getIcon().DATE_PICKER_DATE]
        })
      ]);
    };
    const renderVN = () => {
      const { className, type, align, name, autocomplete, autoComplete } = props;
      const { inputValue, visiblePanel, isActivated } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-date-picker--readonly", `type--${type}`, className]
        }, inputValue);
      }
      const inputReadonly = computeInputReadonly.value;
      const inputType = computeDatePickerType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon2();
      const suffix = renderSuffixIcon2();
      return h("div", {
        ref: refElem,
        class: ["vxe-date-picker", `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          "is--prefix": !!prefix,
          "is--suffix": !!suffix,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--active": isActivated,
          "show--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils24.default.eqNull(inputValue))
        }],
        spellcheck: false
      }, [
        prefix || createCommentVNode(),
        h("div", {
          class: "vxe-date-picker--wrapper"
        }, [
          h("input", {
            ref: refInputTarget,
            class: "vxe-date-picker--inner",
            value: inputValue,
            name,
            type: inputType,
            placeholder: inpPlaceholder,
            readonly: inputReadonly,
            disabled: isDisabled,
            autocomplete: autoComplete || autocomplete,
            onKeydown: keydownEvent,
            onKeyup: keyupEvent,
            onClick: clickEvent,
            onInput: inputEvent,
            onChange: changeEvent,
            onFocus: focusEvent,
            onBlur: blurEvent
          })
        ]),
        suffix || createCommentVNode(),
        // 下拉面板
        renderPanel()
      ]);
    };
    watch(() => props.modelValue, (val) => {
      updateModelValue(val);
      changeValue();
    });
    watch(() => props.type, () => {
      Object.assign(reactData, {
        inputValue: "",
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: "",
        datePanelType: "day",
        selectMonth: null,
        currentDate: null
      });
      initValue();
    });
    watch(computeDateLabelFormat, () => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    nextTick(() => {
      globalEvents.on($xeDatePicker, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeDatePicker, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeDatePicker, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeDatePicker, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeDatePicker, "mousewheel");
      globalEvents.off($xeDatePicker, "mousedown");
      globalEvents.off($xeDatePicker, "keydown");
      globalEvents.off($xeDatePicker, "blur");
    });
    initValue();
    $xeDatePicker.renderVN = renderVN;
    return $xeDatePicker;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/date-picker/index.js
var VxeDatePicker = Object.assign({}, date_picker_default, {
  install(app) {
    app.component(date_picker_default.name, date_picker_default);
    app.component("VxeDateInput", date_picker_default);
  }
});
dynamicApp.use(VxeDatePicker);
VxeUI.component(date_picker_default);
var DatePicker = VxeDatePicker;
var date_picker_default2 = VxeDatePicker;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/drawer/index.js
var import_xe_utils26 = __toESM(require_xe_utils());

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/drawer/src/drawer.js
var import_xe_utils25 = __toESM(require_xe_utils());
var allActiveDrawers = [];
var drawer_default = defineComponent({
  name: "VxeDrawer",
  props: {
    modelValue: Boolean,
    id: String,
    title: String,
    loading: {
      type: Boolean,
      default: null
    },
    className: String,
    position: {
      type: [String, Object],
      default: () => getConfig().drawer.position
    },
    lockView: {
      type: Boolean,
      default: () => getConfig().drawer.lockView
    },
    lockScroll: Boolean,
    mask: {
      type: Boolean,
      default: () => getConfig().drawer.mask
    },
    maskClosable: {
      type: Boolean,
      default: () => getConfig().drawer.maskClosable
    },
    escClosable: {
      type: Boolean,
      default: () => getConfig().drawer.escClosable
    },
    cancelClosable: {
      type: Boolean,
      default: () => getConfig().drawer.cancelClosable
    },
    confirmClosable: {
      type: Boolean,
      default: () => getConfig().drawer.confirmClosable
    },
    showHeader: {
      type: Boolean,
      default: () => getConfig().drawer.showHeader
    },
    showFooter: {
      type: Boolean,
      default: () => getConfig().drawer.showFooter
    },
    showClose: {
      type: Boolean,
      default: () => getConfig().drawer.showClose
    },
    content: [Number, String],
    showCancelButton: {
      type: Boolean,
      default: null
    },
    cancelButtonText: {
      type: String,
      default: () => getConfig().drawer.cancelButtonText
    },
    showConfirmButton: {
      type: Boolean,
      default: () => getConfig().drawer.showConfirmButton
    },
    confirmButtonText: {
      type: String,
      default: () => getConfig().drawer.confirmButtonText
    },
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().drawer.destroyOnClose
    },
    showTitleOverflow: {
      type: Boolean,
      default: () => getConfig().drawer.showTitleOverflow
    },
    width: [Number, String],
    height: [Number, String],
    resize: {
      type: Boolean,
      default: () => getConfig().drawer.resize
    },
    zIndex: Number,
    transfer: {
      type: Boolean,
      default: () => getConfig().drawer.transfer
    },
    padding: {
      type: Boolean,
      default: () => getConfig().drawer.padding
    },
    size: {
      type: String,
      default: () => getConfig().drawer.size || getConfig().size
    },
    beforeHideMethod: {
      type: Function,
      default: () => getConfig().drawer.beforeHideMethod
    },
    slots: Object
  },
  emits: [
    "update:modelValue",
    "show",
    "hide",
    "before-hide",
    "close",
    "confirm",
    "cancel",
    "resize"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils25.default.uniqueId();
    const $xeModal = inject("$xeModal", null);
    const $xeParentDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refDrawerBox = ref();
    const refConfirmBtn = ref();
    const refCancelBtn = ref();
    const reactData = reactive({
      initialized: false,
      visible: false,
      contentVisible: false,
      drawerZIndex: 0,
      resizeFlag: 1
    });
    const refMaps = {
      refElem
    };
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().modal.transfer;
        if (import_xe_utils25.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeParentDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeDragType = computed(() => {
      switch (props.position) {
        case "top":
          return "sb";
        case "bottom":
          return "st";
        case "left":
          return "wr";
      }
      return "wl";
    });
    const computeMaps = {};
    const $xeDrawer = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getBox = () => {
      const boxElem = refDrawerBox.value;
      return boxElem;
    };
    const recalculate = () => {
      const { width, height } = props;
      const boxElem = getBox();
      if (boxElem) {
        boxElem.style.width = toCssUnit(width);
        boxElem.style.height = toCssUnit(height);
      }
      return nextTick();
    };
    const updateZindex = () => {
      const { zIndex } = props;
      const { drawerZIndex } = reactData;
      if (zIndex) {
        reactData.drawerZIndex = zIndex;
      } else if (drawerZIndex < getLastZIndex()) {
        reactData.drawerZIndex = nextZIndex();
      }
    };
    const closeDrawer2 = (type) => {
      const { beforeHideMethod } = props;
      const { visible } = reactData;
      const params = { type };
      if (visible) {
        Promise.resolve(beforeHideMethod ? beforeHideMethod(params) : null).then((rest) => {
          if (!import_xe_utils25.default.isError(rest)) {
            reactData.contentVisible = false;
            import_xe_utils25.default.remove(allActiveDrawers, (item) => item === $xeDrawer);
            dispatchEvent("before-hide", params, null);
            setTimeout(() => {
              reactData.visible = false;
              emit("update:modelValue", false);
              dispatchEvent("hide", params, null);
            }, 200);
          }
        }).catch((e) => e);
      }
      return nextTick();
    };
    const closeEvent = (evnt) => {
      const type = "close";
      dispatchEvent(type, { type }, evnt);
      closeDrawer2(type);
    };
    const confirmEvent = (evnt) => {
      const { confirmClosable } = props;
      const type = "confirm";
      dispatchEvent(type, { type }, evnt);
      if (confirmClosable) {
        closeDrawer2(type);
      }
    };
    const cancelEvent = (evnt) => {
      const { cancelClosable } = props;
      const type = "cancel";
      dispatchEvent(type, { type }, evnt);
      if (cancelClosable) {
        closeDrawer2(type);
      }
    };
    const openDrawer2 = () => {
      const { showFooter } = props;
      const { initialized, visible } = reactData;
      if (!initialized) {
        reactData.initialized = true;
      }
      if (!visible) {
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActiveDrawers.push($xeDrawer);
        setTimeout(() => {
          recalculate();
          reactData.contentVisible = true;
          nextTick(() => {
            if (showFooter) {
              const confirmBtn = refConfirmBtn.value;
              const cancelBtn = refCancelBtn.value;
              const operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            const type = "";
            const params = { type };
            emit("update:modelValue", true);
            dispatchEvent("show", params, null);
          });
        }, 10);
      }
      return nextTick();
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $drawer: $xeDrawer }, params));
    };
    const drawerMethods = {
      dispatchEvent,
      open: openDrawer2,
      close() {
        return closeDrawer2("close");
      },
      getBox
    };
    const selfClickEvent = (evnt) => {
      const el = refElem.value;
      if (props.maskClosable && evnt.target === el) {
        const type = "mask";
        closeDrawer2(type);
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      if (isEsc) {
        const lastDrawer = import_xe_utils25.default.max(allActiveDrawers, (item) => item.reactData.drawerZIndex);
        if (lastDrawer) {
          setTimeout(() => {
            if (lastDrawer === $xeDrawer && lastDrawer.props.escClosable) {
              const type = "exit";
              dispatchEvent("close", { type }, evnt);
              closeDrawer2(type);
            }
          }, 10);
        }
      }
    };
    const boxMousedownEvent = () => {
      const { drawerZIndex } = reactData;
      if (allActiveDrawers.some((comp) => comp.reactData.visible && comp.reactData.drawerZIndex > drawerZIndex)) {
        updateZindex();
      }
    };
    const dragEvent = (evnt) => {
      evnt.preventDefault();
      const { visibleHeight, visibleWidth } = getDomNode();
      const marginSize = 0;
      const targetElem = evnt.target;
      const type = targetElem.getAttribute("type");
      const minWidth = 0;
      const minHeight = 0;
      const maxWidth = visibleWidth;
      const maxHeight = visibleHeight;
      const boxElem = getBox();
      const clientWidth = boxElem.clientWidth;
      const clientHeight = boxElem.clientHeight;
      const disX = evnt.clientX;
      const disY = evnt.clientY;
      const offsetTop = boxElem.offsetTop;
      const offsetLeft = boxElem.offsetLeft;
      const params = { type: "resize" };
      document.onmousemove = (evnt2) => {
        evnt2.preventDefault();
        let dragLeft;
        let dragTop;
        let width;
        let height;
        switch (type) {
          case "wl":
            dragLeft = disX - evnt2.clientX;
            width = dragLeft + clientWidth;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case "st":
            dragTop = disY - evnt2.clientY;
            height = clientHeight + dragTop;
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case "wr":
            dragLeft = evnt2.clientX - disX;
            width = dragLeft + clientWidth;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case "sb":
            dragTop = evnt2.clientY - disY;
            height = dragTop + clientHeight;
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
        }
        boxElem.className = boxElem.className.replace(/\s?is--drag/, "") + " is--drag";
        dispatchEvent("resize", params, evnt2);
        reactData.resizeFlag++;
      };
      document.onmouseup = () => {
        document.onmousemove = null;
        document.onmouseup = null;
        reactData.resizeFlag++;
        setTimeout(() => {
          boxElem.className = boxElem.className.replace(/\s?is--drag/, "");
        }, 50);
      };
    };
    const formDesignPrivateMethods = {};
    Object.assign($xeDrawer, drawerMethods, formDesignPrivateMethods);
    const renderTitles = () => {
      const { slots: propSlots = {}, showClose, title } = props;
      const titleSlot = slots.title || propSlots.title;
      const cornerSlot = slots.corner || propSlots.corner;
      return [
        h("div", {
          class: "vxe-drawer--header-title"
        }, titleSlot ? getSlotVNs(titleSlot({ $drawer: $xeDrawer })) : title ? getFuncText(title) : getI18n("vxe.alert.title")),
        h("div", {
          class: "vxe-drawer--header-right"
        }, [
          cornerSlot ? h("div", {
            class: "vxe-drawer--corner-wrapper"
          }, getSlotVNs(cornerSlot({ $drawer: $xeDrawer }))) : renderEmptyElement($xeDrawer),
          showClose ? h("div", {
            class: ["vxe-drawer--close-btn", "trigger--btn"],
            title: getI18n("vxe.drawer.close"),
            onClick: closeEvent
          }, [
            h("i", {
              class: getIcon().DRAWER_CLOSE
            })
          ]) : renderEmptyElement($xeDrawer)
        ])
      ];
    };
    const renderHeader = () => {
      const { slots: propSlots = {}, showTitleOverflow } = props;
      const headerSlot = slots.header || propSlots.header;
      if (props.showHeader) {
        return h("div", {
          class: ["vxe-drawer--header", {
            "is--ellipsis": showTitleOverflow
          }]
        }, headerSlot ? getSlotVNs(headerSlot({ $drawer: $xeDrawer })) : renderTitles());
      }
      return renderEmptyElement($xeDrawer);
    };
    const renderBody = () => {
      const { slots: propSlots = {}, content } = props;
      const defaultSlot = slots.default || propSlots.default;
      const leftSlot = slots.left || propSlots.left;
      const rightSlot = slots.right || propSlots.right;
      return h("div", {
        class: "vxe-drawer--body"
      }, [
        leftSlot ? h("div", {
          class: "vxe-drawer--body-left"
        }, getSlotVNs(leftSlot({ $drawer: $xeDrawer }))) : renderEmptyElement($xeDrawer),
        h("div", {
          class: "vxe-drawer--body-default"
        }, [
          h("div", {
            class: "vxe-drawer--content"
          }, defaultSlot ? getSlotVNs(defaultSlot({ $drawer: $xeDrawer })) : getFuncText(content))
        ]),
        rightSlot ? h("div", {
          class: "vxe-drawer--body-right"
        }, getSlotVNs(rightSlot({ $drawer: $xeDrawer }))) : renderEmptyElement($xeDrawer),
        h(loading_default2, {
          class: "vxe-drawer--loading",
          modelValue: props.loading
        })
      ]);
    };
    const renderDefaultFooter = () => {
      const { slots: propSlots = {}, showCancelButton, showConfirmButton, loading: loading2 } = props;
      const lfSlot = slots.leftfoot || propSlots.leftfoot;
      const rfSlot = slots.rightfoot || propSlots.rightfoot;
      const btnVNs = [];
      if (showCancelButton) {
        btnVNs.push(h(button_default, {
          key: 1,
          ref: refCancelBtn,
          content: props.cancelButtonText || getI18n("vxe.button.cancel"),
          onClick: cancelEvent
        }));
      }
      if (showConfirmButton) {
        btnVNs.push(h(button_default, {
          key: 2,
          ref: refConfirmBtn,
          loading: loading2,
          status: "primary",
          content: props.confirmButtonText || getI18n("vxe.button.confirm"),
          onClick: confirmEvent
        }));
      }
      return h("div", {
        class: "vxe-drawer--footer-wrapper"
      }, [
        h("div", {
          class: "vxe-drawer--footer-left"
        }, lfSlot ? getSlotVNs(lfSlot({ $drawer: $xeDrawer })) : []),
        h("div", {
          class: "vxe-drawer--footer-right"
        }, rfSlot ? getSlotVNs(rfSlot({ $drawer: $xeDrawer })) : btnVNs)
      ]);
    };
    const renderFooter = () => {
      const { slots: propSlots = {} } = props;
      const footerSlot = slots.footer || propSlots.footer;
      if (props.showFooter) {
        return h("div", {
          class: "vxe-drawer--footer"
        }, footerSlot ? getSlotVNs(footerSlot({ $drawer: $xeDrawer })) : [renderDefaultFooter()]);
      }
      return renderEmptyElement($xeDrawer);
    };
    const renderVN = () => {
      const { slots: propSlots = {}, className, position, loading: loading2, lockScroll, padding, lockView, mask, resize, destroyOnClose } = props;
      const { initialized, contentVisible, visible } = reactData;
      const asideSlot = slots.aside || propSlots.aside;
      const vSize = computeSize.value;
      const dragType = computeDragType.value;
      const btnTransfer = computeBtnTransfer.value;
      return h(Teleport, {
        to: "body",
        disabled: btnTransfer ? !initialized : true
      }, [
        h("div", {
          ref: refElem,
          class: ["vxe-drawer--wrapper", `pos--${position}`, className || "", {
            [`size--${vSize}`]: vSize,
            "is--padding": padding,
            "lock--scroll": lockScroll,
            "lock--view": lockView,
            "is--resize": resize,
            "is--mask": mask,
            "is--visible": contentVisible,
            "is--active": visible,
            "is--loading": loading2
          }],
          style: {
            zIndex: reactData.drawerZIndex
          },
          onClick: selfClickEvent
        }, [
          h("div", {
            ref: refDrawerBox,
            class: "vxe-drawer--box",
            onMousedown: boxMousedownEvent
          }, [
            asideSlot ? h("div", {
              class: "vxe-drawer--aside"
            }, getSlotVNs(asideSlot({ $drawer: $xeDrawer }))) : renderEmptyElement($xeDrawer),
            h("div", {
              class: "vxe-drawer--container"
            }, !reactData.initialized || destroyOnClose && !reactData.visible ? [] : [
              renderHeader(),
              renderBody(),
              renderFooter(),
              resize ? h("span", {
                class: "vxe-drawer--resize"
              }, [
                h("span", {
                  class: `${dragType}-resize`,
                  type: dragType,
                  onMousedown: dragEvent
                })
              ]) : renderEmptyElement($xeDrawer)
            ])
          ])
        ])
      ]);
    };
    watch(() => props.width, recalculate);
    watch(() => props.height, recalculate);
    watch(() => props.modelValue, (value) => {
      if (value) {
        openDrawer2();
      } else {
        closeDrawer2("model");
      }
    });
    onMounted(() => {
      nextTick(() => {
        if (props.modelValue) {
          openDrawer2();
        }
        recalculate();
      });
      if (props.escClosable) {
        globalEvents.on($xeDrawer, "keydown", handleGlobalKeydownEvent);
      }
    });
    onUnmounted(() => {
      globalEvents.off($xeDrawer, "keydown");
    });
    provide("$xeDrawer", $xeDrawer);
    $xeDrawer.renderVN = renderVN;
    return $xeDrawer;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/drawer/index.js
function handleDrawer(options) {
  checkDynamic();
  return new Promise((resolve) => {
    if (options && options.id && allActiveDrawers.some((comp) => comp.props.id === options.id)) {
      resolve("exist");
    } else {
      const _onHide = options.onHide;
      const drawerOpts = Object.assign(options, {
        key: import_xe_utils26.default.uniqueId(),
        modelValue: true,
        onHide(params) {
          const drawerList = dynamicStore.drawers;
          if (_onHide) {
            _onHide(params);
          }
          dynamicStore.drawers = drawerList.filter((item) => item.key !== drawerOpts.key);
          resolve(params.type);
        }
      });
      dynamicStore.drawers.push(drawerOpts);
    }
  });
}
function getDrawer(id) {
  return import_xe_utils26.default.find(allActiveDrawers, ($drawer) => $drawer.props.id === id);
}
function closeDrawer(id) {
  const drawers = id ? [getDrawer(id)] : allActiveDrawers;
  const restPromises = [];
  drawers.forEach(($drawer) => {
    if ($drawer) {
      restPromises.push($drawer.close());
    }
  });
  return Promise.all(restPromises);
}
function openDrawer(options) {
  return handleDrawer(Object.assign({}, options));
}
var DrawerController = {
  get: getDrawer,
  close: closeDrawer,
  open: openDrawer
};
var VxeDrawer = Object.assign(drawer_default, {
  install: function(app) {
    app.component(drawer_default.name, drawer_default);
  }
});
VxeUI.drawer = DrawerController;
dynamicApp.use(VxeDrawer);
VxeUI.component(drawer_default);
var Drawer = VxeDrawer;
var drawer_default2 = VxeDrawer;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/empty/src/empty.js
var import_xe_utils27 = __toESM(require_xe_utils());
var empty_default = defineComponent({
  name: "VxeEmpty",
  props: {
    imageUrl: String,
    imageStyle: Object,
    icon: String,
    status: String,
    content: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils27.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeEmpty = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $empty: $xeEmpty }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeEmpty, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const { imageUrl, imageStyle, icon, status, content } = props;
      return h("div", {
        ref: refElem,
        class: ["vxe-empty", {
          [`theme--${status}`]: status
        }]
      }, [
        h("div", {
          class: "vxe-empty--inner"
        }, [
          imageUrl ? h("div", {
            class: "vxe-empty--img-wrapper"
          }, [
            h("img", {
              src: imageUrl,
              style: imageStyle
            })
          ]) : h("div", {
            class: "vxe-empty--icon-wrapper"
          }, [
            h("i", {
              class: icon || getIcon().EMPTY_DEFAULT
            })
          ]),
          h("div", {
            class: "vxe-empty--content-wrapper"
          }, `${content || getI18n("vxe.empty.defText")}`)
        ])
      ]);
    };
    $xeEmpty.renderVN = renderVN;
    return $xeEmpty;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/empty/index.js
var VxeEmpty = Object.assign({}, empty_default, {
  install(app) {
    app.component(empty_default.name, empty_default);
  }
});
dynamicApp.use(VxeEmpty);
VxeUI.component(empty_default);
var Empty = VxeEmpty;
var empty_default2 = VxeEmpty;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form/src/form.js
var import_xe_utils32 = __toESM(require_xe_utils());

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form/src/util.js
var import_xe_utils29 = __toESM(require_xe_utils());

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form/src/itemInfo.js
var import_xe_utils28 = __toESM(require_xe_utils());
var ItemInfo = class {
  constructor($xeForm, item) {
    Object.assign(this, {
      id: import_xe_utils28.default.uniqueId("item_"),
      title: item.title,
      field: item.field,
      span: item.span,
      align: item.align,
      verticalAlign: item.verticalAlign,
      titleBackground: item.titleBackground,
      titleBold: item.titleBold,
      titleAlign: item.titleAlign,
      titleWidth: item.titleWidth,
      titleColon: item.titleColon,
      vertical: item.vertical,
      padding: item.padding,
      titleAsterisk: item.titleAsterisk,
      titlePrefix: item.titlePrefix,
      titleSuffix: item.titleSuffix,
      titleOverflow: item.titleOverflow,
      showTitle: item.showTitle,
      resetValue: item.resetValue,
      visibleMethod: item.visibleMethod,
      visible: item.visible,
      showContent: item.showContent,
      folding: item.folding,
      collapseNode: item.collapseNode,
      className: item.className,
      contentClassName: item.contentClassName,
      contentStyle: item.contentStyle,
      titleClassName: item.titleClassName,
      titleStyle: item.titleStyle,
      itemRender: item.itemRender,
      rules: item.rules,
      // 渲染属性
      showError: false,
      errRule: null,
      slots: item.slots,
      children: []
    });
  }
  update(name, value) {
    this[name] = value;
  }
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form/src/util.js
function isFormItem(item) {
  return item instanceof ItemInfo;
}
function createItem($xeForm, _vm) {
  return isFormItem(_vm) ? _vm : new ItemInfo($xeForm, _vm);
}
function handleFieldOrItem($xeForm, fieldOrItem) {
  if (fieldOrItem) {
    return import_xe_utils29.default.isString(fieldOrItem) ? $xeForm.getItemByField(fieldOrItem) : fieldOrItem;
  }
  return null;
}
function isHiddenItem($xeForm, formItem) {
  const { reactData } = $xeForm;
  const { collapseAll } = reactData;
  const { folding, visible } = formItem;
  return visible === false || folding && collapseAll;
}
function isActiveItem($xeForm, formItem) {
  const $xeGrid = $xeForm.xeGrid;
  let { visibleMethod, itemRender, visible, field } = formItem;
  if (visible === false) {
    return visible;
  }
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const fiVisibleMethod = compConf ? compConf.formItemVisibleMethod || compConf.itemVisibleMethod : null;
  if (!visibleMethod && fiVisibleMethod) {
    visibleMethod = fiVisibleMethod;
  }
  if (!visibleMethod) {
    return true;
  }
  const formProps = $xeForm.props;
  const { data } = formProps;
  return visibleMethod({ data, field, property: field, item: formItem, $form: $xeForm, $grid: $xeGrid });
}
function watchItem(props, formItem) {
  Object.keys(props).forEach((name) => {
    watch(() => props[name], (value) => {
      formItem.update(name, value);
    });
  });
}
function assembleItem($xeForm, el, formItem, formGroup) {
  const { reactData } = $xeForm;
  const formProps = $xeForm.props;
  const { customLayout } = formProps;
  const { staticItems } = reactData;
  if (customLayout) {
    if (!staticItems.some((item) => item.id === formItem.id)) {
      staticItems.push(formItem);
    }
  } else {
    if (el) {
      const parentElem = el.parentNode;
      const parentItem = formGroup ? formGroup.formItem : null;
      const parentItems = parentItem ? parentItem.children : staticItems;
      if (parentElem) {
        parentItems.splice(import_xe_utils29.default.arrayIndexOf(parentElem.children, el), 0, formItem);
        reactData.staticItems = staticItems.slice(0);
      }
    }
  }
}
function destroyItem($xeForm, formItem) {
  const { reactData } = $xeForm;
  const { staticItems } = reactData;
  const index = import_xe_utils29.default.findIndexOf(staticItems, (item) => item.id === formItem.id);
  if (index > -1) {
    staticItems.splice(index, 1);
  }
  reactData.staticItems = staticItems.slice(0);
}

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form/src/render.js
var import_xe_utils30 = __toESM(require_xe_utils());
function renderPrefixIcon(titlePrefix) {
  return h("span", {
    class: "vxe-form--item-title-prefix"
  }, [
    h(icon_default, {
      class: titlePrefix.icon || getIcon().FORM_PREFIX,
      status: titlePrefix.iconStatus
    })
  ]);
}
function renderSuffixIcon(titleSuffix) {
  return h("span", {
    class: "vxe-form--item-title-suffix"
  }, [
    h(icon_default, {
      class: titleSuffix.icon || getIcon().FORM_SUFFIX,
      status: titleSuffix.iconStatus
    })
  ]);
}
var getItemClass = ($xeForm, item, isGroup) => {
  const formProps = $xeForm.props;
  const formReactData = $xeForm.reactData;
  const $xeGrid = $xeForm.xeGrid;
  const { data, rules, readonly, disabled, span: allSpan, titleBackground: allTitleBackground, titleBold: allTitleBold, titleColon: allTitleColon, titleAsterisk: allTitleAsterisk, vertical: allVertical, padding: allPadding } = formProps;
  const { collapseAll } = formReactData;
  const { folding, field, itemRender, showError, className, vertical, padding, children, showContent } = item;
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const itemClassName = compConf ? compConf.formItemClassName || compConf.itemClassName : "";
  const span = item.span || allSpan;
  const itemPadding = import_xe_utils30.default.eqNull(padding) ? allPadding : padding;
  const itemVertical = import_xe_utils30.default.eqNull(vertical) ? allVertical : vertical;
  const titleBackground = import_xe_utils30.default.eqNull(item.titleBackground) ? allTitleBackground : item.titleBackground;
  const titleBold = import_xe_utils30.default.eqNull(item.titleBold) ? allTitleBold : item.titleBold;
  const titleColon = import_xe_utils30.default.eqNull(item.titleColon) ? allTitleColon : item.titleColon;
  const titleAsterisk = import_xe_utils30.default.eqNull(item.titleAsterisk) ? allTitleAsterisk : item.titleAsterisk;
  const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm, $grid: $xeGrid };
  const hasGroup = children && children.length > 0;
  let isRequired = false;
  let isValid = false;
  if (!readonly && rules) {
    const itemRules = rules[field];
    if (itemRules && itemRules.length) {
      isValid = true;
      isRequired = itemRules.some((rule) => rule.required);
    }
  }
  return [
    isGroup || hasGroup ? "vxe-form--group" : "",
    "vxe-form--item",
    item.id,
    span ? `vxe-form--item-col_${span} is--span` : "",
    className ? import_xe_utils30.default.isFunction(className) ? className(params) : className : "",
    itemClassName ? import_xe_utils30.default.isFunction(itemClassName) ? itemClassName(params) : itemClassName : "",
    {
      "is--colon": titleColon,
      "is--tbg": titleBackground,
      "is--bold": titleBold,
      "is--padding": itemPadding,
      "is--vertical": itemVertical,
      "is--asterisk": titleAsterisk,
      "hide--content": showContent === false,
      "is--valid": isValid,
      "is--required": isRequired,
      "is--hidden": folding && collapseAll,
      "is--active": isActiveItem($xeForm, item),
      "is--error": showError
    }
  ];
};
var getItemContentClass = ($xeForm, item, isGroup) => {
  const formProps = $xeForm.props;
  const $xeGrid = $xeForm.xeGrid;
  const { data, readonly, disabled, align: allAlign, verticalAlign: allVerticalAlign } = formProps;
  const { field, itemRender, contentClassName, children } = item;
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const itemContentClassName = compConf ? compConf.formItemContentClassName || compConf.itemContentClassName : "";
  const align = import_xe_utils30.default.eqNull(item.align) ? allAlign : item.align;
  const verticalAlign = import_xe_utils30.default.eqNull(item.verticalAlign) ? allVerticalAlign : item.verticalAlign;
  const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm, $grid: $xeGrid };
  const hasGroup = children && children.length > 0;
  return [
    isGroup || hasGroup ? "vxe-form--group-content vxe-form--item-row" : "",
    "vxe-form--item-content",
    align ? `align--${align}` : "",
    verticalAlign ? `vertical-align--${verticalAlign}` : "",
    itemContentClassName ? import_xe_utils30.default.isFunction(itemContentClassName) ? itemContentClassName(params) : itemContentClassName : "",
    contentClassName ? import_xe_utils30.default.isFunction(contentClassName) ? contentClassName(params) : contentClassName : ""
  ];
};
function renderTitle($xeForm, item, isGroup) {
  const formProps = $xeForm.props;
  const $xeGrid = $xeForm.xeGrid;
  const { data, readonly, disabled, titleAlign: allTitleAlign, titleWidth: allTitleWidth, titleOverflow: allTitleOverflow, vertical: allVertical } = formProps;
  const { slots, title, field, itemRender, titleOverflow, vertical, showTitle, titleClassName, titleStyle, titlePrefix, titleSuffix, children, showContent } = item;
  const { computeTooltipOpts } = $xeForm.getComputeMaps();
  const tooltipOpts = computeTooltipOpts.value;
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const itemTitleClassName = compConf ? compConf.formItemTitleClassName || compConf.itemTitleClassName : "";
  const itemTitleStyle = compConf ? compConf.formItemTitleStyle || compConf.itemTitleStyle : null;
  const itemVertical = import_xe_utils30.default.eqNull(vertical) ? allVertical : vertical;
  const titleAlign = import_xe_utils30.default.eqNull(item.titleAlign) ? allTitleAlign : item.titleAlign;
  const titleWidth = itemVertical ? null : import_xe_utils30.default.eqNull(item.titleWidth) ? allTitleWidth : item.titleWidth;
  const itemOverflow = import_xe_utils30.default.eqNull(titleOverflow) ? allTitleOverflow : titleOverflow;
  const ovEllipsis = itemOverflow === "ellipsis";
  const ovTitle = itemOverflow === "title";
  const ovTooltip = itemOverflow === true || itemOverflow === "tooltip";
  const hasEllipsis = ovTitle || ovTooltip || ovEllipsis;
  const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm, $grid: $xeGrid };
  const titleSlot = slots ? slots.title : null;
  const extraSlot = slots ? slots.extra : null;
  const isTitle = showTitle !== false && (title || titleSlot);
  const hasGroup = children && children.length > 0;
  const titVNs = [];
  if (titlePrefix) {
    titVNs.push(titlePrefix.content || titlePrefix.message ? h(tooltip_default, Object.assign(Object.assign(Object.assign({}, tooltipOpts), titlePrefix), { content: getFuncText(titlePrefix.content || titlePrefix.message) }), {
      default: () => renderPrefixIcon(titlePrefix)
    }) : renderPrefixIcon(titlePrefix));
  }
  const rftTitle = compConf ? compConf.renderFormItemTitle || compConf.renderItemTitle : null;
  titVNs.push(h("span", {
    class: "vxe-form--item-title-label"
  }, titleSlot ? $xeForm.callSlot(titleSlot, params) : rftTitle ? getSlotVNs(rftTitle(itemRender, params)) : getFuncText(item.title)));
  const fixVNs = [];
  if (titleSuffix) {
    fixVNs.push(titleSuffix.content || titleSuffix.message ? h(tooltip_default, Object.assign(Object.assign(Object.assign({}, tooltipOpts), titleSuffix), { content: getFuncText(titleSuffix.content || titleSuffix.message) }), {
      default: () => renderSuffixIcon(titleSuffix)
    }) : renderSuffixIcon(titleSuffix));
  }
  const ons = ovTooltip ? {
    onMouseenter(evnt) {
      $xeForm.triggerTitleTipEvent(evnt, params);
    },
    onMouseleave: $xeForm.handleTitleTipLeaveEvent
  } : {};
  return isTitle ? h("div", Object.assign({ class: [
    isGroup || hasGroup ? "vxe-form--group-title" : "",
    "vxe-form--item-title",
    titleAlign ? `align--${titleAlign}` : "",
    hasEllipsis ? "is--ellipsis" : "",
    itemTitleClassName ? import_xe_utils30.default.isFunction(itemTitleClassName) ? itemTitleClassName(params) : itemTitleClassName : "",
    titleClassName ? import_xe_utils30.default.isFunction(titleClassName) ? titleClassName(params) : titleClassName : ""
  ], style: Object.assign({}, import_xe_utils30.default.isFunction(itemTitleStyle) ? itemTitleStyle(params) : itemTitleStyle, import_xe_utils30.default.isFunction(titleStyle) ? titleStyle(params) : titleStyle, titleWidth && showContent !== false ? {
    width: toCssUnit(titleWidth)
  } : null), title: ovTitle ? getFuncText(title) : null }, ons), [
    h("div", {
      class: "vxe-form--item-title-content"
    }, titVNs),
    h("div", {
      class: "vxe-form--item-title-postfix"
    }, fixVNs),
    extraSlot ? h("div", {
      class: "vxe-form--item-title-extra"
    }, $xeForm.callSlot(extraSlot, params)) : createCommentVNode()
  ]) : createCommentVNode();
}
var renderItemContent = ($xeForm, item) => {
  const formProps = $xeForm.props;
  const formReactData = $xeForm.reactData;
  const $xeGrid = $xeForm.xeGrid;
  const { computeCollapseOpts, computeValidOpts } = $xeForm.getComputeMaps();
  const { data, readonly, disabled } = formProps;
  const { collapseAll } = formReactData;
  const { slots, field, itemRender, collapseNode, errRule } = item;
  const defaultSlot = slots ? slots.default : null;
  const validSlot = slots ? slots.valid : null;
  const collapseOpts = computeCollapseOpts.value;
  const validOpts = computeValidOpts.value;
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm, $grid: $xeGrid };
  let contentVNs = [];
  const rftContent = compConf ? compConf.renderFormItemContent || compConf.renderItemContent : null;
  if (defaultSlot) {
    contentVNs = $xeForm.callSlot(defaultSlot, params);
  } else if (rftContent) {
    contentVNs = getSlotVNs(rftContent(itemRender, params));
  } else if (field) {
    const itemValue = import_xe_utils30.default.get(data, field);
    contentVNs = [eqEmptyValue(itemValue) ? "" : `${itemValue}`];
  }
  if (collapseNode) {
    contentVNs.push(h("div", {
      class: "vxe-form--item-trigger-node",
      onClick: $xeForm.toggleCollapseEvent
    }, [
      h("span", {
        class: "vxe-form--item-trigger-text"
      }, collapseAll ? collapseOpts.unfoldButtonText || getI18n("vxe.form.unfolding") : collapseOpts.foldButtonText || getI18n("vxe.form.folding")),
      h("i", {
        class: ["vxe-form--item-trigger-icon", collapseAll ? collapseOpts.foldIcon || getIcon().FORM_FOLDING : collapseOpts.unfoldIcon || getIcon().FORM_UNFOLDING]
      })
    ]));
  }
  if (errRule && validOpts.showMessage) {
    const validParams = Object.assign(Object.assign({}, params), { rule: errRule });
    contentVNs.push(h("div", {
      class: "vxe-form-item--valid-error-tip",
      style: errRule.maxWidth ? {
        width: toCssUnit(errRule.maxWidth)
      } : null
    }, [
      h("div", {
        class: `vxe-form-item--valid-error-wrapper vxe-form-item--valid-error-theme-${validOpts.theme || "normal"}`
      }, [
        validSlot ? $xeForm.callSlot(validSlot, validParams) : [
          h("span", {
            class: "vxe-form--item--valid-error-msg"
          }, errRule.content || errRule.message)
        ]
      ])
    ]));
  }
  return h("div", {
    class: "vxe-form--item-inner"
  }, contentVNs);
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form/src/form-config-item.js
var import_xe_utils31 = __toESM(require_xe_utils());
var VxeFormConfigItem = defineComponent({
  name: "VxeFormConfigItem",
  props: {
    itemConfig: Object
  },
  setup(props) {
    const $xeForm = inject("$xeForm", {});
    const xeformiteminfo = { itemConfig: props.itemConfig };
    provide("xeFormItemInfo", xeformiteminfo);
    const renderItem = ($xeForm2, item) => {
      const formProps = $xeForm2.props;
      const $xeGrid = $xeForm2.xeGrid;
      const { data, readonly, disabled } = formProps;
      const { visible, field, itemRender, contentStyle, children, showContent } = item;
      const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm2, $grid: $xeGrid };
      const hasGroup = children && children.length > 0;
      if (visible === false) {
        return createCommentVNode();
      }
      return h("div", {
        key: item.id,
        class: getItemClass($xeForm2, item),
        style: import_xe_utils31.default.isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [
        renderTitle($xeForm2, item),
        showContent === false ? createCommentVNode() : h("div", {
          class: getItemContentClass($xeForm2, item),
          style: Object.assign({}, import_xe_utils31.default.isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, import_xe_utils31.default.isFunction(contentStyle) ? contentStyle(params) : contentStyle)
        }, hasGroup ? children.map((childItem) => renderItem($xeForm2, childItem)) : [
          renderItemContent($xeForm2, item)
        ])
      ]);
    };
    const renderVN = () => {
      return renderItem($xeForm, props.itemConfig);
    };
    const $xeFormconfigitem = {
      renderVN
    };
    provide("$xeFormGroup", null);
    return $xeFormconfigitem;
  },
  render() {
    return this.renderVN();
  }
});
var form_config_item_default = VxeFormConfigItem;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form/src/form.js
var Rule = class {
  constructor(rule) {
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.min,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  get content() {
    return getFuncText(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
};
var validErrorRuleValue = (rule, val) => {
  const { type, min, max, pattern } = rule;
  const isNumType = type === "number";
  const numVal = isNumType ? import_xe_utils32.default.toNumber(val) : import_xe_utils32.default.getSize(val);
  if (isNumType && isNaN(val)) {
    return true;
  }
  if (!import_xe_utils32.default.eqNull(min) && numVal < import_xe_utils32.default.toNumber(min)) {
    return true;
  }
  if (!import_xe_utils32.default.eqNull(max) && numVal > import_xe_utils32.default.toNumber(max)) {
    return true;
  }
  if (pattern && !(import_xe_utils32.default.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
    return true;
  }
  return false;
};
var form_default = defineComponent({
  name: "VxeForm",
  props: {
    collapseStatus: {
      type: Boolean,
      default: true
    },
    loading: Boolean,
    data: Object,
    size: {
      type: String,
      default: () => getConfig().form.size || getConfig().size
    },
    span: {
      type: [String, Number],
      default: () => getConfig().form.span
    },
    align: {
      type: String,
      default: () => getConfig().form.align
    },
    verticalAlign: {
      type: String,
      default: () => getConfig().form.verticalAlign
    },
    border: {
      type: Boolean,
      default: () => getConfig().form.border
    },
    titleBackground: {
      type: Boolean,
      default: () => getConfig().form.titleBackground
    },
    titleBold: {
      type: Boolean,
      default: () => getConfig().form.titleBold
    },
    titleAlign: {
      type: String,
      default: () => getConfig().form.titleAlign
    },
    titleWidth: {
      type: [String, Number],
      default: () => getConfig().form.titleWidth
    },
    titleColon: {
      type: Boolean,
      default: () => getConfig().form.titleColon
    },
    titleAsterisk: {
      type: Boolean,
      default: () => getConfig().form.titleAsterisk
    },
    titleOverflow: {
      type: [Boolean, String],
      default: () => getConfig().form.titleOverflow
    },
    vertical: {
      type: Boolean,
      default: () => getConfig().form.vertical
    },
    padding: {
      type: Boolean,
      default: () => getConfig().form.padding
    },
    className: [String, Function],
    readonly: Boolean,
    disabled: Boolean,
    items: Array,
    rules: Object,
    preventSubmit: {
      type: Boolean,
      default: () => getConfig().form.preventSubmit
    },
    validConfig: Object,
    tooltipConfig: Object,
    collapseConfig: Object,
    customLayout: {
      type: Boolean,
      default: () => getConfig().form.customLayout
    }
  },
  emits: [
    "update:collapseStatus",
    "collapse",
    "toggle-collapse",
    "submit",
    "submit-invalid",
    "reset"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeGrid = inject("$xeGrid", null);
    const xID = import_xe_utils32.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      collapseAll: props.collapseStatus,
      staticItems: [],
      formItems: []
    });
    const internalData = reactive({
      meTimeout: void 0,
      stTimeout: void 0,
      tooltipStore: {
        item: null,
        visible: false
      }
    });
    const refElem = ref();
    const refTooltip = ref();
    let formMethods = {};
    const computeValidOpts = computed(() => {
      return Object.assign({}, getConfig().form.validConfig, props.validConfig);
    });
    const computeTooltipOpts = computed(() => {
      return Object.assign({}, getConfig().tooltip, getConfig().form.tooltipConfig, props.tooltipConfig);
    });
    const computeCollapseOpts = computed(() => {
      return Object.assign({}, getConfig().form.collapseConfig, props.collapseConfig);
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize,
      computeValidOpts,
      computeTooltipOpts,
      computeCollapseOpts
    };
    const $xeForm = {
      xID,
      props,
      context,
      reactData,
      xeGrid: $xeGrid,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils32.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils32.default.isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const loadItem = (list) => {
      if (list.length) {
        list.forEach((item) => {
          if (item.slots) {
            import_xe_utils32.default.each(item.slots, (func) => {
              if (!import_xe_utils32.default.isFunction(func)) {
                if (!slots[func]) {
                  errLog("vxe.error.notSlot", [func]);
                }
              }
            });
          }
        });
      }
      reactData.staticItems = import_xe_utils32.default.mapTree(list, (item) => createItem($xeForm, item), { children: "children" });
      return nextTick();
    };
    const getItems = () => {
      const itemList = [];
      import_xe_utils32.default.eachTree(reactData.formItems, (item) => {
        itemList.push(item);
      }, { children: "children" });
      return itemList;
    };
    const getItemByField = (field) => {
      const rest = import_xe_utils32.default.findTree(reactData.formItems, (item) => item.field === field, { children: "children" });
      return rest ? rest.item : null;
    };
    const getCollapseStatus = () => {
      return reactData.collapseAll;
    };
    const toggleCollapse = () => {
      const status = !getCollapseStatus();
      reactData.collapseAll = status;
      emit("update:collapseStatus", status);
      return nextTick();
    };
    const toggleCollapseEvent = (evnt) => {
      toggleCollapse();
      const status = getCollapseStatus();
      formMethods.dispatchEvent("toggle-collapse", { status, collapse: status, data: props.data }, evnt);
      formMethods.dispatchEvent("collapse", { status, collapse: status, data: props.data }, evnt);
      nextTick(() => {
        if ($xeGrid) {
          $xeGrid.recalculate();
        }
      });
    };
    const clearValidate = (fieldOrItem) => {
      if (fieldOrItem) {
        let fields = fieldOrItem;
        if (!import_xe_utils32.default.isArray(fieldOrItem)) {
          fields = [fieldOrItem];
        }
        fields.forEach((field) => {
          if (field) {
            const item = handleFieldOrItem($xeForm, field);
            if (item) {
              item.showError = false;
            }
          }
        });
      } else {
        getItems().forEach((item) => {
          item.showError = false;
        });
      }
      return nextTick();
    };
    const getResetValue = (item, data) => {
      const { field, resetValue } = item;
      const itemValue = import_xe_utils32.default.get(data, field);
      if (import_xe_utils32.default.isFunction(resetValue)) {
        return resetValue({ field, item, data, $form: $xeForm, $grid: $xeGrid });
      } else if (resetValue === null) {
        if (import_xe_utils32.default.isArray(itemValue)) {
          return [];
        }
      }
      return resetValue;
    };
    const reset = () => {
      const { data } = props;
      const itemList = getItems();
      if (data) {
        itemList.forEach((item) => {
          const { field, itemRender } = item;
          if (isEnableConf(itemRender)) {
            const compConf = renderer.get(itemRender.name);
            const fiResetMethod = compConf ? compConf.formItemResetMethod || compConf.itemResetMethod : null;
            if (compConf && fiResetMethod) {
              fiResetMethod({ data, field, property: field, item, $form: $xeForm, $grid: $xeGrid });
            } else if (field) {
              import_xe_utils32.default.set(data, field, getResetValue(item, data));
            }
          }
        });
      }
      return clearValidate();
    };
    const resetEvent = (evnt) => {
      evnt.preventDefault();
      reset();
      formMethods.dispatchEvent("reset", { data: props.data }, evnt);
    };
    const handleFocus = (fields) => {
      const el = refElem.value;
      if (el) {
        for (let i = 0; i < fields.length; i++) {
          const field = fields[i];
          const item = getItemByField(field);
          if (item && isEnableConf(item.itemRender)) {
            const { itemRender } = item;
            const compConf = renderer.get(itemRender.name);
            if (!i) {
              scrollToView(el.querySelector(`.${item.id}`));
            }
            let inputElem = null;
            const autoFocus = itemRender.autoFocus || itemRender.autofocus || (compConf ? compConf.formItemAutoFocus : null);
            if (import_xe_utils32.default.isFunction(autoFocus)) {
              inputElem = autoFocus({ $form: $xeForm, $grid: $xeGrid, item, data: props.data, field });
            } else {
              if (autoFocus === true) {
                inputElem = el.querySelector(`.${item.id} input,textarea`);
              } else if (autoFocus) {
                inputElem = el.querySelector(`.${item.id} ${autoFocus}`);
              }
            }
            if (inputElem) {
              inputElem.focus();
              break;
            }
          }
        }
      }
    };
    const validItemRules = (validType, fields, val) => {
      const { data, rules: formRules } = props;
      const errorMaps = {};
      if (!import_xe_utils32.default.isArray(fields)) {
        fields = [fields];
      }
      return Promise.all(fields.map((property) => {
        const errorRules = [];
        const syncVailds = [];
        if (property && formRules) {
          const rules = import_xe_utils32.default.get(formRules, property);
          if (rules) {
            const itemValue = import_xe_utils32.default.isUndefined(val) ? import_xe_utils32.default.get(data, property) : val;
            rules.forEach((rule) => {
              const { type, trigger, required, validator } = rule;
              if (validType === "all" || !trigger || validType === trigger) {
                if (validator) {
                  const validParams = {
                    itemValue,
                    rule,
                    rules,
                    data,
                    field: property,
                    property,
                    $form: $xeForm
                  };
                  let customValid;
                  if (import_xe_utils32.default.isString(validator)) {
                    const gvItem = validators.get(validator);
                    if (gvItem) {
                      const validatorMethod = gvItem.formItemValidatorMethod || gvItem.itemValidatorMethod;
                      if (validatorMethod) {
                        customValid = validatorMethod(validParams);
                      } else {
                        if (true) {
                          warnLog("vxe.error.notValidators", [validator]);
                        }
                      }
                    } else {
                      if (true) {
                        errLog("vxe.error.notValidators", [validator]);
                      }
                    }
                  } else {
                    customValid = validator(validParams);
                  }
                  if (customValid) {
                    if (import_xe_utils32.default.isError(customValid)) {
                      errorRules.push(new Rule({ type: "custom", trigger, content: customValid.message, rule: new Rule(rule) }));
                    } else if (customValid.catch) {
                      syncVailds.push(customValid.catch((e) => {
                        errorRules.push(new Rule({ type: "custom", trigger, content: e ? e.message : rule.content || rule.message, rule: new Rule(rule) }));
                      }));
                    }
                  }
                } else {
                  const isArrType = type === "array";
                  const isArrVal = import_xe_utils32.default.isArray(itemValue);
                  let hasEmpty = true;
                  if (isArrType || isArrVal) {
                    hasEmpty = !isArrVal || !itemValue.length;
                  } else if (import_xe_utils32.default.isString(itemValue)) {
                    hasEmpty = eqEmptyValue(itemValue.trim());
                  } else {
                    hasEmpty = eqEmptyValue(itemValue);
                  }
                  if (required ? hasEmpty || validErrorRuleValue(rule, itemValue) : !hasEmpty && validErrorRuleValue(rule, itemValue)) {
                    errorRules.push(new Rule(rule));
                  }
                }
              }
            });
          }
        }
        return Promise.all(syncVailds).then(() => {
          if (errorRules.length) {
            errorMaps[property] = errorRules.map((rule) => {
              return {
                $form: $xeForm,
                rule,
                data,
                field: property,
                property
              };
            });
          }
        });
      })).then(() => {
        if (!import_xe_utils32.default.isEmpty(errorMaps)) {
          return Promise.reject(errorMaps);
        }
      });
    };
    const beginValidate = (itemList, type, callback) => {
      const { data, rules: formRules } = props;
      const validOpts = computeValidOpts.value;
      const validRest = {};
      const validFields = [];
      const itemValids = [];
      clearTimeout(internalData.meTimeout);
      if (data && formRules) {
        itemList.forEach((item) => {
          const { field } = item;
          if (field && !isHiddenItem($xeForm, item) && isActiveItem($xeForm, item)) {
            itemValids.push(validItemRules(type || "all", field).then(() => {
              item.errRule = null;
            }).catch((errorMaps) => {
              const rest = errorMaps[field];
              if (!validRest[field]) {
                validRest[field] = [];
              }
              validRest[field].push(rest);
              validFields.push(field);
              item.errRule = rest[0].rule;
              return Promise.reject(rest);
            }));
          }
        });
        return Promise.all(itemValids).then(() => {
          if (callback) {
            callback();
          }
        }).catch(() => {
          return new Promise((resolve) => {
            internalData.meTimeout = setTimeout(() => {
              itemList.forEach((item) => {
                if (item.errRule) {
                  item.showError = true;
                }
              });
            }, 20);
            if (validOpts.autoPos !== false) {
              nextTick(() => {
                handleFocus(validFields);
              });
            }
            if (callback) {
              callback(validRest);
              resolve();
            } else {
              resolve(validRest);
            }
          });
        });
      }
      if (callback) {
        callback();
      }
      return Promise.resolve();
    };
    const validate = (callback) => {
      const { readonly } = props;
      clearValidate();
      if (readonly) {
        return nextTick();
      }
      return beginValidate(getItems(), "", callback);
    };
    const validateField = (fieldOrItem, callback) => {
      const { readonly } = props;
      if (readonly) {
        return nextTick();
      }
      let fields = [];
      if (fieldOrItem) {
        if (import_xe_utils32.default.isArray(fieldOrItem)) {
          fields = fieldOrItem;
        } else {
          fields = [fieldOrItem];
        }
      }
      return beginValidate(fields.map((field) => handleFieldOrItem($xeForm, field)), "", callback);
    };
    const submitEvent = (evnt) => {
      const { readonly } = props;
      evnt.preventDefault();
      if (!props.preventSubmit) {
        clearValidate();
        if (readonly) {
          formMethods.dispatchEvent("submit", { data: props.data }, evnt);
          return;
        }
        beginValidate(getItems()).then((errMap) => {
          if (errMap) {
            formMethods.dispatchEvent("submit-invalid", { data: props.data, errMap }, evnt);
          } else {
            formMethods.dispatchEvent("submit", { data: props.data }, evnt);
          }
        });
      }
    };
    const closeTooltip = () => {
      const { tooltipStore } = internalData;
      const $tooltip = refTooltip.value;
      if (tooltipStore.visible) {
        Object.assign(tooltipStore, {
          item: null,
          visible: false
        });
        if ($tooltip) {
          $tooltip.close();
        }
      }
      return nextTick();
    };
    const triggerTitleTipEvent = (evnt, params) => {
      const { item } = params;
      const { tooltipStore } = internalData;
      const $tooltip = refTooltip.value;
      const overflowElem = evnt.currentTarget.children[0];
      const content = (overflowElem.textContent || "").trim();
      const isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;
      clearTimeout(internalData.stTimeout);
      if (tooltipStore.item !== item) {
        closeTooltip();
      }
      if (content && isCellOverflow) {
        Object.assign(tooltipStore, {
          item,
          visible: true
        });
        if ($tooltip) {
          $tooltip.open(overflowElem, content);
        }
      }
    };
    const handleTitleTipLeaveEvent = () => {
      const tooltipOpts = computeTooltipOpts.value;
      let $tooltip = refTooltip.value;
      if ($tooltip) {
        $tooltip.setActived(false);
      }
      if (tooltipOpts.enterable) {
        internalData.stTimeout = setTimeout(() => {
          $tooltip = refTooltip.value;
          if ($tooltip && !$tooltip.isActived()) {
            closeTooltip();
          }
        }, tooltipOpts.leaveDelay);
      } else {
        closeTooltip();
      }
    };
    const triggerItemEvent = (evnt, field, itemValue) => {
      if (field) {
        return validItemRules(evnt ? ["blur"].includes(evnt.type) ? "blur" : "change" : "all", field, itemValue).then(() => {
          clearValidate(field);
        }).catch((errorMaps) => {
          const rest = errorMaps[field];
          const item = getItemByField(field);
          if (rest && item) {
            item.showError = true;
            item.errRule = rest[0].rule;
          }
        });
      }
      return nextTick();
    };
    const updateStatus = (scope, itemValue) => {
      const { field } = scope;
      return triggerItemEvent(new Event("change"), field, itemValue);
    };
    formMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $form: $xeForm, $grid: $xeGrid }, params));
      },
      reset,
      validate,
      validateField,
      clearValidate,
      updateStatus,
      toggleCollapse,
      getItems,
      getItemByField,
      closeTooltip
    };
    const formPrivateMethods = {
      callSlot,
      triggerItemEvent,
      toggleCollapseEvent,
      triggerTitleTipEvent,
      handleTitleTipLeaveEvent
    };
    Object.assign($xeForm, formMethods, formPrivateMethods);
    const renderVN = () => {
      const { loading: loading2, border, className, data, customLayout } = props;
      const { formItems } = reactData;
      const vSize = computeSize.value;
      const tooltipOpts = computeTooltipOpts.value;
      const defaultSlot = slots.default;
      return h("form", {
        ref: refElem,
        class: ["vxe-form", className ? import_xe_utils32.default.isFunction(className) ? className({ items: formItems, data, $form: $xeForm }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--border": border,
          "custom--layout": customLayout,
          "is--loading": loading2
        }],
        onSubmit: submitEvent,
        onReset: resetEvent
      }, [
        h("div", {
          class: "vxe-form--wrapper vxe-form--item-row"
        }, customLayout ? defaultSlot ? defaultSlot({}) : [] : formItems.map((item, index) => {
          return h(form_config_item_default, {
            key: index,
            itemConfig: item
          });
        })),
        h("div", {
          class: "vxe-form-slots",
          ref: "hideItem"
        }, customLayout ? [] : defaultSlot ? defaultSlot({}) : []),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-form--loading",
          modelValue: loading2
        }),
        /**
         * 工具提示
         */
        h(tooltip_default, Object.assign({ ref: refTooltip }, tooltipOpts))
      ]);
    };
    const staticItemFlag = ref(0);
    watch(() => reactData.staticItems.length, () => {
      staticItemFlag.value++;
    });
    watch(() => reactData.staticItems, () => {
      staticItemFlag.value++;
    });
    watch(staticItemFlag, () => {
      reactData.formItems = reactData.staticItems;
    });
    const itemFlag = ref(0);
    watch(() => props.items ? props.items.length : -1, () => {
      itemFlag.value++;
    });
    watch(() => props.items, () => {
      itemFlag.value++;
    });
    watch(itemFlag, () => {
      loadItem(props.items || []);
    });
    watch(() => props.collapseStatus, (value) => {
      reactData.collapseAll = !!value;
    });
    watch(() => props.readonly, () => {
      clearValidate();
    });
    watch(() => props.disabled, () => {
      clearValidate();
    });
    onMounted(() => {
      nextTick(() => {
        if (props.customLayout && props.items) {
          errLog("vxe.error.errConflicts", ["custom-layout", "items"]);
        }
      });
    });
    if (props.items) {
      loadItem(props.items);
    }
    provide("xeFormItemInfo", null);
    provide("$xeForm", $xeForm);
    provide("$xeFormGroup", null);
    provide("$xeFormItem", null);
    $xeForm.renderVN = renderVN;
    return $xeForm;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form/render/index.js
var import_xe_utils33 = __toESM(require_xe_utils());
var componentDefaultModelProp = "modelValue";
function getOldComponentName(name) {
  return `vxe-${name.replace("$", "")}`;
}
function getDefaultComponent({ name }) {
  return getComponent(name) || resolveComponent(name);
}
function getOldComponent({ name }) {
  return resolveComponent(getOldComponentName(name));
}
function getNativeAttrs(renderOpts) {
  let { name, attrs } = renderOpts;
  if (name === "input") {
    attrs = Object.assign({ type: "text" }, attrs);
  }
  return attrs;
}
function getComponentFormItemProps(renderOpts, params, value, defaultProps) {
  return import_xe_utils33.default.assign({}, defaultProps, renderOpts.props, { [componentDefaultModelProp]: value });
}
function getNativeElementOns(renderOpts, params, modelFunc, changeFunc) {
  const { events } = renderOpts;
  const modelEvent = getModelEvent(renderOpts.name);
  const changeEvent = getChangeEvent(renderOpts.name);
  const isSameEvent = changeEvent === modelEvent;
  const ons = {};
  if (events) {
    import_xe_utils33.default.objectEach(events, (func, key) => {
      ons[getOnName(key)] = function(...args) {
        func(params, ...args);
      };
    });
  }
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (isSameEvent && changeFunc) {
        changeFunc(targetEvnt);
      }
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (!isSameEvent && changeFunc) {
    ons[getOnName(changeEvent)] = function(...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
function getComponentOns(renderOpts, params, modelFunc, changeFunc) {
  const { events } = renderOpts;
  const modelEvent = getModelEvent(renderOpts.name);
  const changeEvent = getChangeEvent(renderOpts.name);
  const ons = {};
  import_xe_utils33.default.objectEach(events, (func, key) => {
    ons[getOnName(key)] = function(...args) {
      if (true) {
        if (!import_xe_utils33.default.isFunction(func)) {
          errLog("vxe.error.errFunc", [func]);
        }
      }
      func(params, ...args);
    };
  });
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (changeFunc) {
    ons[getOnName(changeEvent)] = function(...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
function getItemOns(renderOpts, params) {
  const { $form, data, field } = params;
  return getComponentOns(renderOpts, params, (value) => {
    import_xe_utils33.default.set(data, field, value);
  }, () => {
    $form.updateStatus(params);
  });
}
function getNativeItemOns(renderOpts, params) {
  const { $form, data, field } = params;
  return getNativeElementOns(renderOpts, params, (evnt) => {
    const itemValue = evnt.target.value;
    import_xe_utils33.default.set(data, field, itemValue);
  }, () => {
    $form.updateStatus(params);
  });
}
function renderNativeOptgroup(renderOpts, params, renderOptionsMethods) {
  const { optionGroups, optionGroupProps = {} } = renderOpts;
  const groupOptions = optionGroupProps.options || "options";
  const groupLabel = optionGroupProps.label || "label";
  return optionGroups.map((group, gIndex) => {
    return h("optgroup", {
      key: gIndex,
      label: group[groupLabel]
    }, renderOptionsMethods(group[groupOptions], renderOpts, params));
  });
}
function nativeItemRender(renderOpts, params) {
  const { data, field } = params;
  const { name } = renderOpts;
  const attrs = getNativeAttrs(renderOpts);
  const itemValue = import_xe_utils33.default.get(data, field);
  return [
    h(name, Object.assign(Object.assign(Object.assign({ class: `vxe-default-${name}` }, attrs), { value: attrs && name === "input" && (attrs.type === "submit" || attrs.type === "reset") ? null : itemValue }), getNativeItemOns(renderOpts, params)))
  ];
}
function defaultItemRender(renderOpts, params) {
  const { data, field } = params;
  const itemValue = import_xe_utils33.default.get(data, field);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function oldItemRender(renderOpts, params) {
  const { data, field } = params;
  const itemValue = import_xe_utils33.default.get(data, field);
  return [
    h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function oldButtonItemRender(renderOpts, params) {
  return [
    h(resolveComponent("vxe-button"), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
  ];
}
function oldButtonsItemRender(renderOpts, params) {
  return renderOpts.children.map((childRenderOpts) => oldButtonItemRender(childRenderOpts, params)[0]);
}
function renderNativeFormOptions(options, renderOpts, params) {
  const { data, field } = params;
  const { optionProps = {} } = renderOpts;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const disabledProp = optionProps.disabled || "disabled";
  const cellValue = import_xe_utils33.default.get(data, field);
  return options.map((item, oIndex) => {
    return h("option", {
      key: oIndex,
      value: item[valueProp],
      disabled: item[disabledProp],
      /* eslint-disable eqeqeq */
      selected: item[valueProp] == cellValue
    }, item[labelProp]);
  });
}
function defaultFormItemRender(renderOpts, params) {
  const { data, field } = params;
  const itemValue = import_xe_utils33.default.get(data, field);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function formItemRadioAndCheckboxRender(renderOpts, params) {
  const { options, optionProps } = renderOpts;
  const { data, field } = params;
  const itemValue = import_xe_utils33.default.get(data, field);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({
      options,
      optionProps
    }, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function oldFormItemRadioAndCheckboxRender(renderOpts, params) {
  const { name, options, optionProps = {} } = renderOpts;
  const { data, field } = params;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const disabledProp = optionProps.disabled || "disabled";
  const itemValue = import_xe_utils33.default.get(data, field);
  const compName = getOldComponentName(name);
  if (options) {
    return [
      h(resolveComponent(`${compName}-group`), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)), {
        default: () => {
          return options.map((item, index) => {
            return h(resolveComponent(compName), {
              key: index,
              label: item[valueProp],
              content: item[labelProp],
              disabled: item[disabledProp]
            });
          });
        }
      })
    ];
  }
  return [
    h(resolveComponent(compName), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
renderer.mixin({
  input: {
    formItemAutoFocus: "input",
    renderFormItemContent: nativeItemRender
  },
  textarea: {
    formItemAutoFocus: "textarea",
    renderFormItemContent: nativeItemRender
  },
  select: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      return [
        h("select", Object.assign(Object.assign({ class: "vxe-default-select" }, getNativeAttrs(renderOpts)), getNativeItemOns(renderOpts, params)), renderOpts.optionGroups ? renderNativeOptgroup(renderOpts, params, renderNativeFormOptions) : renderNativeFormOptions(renderOpts.options, renderOpts, params))
      ];
    }
  },
  VxeInput: {
    formItemAutoFocus: "input",
    renderFormItemContent: defaultItemRender
  },
  VxeNumberInput: {
    formItemAutoFocus: "input",
    renderFormItemContent: defaultItemRender
  },
  VxePasswordInput: {
    formItemAutoFocus: "input",
    renderFormItemContent: defaultItemRender
  },
  VxeTextarea: {
    formItemAutoFocus: "textarea",
    renderFormItemContent: defaultItemRender
  },
  VxeDatePicker: {
    formItemAutoFocus: "input",
    renderFormItemContent: defaultItemRender
  },
  VxeButton: {
    renderFormItemContent: defaultFormItemRender
  },
  VxeButtonGroup: {
    renderFormItemContent(renderOpts, params) {
      const { options } = renderOpts;
      const { data, field } = params;
      const itemValue = import_xe_utils33.default.get(data, field);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ options }, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeSelect: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      const itemValue = import_xe_utils33.default.get(data, field);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps, optionGroups, optionGroupProps })), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeTreeSelect: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options, optionProps } = renderOpts;
      const itemValue = import_xe_utils33.default.get(data, field);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps })), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeTableSelect: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options, optionProps } = renderOpts;
      const itemValue = import_xe_utils33.default.get(data, field);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps })), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeColorPicker: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options } = renderOpts;
      const itemValue = import_xe_utils33.default.get(data, field);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { colors: options })), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeIconPicker: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options } = renderOpts;
      const itemValue = import_xe_utils33.default.get(data, field);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { icons: options })), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeRadio: {
    renderFormItemContent: defaultFormItemRender
  },
  VxeRadioGroup: {
    renderFormItemContent: formItemRadioAndCheckboxRender
  },
  VxeCheckbox: {
    renderFormItemContent: defaultFormItemRender
  },
  VxeCheckboxGroup: {
    renderFormItemContent: formItemRadioAndCheckboxRender
  },
  VxeSwitch: {
    renderFormItemContent: defaultItemRender
  },
  VxeRate: {
    renderFormItemContent: defaultItemRender
  },
  VxeSlider: {
    renderFormItemContent: defaultItemRender
  },
  VxeImage: {
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { props } = renderOpts;
      const itemValue = import_xe_utils33.default.get(data, field);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { src: itemValue }), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeImageGroup: {
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { props } = renderOpts;
      const itemValue = import_xe_utils33.default.get(data, field);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { urlList: itemValue }), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeUpload: {
    renderFormItemContent: defaultItemRender
  },
  // 以下已废弃
  $input: {
    formItemAutoFocus: "input",
    renderFormItemContent: oldItemRender
  },
  $textarea: {
    formItemAutoFocus: "textarea",
    renderFormItemContent: oldItemRender
  },
  $button: {
    renderFormItemContent: oldButtonItemRender
  },
  $buttons: {
    renderFormItemContent: oldButtonsItemRender
  },
  $select: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      const itemValue = import_xe_utils33.default.get(data, field);
      return [
        h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps, optionGroups, optionGroupProps })), getItemOns(renderOpts, params)))
      ];
    }
  },
  $radio: {
    renderFormItemContent: oldFormItemRadioAndCheckboxRender
  },
  $checkbox: {
    renderFormItemContent: oldFormItemRadioAndCheckboxRender
  },
  $switch: {
    renderFormItemContent: oldItemRender
  }
  // 以上已废弃
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form/index.js
var VxeForm = Object.assign(form_default, {
  install(app) {
    app.component(form_default.name, form_default);
  }
});
dynamicApp.use(VxeForm);
VxeUI.component(form_default);
var Form = VxeForm;
var form_default2 = VxeForm;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/src/util.js
var import_xe_utils34 = __toESM(require_xe_utils());
var maxWidgetId = 1e5;
function getNewWidgetId(widgetObjList) {
  import_xe_utils34.default.eachTree(widgetObjList, (item) => {
    if (item) {
      maxWidgetId = Math.max(maxWidgetId, item.id);
    }
  }, { children: "children" });
  return ++maxWidgetId;
}
var hasFormDesignLayoutType = (widget) => {
  if (widget) {
    const widgetConf = getWidgetConfig(widget.name);
    return widgetConf.group === "layout";
  }
  return false;
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/src/widget-info.js
var import_xe_utils35 = __toESM(require_xe_utils());
var refWidgetReactConfigMaps = ref({});
var getWidgetConfig = (name) => {
  const widgetReactConfigMaps = refWidgetReactConfigMaps.value;
  return widgetReactConfigMaps[name] || {};
};
function getWidgetConfigTitle(name, $xeFormDesign) {
  const widgetConf = getWidgetConfig(name);
  if (widgetConf) {
    const configTitle = widgetConf.title;
    const params = { name, $formDesign: $xeFormDesign };
    return import_xe_utils35.default.toValueString(import_xe_utils35.default.isFunction(configTitle) ? configTitle(params) : configTitle);
  }
  return name;
}
function getWidgetConfigCustomGroup(name, $xeFormDesign) {
  const widgetConf = getWidgetConfig(name);
  if (widgetConf) {
    const configCustomGroup = widgetConf.customGroup;
    const params = { name, $formDesign: $xeFormDesign };
    return import_xe_utils35.default.toValueString(import_xe_utils35.default.isFunction(configCustomGroup) ? configCustomGroup(params) : configCustomGroup);
  }
  return name;
}
var validWidgetUniqueField = (field, widgetObjList) => {
  return !import_xe_utils35.default.findTree(widgetObjList, (item) => item.field === field, { children: "children" });
};
var FormDesignWidgetInfo = class {
  constructor($xeFormDesign, name, widgetObjList) {
    Object.defineProperty(this, "id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "field", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    Object.defineProperty(this, "title", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    Object.defineProperty(this, "required", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "hidden", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "options", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "children", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "model", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {
        update: false,
        value: ""
      }
    });
    let customField = "";
    if (name) {
      const compConf = renderer.get(name) || {};
      if (compConf) {
        const widgetReactConfigMaps = refWidgetReactConfigMaps.value;
        const createWidgetFormConfig = compConf.createFormDesignWidgetConfig;
        if (createWidgetFormConfig) {
          const params = { name, $formDesign: $xeFormDesign };
          const widgetConfig = createWidgetFormConfig(params) || {};
          const titleConf = widgetConfig.title;
          const fieldConf = widgetConfig.field;
          this.title = import_xe_utils35.default.toValueString(import_xe_utils35.default.isFunction(titleConf) ? titleConf(params) : titleConf);
          this.options = widgetConfig.options || {};
          this.children = widgetConfig.children || [];
          if (fieldConf) {
            if (import_xe_utils35.default.isFunction(fieldConf)) {
              customField = fieldConf({ name, $formDesign: $xeFormDesign });
            } else {
              customField = fieldConf;
            }
          }
          if (!widgetReactConfigMaps[name]) {
            widgetReactConfigMaps[name] = Object.assign({}, widgetConfig);
            refWidgetReactConfigMaps.value = Object.assign({}, widgetReactConfigMaps);
          }
        }
      }
    }
    const widgetId = getNewWidgetId(widgetObjList);
    if (customField) {
      if (!validWidgetUniqueField(customField, widgetObjList)) {
        errLog("vxe.error.uniField", [customField]);
      }
    }
    this.id = widgetId;
    this.field = customField || `${name}${widgetId}`;
    this.name = name;
  }
};
function configToWidget(conf) {
  const widget = new FormDesignWidgetInfo(null, conf.name, []);
  widget.id = conf.id;
  widget.title = conf.title || "";
  widget.field = conf.field || "";
  widget.required = conf.required || false;
  widget.hidden = conf.hidden || false;
  widget.options = Object.assign({}, widget.options, conf.options);
  widget.children = conf.children ? conf.children.map((item) => configToWidget(item)) : [];
  return widget;
}

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/src/form-design.js
var import_xe_utils46 = __toESM(require_xe_utils());

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/src/layout-widget.js
var import_xe_utils36 = __toESM(require_xe_utils());
var layout_widget_default = defineComponent({
  props: {},
  emits: [],
  setup() {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const dragstartEvent = (evnt) => {
      const divEl = evnt.currentTarget;
      const dataTransfer = evnt.dataTransfer;
      const widgetName = divEl.getAttribute("data-widget-name") || "";
      if ($xeFormDesign.validWidgetUnique(widgetName)) {
        const dragWidget = $xeFormDesign.createWidget(widgetName);
        if (dataTransfer) {
          dataTransfer.setData("text/plain", widgetName);
        }
        formDesignReactData.sortWidget = null;
        formDesignReactData.dragWidget = dragWidget;
      } else {
        evnt.preventDefault();
      }
    };
    const dragendEvent = (evnt) => {
      evnt.preventDefault();
      if (formDesignReactData.dragWidget) {
        const newWidget = formDesignReactData.dragWidget;
        formDesignReactData.activeWidget = newWidget;
        $xeFormDesign.dispatchEvent("add-widget", { newWidget }, evnt);
      }
      formDesignReactData.dragWidget = null;
      formDesignReactData.sortWidget = null;
    };
    const cancelDragoverItem = (evnt, group) => {
      const { widgetObjList, dragWidget } = formDesignReactData;
      if (dragWidget) {
        if (group.children.some((widget) => widget.name === dragWidget.name)) {
          const rest = import_xe_utils36.default.findTree(widgetObjList, (item) => item && item.id === dragWidget.id, { children: "children" });
          if (rest) {
            rest.items.splice(rest.index, 1);
          }
        }
      }
    };
    const addNewWidget = (evnt, widgetName) => {
      if ($xeFormDesign.validWidgetUnique(widgetName)) {
        const { widgetObjList } = formDesignReactData;
        const dragWidget = $xeFormDesign.createWidget(widgetName);
        widgetObjList.push(dragWidget);
        formDesignReactData.activeWidget = dragWidget;
        formDesignReactData.sortWidget = null;
        formDesignReactData.dragWidget = null;
        $xeFormDesign.dispatchEvent("add-widget", { newWidget: dragWidget }, evnt);
      }
    };
    const renderWidgetList = (group) => {
      const widgetVNs = [];
      if (group.children) {
        group.children.forEach((widget, index) => {
          const { name } = widget;
          const configTitle = getWidgetConfigTitle(name, $xeFormDesign);
          const compConf = renderer.get(name) || {};
          const widgetConf = getWidgetConfig(name);
          const renderWidgetItem = compConf.renderFormDesignWidgetItem;
          widgetVNs.push(h("div", {
            key: index,
            class: "vxe-form-design--widget-item"
          }, h("div", {
            class: "vxe-form-design--widget-box",
            "data-widget-name": name,
            title: configTitle,
            draggable: true,
            onDragstart: dragstartEvent,
            onDragend: dragendEvent
          }, renderWidgetItem ? getSlotVNs(renderWidgetItem({}, { $formDesign: $xeFormDesign })) : [
            h("i", {
              class: ["vxe-form-design--widget-item-icon", widgetConf ? widgetConf.icon || "" : ""]
            }),
            h("span", {
              class: "vxe-form-design--widget-item-name"
            }, configTitle),
            h("span", {
              class: "vxe-form-design--widget-item-add",
              onClick(evnt) {
                addNewWidget(evnt, name);
              }
            }, [
              h("i", {
                class: getIcon().FORM_DESIGN_WIDGET_ADD
              })
            ])
          ])));
        });
      }
      return widgetVNs;
    };
    const renderWidgetGroups = () => {
      const { widgetConfigs } = formDesignReactData;
      return widgetConfigs.map((config2, gIndex) => {
        const { title, group } = config2;
        return h("div", {
          key: gIndex,
          class: "vxe-form-design--widget-group"
        }, [
          h("div", {
            class: "vxe-form-design--widget-title"
          }, group ? getI18n(`vxe.formDesign.widget.group.${group}`) : `${title || ""}`),
          h("div", {
            class: "vxe-form-design--widget-list",
            onDragover(evnt) {
              cancelDragoverItem(evnt, config2);
            }
          }, renderWidgetList(config2))
        ]);
      });
    };
    return () => {
      return h("div", {
        class: "vxe-form-design--widget"
      }, renderWidgetGroups());
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/src/layout-view-item.js
var import_xe_utils37 = __toESM(require_xe_utils());
var ViewItemComponent = defineComponent({
  name: "FormDesignLayoutViewItem",
  props: {
    item: {
      type: Object,
      default: () => ({})
    },
    itemIndex: {
      type: Number,
      default: 0
    },
    items: {
      type: Array,
      default: () => []
    }
  },
  emits: [],
  setup(props, { slots }) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const sortDragstartEvent = (evnt) => {
      const { widgetObjList } = formDesignReactData;
      const divEl = evnt.currentTarget;
      const widgetId = Number(divEl.getAttribute("data-widget-id"));
      const currRest = import_xe_utils37.default.findTree(widgetObjList, (item) => item && item.id === widgetId, { children: "children" });
      if (currRest) {
        formDesignReactData.dragWidget = null;
        formDesignReactData.sortWidget = currRest.item;
      }
    };
    const sortDragendEvent = () => {
      formDesignReactData.activeWidget = formDesignReactData.sortWidget;
      formDesignReactData.sortWidget = null;
    };
    const sortDragenterEvent = (evnt) => {
      const { widgetObjList, sortWidget } = formDesignReactData;
      const formDesignInternalData = $xeFormDesign.internalData;
      const { lastDragTime } = formDesignInternalData;
      if (lastDragTime && lastDragTime > Date.now() - 300) {
        evnt.preventDefault();
        return;
      }
      if (sortWidget) {
        const divEl = evnt.currentTarget;
        evnt.preventDefault();
        const widgetId = Number(divEl.getAttribute("data-widget-id"));
        if (widgetId !== sortWidget.id) {
          const targetRest = import_xe_utils37.default.findTree(widgetObjList, (item) => item && item.id === widgetId, { children: "children" });
          if (targetRest) {
            const currRest = import_xe_utils37.default.findTree(widgetObjList, (item) => item && item.id === sortWidget.id, { children: "children" });
            if (currRest) {
              if (currRest.parent && currRest.parent.name === "row") {
                currRest.items[currRest.index] = $xeFormDesign.createEmptyWidget();
              } else {
                currRest.items.splice(currRest.index, 1);
              }
              targetRest.items.splice(targetRest.index, 0, currRest.item);
              formDesignInternalData.lastDragTime = Date.now();
              $xeFormDesign.dispatchEvent("drag-widget", { widget: currRest.item }, evnt);
            }
          }
        }
      }
    };
    const handleClickEvent = (evnt, item) => {
      $xeFormDesign.handleClickWidget(evnt, item);
    };
    return () => {
      const { dragWidget, activeWidget, sortWidget } = formDesignReactData;
      const { item } = props;
      const { name } = item;
      const isActive = activeWidget && activeWidget.id === item.id;
      const defaultSlot = slots.default;
      return h("div", {
        key: item.id,
        "data-widget-id": item.id,
        draggable: true,
        class: ["vxe-form-design--preview-item", `widget-${import_xe_utils37.default.kebabCase(name)}`, {
          "is--active": isActive,
          "is--sort": sortWidget && sortWidget.id === item.id,
          "is--drag": dragWidget && dragWidget.id === item.id
        }],
        onDragstart: sortDragstartEvent,
        onDragend: sortDragendEvent,
        onDragenter: sortDragenterEvent,
        // onDragover: dragoverItemEvent,
        onClick(evnt) {
          handleClickEvent(evnt, item);
        }
      }, [
        h("div", {
          class: "vxe-form-design--preview-item-view vxe-form--item-row"
        }, defaultSlot ? defaultSlot({}) : []),
        isActive ? h("div", {
          class: "vxe-form-design--preview-item-operate"
        }, [
          h(button_default, {
            icon: getIcon().FORM_DESIGN_WIDGET_COPY,
            status: "primary",
            size: "mini",
            circle: true,
            onClick(params) {
              $xeFormDesign.handleCopyWidget(params.$event, item);
            }
          }),
          h(button_default, {
            icon: getIcon().FORM_DESIGN_WIDGET_DELETE,
            status: "danger",
            size: "mini",
            circle: true,
            onClick(params) {
              $xeFormDesign.handleRemoveWidget(params.$event, item);
            }
          })
        ]) : createCommentVNode()
      ]);
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/src/layout-preview.js
var import_xe_utils38 = __toESM(require_xe_utils());
var layout_preview_default = defineComponent({
  name: "FormDesignLayoutPreview",
  props: {},
  emits: [],
  setup() {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const dragenterEvent = (evnt) => {
      const { widgetObjList, dragWidget } = formDesignReactData;
      if (dragWidget) {
        evnt.preventDefault();
        const rest = import_xe_utils38.default.findTree(widgetObjList, (item) => item && item.id === dragWidget.id, { children: "children" });
        if (!rest) {
          formDesignReactData.sortWidget = dragWidget;
          widgetObjList.push(dragWidget);
          $xeFormDesign.dispatchEvent("drag-widget", { widget: dragWidget }, evnt);
        }
      }
    };
    const dragoverEvent = (evnt) => {
      evnt.preventDefault();
    };
    let lastDragTime = Date.now();
    const handleDragenterTopPlaceEvent = (evnt) => {
      const { widgetObjList, sortWidget } = formDesignReactData;
      evnt.stopPropagation();
      if (lastDragTime > Date.now() - 300) {
        evnt.preventDefault();
        return;
      }
      if (sortWidget) {
        if (hasFormDesignLayoutType(sortWidget)) {
          return;
        }
        const currRest = import_xe_utils38.default.findTree(widgetObjList, (item) => item.id === sortWidget.id, { children: "children" });
        if (currRest) {
          const { item, index, items, parent } = currRest;
          if (parent && parent.name === "row") {
            currRest.items[currRest.index] = $xeFormDesign.createEmptyWidget();
          } else {
            items.splice(index, 1);
          }
          widgetObjList.unshift(item);
          lastDragTime = Date.now();
          $xeFormDesign.dispatchEvent("drag-widget", { widget: item }, evnt);
        }
      }
    };
    const handleDragenterBottomPlaceEvent = (evnt) => {
      const { widgetObjList, sortWidget } = formDesignReactData;
      evnt.stopPropagation();
      if (lastDragTime > Date.now() - 300) {
        evnt.preventDefault();
        return;
      }
      if (sortWidget) {
        if (hasFormDesignLayoutType(sortWidget)) {
          return;
        }
        const currRest = import_xe_utils38.default.findTree(widgetObjList, (item) => item.id === sortWidget.id, { children: "children" });
        if (currRest) {
          const { item, index, items, parent } = currRest;
          if (parent && parent.name === "row") {
            currRest.items[currRest.index] = $xeFormDesign.createEmptyWidget();
          } else {
            items.splice(index, 1);
          }
          widgetObjList.push(item);
          lastDragTime = Date.now();
          $xeFormDesign.dispatchEvent("drag-widget", { widget: item }, evnt);
        }
      }
    };
    return () => {
      const { widgetObjList } = formDesignReactData;
      return h("div", {
        class: "vxe-form-design--preview",
        onDragenter: dragenterEvent,
        onDragover: dragoverEvent
      }, [
        h("div", {
          class: "vxe-form-design--preview-wrapper"
        }, [
          h("div", {
            class: "vxe-form-design--preview-place-widget",
            onDragenter: handleDragenterTopPlaceEvent
          }),
          h(form_default, {
            customLayout: true,
            span: 24,
            vertical: true
          }, {
            default() {
              return h(TransitionGroup, {
                class: "vxe-form-design--preview-list",
                tag: "div",
                name: "vxe-form-design--preview-list"
              }, {
                default: () => {
                  return widgetObjList.map((widget, widgetIndex) => {
                    return h(ViewItemComponent, {
                      key: widget.id,
                      item: widget,
                      itemIndex: widgetIndex,
                      items: widgetObjList
                    }, {
                      default() {
                        const { name } = widget;
                        const compConf = renderer.get(name) || {};
                        const renderWidgetDesignView = compConf.renderFormDesignWidgetEdit || compConf.renderFormDesignWidgetView;
                        const renderOpts = widget;
                        const isEditMode = true;
                        const params = { widget, readonly: false, disabled: false, isEditMode, isViewMode: !isEditMode, $formDesign: $xeFormDesign, $formView: null };
                        return renderWidgetDesignView ? getSlotVNs(renderWidgetDesignView(renderOpts, params)) : [];
                      }
                    });
                  });
                }
              });
            }
          }),
          h("div", {
            class: "vxe-form-design--preview-place-widget",
            onDragenter: handleDragenterBottomPlaceEvent
          })
        ])
      ]);
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/tabs/src/tabs.js
var import_xe_utils39 = __toESM(require_xe_utils());
var tabs_default = defineComponent({
  name: "VxeTabs",
  props: {
    modelValue: [String, Number, Boolean],
    options: Array,
    height: [String, Number],
    destroyOnClose: Boolean,
    titleWidth: [String, Number],
    titleAlign: [String, Number],
    type: String,
    showClose: Boolean,
    padding: {
      type: Boolean,
      default: () => getConfig().tabs.padding
    },
    trigger: String,
    beforeChangeMethod: Function,
    closeConfig: Object,
    refreshConfig: Object,
    // 已废弃
    beforeCloseMethod: Function
  },
  emits: [
    "update:modelValue",
    "change",
    "tab-change",
    "tab-change-fail",
    "tab-close",
    "tab-close-fail",
    "tab-click",
    "tab-load"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils39.default.uniqueId();
    const $xeParentTabs = inject("$xeTabs", null);
    const refElem = ref();
    const refHeadWrapperElem = ref();
    const reactData = reactive({
      staticTabs: [],
      activeName: null,
      initNames: [],
      lintLeft: 0,
      lintWidth: 0,
      isTabOver: false,
      resizeFlag: 1,
      cacheTabMaps: {}
    });
    const internalData = {
      slTimeout: void 0
    };
    const refMaps = {
      refElem
    };
    const computeCloseOpts = computed(() => {
      return Object.assign({}, getConfig().tabs.closeConfig, props.closeConfig);
    });
    const computeRefreshOpts = computed(() => {
      return Object.assign({}, getConfig().tabs.refreshConfig, props.refreshConfig);
    });
    const computeTabOptions = computed(() => {
      const { options } = props;
      return (options || []).filter((item) => handleFilterTab(item));
    });
    const computeTabStaticOptions = computed(() => {
      const { staticTabs } = reactData;
      return staticTabs.filter((item) => handleFilterTab(item));
    });
    const computeMaps = {};
    const $xeTabs = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const handleFilterTab = (item) => {
      const { permissionCode } = item;
      if (permissionCode) {
        if (!permission.checkVisible(permissionCode)) {
          return false;
        }
      }
      return true;
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils39.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils39.default.isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const updateTabStyle = () => {
      nextTick(() => {
        const { type } = props;
        const { activeName } = reactData;
        const tabOptions = computeTabOptions.value;
        const tabStaticOptions = computeTabStaticOptions.value;
        const headerWrapperEl = refHeadWrapperElem.value;
        let lintWidth = 0;
        let lintLeft = 0;
        let isOver = false;
        if (headerWrapperEl) {
          const index = import_xe_utils39.default.findIndexOf(tabStaticOptions.length ? tabStaticOptions : tabOptions, (item) => item.name === activeName);
          const { children, scrollWidth, clientWidth } = headerWrapperEl;
          isOver = scrollWidth !== clientWidth;
          if (index > -1) {
            const tabEl = children[index];
            const tabWidth = tabEl.clientWidth;
            if (type) {
              if (type === "card") {
                lintWidth = tabWidth + 2;
                lintLeft = tabEl.offsetLeft;
              } else if (type === "border-card") {
                lintWidth = tabWidth + 2;
                lintLeft = tabEl.offsetLeft - 1;
              }
            } else {
              lintWidth = Math.max(4, Math.floor(tabWidth * 0.6));
              lintLeft = tabEl.offsetLeft + Math.floor((tabWidth - lintWidth) / 2);
            }
          }
        }
        reactData.lintLeft = lintLeft;
        reactData.lintWidth = lintWidth;
        reactData.isTabOver = isOver;
      });
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tabs: $xeTabs }, params));
    };
    const addInitName = (name, evnt) => {
      const { initNames } = reactData;
      if (name && !initNames.includes(name)) {
        dispatchEvent("tab-load", { name }, evnt);
        initNames.push(name);
        return true;
      }
      return false;
    };
    const initDefaultName = (list) => {
      let activeName = null;
      const nameMaps = {};
      if (list && list.length) {
        let validVal = false;
        activeName = props.modelValue;
        list.forEach((item) => {
          const { name, preload } = item || {};
          if (name) {
            nameMaps[`${name}`] = {
              loading: false
            };
            if (activeName === name) {
              validVal = true;
            }
            if (preload) {
              addInitName(name, null);
            }
          }
        });
        if (!validVal) {
          activeName = list[0].name;
          addInitName(activeName, null);
          emit("update:modelValue", activeName);
        }
      }
      reactData.activeName = activeName;
      reactData.cacheTabMaps = nameMaps;
    };
    const clickEvent = (evnt, item) => {
      const { trigger } = props;
      const beforeMethod = props.beforeChangeMethod || getConfig().tabs.beforeChangeMethod;
      const { activeName } = reactData;
      const { name } = item;
      const value = name;
      dispatchEvent("tab-click", { name }, evnt);
      if (trigger === "manual") {
        return;
      }
      if (name !== activeName) {
        Promise.resolve(!beforeMethod || beforeMethod({ $tabs: $xeTabs, name, oldName: activeName, newName: name, option: item })).then((status) => {
          if (status) {
            reactData.activeName = name;
            emit("update:modelValue", value);
            addInitName(name, evnt);
            dispatchEvent("change", { value, name, oldName: activeName, newName: name, option: item }, evnt);
            dispatchEvent("tab-change", { value, name, oldName: activeName, newName: name, option: item }, evnt);
          } else {
            dispatchEvent("tab-change-fail", { value, name, oldName: activeName, newName: name, option: item }, evnt);
          }
        }).catch(() => {
          dispatchEvent("tab-change-fail", { value, name, oldName: activeName, newName: name, option: item }, evnt);
        });
      }
    };
    const handleRefreshTabEvent = (evnt, item) => {
      evnt.stopPropagation();
      const { activeName, cacheTabMaps } = reactData;
      const { name } = item;
      const refreshOpts = computeRefreshOpts.value;
      const { queryMethod } = refreshOpts;
      const cacheItem = name ? cacheTabMaps[`${name}`] : null;
      if (cacheItem) {
        if (queryMethod) {
          cacheItem.loading = true;
          Promise.resolve(queryMethod({ $tabs: $xeTabs, value: activeName, name, option: item })).finally(() => {
            cacheItem.loading = false;
          });
        } else {
          errLog("vxe.error.notFunc", ["refresh-config.queryMethod"]);
        }
      }
    };
    const handleCloseTabEvent = (evnt, item, index, list) => {
      evnt.stopPropagation();
      const { activeName } = reactData;
      const closeOpts = computeCloseOpts.value;
      const beforeMethod = closeOpts.beforeMethod || props.beforeCloseMethod || getConfig().tabs.beforeCloseMethod;
      const { name } = item;
      const value = activeName;
      let nextName = value;
      if (activeName === name) {
        const nextItem = index < list.length - 1 ? list[index + 1] : list[index - 1];
        nextName = nextItem ? nextItem.name : null;
      }
      Promise.resolve(!beforeMethod || beforeMethod({ $tabs: $xeTabs, value, name, nextName, option: item })).then((status) => {
        if (status) {
          dispatchEvent("tab-close", { value, name, nextName }, evnt);
        } else {
          dispatchEvent("tab-close-fail", { value, name, nextName }, evnt);
        }
      }).catch(() => {
        dispatchEvent("tab-close-fail", { value, name, nextName }, evnt);
      });
    };
    const startScrollAnimation = (offsetPos, offsetSize) => {
      const { slTimeout } = internalData;
      let offsetLeft = offsetSize;
      let scrollCount = 6;
      let delayNum = 35;
      if (slTimeout) {
        clearTimeout(slTimeout);
        internalData.slTimeout = void 0;
      }
      const scrollAnimate = () => {
        const headerWrapperEl = refHeadWrapperElem.value;
        if (scrollCount > 0) {
          scrollCount--;
          if (headerWrapperEl) {
            const { clientWidth, scrollWidth, scrollLeft } = headerWrapperEl;
            offsetLeft = Math.floor(offsetLeft / 2);
            if (offsetPos > 0) {
              if (clientWidth + scrollLeft < scrollWidth) {
                headerWrapperEl.scrollLeft += offsetLeft;
                delayNum -= 4;
                internalData.slTimeout = setTimeout(scrollAnimate, delayNum);
              }
            } else {
              if (scrollLeft > 0) {
                headerWrapperEl.scrollLeft -= offsetLeft;
                delayNum -= 4;
                internalData.slTimeout = setTimeout(scrollAnimate, delayNum);
              }
            }
            updateTabStyle();
          }
        }
      };
      scrollAnimate();
    };
    const handleScrollToLeft = (offsetPos) => {
      const headerWrapperEl = refHeadWrapperElem.value;
      if (headerWrapperEl) {
        const offsetSize = Math.floor(headerWrapperEl.clientWidth * 0.75);
        startScrollAnimation(offsetPos, offsetSize);
      }
    };
    const scrollLeftEvent = () => {
      handleScrollToLeft(-1);
    };
    const scrollRightEvent = () => {
      handleScrollToLeft(1);
    };
    const scrollToTab = (name) => {
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      return nextTick().then(() => {
        const headerWrapperEl = refHeadWrapperElem.value;
        if (headerWrapperEl) {
          const index = import_xe_utils39.default.findIndexOf(tabStaticOptions.length ? tabStaticOptions : tabOptions, (item) => item.name === name);
          if (index > -1) {
            const { scrollLeft, clientWidth, children } = headerWrapperEl;
            const tabEl = children[index];
            if (tabEl) {
              const tabOffsetLeft = tabEl.offsetLeft;
              const tabClientWidth = tabEl.clientWidth;
              const overSize = tabOffsetLeft + tabClientWidth - (scrollLeft + clientWidth);
              if (overSize > 0) {
                headerWrapperEl.scrollLeft += overSize;
              }
              if (tabOffsetLeft < scrollLeft) {
                headerWrapperEl.scrollLeft = tabOffsetLeft;
              }
            }
          }
          updateTabStyle();
        }
      });
    };
    const handlePrevNext = (isNext) => {
      const { activeName } = reactData;
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      const list = tabStaticOptions.length ? tabStaticOptions : tabOptions;
      const index = import_xe_utils39.default.findIndexOf(list, (item) => item.name === activeName);
      if (index > -1) {
        let item = null;
        if (isNext) {
          if (index < list.length - 1) {
            item = list[index + 1];
          }
        } else {
          if (index > 0) {
            item = list[index - 1];
          }
        }
        if (item) {
          const name = item.name;
          const value = name;
          reactData.activeName = name;
          emit("update:modelValue", value);
          addInitName(name, null);
        }
      }
      return nextTick();
    };
    const tabsMethods = {
      dispatchEvent,
      scrollToTab,
      prev() {
        return handlePrevNext(false);
      },
      next() {
        return handlePrevNext(true);
      },
      prevTab() {
        if (true) {
          warnLog("vxe.error.delFunc", ["prevTab", "prev"]);
        }
        return tabsMethods.prev();
      },
      nextTab() {
        if (true) {
          warnLog("vxe.error.delFunc", ["nextTab", "next"]);
        }
        return tabsMethods.next();
      }
    };
    const tabsPrivateMethods = {};
    Object.assign($xeTabs, tabsMethods, tabsPrivateMethods);
    const renderTabHeader = (tabList) => {
      const { type, titleWidth: allTitleWidth, titleAlign: allTitleAlign, showClose, closeConfig, refreshConfig } = props;
      const { activeName, lintLeft, lintWidth, isTabOver, cacheTabMaps } = reactData;
      const extraSlot = slots.extra;
      const closeOpts = computeCloseOpts.value;
      const closeVisibleMethod = closeOpts.visibleMethod;
      const refreshOpts = computeRefreshOpts.value;
      const refreshVisibleMethod = refreshOpts.visibleMethod;
      return h("div", {
        class: "vxe-tabs-header"
      }, [
        isTabOver ? h("div", {
          class: "vxe-tabs-header--bar vxe-tabs-header--left-bar",
          onClick: scrollLeftEvent
        }, [
          h("span", {
            class: getIcon().TABS_TAB_BUTTON_LEFT
          })
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-tabs-header--wrapper"
        }, [
          h("div", {
            ref: refHeadWrapperElem,
            class: "vxe-tabs-header--item-wrapper"
          }, tabList.map((item, index) => {
            const { title, titleWidth, titleAlign, icon, name, slots: slots2 } = item;
            const titleSlot = slots2 ? slots2.title || slots2.tab : null;
            const itemWidth = titleWidth || allTitleWidth;
            const itemAlign = titleAlign || allTitleAlign;
            const params = { $tabs: $xeTabs, value: activeName, name, option: item };
            const isActive = activeName === name;
            const cacheItem = name ? cacheTabMaps[`${name}`] : null;
            const isLoading = cacheItem ? cacheItem.loading : false;
            return h("div", {
              key: `${name}`,
              class: ["vxe-tabs-header--item", itemAlign ? `align--${itemAlign}` : "", {
                "is--active": isActive
              }],
              style: itemWidth ? {
                width: toCssUnit(itemWidth)
              } : null,
              onClick(evnt) {
                clickEvent(evnt, item);
              }
            }, [
              h("div", {
                class: "vxe-tabs-header--item-inner"
              }, [
                h("div", {
                  class: "vxe-tabs-header--item-content"
                }, [
                  icon ? h("span", {
                    class: "vxe-tabs-header--item-icon"
                  }, [
                    h("i", {
                      class: icon
                    })
                  ]) : createCommentVNode(),
                  h("span", {
                    class: "vxe-tabs-header--item-name"
                  }, titleSlot ? callSlot(titleSlot, { name, title }) : `${title}`)
                ]),
                (isEnableConf(refreshConfig) || refreshOpts.enabled) && (refreshVisibleMethod ? refreshVisibleMethod(params) : isActive) ? h("div", {
                  class: "vxe-tabs-header--refresh-btn",
                  onClick(evnt) {
                    handleRefreshTabEvent(evnt, item);
                  }
                }, [
                  h("i", {
                    class: isLoading ? getIcon().TABS_TAB_REFRESH_LOADING : getIcon().TABS_TAB_REFRESH
                  })
                ]) : createCommentVNode(),
                (showClose || (isEnableConf(closeConfig) || closeOpts.enabled)) && (!closeVisibleMethod || closeVisibleMethod(params)) ? h("div", {
                  class: "vxe-tabs-header--close-btn",
                  onClick(evnt) {
                    handleCloseTabEvent(evnt, item, index, tabList);
                  }
                }, [
                  h("i", {
                    class: getIcon().TABS_TAB_CLOSE
                  })
                ]) : createCommentVNode()
              ])
            ]);
          }).concat([
            h("span", {
              key: "line",
              class: `vxe-tabs-header--active-line type--${type || "default"}`,
              style: {
                left: `${lintLeft}px`,
                width: `${lintWidth}px`
              }
            })
          ]))
        ]),
        isTabOver ? h("div", {
          class: "vxe-tabs-header--bar vxe-tabs-header--right-bar",
          onClick: scrollRightEvent
        }, [
          h("span", {
            class: getIcon().TABS_TAB_BUTTON_RIGHT
          })
        ]) : createCommentVNode(),
        extraSlot ? h("div", {
          class: "vxe-tabs-header--extra"
        }, getSlotVNs(extraSlot({}))) : createCommentVNode()
      ]);
    };
    const renderTabPane = (item) => {
      const { initNames, activeName } = reactData;
      const { name, slots: slots2 } = item;
      const defaultSlot = slots2 ? slots2.default : null;
      return name && initNames.includes(name) ? h("div", {
        key: `${name}`,
        class: ["vxe-tabs-pane--item", {
          "is--visible": activeName === name,
          "has--content": !!defaultSlot
        }]
      }, defaultSlot ? callSlot(defaultSlot, { name }) : []) : createCommentVNode();
    };
    const renderTabContent = (tabList) => {
      const { destroyOnClose } = props;
      const { activeName } = reactData;
      const activeDefaultTab = tabList.find((item) => item.name === activeName);
      if (destroyOnClose) {
        return [activeDefaultTab ? renderTabPane(activeDefaultTab) : createCommentVNode()];
      }
      return tabList.map((item) => renderTabPane(item));
    };
    const renderVN = () => {
      const { type, height, padding, trigger } = props;
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const tabList = defaultSlot ? tabStaticOptions : tabOptions;
      return h("div", {
        ref: refElem,
        class: ["vxe-tabs", `vxe-tabs--${type || "default"}`, `trigger--${trigger === "manual" ? "trigger" : "default"}`, {
          "is--padding": padding,
          "is--height": height
        }],
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [
        h("div", {
          class: "vxe-tabs-slots"
        }, defaultSlot ? defaultSlot({}) : []),
        renderTabHeader(tabList),
        h("div", {
          class: "vxe-tabs-pane"
        }, renderTabContent(tabList)),
        footerSlot ? h("div", {
          class: "vxe-tabs-footer"
        }, callSlot(footerSlot, {})) : renderEmptyElement($xeTabs)
      ]);
    };
    watch(() => props.modelValue, (val) => {
      addInitName(val, null);
      reactData.activeName = val;
    });
    watch(() => reactData.activeName, (val) => {
      scrollToTab(val);
      nextTick(() => {
        reactData.resizeFlag++;
      });
    });
    const optsFlag = ref(0);
    watch(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    watch(() => props.options, () => {
      optsFlag.value++;
    });
    watch(optsFlag, () => {
      initDefaultName(props.options);
      updateTabStyle();
    });
    const stFlag = ref(0);
    watch(() => reactData.staticTabs ? reactData.staticTabs.length : -1, () => {
      stFlag.value++;
    });
    watch(() => reactData.staticTabs, () => {
      stFlag.value++;
    });
    watch(stFlag, () => {
      initDefaultName(reactData.staticTabs);
      updateTabStyle();
    });
    if ($xeParentTabs) {
      watch(() => $xeParentTabs ? $xeParentTabs.reactData.resizeFlag : null, () => {
        reactData.resizeFlag++;
      });
    }
    watch(() => reactData.resizeFlag, () => {
      nextTick(() => {
        updateTabStyle();
      });
    });
    onMounted(() => {
      globalEvents.on($xeTabs, "resize", updateTabStyle);
      updateTabStyle();
    });
    onUnmounted(() => {
      globalEvents.off($xeTabs, "resize");
    });
    provide("$xeTabs", $xeTabs);
    addInitName(props.modelValue, null);
    initDefaultName(reactData.staticTabs.length ? reactData.staticTabs : props.options);
    $xeTabs.renderVN = renderVN;
    return $xeTabs;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/tabs/src/tab-pane.js
var import_xe_utils41 = __toESM(require_xe_utils());

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/tabs/src/util.js
var import_xe_utils40 = __toESM(require_xe_utils());
function assembleTabItem($xeTabs, elem, tabConfig) {
  const staticTabs = $xeTabs.reactData.staticTabs;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticTabs.splice(import_xe_utils40.default.arrayIndexOf(parentElem.children, elem), 0, tabConfig);
    $xeTabs.reactData.staticTabs = staticTabs.slice(0);
  }
}
function destroyTabItem($xeTabs, tabConfig) {
  const staticTabs = $xeTabs.reactData.staticTabs;
  const matchObj = import_xe_utils40.default.findTree(staticTabs, (item) => item.id === tabConfig.id, { children: "children" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeTabs.reactData.staticTabs = staticTabs.slice(0);
}

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/tabs/src/tab-pane.js
var tab_pane_default = defineComponent({
  name: "VxeTabPane",
  props: {
    title: [String, Number],
    name: [String, Number],
    icon: String,
    titleWidth: [String, Number],
    titleAlign: [String, Number],
    preload: Boolean,
    permissionCode: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils41.default.uniqueId();
    const refElem = ref();
    const $xeTabs = inject("$xeTabs", null);
    const reactData = reactive({});
    const tabConfig = reactive({
      id: xID,
      title: props.title,
      name: props.name,
      icon: props.icon,
      titleWidth: props.titleWidth,
      titleAlign: props.titleAlign,
      preload: props.preload,
      permissionCode: props.permissionCode,
      slots
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTabPane = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tabPane: $xeTabPane }, params));
    };
    const tabPaneMethods = {
      dispatchEvent
    };
    const tabPanePrivateMethods = {};
    Object.assign($xeTabPane, tabPaneMethods, tabPanePrivateMethods);
    watch(() => props.title, (val) => {
      tabConfig.title = val;
    });
    watch(() => props.name, (val) => {
      tabConfig.name = val;
    });
    watch(() => props.icon, (val) => {
      tabConfig.icon = val;
    });
    watch(() => props.permissionCode, (val) => {
      tabConfig.permissionCode = val;
    });
    onMounted(() => {
      const elem = refElem.value;
      if ($xeTabs && elem) {
        assembleTabItem($xeTabs, elem, tabConfig);
      }
    });
    onUnmounted(() => {
      if ($xeTabs) {
        destroyTabItem($xeTabs, tabConfig);
      }
    });
    const renderVN = () => {
      return h("div", {
        ref: refElem
      }, []);
    };
    $xeTabPane.renderVN = renderVN;
    return $xeTabPane;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form/src/form-item.js
var import_xe_utils42 = __toESM(require_xe_utils());
var formItemProps = {
  title: String,
  field: String,
  span: {
    type: [String, Number],
    default: null
  },
  align: {
    type: String,
    default: null
  },
  verticalAlign: {
    type: String,
    default: null
  },
  titleBackground: {
    type: Boolean,
    default: null
  },
  titleBold: {
    type: Boolean,
    default: null
  },
  titleAlign: {
    type: String,
    default: null
  },
  titleWidth: {
    type: [String, Number],
    default: null
  },
  titleColon: {
    type: Boolean,
    default: null
  },
  titleAsterisk: {
    type: Boolean,
    default: null
  },
  showTitle: {
    type: Boolean,
    default: true
  },
  vertical: {
    type: Boolean,
    default: null
  },
  padding: {
    type: Boolean,
    default: null
  },
  className: [String, Function],
  contentClassName: [String, Function],
  contentStyle: [Object, Function],
  titleClassName: [String, Function],
  titleStyle: [Object, Function],
  titleOverflow: {
    type: [Boolean, String],
    default: null
  },
  titlePrefix: Object,
  titleSuffix: Object,
  resetValue: { default: null },
  visibleMethod: Function,
  visible: {
    type: Boolean,
    default: null
  },
  showContent: {
    type: Boolean,
    default: null
  },
  folding: Boolean,
  collapseNode: Boolean,
  itemRender: Object,
  rules: Array
};
var form_item_default = defineComponent({
  name: "VxeFormItem",
  props: formItemProps,
  setup(props, { slots }) {
    const refElem = ref();
    const $xeForm = inject("$xeForm", {});
    const $xeFormGroup = inject("$xeFormGroup", null);
    const formItem = reactive(createItem($xeForm, props));
    formItem.slots = slots;
    const formItemInfo = { itemConfig: formItem };
    provide("xeFormItemInfo", formItemInfo);
    const renderItem = ($xeForm2, item) => {
      const formProps = $xeForm2.props;
      const $xeGrid = $xeForm2.xeGrid;
      const { data, readonly, disabled } = formProps;
      const { visible, field, itemRender, contentStyle, showContent } = item;
      const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm2, $grid: $xeGrid };
      if (visible === false) {
        return createCommentVNode();
      }
      return h("div", {
        ref: refElem,
        key: item.id,
        class: getItemClass($xeForm2, item),
        style: import_xe_utils42.default.isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [
        renderTitle($xeForm2, item),
        showContent === false ? createCommentVNode() : h("div", {
          class: getItemContentClass($xeForm2, item),
          style: Object.assign({}, import_xe_utils42.default.isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, import_xe_utils42.default.isFunction(contentStyle) ? contentStyle(params) : contentStyle)
        }, [
          renderItemContent($xeForm2, item)
        ])
      ]);
    };
    const renderVN = () => {
      const customLayout = $xeForm ? $xeForm.props.customLayout : false;
      const item = formItem;
      return customLayout ? renderItem($xeForm, item) : h("div", {
        ref: refElem
      });
    };
    const $xeFormitem = {
      formItem,
      renderVN
    };
    watchItem(props, formItem);
    onMounted(() => {
      const elem = refElem.value;
      assembleItem($xeForm, elem, formItem, $xeFormGroup);
    });
    onUnmounted(() => {
      destroyItem($xeForm, formItem);
    });
    provide("$xeFormItem", $xeFormitem);
    provide("$xeFormGroup", null);
    return $xeFormitem;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/switch/src/switch.js
var import_xe_utils43 = __toESM(require_xe_utils());
var switch_default = defineComponent({
  name: "VxeSwitch",
  props: {
    modelValue: [String, Number, Boolean],
    disabled: {
      type: Boolean,
      default: null
    },
    readonly: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().switch.size || getConfig().size
    },
    openLabel: String,
    closeLabel: String,
    openValue: {
      type: [String, Number, Boolean],
      default: true
    },
    closeValue: {
      type: [String, Number, Boolean],
      default: false
    },
    openIcon: String,
    closeIcon: String,
    openActiveIcon: String,
    closeActiveIcon: String
  },
  emits: [
    "update:modelValue",
    "change",
    "focus",
    "blur"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils43.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      isActivated: false,
      hasAnimat: false,
      offsetLeft: 0
    });
    const internalData = {};
    const $xeSwitch = {
      xID,
      props,
      context,
      reactData,
      internalData
    };
    const refButton = ref();
    let switchMethods = {};
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return readonly;
    });
    const computeOnShowLabel = computed(() => {
      return getFuncText(props.openLabel);
    });
    const computeOffShowLabel = computed(() => {
      return getFuncText(props.closeLabel);
    });
    const computeIsChecked = computed(() => {
      return props.modelValue === props.openValue;
    });
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const clickEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!(isDisabled || isReadonly)) {
        const isChecked = computeIsChecked.value;
        clearTimeout(internalData.atTimeout);
        const value = isChecked ? props.closeValue : props.openValue;
        reactData.hasAnimat = true;
        emitModel(value);
        switchMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
        internalData.atTimeout = setTimeout(() => {
          reactData.hasAnimat = false;
          internalData.atTimeout = void 0;
        }, 400);
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $switch: $xeSwitch }, params));
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      switchMethods.dispatchEvent("focus", { value: props.modelValue }, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      switchMethods.dispatchEvent("blur", { value: props.modelValue }, evnt);
    };
    switchMethods = {
      dispatchEvent,
      focus() {
        const btnElem = refButton.value;
        reactData.isActivated = true;
        if (btnElem) {
          btnElem.focus();
        }
        return nextTick();
      },
      blur() {
        const btnElem = refButton.value;
        if (btnElem) {
          btnElem.blur();
        }
        reactData.isActivated = false;
        return nextTick();
      }
    };
    Object.assign($xeSwitch, switchMethods);
    const renderVN = () => {
      const { openIcon, closeIcon, openActiveIcon, closeActiveIcon } = props;
      const vSize = computeSize.value;
      const isChecked = computeIsChecked.value;
      const onShowLabel = computeOnShowLabel.value;
      const offShowLabel = computeOffShowLabel.value;
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      return h("div", {
        class: ["vxe-switch", isChecked ? "is--on" : "is--off", {
          [`size--${vSize}`]: vSize,
          "is--disabled": isDisabled,
          "is--readonly": isReadonly,
          "is--animat": reactData.hasAnimat
        }]
      }, [
        h("button", {
          ref: refButton,
          class: "vxe-switch--button",
          type: "button",
          disabled: isDisabled || isReadonly,
          onClick: clickEvent,
          onFocus: focusEvent,
          onBlur: blurEvent
        }, [
          h("span", {
            class: "vxe-switch--label vxe-switch--label-on"
          }, [
            openIcon ? h("i", {
              class: ["vxe-switch--label-icon", openIcon]
            }) : createCommentVNode(),
            onShowLabel
          ]),
          h("span", {
            class: "vxe-switch--label vxe-switch--label-off"
          }, [
            closeIcon ? h("i", {
              class: ["vxe-switch--label-icon", closeIcon]
            }) : createCommentVNode(),
            offShowLabel
          ]),
          h("span", {
            class: ["vxe-switch--icon"]
          }, openActiveIcon || closeActiveIcon ? [
            h("i", {
              class: isChecked ? openActiveIcon : closeActiveIcon
            })
          ] : [])
        ])
      ]);
    };
    $xeSwitch.renderVN = renderVN;
    return $xeSwitch;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/src/default-setting-form.js
var DefaultSettingFormComponent = defineComponent({
  name: "DefaultSettingForm",
  props: {
    formData: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { props: formDesignProps } = $xeFormDesign;
    return () => {
      const { formData } = props;
      return h(form_default, {
        data: formData,
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          const { showPc, showMobile } = formDesignProps;
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.formName"),
              field: "title",
              itemRender: { name: "VxeInput", props: { placeholder: getI18n("vxe.formDesign.defFormTitle") } }
            }),
            showPc && showMobile ? h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.displaySetting.name")
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-devices"
                  }, [
                    h("div", {
                      class: "vxe-form-design--widget-form-item-pc"
                    }, [
                      h(text_default, {
                        icon: getIcon().FORM_DESIGN_PROPS_PC,
                        content: getI18n("vxe.formDesign.widgetProp.displaySetting.pc")
                      }),
                      h(switch_default, {
                        modelValue: formData.pcVisible,
                        openLabel: getI18n("vxe.formDesign.widgetProp.displaySetting.visible"),
                        closeLabel: getI18n("vxe.formDesign.widgetProp.displaySetting.hidden"),
                        "onUpdate:modelValue"(val) {
                          formData.pcVisible = val;
                        }
                      })
                    ]),
                    h("div", {
                      class: "vxe-form-design--widget-form-item-mobile"
                    }, [
                      h(text_default, {
                        icon: getIcon().FORM_DESIGN_PROPS_MOBILE,
                        content: getI18n("vxe.formDesign.widgetProp.displaySetting.mobile")
                      }),
                      h(switch_default, {
                        modelValue: formData.mobileVisible,
                        openLabel: getI18n("vxe.formDesign.widgetProp.displaySetting.visible"),
                        closeLabel: getI18n("vxe.formDesign.widgetProp.displaySetting.hidden"),
                        "onUpdate:modelValue"(val) {
                          formData.mobileVisible = val;
                        }
                      })
                    ])
                  ])
                ];
              }
            }) : createCommentVNode()
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/src/layout-setting.js
var layout_setting_default = defineComponent({
  name: "FormDesignLayoutSetting",
  props: {},
  emits: [],
  setup() {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { props: formDesignProps, reactData: formDesignReactData } = $xeFormDesign;
    const activeTab = ref(1);
    const renderSettingWidgetForm = () => {
      const { activeWidget } = formDesignReactData;
      if (activeWidget) {
        const compConf = renderer.get(activeWidget.name);
        const renderWidgetFormView = compConf ? compConf.renderFormDesignWidgetFormView : null;
        if (renderWidgetFormView) {
          const isEditMode = true;
          return h("div", {
            class: "vxe-form-design--custom-widget-form-view"
          }, getSlotVNs(renderWidgetFormView(activeWidget, { isEditMode, isViewMode: !isEditMode, widget: activeWidget, $formDesign: $xeFormDesign, $formView: null })));
        }
      }
      return createCommentVNode();
    };
    const renderSettingConfigForm = () => {
      const { formRender } = formDesignProps;
      const { formData } = formDesignReactData;
      if (formRender) {
        const compConf = renderer.get(formRender.name);
        const renderSettingView = compConf ? compConf.renderFormDesignSettingFormView : null;
        if (renderSettingView) {
          return h("div", {
            class: "vxe-form-design--custom-setting-form-view"
          }, getSlotVNs(renderSettingView({}, { $formDesign: $xeFormDesign })));
        }
      }
      return h(DefaultSettingFormComponent, {
        formData
      });
    };
    watch(() => formDesignReactData.activeWidget, () => {
      activeTab.value = 1;
    });
    return () => {
      return h("div", {
        class: "vxe-form-design--setting"
      }, [
        h("div", {
          class: "vxe-form-design--setting-form"
        }, [
          h(tabs_default, {
            modelValue: activeTab.value,
            titleWidth: "50%",
            titleAlign: "center",
            padding: true,
            class: "vxe-form-design--setting-form-tabs",
            "onUpdate:modelValue"(val) {
              activeTab.value = val;
            }
          }, {
            default() {
              return [
                h(tab_pane_default, {
                  title: getI18n("vxe.formDesign.widgetPropTab"),
                  name: 1
                }, {
                  default() {
                    return renderSettingWidgetForm();
                  }
                }),
                h(tab_pane_default, {
                  title: getI18n("vxe.formDesign.widgetFormTab"),
                  name: 2
                }, {
                  default() {
                    return renderSettingConfigForm();
                  }
                })
              ];
            }
          })
        ])
      ]);
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/src/form-view.js
var import_xe_utils45 = __toESM(require_xe_utils());

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/src/default-setting-data.js
var getDefaultSettingFormData = (defOpts) => {
  return {
    title: "",
    pcVisible: defOpts ? !!defOpts.pcVisible : true,
    pcVertical: true,
    pcTitleBold: true,
    pcTitleColon: false,
    pcTitleAlign: "",
    pcTitleWidth: "",
    pcTitleWidthUnit: "",
    mobileVisible: defOpts ? !!defOpts.mobileVisible : true,
    mobileVertical: true,
    mobileTitleBold: true,
    mobileTitleColon: false,
    mobileTitleAlign: "",
    mobileTitleWidth: "",
    mobileTitleWidthUnit: ""
  };
};
var createDefaultFormViewPCFormConfig = (params) => {
  const { formConfig } = params;
  return {
    vertical: formConfig.pcVertical,
    titleBold: formConfig.pcTitleBold,
    titleColon: formConfig.pcTitleColon,
    titleAlign: formConfig.pcTitleAlign,
    titleWidth: formConfig.pcTitleWidth
  };
};
var createDefaultFormViewMobileFormConfig = (params) => {
  const { formConfig } = params;
  return {
    vertical: formConfig.mobileVertical,
    titleBold: formConfig.mobileTitleBold,
    titleColon: formConfig.mobileTitleColon,
    titleAlign: formConfig.mobileTitleAlign,
    titleWidth: formConfig.mobileTitleWidth
  };
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form/src/form-group.js
var import_xe_utils44 = __toESM(require_xe_utils());
var form_group_default = defineComponent({
  name: "VxeFormGroup",
  props: formItemProps,
  setup(props, context) {
    const { slots } = context;
    const refElem = ref();
    const $xeForm = inject("$xeForm", {});
    const $xeParentFormGroup = inject("$xeFormGroup", null);
    const formItem = reactive(createItem($xeForm, props));
    formItem.slots = slots;
    formItem.children = [];
    const formItemInfo = { itemConfig: formItem };
    provide("xeFormItemInfo", formItemInfo);
    const renderVN = () => {
      const formProps = $xeForm.props;
      const $xeGrid = $xeForm.xeGrid;
      const item = formItem;
      const { data, readonly, disabled } = formProps;
      const { visible, field, itemRender, contentStyle } = item;
      const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const defaultSlot = slots ? slots.default : null;
      const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm, $grid: $xeGrid };
      if (visible === false) {
        return createCommentVNode();
      }
      return h("div", {
        ref: refElem,
        key: item.id,
        class: getItemClass($xeForm, item, true),
        style: import_xe_utils44.default.isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [
        renderTitle($xeForm, item, true),
        h("div", {
          class: getItemContentClass($xeForm, item, true),
          style: Object.assign({}, import_xe_utils44.default.isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, import_xe_utils44.default.isFunction(contentStyle) ? contentStyle(params) : contentStyle)
        }, defaultSlot ? defaultSlot({}) : [])
      ]);
    };
    const $xeFormGroup = {
      formItem,
      renderVN
    };
    watchItem(props, formItem);
    onMounted(() => {
      const elem = refElem.value;
      assembleItem($xeForm, elem, formItem, $xeParentFormGroup);
    });
    onUnmounted(() => {
      destroyItem($xeForm, formItem);
    });
    provide("$xeFormGroup", $xeFormGroup);
    provide("$xeFormItem", null);
    return $xeFormGroup;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/src/form-view.js
var form_view_default = defineComponent({
  name: "VxeFormView",
  props: {
    modelValue: Object,
    config: Object,
    readonly: Boolean,
    disabled: Boolean,
    viewRender: Object,
    formOptions: Object,
    createFormConfig: Function,
    size: {
      type: String,
      default: () => getConfig().formView.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "submit",
    "reset"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils45.default.uniqueId();
    const refElem = ref();
    const formRef = ref();
    const { computeSize } = useSize(props);
    const $xeFormDesignLayoutStyle = inject("$xeFormDesignLayoutStyle", null);
    const reactData = reactive({
      formConfig: {},
      formRules: {},
      widgetObjList: []
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize
    };
    const $xeFormView = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const clearConfig = () => {
      return loadConfig({
        formConfig: {},
        widgetData: []
      });
    };
    const loadConfig = (config2) => {
      if (config2) {
        const { formConfig, widgetData } = config2;
        loadFormConfig(formConfig || {});
        loadWidgetData(widgetData || []);
      }
      return nextTick();
    };
    const parseConfig = (config2) => {
      const { formConfig, widgetData } = config2 || {};
      const widgetObjList = parseWidgetData(widgetData || []);
      return Object.assign(Object.assign({}, parseForm(widgetObjList)), { formConfig: parseFormConfig(formConfig || {}), widgetData: widgetObjList });
    };
    const parseFormConfig = (formConfig) => {
      const { viewRender, createFormConfig, formOptions } = props;
      const params = { viewRender, formConfig };
      if (createFormConfig) {
        return createFormConfig(params);
      }
      const { name } = viewRender || {};
      const compConf = renderer.get(name) || {};
      const createPCFormConfig = compConf ? compConf.createFormViewFormConfig : null;
      return Object.assign({}, createPCFormConfig ? createPCFormConfig(params) : createDefaultFormViewPCFormConfig(params), formOptions);
    };
    const loadFormConfig = (formConfig) => {
      reactData.formConfig = parseFormConfig(formConfig);
      return nextTick();
    };
    const parseForm = (widgetObjList) => {
      const formData = {};
      const formRules = {};
      import_xe_utils45.default.eachTree(widgetObjList, (widget) => {
        const { name, field, required } = widget;
        const compConf = renderer.get(name) || {};
        const createWidgetFieldValue = compConf.createFormDesignWidgetFieldValue;
        const createWidgetFieldRules = compConf.createFormDesignWidgetFieldRules;
        formData[field] = createWidgetFieldValue ? createWidgetFieldValue({ widget, $formView: $xeFormView }) : getWidgetDefaultValue(widget);
        if (createWidgetFieldRules) {
          const rules = createWidgetFieldRules({ widget, $formView: $xeFormView });
          if (rules && rules.length) {
            formRules[field] = rules;
          }
        } else if (required) {
          formRules[field] = getWidgetDefaultRule();
        }
      }, { children: "children" });
      return {
        formData,
        formRules
      };
    };
    const parseWidgetData = (widgetData) => {
      return (widgetData || []).map((item) => configToWidget(item));
    };
    const loadWidgetData = (widgetData) => {
      const widgetObjList = parseWidgetData(widgetData);
      reactData.widgetObjList = widgetObjList;
      const { formData, formRules } = parseForm(widgetObjList);
      reactData.formRules = formRules;
      emit("update:modelValue", Object.assign(formData, props.modelValue));
      return nextTick();
    };
    const getWidgetDefaultValue = (widget) => {
      switch (widget.name) {
        case "subtable":
          return [];
      }
      return null;
    };
    const getWidgetDefaultRule = () => {
      return [
        { required: true, content: "该填写该字段！" }
      ];
    };
    const updateWidgetStatus = (widget, value) => {
      const { field } = widget;
      const $form = formRef.value;
      if ($form) {
        $form.updateStatus({ field }, value);
      }
      return nextTick();
    };
    const setItemValue = (widget, value) => {
      const { modelValue } = props;
      const { field } = widget;
      const $form = formRef.value;
      if (modelValue) {
        modelValue[field] = value;
      }
      if ($form) {
        $form.updateStatus({ field }, value);
      }
      return nextTick();
    };
    const getItemValue = (widget) => {
      const { modelValue } = props;
      if (modelValue) {
        return modelValue[widget.field];
      }
      return null;
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $formView: $xeFormView }, params));
    };
    const toWidgetFields = (widget) => {
      if (widget) {
        if (import_xe_utils45.default.isArray(widget)) {
          return widget.map((item) => item.name);
        } else {
          return [widget.name];
        }
      }
      return null;
    };
    const formViewMethods = {
      dispatchEvent,
      clearConfig,
      loadConfig,
      parseConfig,
      loadFormConfig,
      loadWidgetData,
      updateWidgetStatus,
      setItemValue,
      getItemValue,
      validate() {
        const $form = formRef.value;
        if ($form) {
          return $form.validate();
        }
        return nextTick();
      },
      validateWidget(widget) {
        const $form = formRef.value;
        if ($form) {
          return $form.validateField(toWidgetFields(widget));
        }
        return nextTick();
      },
      clearValidate(widget) {
        const $form = formRef.value;
        if ($form) {
          return $form.clearValidate(toWidgetFields(widget));
        }
        return nextTick();
      },
      reset() {
        const { widgetObjList } = reactData;
        const { formData } = parseForm(widgetObjList);
        emit("update:modelValue", Object.assign({}, formData));
        return nextTick();
      },
      /**
       * 已废弃
       * @deprecated
       */
      updateItemStatus(widget, value) {
        if (true) {
          warnLog("vxe.error.delFunc", ["updateItemStatus", "updateWidgetStatus"]);
        }
        return updateWidgetStatus(widget, value);
      }
    };
    const handleSubmit = (params) => {
      dispatchEvent("submit", params, params.$event);
    };
    const handleReset = (params) => {
      dispatchEvent("reset", params, params.$event);
    };
    const formViewPrivateMethods = {};
    Object.assign($xeFormView, formViewMethods, formViewPrivateMethods);
    const renderVN = () => {
      const { readonly, disabled, modelValue } = props;
      const { formConfig, formRules, widgetObjList } = reactData;
      const vSize = computeSize.value;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      return h("div", {
        ref: refElem,
        class: ["vxe-form-view", {
          [`size--${vSize}`]: vSize
        }]
      }, [
        topSlot ? h("div", {
          class: "vxe-form-view--top"
        }, getSlotVNs(topSlot({ $formView: $xeFormView }))) : createCommentVNode(),
        h(form_default, Object.assign(Object.assign({ ref: formRef }, formConfig), {
          data: modelValue,
          customLayout: true,
          readonly,
          disabled,
          span: 24,
          rules: formRules,
          onSubmit: handleSubmit,
          onReset: handleReset
        }), {
          default() {
            const { readonly: readonly2, disabled: disabled2 } = props;
            return [
              headerSlot ? h(form_item_default, {}, {
                default() {
                  return headerSlot({});
                }
              }) : createCommentVNode(),
              ...widgetObjList.map((widget) => {
                const { name } = widget;
                const compConf = renderer.get(name) || {};
                const renderWidgetDesignView = compConf.renderFormDesignWidgetView;
                const renderWidgetDesignPreview = compConf.renderFormDesignWidgetPreview;
                const renderWidgetDesignMobilePreview = compConf.renderFormDesignWidgetMobilePreview;
                const isEditMode = !!$xeFormDesignLayoutStyle;
                const renderOpts = widget;
                const params = { widget, readonly: !!readonly2, disabled: !!disabled2, isEditMode, isViewMode: !isEditMode, $formDesign: null, $formView: $xeFormView };
                return h(form_group_default, {
                  key: widget.id
                }, {
                  default() {
                    if ($xeFormDesignLayoutStyle) {
                      if ($xeFormDesignLayoutStyle.reactData.activeTab === 2) {
                        if (renderWidgetDesignMobilePreview) {
                          return getSlotVNs(renderWidgetDesignMobilePreview(renderOpts, params));
                        }
                      } else {
                        if (renderWidgetDesignPreview) {
                          return getSlotVNs(renderWidgetDesignPreview(renderOpts, params));
                        }
                      }
                    }
                    return renderWidgetDesignView ? getSlotVNs(renderWidgetDesignView(renderOpts, params)) : [];
                  }
                });
              }),
              footerSlot ? h(form_group_default, {
                span: 24
              }, {
                default() {
                  return footerSlot({});
                }
              }) : createCommentVNode()
            ];
          }
        }),
        bottomSlot ? h("div", {
          class: "vxe-form-view--bottom"
        }, getSlotVNs(bottomSlot({ $formView: $xeFormView }))) : createCommentVNode()
      ]);
    };
    $xeFormView.renderVN = renderVN;
    watch(() => props.config, (value) => {
      loadConfig(value || {});
    });
    if (props.config) {
      loadConfig(props.config);
    }
    provide("$xeFormView", $xeFormView);
    return $xeFormView;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/src/default-style-form.js
var getBoldOptions = () => {
  return [
    { label: getI18n("vxe.formDesign.styleSetting.fontNormal"), value: false },
    { label: getI18n("vxe.formDesign.styleSetting.fontBold"), value: true }
  ];
};
var getColonOptions = () => {
  return [
    { label: getI18n("vxe.formDesign.styleSetting.colonVisible"), value: true },
    { label: getI18n("vxe.formDesign.styleSetting.colonHidden"), value: false }
  ];
};
var getAlignOptions = () => {
  return [
    { label: getI18n("vxe.formDesign.styleSetting.alignLeft"), value: "" },
    { label: getI18n("vxe.formDesign.styleSetting.alignRight"), value: "right" }
  ];
};
var getWidthUnitOptions = () => {
  return [
    { label: getI18n("vxe.formDesign.styleSetting.unitPx"), value: "" },
    { label: getI18n("vxe.formDesign.styleSetting.unitPct"), value: "%" }
  ];
};
var renderLayoutOption = (formData, field, type, changeEvent) => {
  const isVertical = type === "vertical";
  return h("div", {
    class: ["vxe-form-design--widget-form-item-option", `is--${type}`, {
      "is--active": isVertical ? formData[field] : !formData[field]
    }],
    onClick() {
      formData[field] = isVertical;
      changeEvent();
    }
  }, [
    h("div", {
      class: "vxe-form-design--widget-form-item-option-row"
    }),
    h("div", {
      class: "vxe-form-design--widget-form-item-option-row"
    }),
    h("div", {}, isVertical ? getI18n("vxe.formDesign.styleSetting.verticalLayout") : getI18n("vxe.formDesign.styleSetting.horizontalLayout"))
  ]);
};
var DefaultPCStyleFormComponent = defineComponent({
  name: "DefaultPCStyleForm",
  props: {
    formData: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    const verticalField = "pcVertical";
    const refBoldOpts = ref(getBoldOptions());
    const refColonOpts = ref(getColonOptions());
    const refAlignOpts = ref(getAlignOptions());
    const refWidthUnitOpts = ref(getWidthUnitOptions());
    const refreshPreview = () => {
      if ($xeFormDesign) {
        $xeFormDesign.refreshPreviewView();
      }
    };
    const changeLayoutEvent = () => {
      const { formData } = props;
      if (!formData.pcTitleWidth) {
        formData.pcTitleWidth = 100;
      }
      refreshPreview();
    };
    return () => {
      const { formData } = props;
      return h(form_default, {
        data: formData,
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.styleSetting.layoutTitle"),
              field: verticalField
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-layout"
                  }, [
                    renderLayoutOption(formData, verticalField, "vertical", changeLayoutEvent),
                    renderLayoutOption(formData, verticalField, "horizontal", changeLayoutEvent)
                  ])
                ];
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.styleSetting.styleTitle")
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.boldTitle")),
                    h(group_default, {
                      modelValue: formData.pcTitleBold,
                      options: refBoldOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.pcTitleBold = val;
                      }
                    })
                  ]),
                  h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.colonTitle")),
                    h(group_default, {
                      modelValue: formData.pcTitleColon,
                      options: refColonOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.pcTitleColon = val;
                      }
                    })
                  ]),
                  formData.pcVertical ? createCommentVNode() : h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.alignTitle")),
                    h(group_default, {
                      modelValue: formData.pcTitleAlign,
                      options: refAlignOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.pcTitleAlign = val;
                      }
                    })
                  ]),
                  formData.pcVertical ? createCommentVNode() : h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.widthTitle")),
                    h(input_default, {
                      class: "vxe-form-design--widget-form-item-prop-width",
                      modelValue: formData.pcTitleWidth,
                      type: "integer",
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.pcTitleWidth = val;
                      }
                    }),
                    h(select_default, {
                      class: "vxe-form-design--widget-form-item-prop-unit",
                      modelValue: formData.pcTitleWidthUnit,
                      options: refWidthUnitOpts.value,
                      transfer: true,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.pcTitleWidthUnit = val;
                      }
                    })
                  ])
                ];
              }
            })
          ];
        }
      });
    };
  }
});
var DefaultMobileStyleFormComponent = defineComponent({
  name: "DefaultMobileStyleForm",
  props: {
    formData: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    const verticalField = "mobileVertical";
    const refBoldOpts = ref(getBoldOptions());
    const refColonOpts = ref(getColonOptions());
    const refAlignOpts = ref(getAlignOptions());
    const refWidthUnitOpts = ref(getWidthUnitOptions());
    const refreshPreview = () => {
      if ($xeFormDesign) {
        $xeFormDesign.refreshPreviewView();
      }
    };
    const changeLayoutEvent = () => {
      const { formData } = props;
      if (!formData.mobileTitleWidth) {
        formData.mobileTitleWidth = 100;
      }
      refreshPreview();
    };
    return () => {
      const { formData } = props;
      return h(form_default, {
        data: formData,
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.styleSetting.layoutTitle"),
              field: verticalField
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-layout"
                  }, [
                    renderLayoutOption(formData, verticalField, "vertical", changeLayoutEvent),
                    renderLayoutOption(formData, verticalField, "horizontal", changeLayoutEvent)
                  ])
                ];
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.styleSetting.styleTitle")
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.boldTitle")),
                    h(group_default, {
                      modelValue: formData.mobileTitleBold,
                      options: refBoldOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.mobileTitleBold = val;
                      }
                    })
                  ]),
                  h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.colonTitle")),
                    h(group_default, {
                      modelValue: formData.mobileTitleColon,
                      options: refColonOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.mobileTitleColon = val;
                      }
                    })
                  ]),
                  formData.mobileVertical ? createCommentVNode() : h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.alignTitle")),
                    h(group_default, {
                      modelValue: formData.mobileTitleAlign,
                      options: refAlignOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.mobileTitleAlign = val;
                      }
                    })
                  ]),
                  formData.mobileVertical ? createCommentVNode() : h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.widthTitle")),
                    h(input_default, {
                      class: "vxe-form-design--widget-form-item-prop-width",
                      modelValue: formData.mobileTitleWidth,
                      type: "integer",
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.mobileTitleWidth = val;
                      }
                    }),
                    h(select_default, {
                      class: "vxe-form-design--widget-form-item-prop-unit",
                      modelValue: formData.mobileTitleWidthUnit,
                      options: refWidthUnitOpts.value,
                      transfer: true,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.mobileTitleWidthUnit = val;
                      }
                    })
                  ])
                ];
              }
            })
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/src/layout-style.js
var layout_style_default = defineComponent({
  name: "FormDesignLayoutStyle",
  props: {},
  emits: [],
  setup() {
    const $xeFormDesign = inject("$xeFormDesign", null);
    const reactData = reactive({
      activeTab: 1
    });
    const $xeFormDesignLayoutStyle = {
      reactData,
      renderVN() {
        return [];
      }
    };
    if (!$xeFormDesign) {
      return $xeFormDesignLayoutStyle;
    }
    const { props: formDesignProps, reactData: formDesignReactData } = $xeFormDesign;
    const settingVisible = ref(false);
    const settingConfig = ref(null);
    const settingFormData = ref({});
    const updatePreviewView = () => {
      settingConfig.value = $xeFormDesign.getConfig();
    };
    const createFormViewFormConfig = (params) => {
      const { viewRender } = params;
      const { activeTab } = reactData;
      const { name } = viewRender || {};
      const compConf = renderer.get(name) || {};
      const createPCFormConfig = compConf ? compConf.createFormViewFormConfig : null;
      const createMobileFormConfig = compConf ? compConf.createFormViewMobileFormConfig : null;
      if (activeTab === 2) {
        if (createMobileFormConfig) {
          return createMobileFormConfig(params);
        }
        return createDefaultFormViewMobileFormConfig(params);
      }
      if (createPCFormConfig) {
        return createPCFormConfig(params);
      }
      return createDefaultFormViewPCFormConfig(params);
    };
    const formDesignLayoutStyleMethod = {
      updatePreviewView,
      openStylePreview() {
        const { showPc } = formDesignProps;
        updatePreviewView();
        reactData.activeTab = showPc ? 1 : 2;
        settingVisible.value = true;
      }
    };
    Object.assign($xeFormDesignLayoutStyle, formDesignLayoutStyleMethod);
    const renderStylePreview = () => {
      const { activeTab } = reactData;
      return h("div", {
        class: ["vxe-form-design--layout-style-preview", `is--${activeTab === 2 ? "mobile" : "pc"}`]
      }, [
        h(form_view_default, {
          modelValue: settingFormData.value,
          config: settingConfig.value,
          createFormConfig: createFormViewFormConfig,
          "onUpdate:modelValue"(val) {
            settingFormData.value = val;
          }
        })
      ]);
    };
    const renderMobileStyle = () => {
      const { formRender } = formDesignProps;
      const { formData } = formDesignReactData;
      if (formRender) {
        const compConf = renderer.get(formRender.name);
        const renderSettingMobileFormView = compConf ? compConf.renderFormDesignMobileStyleFormView : null;
        if (renderSettingMobileFormView) {
          return h("div", {
            class: "vxe-form-design--custom-setting-mobile-form-view"
          }, getSlotVNs(renderSettingMobileFormView({}, { $formDesign: $xeFormDesign, formConfig: formData })));
        }
      }
      return h(DefaultMobileStyleFormComponent, {
        formData
      });
    };
    const renderPCStyle = () => {
      const { formRender } = formDesignProps;
      const { formData } = formDesignReactData;
      if (formRender) {
        const compConf = renderer.get(formRender.name);
        const renderStylePCFormView = compConf ? compConf.renderFormDesignStyleFormView : null;
        if (renderStylePCFormView) {
          return h("div", {
            class: "vxe-form-design--custom-setting-pc-form-view"
          }, getSlotVNs(renderStylePCFormView({}, { $formDesign: $xeFormDesign, formConfig: formData })));
        }
      }
      return h(DefaultPCStyleFormComponent, {
        formData
      });
    };
    const renderStyleSetting = () => {
      const { showPc, showMobile } = formDesignProps;
      const { activeTab } = reactData;
      return h("div", {
        class: "vxe-form-design--layout-style-setting"
      }, [
        h(tabs_default, {
          modelValue: activeTab,
          titleWidth: showPc && showMobile ? "50%" : "100%",
          titleAlign: "center",
          padding: true,
          onChange: updatePreviewView,
          "onUpdate:modelValue"(val) {
            reactData.activeTab = val;
          }
        }, {
          default() {
            const tabVNs = [];
            if (showPc) {
              tabVNs.push(h(tab_pane_default, {
                title: getI18n("vxe.formDesign.widgetProp.displaySetting.pc"),
                icon: getIcon().FORM_DESIGN_PROPS_PC,
                k: 1,
                name: 1
              }, {
                default() {
                  return renderPCStyle();
                }
              }));
            }
            if (showMobile) {
              tabVNs.push(h(tab_pane_default, {
                title: getI18n("vxe.formDesign.widgetProp.displaySetting.mobile"),
                icon: getIcon().FORM_DESIGN_PROPS_MOBILE,
                key: 2,
                name: 2
              }, {
                default() {
                  return renderMobileStyle();
                }
              }));
            }
            return tabVNs;
          }
        })
      ]);
    };
    const renderVN = () => {
      const { showPc, showMobile } = formDesignProps;
      return h(modal_default, {
        modelValue: settingVisible.value,
        title: getI18n("vxe.formDesign.styleSetting.title"),
        height: "90vh",
        width: "90vw",
        escClosable: true,
        maskClosable: true,
        destroyOnClose: true,
        showMaximize: true,
        transfer: true,
        "onUpdate:modelValue"(val) {
          settingVisible.value = val;
        }
      }, {
        default() {
          return h("div", {
            class: "vxe-form-design--layout-style"
          }, [
            renderStylePreview(),
            showPc || showMobile ? renderStyleSetting() : createCommentVNode()
          ]);
        }
      });
    };
    $xeFormDesignLayoutStyle.renderVN = renderVN;
    provide("$xeFormDesignLayoutStyle", $xeFormDesignLayoutStyle);
    return $xeFormDesignLayoutStyle;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/src/form-design.js
var form_design_default = defineComponent({
  name: "VxeFormDesign",
  props: {
    size: {
      type: String,
      default: () => getConfig().formDesign.size || getConfig().size
    },
    config: Object,
    height: {
      type: [String, Number],
      default: () => getConfig().formDesign.height
    },
    widgets: {
      type: Array,
      default: () => import_xe_utils46.default.clone(getConfig().formDesign.widgets) || []
    },
    showHeader: {
      type: Boolean,
      default: () => getConfig().formDesign.showHeader
    },
    showPc: {
      type: Boolean,
      default: () => getConfig().formDesign.showPc
    },
    showMobile: {
      type: Boolean,
      default: () => getConfig().formDesign.showMobile
    },
    formRender: Object
  },
  emits: [
    "click-widget",
    "add-widget",
    "copy-widget",
    "remove-widget",
    "drag-widget"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils46.default.uniqueId();
    const refElem = ref();
    const refLayoutStyle = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      formData: {},
      widgetConfigs: [],
      widgetObjList: [],
      dragWidget: null,
      sortWidget: null,
      activeWidget: null
    });
    const internalData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize
    };
    const $xeFormDesign = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const createWidget = (name) => {
      return new FormDesignWidgetInfo($xeFormDesign, name, reactData.widgetObjList);
    };
    const createEmptyWidget = () => {
      return new FormDesignWidgetInfo($xeFormDesign, "", reactData.widgetObjList);
    };
    const loadConfig = (config2) => {
      if (config2) {
        const { formConfig, widgetData } = config2;
        if (formConfig) {
          loadFormConfig(formConfig);
        }
        if (widgetData) {
          loadWidgetData(widgetData);
        }
      }
      const { activeWidget, widgetObjList } = reactData;
      if (activeWidget) {
        const rest = import_xe_utils46.default.findTree(widgetObjList, (item) => item.id === activeWidget.id, { children: "children" });
        if (rest) {
          reactData.activeWidget = rest.item;
        } else {
          reactData.activeWidget = widgetObjList[0] || null;
        }
      } else {
        reactData.activeWidget = widgetObjList[0] || null;
      }
      return nextTick();
    };
    const reloadConfig = (config2) => {
      clearConfig();
      return loadConfig(config2);
    };
    const getFormConfig = () => {
      return import_xe_utils46.default.clone(reactData.formData, true);
    };
    const loadFormConfig = (data) => {
      reactData.formData = Object.assign({}, createSettingForm(), data);
      return nextTick();
    };
    const getWidgetById = (id) => {
      const { widgetObjList } = reactData;
      if (id) {
        const widgetId = import_xe_utils46.default.toNumber(id);
        const rest = import_xe_utils46.default.findTree(widgetObjList, (item) => item && item.id === widgetId, { children: "children" });
        if (rest) {
          return rest.item;
        }
      }
      return null;
    };
    const getWidgetData = () => {
      const objList = import_xe_utils46.default.clone(reactData.widgetObjList, true);
      import_xe_utils46.default.eachTree(objList, (item) => {
        item.model.value = null;
      }, { children: "children" });
      return objList;
    };
    const loadWidgetData = (widgetData) => {
      reactData.widgetObjList = (widgetData || []).map((item) => configToWidget(item));
      return nextTick();
    };
    const openStyleSetting = () => {
      const $layoutStyle = refLayoutStyle.value;
      if ($layoutStyle) {
        $layoutStyle.openStylePreview();
      }
      return nextTick();
    };
    const clearConfig = () => {
      reactData.widgetObjList = [];
      initSettingForm();
      return nextTick();
    };
    const formDesignMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $xeFormDesign }, params));
      },
      createWidget,
      createEmptyWidget,
      getConfig() {
        return {
          formConfig: getFormConfig(),
          widgetData: getWidgetData()
        };
      },
      clearConfig,
      loadConfig,
      reloadConfig,
      getFormConfig,
      loadFormConfig,
      getWidgetById,
      getFormData() {
        const { widgetObjList } = reactData;
        const formData = {};
        import_xe_utils46.default.eachTree(widgetObjList, (widget) => {
          formData[widget.field] = null;
        }, { children: "children" });
        return formData;
      },
      getWidgetData,
      loadWidgetData,
      refreshPreviewView() {
        const $layoutStyle = refLayoutStyle.value;
        if ($layoutStyle) {
          $layoutStyle.updatePreviewView();
        }
        return nextTick();
      },
      openStyleSetting
    };
    const updateWidgetConfigs = () => {
      const { widgets } = props;
      const widgetConfs = [];
      const baseWidgets = [];
      const layoutWidgets = [];
      const advancedWidgets = [];
      const customGroups = [];
      renderer.forEach((item, name) => {
        const { createFormDesignWidgetConfig } = item;
        if (createFormDesignWidgetConfig) {
          const widthItem = createWidget(name);
          const widgetConf = getWidgetConfig(name);
          const widgetCustomGroup = getWidgetConfigCustomGroup(name, $xeFormDesign);
          if (widgetCustomGroup) {
            const cusGroup = customGroups.find((item2) => item2.title === widgetCustomGroup);
            if (cusGroup) {
              cusGroup.children.push(widthItem);
            } else {
              customGroups.push({
                title: widgetCustomGroup,
                children: [widthItem]
              });
            }
          } else {
            switch (widgetConf.group) {
              case "layout":
                layoutWidgets.push(widthItem);
                break;
              case "advanced":
                advancedWidgets.push(widthItem);
                break;
              default:
                if (!["title"].includes(widthItem.name)) {
                  baseWidgets.push(widthItem);
                }
                break;
            }
          }
        }
      });
      if (baseWidgets.length) {
        widgetConfs.push({
          group: "base",
          children: baseWidgets
        });
      }
      if (layoutWidgets.length) {
        widgetConfs.push({
          group: "layout",
          children: layoutWidgets
        });
      }
      if (advancedWidgets.length) {
        widgetConfs.push({
          group: "advanced",
          children: advancedWidgets
        });
      }
      if (customGroups.length) {
        widgetConfs.push(...customGroups);
      }
      if (widgets && widgets.length) {
        reactData.widgetConfigs = props.widgets.map((config2) => {
          return {
            title: config2.customGroup,
            group: config2.group,
            children: config2.children ? config2.children.map((name) => {
              const widthItem = createWidget(name);
              return widthItem;
            }) : []
          };
        });
      } else {
        reactData.widgetConfigs = widgetConfs;
      }
    };
    const validWidgetUnique = (widgetName) => {
      const { widgetObjList } = reactData;
      const widgetConf = getWidgetConfig(widgetName);
      if (widgetConf.unique) {
        const existWidgetList = [];
        import_xe_utils46.default.eachTree(widgetObjList, (obj) => {
          if (obj.name === widgetName) {
            existWidgetList.push(obj);
          }
        }, { children: "children" });
        const status = existWidgetList.length < 1;
        if (!status) {
          if (VxeUI.modal) {
            VxeUI.modal.message({
              content: getI18n("vxe.formDesign.error.wdFormUni"),
              status: "error",
              id: "wdFormUni"
            });
          }
        }
        return status;
      }
      return true;
    };
    const formDesignPrivateMethods = {
      validWidgetUnique,
      handleClickWidget(evnt, item) {
        if (item && item.name) {
          evnt.stopPropagation();
          reactData.activeWidget = item;
          formDesignMethods.dispatchEvent("click-widget", { widget: item }, evnt);
        }
      },
      handleCopyWidget(evnt, widget) {
        const { widgetObjList } = reactData;
        const rest = import_xe_utils46.default.findTree(widgetObjList, (obj) => obj.id === widget.id, { children: "children" });
        if (rest) {
          evnt.stopPropagation();
          if (validWidgetUnique(widget.name)) {
            const { path } = rest;
            const rootIndex = Number(path[0]);
            const newWidget = createWidget(widget.name);
            if (newWidget.title) {
              newWidget.title = getI18n("vxe.formDesign.widget.copyTitle", [`${widget.title}`.replace(getI18n("vxe.formDesign.widget.copyTitle", [""]), "")]);
            }
            if (rootIndex >= widgetObjList.length - 1) {
              widgetObjList.push(newWidget);
            } else {
              widgetObjList.splice(rootIndex + 1, 0, newWidget);
            }
            reactData.activeWidget = newWidget;
            reactData.widgetObjList = [...widgetObjList];
            formDesignMethods.dispatchEvent("copy-widget", { widget, newWidget }, evnt);
          }
        }
      },
      handleRemoveWidget(evnt, widget) {
        const { widgetObjList } = reactData;
        const rest = import_xe_utils46.default.findTree(widgetObjList, (obj) => obj.id === widget.id, { children: "children" });
        if (rest) {
          const { index, parent, items } = rest;
          evnt.stopPropagation();
          if (index >= items.length - 1) {
            reactData.activeWidget = items[index - 1];
          } else {
            reactData.activeWidget = items[index + 1] || null;
          }
          if (parent && parent.name === "row") {
            items[index] = createEmptyWidget();
          } else {
            items.splice(index, 1);
          }
          reactData.widgetObjList = [...widgetObjList];
          formDesignMethods.dispatchEvent("remove-widget", { widget }, evnt);
        }
      }
    };
    const createSettingForm = () => {
      const { formRender, showPc, showMobile } = props;
      let conf = getDefaultSettingFormData({
        pcVisible: showPc,
        mobileVisible: showMobile
      });
      if (formRender) {
        const compConf = renderer.get(formRender.name);
        const createFormConfig = compConf ? compConf.createFormDesignSettingFormConfig : null;
        conf = (createFormConfig ? createFormConfig({}) : {}) || {};
      }
      return conf;
    };
    const initSettingForm = () => {
      reactData.formData = createSettingForm();
    };
    const openStylePreviewEvent = () => {
      openStyleSetting();
    };
    Object.assign($xeFormDesign, formDesignMethods, formDesignPrivateMethods);
    const renderLayoutHeader = () => {
      const extraSlot = slots.extra;
      return h("div", {
        class: "vxe-form-design--header-wrapper"
      }, [
        h("div", {
          class: "vxe-form-design--header-left"
        }),
        h("div", {
          class: "vxe-form-design--header-middle"
        }),
        h("div", {
          class: "vxe-form-design--header-right"
        }, [
          extraSlot ? h("div", {
            class: "vxe-form-design--header-extra"
          }, extraSlot({})) : renderEmptyElement($xeFormDesign),
          h("div", {
            class: "vxe-form-design--header-setting"
          }, [
            h(button_default, {
              mode: "text",
              status: "primary",
              icon: getIcon().FORM_DESIGN_STYLE_SETTING,
              content: getI18n("vxe.formDesign.styleSetting.btn"),
              onClick: openStylePreviewEvent
            })
          ])
        ])
      ]);
    };
    const renderVN = () => {
      const { height, showHeader } = props;
      const vSize = computeSize.value;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      return h("div", {
        ref: refElem,
        class: ["vxe-form-design", {
          [`size--${vSize}`]: vSize
        }],
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [
        showHeader || headerSlot ? h("div", {
          class: "vxe-form-design--header"
        }, headerSlot ? headerSlot({}) : renderLayoutHeader()) : createCommentVNode(),
        h("div", {
          class: "vxe-form-design--body"
        }, [
          h(layout_widget_default),
          h(layout_preview_default),
          h(layout_setting_default),
          h(layout_style_default, {
            ref: refLayoutStyle
          })
        ]),
        footerSlot ? h("div", {
          class: "vxe-form-design--footer"
        }, footerSlot ? footerSlot({}) : []) : createCommentVNode()
      ]);
    };
    $xeFormDesign.renderVN = renderVN;
    watch(() => props.widgets, () => {
      updateWidgetConfigs();
    });
    watch(() => props.widgets, () => {
      updateWidgetConfigs();
    });
    watch(() => props.config, (value) => {
      loadConfig(value || {});
    });
    initSettingForm();
    updateWidgetConfigs();
    if (props.config) {
      loadConfig(props.config);
    }
    provide("$xeFormDesign", $xeFormDesign);
    return $xeFormDesign;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/src/use/widget-name.js
var import_xe_utils47 = __toESM(require_xe_utils());
function useWidgetName(props) {
  const computeKebabCaseName = computed(() => {
    const { renderOpts } = props;
    return renderOpts ? import_xe_utils47.default.kebabCase(renderOpts.name) : "";
  });
  return {
    computeKebabCaseName
  };
}

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/src/use/widget-view.js
function useWidgetView(props) {
  const currWidget = computed(() => {
    const { renderParams } = props;
    return renderParams.widget;
  });
  const isEditMode = computed(() => {
    const { renderParams } = props;
    return renderParams.isEditMode || false;
  });
  const isViewMode = computed(() => {
    const { renderParams } = props;
    return renderParams.isViewMode || false;
  });
  const widgetOptions = computed(() => {
    const { renderParams } = props;
    const { widget } = renderParams;
    return widget ? widget.options : {};
  });
  const widgetModel = computed({
    get() {
      const { renderParams } = props;
      const { $formView, widget } = renderParams;
      return $formView ? $formView.getItemValue(widget) : null;
    },
    set(value) {
      const { renderParams } = props;
      const { $formView, widget } = renderParams;
      if ($formView) {
        $formView.setItemValue(widget, value);
      }
    }
  });
  return {
    currWidget,
    widgetOptions,
    widgetModel,
    isEditMode,
    isViewMode
  };
}

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/src/use/widget-subtable-view.js
var import_xe_utils48 = __toESM(require_xe_utils());
function useSubtableView(props) {
  const currWidget = computed(() => {
    const { renderParams } = props;
    return renderParams.widget;
  });
  const currColumn = computed(() => {
    const { renderParams } = props;
    return renderParams.column;
  });
  const currRow = computed(() => {
    const { renderParams } = props;
    return renderParams.row;
  });
  const widgetOptions = computed(() => {
    const { renderParams } = props;
    const { widget } = renderParams;
    return widget ? widget.options : {};
  });
  const cellModel = computed({
    get() {
      const { renderParams } = props;
      const { row, column } = renderParams;
      return import_xe_utils48.default.get(row, column.field);
    },
    set(value) {
      const { renderParams } = props;
      const { row, column } = renderParams;
      return import_xe_utils48.default.set(row, column.field, value);
    }
  });
  return {
    currColumn,
    currRow,
    currWidget,
    widgetOptions,
    cellModel
  };
}

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/textarea/src/textarea.js
var import_xe_utils49 = __toESM(require_xe_utils());
var autoTxtElem;
var textarea_default = defineComponent({
  name: "VxeTextarea",
  props: {
    modelValue: [String, Number],
    className: String,
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    readonly: {
      type: Boolean,
      default: null
    },
    editable: {
      type: Boolean,
      default: true
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    rows: {
      type: [String, Number],
      default: null
    },
    cols: {
      type: [String, Number],
      default: null
    },
    showWordCount: Boolean,
    countMethod: Function,
    autosize: [Boolean, Object],
    form: String,
    resize: {
      type: String,
      default: () => getConfig().textarea.resize
    },
    size: {
      type: String,
      default: () => getConfig().textarea.size || getConfig().size
    },
    // 已废弃
    maxlength: [String, Number]
  },
  emits: [
    "update:modelValue",
    "input",
    "keydown",
    "keyup",
    "click",
    "change",
    "focus",
    "blur"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils49.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      inputValue: props.modelValue
    });
    const refElem = ref();
    const refTextarea = ref();
    const refMaps = {
      refElem,
      refTextarea
    };
    const $xeTextarea = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let textareaMethods = {};
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeInputReadonly = computed(() => {
      const { editable } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || !editable;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().textarea.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseInput");
    });
    const computeInpMaxLength = computed(() => {
      const { maxLength, maxlength } = props;
      return maxLength || maxlength;
    });
    const computeInputCount = computed(() => {
      return import_xe_utils49.default.getSize(reactData.inputValue);
    });
    const computeIsCountError = computed(() => {
      const inputCount = computeInputCount.value;
      const inpMaxLength = computeInpMaxLength.value;
      return inpMaxLength && inputCount > import_xe_utils49.default.toNumber(inpMaxLength);
    });
    const computeSizeOpts = computed(() => {
      return Object.assign({ minRows: 1, maxRows: 10 }, getConfig().textarea.autosize, props.autosize);
    });
    const updateAutoTxt = () => {
      const { size, autosize } = props;
      const { inputValue } = reactData;
      if (autosize) {
        if (!autoTxtElem) {
          autoTxtElem = document.createElement("div");
        }
        if (!autoTxtElem.parentNode) {
          document.body.appendChild(autoTxtElem);
        }
        const textElem = refTextarea.value;
        if (!textElem) {
          return;
        }
        const textStyle = getComputedStyle(textElem);
        autoTxtElem.className = ["vxe-textarea--autosize", size ? `size--${size}` : ""].join(" ");
        autoTxtElem.style.width = `${textElem.clientWidth}px`;
        autoTxtElem.style.padding = textStyle.padding;
        autoTxtElem.innerText = ("" + (inputValue || "　")).replace(/\n$/, "\n　");
      }
    };
    const handleResize = () => {
      if (props.autosize) {
        nextTick(() => {
          const sizeOpts = computeSizeOpts.value;
          const { minRows, maxRows } = sizeOpts;
          const textElem = refTextarea.value;
          if (!textElem) {
            return;
          }
          const sizeHeight = autoTxtElem.clientHeight;
          const textStyle = getComputedStyle(textElem);
          const lineHeight = import_xe_utils49.default.toNumber(textStyle.lineHeight);
          const paddingTop = import_xe_utils49.default.toNumber(textStyle.paddingTop);
          const paddingBottom = import_xe_utils49.default.toNumber(textStyle.paddingBottom);
          const borderTopWidth = import_xe_utils49.default.toNumber(textStyle.borderTopWidth);
          const borderBottomWidth = import_xe_utils49.default.toNumber(textStyle.borderBottomWidth);
          const intervalHeight = paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;
          const rowNum = (sizeHeight - intervalHeight) / lineHeight;
          const textRows = rowNum && /[0-9]/.test("" + rowNum) ? rowNum : Math.floor(rowNum) + 1;
          let vaildRows = textRows;
          if (textRows < minRows) {
            vaildRows = minRows;
          } else if (textRows > maxRows) {
            vaildRows = maxRows;
          }
          textElem.style.height = `${vaildRows * lineHeight + intervalHeight}px`;
        });
      }
    };
    const triggerEvent = (evnt) => {
      const value = reactData.inputValue;
      $xeTextarea.dispatchEvent(evnt.type, { value }, evnt);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      if (import_xe_utils49.default.toValueString(props.modelValue) !== value) {
        textareaMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const inputEvent = (evnt) => {
      const { immediate } = props;
      const textElem = evnt.target;
      const value = textElem.value;
      reactData.inputValue = value;
      if (immediate) {
        handleChange(value, evnt);
      }
      $xeTextarea.dispatchEvent("input", { value }, evnt);
      handleResize();
    };
    const changeEvent = (evnt) => {
      const { immediate } = props;
      if (immediate) {
        triggerEvent(evnt);
      } else {
        handleChange(reactData.inputValue, evnt);
      }
    };
    const blurEvent = (evnt) => {
      const { immediate } = props;
      const { inputValue } = reactData;
      if (!immediate) {
        handleChange(inputValue, evnt);
      }
      $xeTextarea.dispatchEvent("blur", { value: inputValue }, evnt);
    };
    textareaMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $textarea: $xeTextarea }, params));
      },
      focus() {
        const textElem = refTextarea.value;
        textElem.focus();
        return nextTick();
      },
      blur() {
        const textElem = refTextarea.value;
        textElem.blur();
        return nextTick();
      }
    };
    Object.assign($xeTextarea, textareaMethods);
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
      updateAutoTxt();
    });
    watch(computeSizeOpts, () => {
      updateAutoTxt();
      handleResize();
    });
    nextTick(() => {
      const { autosize } = props;
      if (autosize) {
        updateAutoTxt();
        handleResize();
      }
    });
    const renderVN = () => {
      const { className, resize, autosize, showWordCount, countMethod, rows, cols } = props;
      const { inputValue } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const isCountError = computeIsCountError.value;
      const inputCount = computeInputCount.value;
      const inputReadonly = computeInputReadonly.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const inpMaxLength = computeInpMaxLength.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-textarea--readonly", className]
        }, inputValue);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-textarea", className, {
          [`size--${vSize}`]: vSize,
          "is--autosize": autosize,
          "is--count": showWordCount,
          "is--disabled": isDisabled,
          "is--rows": !import_xe_utils49.default.eqNull(rows),
          "is--cols": !import_xe_utils49.default.eqNull(cols)
        }],
        spellcheck: false
      }, [
        h("textarea", {
          ref: refTextarea,
          class: "vxe-textarea--inner",
          value: inputValue,
          name: props.name,
          placeholder: inpPlaceholder,
          maxlength: inpMaxLength,
          readonly: inputReadonly,
          disabled: isDisabled,
          rows,
          cols,
          style: resize ? {
            resize
          } : null,
          onInput: inputEvent,
          onChange: changeEvent,
          onKeydown: triggerEvent,
          onKeyup: triggerEvent,
          onClick: triggerEvent,
          onFocus: triggerEvent,
          onBlur: blurEvent
        }),
        showWordCount ? h("span", {
          class: ["vxe-textarea--count", {
            "is--error": isCountError
          }]
        }, countMethod ? `${countMethod({ value: inputValue })}` : `${inputCount}${inpMaxLength ? `/${inpMaxLength}` : ""}`) : null
      ]);
    };
    $xeTextarea.renderVN = renderVN;
    return $xeTextarea;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/tip/src/tip.js
var import_xe_utils50 = __toESM(require_xe_utils());
var tip_default = defineComponent({
  name: "VxeTip",
  props: {
    title: {
      type: [String, Number],
      default: () => getConfig().tip.title
    },
    content: [String, Number],
    status: String,
    icon: {
      type: String,
      default: () => getConfig().tip.icon
    },
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    size: {
      type: String,
      default: () => getConfig().tip.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils50.default.uniqueId();
    const { computeSize } = useSize(props);
    const { computePermissionInfo } = usePermission(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTip = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tip: $xeTip }, params));
    };
    const tipMethods = {
      dispatchEvent
    };
    const tipPrivateMethods = {};
    Object.assign($xeTip, tipMethods, tipPrivateMethods);
    const renderVN = () => {
      const { status, content, icon, title } = props;
      const defaultSlot = slots.default;
      const titleSlot = slots.title;
      const iconSlot = slots.icon;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      if (!permissionInfo.visible) {
        return createCommentVNode();
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-tip", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "has--title": !!(titleSlot || title)
        }]
      }, [
        iconSlot || icon ? h("div", {
          class: "vxe-tip--icon"
        }, iconSlot ? getSlotVNs(iconSlot({})) : [
          h("i", {
            class: icon
          })
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-tip--body"
        }, [
          titleSlot || title ? h("div", {
            class: "vxe-tip--title"
          }, titleSlot ? getSlotVNs(titleSlot({})) : import_xe_utils50.default.toValueString(title)) : createCommentVNode(),
          h("div", {
            class: "vxe-tip--content"
          }, defaultSlot ? getSlotVNs(defaultSlot({})) : import_xe_utils50.default.toValueString(content))
        ])
      ]);
    };
    $xeTip.renderVN = renderVN;
    return $xeTip;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/src/use/widget-prop-data-source.js
function useWidgetPropDataSource(props, renderConfig) {
  const renConf = Object.assign({}, renderConfig);
  const isSubOption = renConf.isSubOption;
  const optionsContent = ref("");
  const expandIndexList = ref([]);
  const addOptionEvent = () => {
    const { renderParams } = props;
    const { widget } = renderParams;
    const options = widget.options.options || [];
    options.push({
      value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [options.length + 1])
    });
    widget.options.options = [...options];
  };
  const subRE = /^(\s|\t)+/;
  const hasSubOption = (str) => {
    return subRE.test(str);
  };
  const expandAllOption = () => {
    const { renderParams } = props;
    const { widget } = renderParams;
    const options = widget.options.options || [];
    const indexList = [];
    options.forEach((group, gIndex) => {
      const { options: options2 } = group;
      if (options2 && options2.length) {
        indexList.push(gIndex);
      }
    });
    expandIndexList.value = indexList;
  };
  const toggleExpandOption = (item, gIndex) => {
    if (expandIndexList.value.includes(gIndex)) {
      expandIndexList.value = expandIndexList.value.filter((num) => num !== gIndex);
    } else {
      expandIndexList.value.push(gIndex);
    }
  };
  const removeOptionEvent = (item, group) => {
    const { renderParams } = props;
    const { widget } = renderParams;
    const { options } = widget;
    if (group) {
      if (group.options) {
        group.options = group.options.filter((obj) => obj !== item);
      }
    } else {
      options.options = options.options.filter((obj) => obj !== item);
    }
  };
  const confirmBatchAddOptionEvent = () => {
    const { renderParams } = props;
    const { widget } = renderParams;
    const optList = [];
    const rowList = optionsContent.value.split("\n");
    let prevGroup = null;
    if (isSubOption) {
      rowList.forEach((str, index) => {
        const nextStr = rowList[index + 1];
        const value = str.trim();
        if (!value) {
          return;
        }
        const item = {
          value
        };
        if (prevGroup) {
          if (hasSubOption(str)) {
            prevGroup.options.push(item);
            return;
          }
          prevGroup = null;
          optList.push(item);
        } else {
          optList.push(item);
        }
        if (nextStr) {
          if (hasSubOption(nextStr)) {
            prevGroup = Object.assign(item, { options: [] });
          }
        }
      });
    } else {
      rowList.forEach((str) => {
        optList.push({
          value: str.trim()
        });
      });
    }
    widget.options.options = optList;
    expandAllOption();
  };
  const openPopupEditEvent = () => {
    var _a;
    const { renderParams } = props;
    const { widget } = renderParams;
    const contList = [];
    (_a = widget.options.options) === null || _a === void 0 ? void 0 : _a.forEach((group) => {
      var _a2;
      contList.push(group.value);
      (_a2 = group.options) === null || _a2 === void 0 ? void 0 : _a2.forEach((item) => {
        contList.push(`	${item.value}`);
      });
    });
    optionsContent.value = contList.join("\n");
    VxeUI.modal.open({
      title: `${widget.title} - ${getI18n("vxe.formDesign.widgetProp.dataSource.batchEditOption")}`,
      width: 500,
      height: "50vh ",
      resize: true,
      showFooter: true,
      showCancelButton: true,
      showConfirmButton: true,
      confirmButtonText: getI18n("vxe.formDesign.widgetProp.dataSource.buildOption"),
      onConfirm: confirmBatchAddOptionEvent,
      slots: {
        default() {
          return h("div", {
            class: "vxe-form-design--widget-form-item-data-source-popup"
          }, [
            h(tip_default, {
              status: "primary",
              title: "",
              content: getI18n(`vxe.formDesign.widgetProp.dataSource.${isSubOption ? "batchEditSubTip" : "batchEditTip"}`)
            }),
            h(textarea_default, {
              resize: "none",
              modelValue: optionsContent.value,
              "onUpdate:modelValue"(val) {
                optionsContent.value = val;
              }
            })
          ]);
        }
      }
    });
  };
  const renderOption = (item, group, isExpand, gIndex, hasSub, isFirst, isLast) => {
    const hasFirstLevel = !group;
    return h("div", {
      class: ["vxe-form-design--widget-form-item-data-source-option", {
        "is--first": isFirst,
        "is--last": isLast
      }]
    }, [
      h("div", {
        class: "vxe-form-design--widget-expand-btn"
      }, hasFirstLevel && hasSub ? [
        h("i", {
          class: isExpand ? getIcon().FORM_DESIGN_WIDGET_OPTION_EXPAND_CLOSE : getIcon().FORM_DESIGN_WIDGET_OPTION_EXPAND_OPEN,
          onClick() {
            toggleExpandOption(item, gIndex);
          }
        })
      ] : []),
      h("input", {
        class: "vxe-default-input",
        value: item.value,
        onInput(evnt) {
          item.value = evnt.target.value;
        }
      }),
      h(button_default, {
        status: "danger",
        mode: "text",
        icon: getIcon().FORM_DESIGN_WIDGET_DELETE,
        onClick() {
          removeOptionEvent(item, group);
        }
      })
    ]);
  };
  const renderOptions = () => {
    const { renderParams } = props;
    const { widget } = renderParams;
    const { options } = widget;
    const groups = options.options;
    const optVNs = [];
    if (groups) {
      groups.forEach((group, gIndex) => {
        const { options: options2 } = group;
        const isExpand = expandIndexList.value.includes(gIndex);
        if (options2 && options2.length) {
          optVNs.push(renderOption(group, null, isExpand, gIndex, true, gIndex === 0, gIndex === groups.length - 1));
          if (isExpand) {
            optVNs.push(h("div", {
              class: "vxe-form-design--widget-form-item-data-source-sub-option"
            }, options2.map((item) => renderOption(item, group, isExpand, 0, false, false, false))));
          }
        } else {
          optVNs.push(renderOption(group, null, isExpand, gIndex, false, gIndex === 0, gIndex === groups.length - 1));
        }
      });
    }
    return optVNs;
  };
  watch(() => props.renderParams.widget, () => {
    expandAllOption();
  });
  onMounted(() => {
    expandAllOption();
  });
  const renderDataSourceFormItemContent = () => {
    return [
      h("div", {}, [
        h(button_default, {
          status: "primary",
          mode: "text",
          content: getI18n("vxe.formDesign.widgetProp.dataSource.addOption"),
          onClick: addOptionEvent
        }),
        h(button_default, {
          status: "primary",
          mode: "text",
          content: getI18n("vxe.formDesign.widgetProp.dataSource.batchEditOption"),
          onClick: openPopupEditEvent
        })
      ]),
      h("div", {
        class: "vxe-form-design--widget-form-item-data-source-wrapper"
      }, renderOptions())
    ];
  };
  return {
    renderDataSourceFormItem() {
      return h(form_item_default, {
        title: getI18n("vxe.formDesign.widgetProp.dataSource.name"),
        field: "options"
      }, {
        default() {
          return renderDataSourceFormItemContent();
        }
      });
    },
    renderDataSourceFormItemContent
  };
}

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/render/util.js
var getFormDesignWidgetName = (name) => {
  return getI18n(`vxe.formDesign.widget.component.${name}`);
};
var handleGetFormDesignWidgetName = (params) => {
  return getFormDesignWidgetName(params.name);
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-text/text-data.js
var getWidgetTextConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-text",
    group: "layout",
    options: {
      color: "",
      align: "",
      bold: false,
      fontSize: ""
    }
  };
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-text/text-form.js
var import_xe_utils51 = __toESM(require_xe_utils());
var getFontSizeOptions = () => {
  return import_xe_utils51.default.range(12, 27).map((num) => {
    return { label: `${num}px`, value: `${num}px` };
  });
};
var getAlignOptions2 = () => {
  return [
    { label: getI18n("vxe.formDesign.widgetProp.textProp.alignLeft"), value: "" },
    { label: getI18n("vxe.formDesign.widgetProp.textProp.alignCenter"), value: "center" },
    { label: getI18n("vxe.formDesign.widgetProp.textProp.alignRight"), value: "right" }
  ];
};
var getBoldOptions2 = () => {
  return [
    { label: getI18n("vxe.formDesign.widgetProp.textProp.fontNormal"), value: false },
    { label: getI18n("vxe.formDesign.widgetProp.textProp.fontBold"), value: true }
  ];
};
var WidgetTextFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    const alignOpts = ref(getAlignOptions2());
    const boldOpts = ref(getBoldOptions2());
    const fontSizeOpts = ref(getFontSizeOptions());
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.textProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.textProp.boldTitle"),
              field: "bold",
              itemRender: { name: "VxeRadioGroup", options: boldOpts.value }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.textProp.alignTitle"),
              field: "align",
              itemRender: { name: "VxeRadioGroup", options: alignOpts.value }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.textProp.sizeTitle"),
              field: "fontSize",
              itemRender: { name: "VxeSelect", options: fontSizeOpts.value }
            })
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-text/text-view.js
var WidgetTextViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        align: options.align
      }, {
        default() {
          return h("div", {
            style: {
              fontSize: options.fontSize,
              fontWeight: options.bold ? "bold" : ""
            }
          }, widget.title);
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-row/row-data.js
var import_xe_utils52 = __toESM(require_xe_utils());
var getWidgetRowConfig = (params) => {
  const { $formDesign } = params;
  const defaultColSize = 2;
  return {
    title: handleGetFormDesignWidgetName,
    group: "layout",
    icon: "vxe-icon-row-col",
    options: {
      colSize: defaultColSize,
      colSpan: "12,12"
    },
    children: $formDesign ? import_xe_utils52.default.range(0, defaultColSize).map(() => {
      return $formDesign.createEmptyWidget();
    }) : []
  };
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/row/src/row.js
var import_xe_utils53 = __toESM(require_xe_utils());
var row_default = defineComponent({
  name: "VxeRow",
  props: {
    gutter: [Number, String, Array],
    wrap: {
      type: Boolean,
      default: () => getConfig().row.wrap
    },
    vertical: Boolean,
    size: {
      type: String,
      default: () => getConfig().row.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils53.default.uniqueId();
    useSize(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeRowStyle = computed(() => {
      const { gutter, vertical } = props;
      const style = {};
      if (gutter) {
        let [lrGutter, tbGutter] = import_xe_utils53.default.isArray(gutter) ? gutter : [gutter];
        if (vertical) {
          tbGutter = lrGutter;
          lrGutter = "";
        }
        if (lrGutter) {
          const offsetSize = import_xe_utils53.default.isNumber(lrGutter) ? toCssUnit(-(lrGutter / 2)) : `calc(${toCssUnit(lrGutter)} / 2 * -1)`;
          style.marginLeft = offsetSize;
          style.marginRight = offsetSize;
        }
        if (tbGutter) {
          const offsetSize = import_xe_utils53.default.isNumber(tbGutter) ? toCssUnit(-(tbGutter / 2)) : `calc(${toCssUnit(tbGutter)} / 2 * -1)`;
          style.marginTop = offsetSize;
          style.marginBottom = offsetSize;
        }
      }
      return style;
    });
    const computeMaps = {};
    const $xeRow = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const clickEvent = (evnt) => {
      dispatchEvent("click", {}, evnt);
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $row: $xeRow }, params));
    };
    const rowMethods = {
      dispatchEvent
    };
    const rowPrivateMethods = {};
    Object.assign($xeRow, rowMethods, rowPrivateMethods);
    const renderVN = () => {
      const { vertical, wrap } = props;
      const rowStyle = computeRowStyle.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-row", {
          "is--vertical": vertical,
          "is--wrap": wrap
        }],
        style: rowStyle,
        onClick: clickEvent
      }, defaultSlot ? defaultSlot({}) : []);
    };
    provide("$xeRow", $xeRow);
    $xeRow.renderVN = renderVN;
    return $xeRow;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-row/row-form.js
var import_xe_utils54 = __toESM(require_xe_utils());
var WidgetRowFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { computeKebabCaseName } = useWidgetName(props);
    const spanOptions = ref([
      {
        label: getI18n("vxe.formDesign.widgetProp.rowProp.col2"),
        value: 2,
        list: [
          { value: "12,12", spans: [12, 12] },
          { value: "8,16", spans: [8, 16] },
          { value: "16,8", spans: [16, 8] },
          { value: "6,18", spans: [6, 18] },
          { value: "18,6", spans: [18, 6] }
        ]
      },
      {
        label: getI18n("vxe.formDesign.widgetProp.rowProp.col3"),
        value: 3,
        list: [
          { value: "8,8,8", spans: [8, 8, 8] },
          { value: "6,6,12", spans: [6, 6, 12] },
          { value: "12,6,6", spans: [12, 6, 6] },
          { value: "6,12,6", spans: [6, 12, 6] }
        ]
      },
      {
        label: getI18n("vxe.formDesign.widgetProp.rowProp.col4"),
        value: 4,
        list: [
          { value: "6,6,6,6", spans: [6, 6, 6, 6] }
        ]
      },
      {
        label: getI18n("vxe.formDesign.widgetProp.rowProp.col6"),
        value: 6,
        list: [
          { value: "4,4,4,4,4,4", spans: [4, 4, 4, 4, 4, 4] }
        ]
      }
    ]);
    const labelMaps = {
      18: "3/4",
      16: "2/3",
      12: "1/2",
      8: "1/3",
      6: "1/4",
      4: "1/6"
    };
    const computeSelectSpanItem = computed(() => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      return spanOptions.value.find((item) => item.value === options.colSize);
    });
    const changeColSpan = (item) => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const { reactData: formDesignReactData } = $xeFormDesign;
      const { widgetObjList } = formDesignReactData;
      const oldChildList = widget.children.filter((item2) => item2.name);
      const overList = oldChildList.slice(options.colSize);
      if (overList.length) {
        const rest = import_xe_utils54.default.findTree(widgetObjList, (obj) => obj.id === widget.id, { children: "children" });
        if (rest) {
          const { items, index } = rest;
          if (index >= items.length - 1) {
            items.push(...overList);
          } else {
            items.splice(index + 1, 0, ...overList);
          }
        }
      }
      options.colSpan = item.value;
      widget.children = import_xe_utils54.default.range(0, options.colSize).map((num, index) => {
        return oldChildList[index] || $xeFormDesign.createEmptyWidget();
      });
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: `vxe-form-design--widget-${kebabCaseName}-form`,
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.rowProp.colSize"),
              field: "colSize",
              itemRender: { name: "VxeRadioGroup", options: spanOptions.value, props: { type: "button" } }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.rowProp.layout")
            }, {
              default() {
                const selectSpanItem = computeSelectSpanItem.value;
                if (selectSpanItem) {
                  return selectSpanItem.list.map((item, rIndex) => {
                    return h(row_default, {
                      key: rIndex,
                      class: [`vxe-form-design--widget-${kebabCaseName}-form-row`, {
                        "is--active": item.value === widget.options.colSpan
                      }],
                      onClick() {
                        changeColSpan(item);
                      }
                    }, {
                      default() {
                        return item.spans.map((span, sIndex) => {
                          return h(col_default, {
                            key: `${rIndex}${sIndex}`,
                            class: `vxe-form-design--widget-${kebabCaseName}-form-col`,
                            span
                          }, {
                            default() {
                              return h("div", {}, `${labelMaps[span]}`);
                            }
                          });
                        });
                      }
                    });
                  });
                }
                return [];
              }
            })
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-row/row-view.js
var import_xe_utils55 = __toESM(require_xe_utils());
var ViewColItemComponent = defineComponent({
  name: "ViewColItem",
  props: {
    parentWidget: {
      type: Object,
      default: () => ({})
    },
    widget: {
      type: Object,
      default: () => ({})
    },
    span: Number,
    colItemIndex: {
      type: Number,
      default: 0
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const handleDragstartColItemEvent = (evnt) => {
      evnt.stopPropagation();
      const divEl = evnt.currentTarget;
      const dataTransfer = evnt.dataTransfer;
      const widgetId = divEl.getAttribute("data-widget-id") || "";
      const dragWidget = $xeFormDesign.getWidgetById(widgetId);
      if (dataTransfer) {
        dataTransfer.setData("text/plain", widgetId);
      }
      formDesignReactData.sortWidget = dragWidget;
      formDesignReactData.dragWidget = null;
    };
    const sortDragenterColItemEvent = (evnt) => {
      const { parentWidget, colItemIndex } = props;
      const { widgetObjList, sortWidget } = formDesignReactData;
      const targetWidget = parentWidget.children[colItemIndex];
      const formDesignInternalData = $xeFormDesign.internalData;
      evnt.stopPropagation();
      if (sortWidget && parentWidget && sortWidget.id !== parentWidget.id) {
        if (hasFormDesignLayoutType(sortWidget)) {
          return;
        }
        if (!hasFormDesignLayoutType(targetWidget)) {
          const currRest = import_xe_utils55.default.findTree(widgetObjList, (item) => item && item.id === sortWidget.id, { children: "children" });
          if (currRest) {
            const { item, index, items, parent } = currRest;
            if (parentWidget.children.length !== parentWidget.options.colSize) {
              parentWidget.children = import_xe_utils55.default.range(0, parentWidget.options.colSize).map((index2) => {
                return parentWidget.children[index2] || $xeFormDesign.createEmptyWidget();
              });
            }
            if (parent && parent.id === parentWidget.id) {
              parentWidget.children[colItemIndex] = item;
              parentWidget.children[index] = targetWidget;
            } else {
              if (targetWidget && targetWidget.name) {
                return;
              }
              parentWidget.children[colItemIndex] = item;
              items.splice(index, 1);
            }
            evnt.preventDefault();
            formDesignInternalData.lastDragTime = Date.now();
            $xeFormDesign.dispatchEvent("drag-widget", { widget: item }, evnt);
          }
        }
      }
    };
    return () => {
      const { widget, span } = props;
      const { dragWidget, activeWidget, sortWidget } = formDesignReactData;
      return h(form_item_default, {
        span,
        padding: false
      }, {
        default() {
          const name = widget ? widget.name : "";
          const compConf = renderer.get(name) || {};
          const renderWidgetDesignView = compConf.renderFormDesignWidgetEdit || compConf.renderFormDesignWidgetView;
          const renderOpts = widget || { name };
          const params = { widget, readonly: false, disabled: false, isEditMode: true, isViewMode: false, $formDesign: $xeFormDesign, $formView: null };
          const isActive = activeWidget && widget && activeWidget.id === widget.id;
          const isEmptyWidget = !renderWidgetDesignView;
          return h("div", {
            class: "vxe-form-design--widget-row-view",
            "data-widget-id": widget.id,
            draggable: !isEmptyWidget,
            onDragstart: handleDragstartColItemEvent,
            onDragenter: sortDragenterColItemEvent,
            onClick(evnt) {
              if (widget) {
                $xeFormDesign.handleClickWidget(evnt, widget);
              }
            }
          }, [
            h("div", {
              class: ["vxe-form-design--widget-row-view-item-inner", {
                "is--empty": isEmptyWidget,
                "is--active": isActive,
                "is--sort": sortWidget && widget && sortWidget.id === widget.id,
                "is--drag": dragWidget && widget && dragWidget.id === widget.id
              }]
            }, [
              renderWidgetDesignView ? h("div", {
                class: "vxe-form-design--widget-row-view-item-wrapper"
              }, [
                h("div", {
                  class: "vxe-form-design--widget-row-view-item-box vxe-form--item-row"
                }, getSlotVNs(renderWidgetDesignView(renderOpts, params))),
                isActive ? h("div", {
                  class: "vxe-form-design--preview-item-operate"
                }, [
                  h(button_default, {
                    icon: getIcon().FORM_DESIGN_WIDGET_COPY,
                    status: "primary",
                    size: "mini",
                    circle: true,
                    onClick(params2) {
                      $xeFormDesign.handleCopyWidget(params2.$event, widget);
                    }
                  }),
                  h(button_default, {
                    icon: getIcon().FORM_DESIGN_WIDGET_DELETE,
                    status: "danger",
                    size: "mini",
                    circle: true,
                    onClick(params2) {
                      $xeFormDesign.handleRemoveWidget(params2.$event, widget);
                    }
                  })
                ]) : createCommentVNode()
              ]) : h("div", {
                class: "vxe-form-design--widget-row-view-empty"
              }, "控件位置")
            ])
          ]);
        }
      });
    };
  }
});
var WidgetRowEditComponent = defineComponent({
  name: "WidgetRowEdit",
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const computedColObjList = computed(() => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const { colSpan } = options;
      const colList = colSpan ? `${colSpan}`.split(",") : [];
      const rest = colList.map((span) => Number(span));
      return rest;
    });
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      return h(form_group_default, {
        field: widget.field
      }, {
        default() {
          const colObjList = computedColObjList.value;
          return colObjList.map((span, colItemIndex) => {
            return h(ViewColItemComponent, {
              key: colItemIndex,
              parentWidget: widget,
              widget: widget.children[colItemIndex],
              span,
              colItemIndex
            });
          });
        }
      });
    };
  }
});
var WidgetRowViewComponent = defineComponent({
  name: "WidgetRowView",
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    const $xeFormView = inject("$xeFormView", null);
    const computedColObjList = computed(() => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const { colSpan } = options;
      const colList = colSpan ? `${colSpan}`.split(",") : [];
      const rest = colList.map((span) => Number(span));
      return rest;
    });
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const colObjList = computedColObjList.value;
      return h(row_default, {}, {
        default() {
          return colObjList.map((span, colItemIndex) => {
            return h(col_default, {
              key: colItemIndex,
              class: "vxe-form--item-row",
              span
            }, {
              default() {
                const subWidget = widget.children[colItemIndex];
                if (subWidget) {
                  const { name } = subWidget;
                  const compConf = renderer.get(name) || {};
                  const renderWidgetDesignView = compConf.renderFormDesignWidgetView;
                  const renderOpts = subWidget;
                  const isEditMode = !!$xeFormDesign;
                  const params = { widget: subWidget, readonly: false, disabled: false, isEditMode, isViewMode: !isEditMode, $formDesign: $xeFormDesign, $formView: $xeFormView };
                  if (renderWidgetDesignView) {
                    return getSlotVNs(renderWidgetDesignView(renderOpts, params));
                  }
                }
                return createCommentVNode();
              }
            });
          });
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-subtable/subtable-data.js
var getWidgetSubtableConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    group: "layout",
    icon: "vxe-icon-subtable",
    options: {
      showCheckbox: false
    }
  };
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-subtable/subtable-form.js
var WidgetSubtableFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: `vxe-form-design--widget-${kebabCaseName}-form`,
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.subtableProp.showCheckbox"),
              field: "showCheckbox"
            }, {
              default() {
                return h(switch_default, {
                  modelValue: options.showCheckbox,
                  "onUpdate:modelValue"(val) {
                    options.showCheckbox = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-subtable/subtable-view.js
var import_xe_utils56 = __toESM(require_xe_utils());
var ViewSubItemComponent = defineComponent({
  props: {
    parentWidget: {
      type: Object,
      default: () => ({})
    },
    widget: {
      type: Object,
      default: () => ({})
    },
    childIndex: {
      type: Number,
      default: 0
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    const $xeFormView = inject("$xeFormView", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const sortDragstartSubItemEvent = (evnt) => {
      evnt.stopPropagation();
      const divEl = evnt.currentTarget;
      const dataTransfer = evnt.dataTransfer;
      const widgetId = divEl.getAttribute("data-widget-id") || "";
      const dragWidget = $xeFormDesign.getWidgetById(widgetId);
      if (dataTransfer) {
        dataTransfer.setData("text/plain", widgetId);
      }
      formDesignReactData.sortWidget = dragWidget;
      formDesignReactData.dragWidget = null;
    };
    const sortDragenterSubItemEvent = (evnt) => {
      const { parentWidget, childIndex } = props;
      const { widgetObjList, sortWidget } = formDesignReactData;
      const targetWidget = parentWidget.children[childIndex];
      const formDesignInternalData = $xeFormDesign.internalData;
      const { lastDragTime } = formDesignInternalData;
      evnt.stopPropagation();
      if (lastDragTime && lastDragTime > Date.now() - 300) {
        evnt.preventDefault();
        return;
      }
      if (sortWidget && targetWidget && parentWidget) {
        if (sortWidget.id === parentWidget.id) {
          return;
        }
        if (sortWidget.id === targetWidget.id) {
          return;
        }
        if (hasFormDesignLayoutType(sortWidget)) {
          return;
        }
        if (targetWidget && !hasFormDesignLayoutType(targetWidget)) {
          const currRest = import_xe_utils56.default.findTree(widgetObjList, (item) => item.id === sortWidget.id, { children: "children" });
          if (currRest) {
            const { item, index, items, parent } = currRest;
            if (parent && parent.id === parentWidget.id) {
              parentWidget.children[childIndex] = item;
              parentWidget.children[index] = targetWidget;
            } else {
              parentWidget.children.splice(childIndex, 0, item);
              items.splice(index, 1);
            }
            formDesignInternalData.lastDragTime = Date.now();
            $xeFormDesign.dispatchEvent("drag-widget", { widget: item }, evnt);
          }
        }
      }
    };
    return () => {
      const { widget } = props;
      const { dragWidget, activeWidget, sortWidget } = formDesignReactData;
      const name = widget ? widget.name : "";
      const compConf = renderer.get(name) || {};
      const renderSubtableView = compConf.renderFormDesignWidgetSubtableEditView || compConf.renderFormDesignWidgetSubtableCellView || compConf.renderFormDesignWidgetSubtableDefaultView;
      const renderWidgetDesignView = compConf.renderFormDesignWidgetEdit || compConf.renderFormDesignWidgetView;
      const renderOpts = widget || { name };
      const isEditMode = !!$xeFormDesign;
      const defParams = { widget, readonly: false, disabled: false, isEditMode, isViewMode: !isEditMode, $formDesign: $xeFormDesign, $formView: $xeFormView };
      const isActive = activeWidget && widget && activeWidget.id === widget.id;
      const subOpts = { name };
      const subParams = {
        $table: null,
        $grid: null,
        seq: "",
        column: {
          field: widget.field,
          title: widget.title
        },
        columnIndex: 0,
        $columnIndex: 0,
        _columnIndex: 0,
        rowid: "",
        row: {},
        rowIndex: 0,
        $rowIndex: 0,
        _rowIndex: 0,
        isEdit: false,
        isHidden: false,
        fixed: null,
        type: "",
        level: 1,
        visibleData: [],
        items: [],
        data: [],
        widget
      };
      return h("div", {
        class: ["vxe-form-design--widget-subtable-view-item", {
          "is--active": isActive,
          "is--sort": sortWidget && widget && sortWidget.id === widget.id,
          "is--drag": dragWidget && widget && dragWidget.id === widget.id
        }],
        draggable: true,
        "data-widget-id": widget.id,
        onDragstart: sortDragstartSubItemEvent,
        onDragenter: sortDragenterSubItemEvent,
        onClick(evnt) {
          if (widget) {
            $xeFormDesign.handleClickWidget(evnt, widget);
          }
        }
      }, [
        h("div", {
          class: "vxe-form-design--widget-subtable-view-item-wrapper"
        }, [
          h("div", {
            class: "vxe-form-design--widget-subtable-view-item-box vxe-form--item-row"
          }, renderSubtableView ? h(form_item_default, {
            class: ["vxe-form-design--widget-render-form-item"],
            title: widget.title,
            field: widget.field,
            itemRender: {}
          }, {
            default() {
              return getSlotVNs(renderSubtableView(subOpts, subParams));
            }
          }) : renderWidgetDesignView ? getSlotVNs(renderWidgetDesignView(renderOpts, defParams)) : []),
          isActive ? h("div", {
            class: "vxe-form-design--preview-item-operate"
          }, [
            h(button_default, {
              icon: getIcon().FORM_DESIGN_WIDGET_COPY,
              status: "primary",
              size: "mini",
              circle: true,
              onClick(params) {
                $xeFormDesign.handleCopyWidget(params.$event, widget);
              }
            }),
            h(button_default, {
              icon: getIcon().FORM_DESIGN_WIDGET_DELETE,
              status: "danger",
              size: "mini",
              circle: true,
              onClick(params) {
                $xeFormDesign.handleRemoveWidget(params.$event, widget);
              }
            })
          ]) : createCommentVNode()
        ])
      ]);
    };
  }
});
var WidgetSubtableEditComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const handleDragoverWrapperEvent = (evnt) => {
      const { sortWidget, widgetObjList } = formDesignReactData;
      const { renderParams } = props;
      const { widget } = renderParams;
      evnt.stopPropagation();
      if (!sortWidget || !widget || widget.id === sortWidget.id) {
        return;
      }
      if (hasFormDesignLayoutType(sortWidget)) {
        if (VxeUI.modal) {
          VxeUI.modal.message({
            content: getI18n("vxe.formDesign.widgetProp.subtableProp.errSubDrag"),
            status: "error",
            id: "errSubDrag"
          });
        }
        return;
      }
      if (widget.name && !widget.children.some((item) => item.id === sortWidget.id)) {
        const rest = import_xe_utils56.default.findTree(widgetObjList, (item) => item.id === sortWidget.id, { children: "children" });
        if (rest) {
          const { item, index, items } = rest;
          formDesignReactData.sortWidget = null;
          formDesignReactData.activeWidget = item;
          widget.children.push(item);
          items.splice(index, 1);
          formDesignReactData.sortWidget = item;
        }
      }
    };
    const handleDragenterWrapperEvent = (evnt) => {
      evnt.stopPropagation();
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { title, children, options } = widget;
      const { showCheckbox } = options;
      return h(form_item_default, {
        title,
        className: "vxe-form-design--widget-subtable-form-item"
      }, {
        default() {
          return h("div", {
            class: "vxe-form-design--widget-subtable-view",
            onDragenter: handleDragenterWrapperEvent,
            onDragover: handleDragoverWrapperEvent
          }, [
            h("div", {
              class: "vxe-form-design--widget-subtable-view-left"
            }, [
              showCheckbox ? h("div", {
                class: "vxe-form-design--widget-subtable-col"
              }, [
                h("div", {
                  class: "vxe-form-design--widget-subtable-head"
                }, [
                  h(checkbox_default)
                ]),
                h("div", {
                  class: "vxe-form-design--widget-subtable-body"
                }, [
                  h(checkbox_default)
                ])
              ]) : createCommentVNode(),
              h("div", {
                class: "vxe-form-design--widget-subtable-col"
              }, [
                h("div", {
                  class: "vxe-form-design--widget-subtable-head"
                }, getI18n("vxe.formDesign.widgetProp.subtableProp.seqTitle")),
                h("div", {
                  class: "vxe-form-design--widget-subtable-body"
                }, "1")
              ])
            ]),
            h("div", {
              class: "vxe-form-design--widget-subtable-view-right"
            }, [
              h("div", {
                class: "vxe-form-design--widget-subtable-view-wrapper"
              }, [
                h(TransitionGroup, {
                  class: "vxe-form-design--widget-subtable-view-list",
                  tag: "div",
                  name: "vxe-form-design--widget-subtable-view-list"
                }, {
                  default: () => {
                    return children ? children.map((childWidget, childIndex) => {
                      return h(ViewSubItemComponent, {
                        key: childWidget.id,
                        parentWidget: widget,
                        widget: childWidget,
                        childIndex
                      });
                    }) : [];
                  }
                }),
                h("div", {
                  key: "empty",
                  class: "vxe-form-design--widget-subtable-view-empty"
                }, getI18n("vxe.formDesign.widgetProp.subtableProp.colPlace"))
              ])
            ])
          ]);
        }
      });
    };
  }
});
var WidgetSubtableViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const VxeTableGridComponent = VxeUI.getComponent("VxeGrid");
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const refGrid = ref();
    const defaultDataList = ref([
      {}
    ]);
    const computeFormReadonly = computed(() => {
      if ($xeFormView) {
        return $xeFormView.props.readonly;
      }
      return false;
    });
    const computeSubtableColumns = computed(() => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { children, options } = widget;
      const formReadonly = computeFormReadonly.value;
      const columns = [];
      if (options.showCheckbox) {
        columns.push({
          type: "checkbox",
          width: 60,
          fixed: "left"
        });
      }
      columns.push({
        type: "seq",
        width: 60,
        fixed: "left"
      });
      if (children) {
        children.forEach((childWidget) => {
          const { name } = childWidget;
          const compConf = renderer.get(name) || {};
          const parseSubtableColumn = compConf.parseFormDesignWidgetSubtableColumn;
          let colConf = {
            field: childWidget.field,
            title: childWidget.title
          };
          if (parseSubtableColumn) {
            colConf = Object.assign(colConf, parseSubtableColumn({
              $formView: $xeFormView,
              name: childWidget.name,
              widget: childWidget,
              readonly: !!formReadonly
            }));
          } else {
            if (formReadonly) {
              colConf.cellRender = {
                name: childWidget.name,
                props: childWidget.options
              };
            } else {
              colConf.editRender = {
                name: childWidget.name,
                props: childWidget.options
              };
            }
          }
          const renderSubtableDefaultView = compConf.renderFormDesignWidgetSubtableDefaultView;
          const renderSubtableCellView = compConf.renderFormDesignWidgetSubtableCellView || renderSubtableDefaultView;
          const renderSubtableEditView = compConf.renderFormDesignWidgetSubtableEditView;
          const colSlots = {};
          if (renderSubtableDefaultView || renderSubtableCellView) {
            colSlots.default = (slotParams) => {
              const { isEdit, column } = slotParams;
              const { editRender, cellRender } = column;
              const params = Object.assign({ widget: childWidget }, slotParams);
              if (isEdit && editRender) {
                if (renderSubtableCellView) {
                  return getSlotVNs(renderSubtableCellView(editRender, params));
                }
              }
              if (renderSubtableDefaultView) {
                return getSlotVNs(renderSubtableDefaultView(cellRender || {}, params));
              }
              return [];
            };
          }
          if (renderSubtableEditView) {
            colSlots.edit = (slotParams) => {
              const { column } = slotParams;
              const { editRender } = column;
              const params = Object.assign({ widget: childWidget }, slotParams);
              return getSlotVNs(renderSubtableEditView(editRender, params));
            };
          }
          colConf.slots = colSlots;
          columns.push(colConf);
        });
      }
      if (!formReadonly) {
        columns.push({
          field: "action",
          title: "操作",
          fixed: "right",
          width: 80,
          slots: {
            default({ row }) {
              return h(button_default, {
                mode: "text",
                icon: "vxe-icon-delete",
                status: "error",
                onClick() {
                  removeSubRow(row);
                }
              });
            }
          }
        });
      }
      return columns;
    });
    const computeGridOptions = computed(() => {
      const { renderParams } = props;
      const { widget, isEditMode } = renderParams;
      const subtableColumns = computeSubtableColumns.value;
      const formReadonly = computeFormReadonly.value;
      const gridConf = {
        border: true,
        showOverflow: true,
        height: 300,
        columnConfig: {
          resizable: true,
          minWidth: 140
        },
        rowConfig: {
          keyField: "_id"
        },
        data: isEditMode ? defaultDataList.value : $xeFormView ? $xeFormView.getItemValue(widget) : null,
        columns: subtableColumns,
        toolbarConfig: {
          zoom: true,
          custom: false,
          slots: {
            buttons: "toolbarButtons"
          }
        }
      };
      if (!formReadonly) {
        gridConf.keepSource = true;
        gridConf.editConfig = {
          mode: "row",
          trigger: "click",
          showStatus: true
        };
      }
      return gridConf;
    });
    const getSubRecord = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const record = {
        _id: Date.now()
      };
      import_xe_utils56.default.each(widget.children, (childWidget) => {
        record[childWidget.field] = null;
      });
      return record;
    };
    const addSubRowEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        let list = $xeFormView.getItemValue(widget);
        if (!import_xe_utils56.default.isArray(list)) {
          list = [];
        }
        const newRow = getSubRecord();
        list.unshift(newRow);
        $xeFormView.setItemValue(widget, list.slice(0)).then(() => {
          return nextTick().then(() => {
            const $grid = refGrid.value;
            if ($grid) {
              $grid.setEditRow(newRow);
            }
          });
        });
      }
    };
    const removeSubRow = (row) => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const list = $xeFormView.getItemValue(widget);
        if (list) {
          $xeFormView.setItemValue(widget, list.filter((item) => item._id !== row._id));
        }
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      const gridOptions = computeGridOptions.value;
      const formReadonly = computeFormReadonly.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        span: 24
      }, {
        default() {
          return VxeTableGridComponent ? h(VxeTableGridComponent, Object.assign(Object.assign({}, gridOptions), { ref: refGrid }), {
            toolbarButtons() {
              return formReadonly ? [] : [
                h(button_default, {
                  content: "新增",
                  icon: "vxe-icon-add",
                  status: "primary",
                  onClick: addSubRowEvent
                })
              ];
            }
          }) : createCommentVNode();
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-input/input-data.js
var getWidgetInputConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-input",
    query: true,
    options: {
      placeholder: ""
    }
  };
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-input/input-form.js
var WidgetInputFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-input/input-view.js
var WidgetInputViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h("input", {
            class: "vxe-default-input",
            type: "text",
            placeholder: options.placeholder || getI18n("vxe.base.pleaseInput"),
            value: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent,
            onInput(evnt) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, evnt.target.value);
              }
            }
          });
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-textarea/textarea-data.js
var getWidgetTextareaConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-textarea",
    query: true,
    options: {
      placeholder: ""
    }
  };
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-textarea/textarea-form.js
var WidgetTextareaFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-textarea/textarea-view.js
var WidgetTextareaViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h("textarea", {
            class: "vxe-default-textarea",
            placeholder: options.placeholder || getI18n("vxe.base.pleaseInput"),
            value: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent,
            onInput(evnt) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, evnt.target.value);
              }
            }
          });
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-select/select-data.js
var import_xe_utils57 = __toESM(require_xe_utils());
var getWidgetSelectConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-select",
    query: true,
    options: {
      options: import_xe_utils57.default.range(0, 3).map((v, i) => {
        return {
          value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [i + 1])
        };
      })
    }
  };
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-select/select-form.js
var WidgetSelectFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { renderDataSourceFormItem } = useWidgetPropDataSource(props, {
      isSubOption: true
    });
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            }),
            renderDataSourceFormItem()
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-select/select-view.js
var WidgetSelectViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    const renderOptions = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget.options;
      return options ? options.map((group) => {
        if (group.options) {
          return h("optgroup", {
            label: group.value
          }, group.options.map((item) => {
            return h("option", {
              value: item.value
            }, item.value);
          }));
        }
        return h("option", {}, group.value);
      }) : [];
    };
    return () => {
      const { renderParams } = props;
      const { widget, isViewMode } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h("select", {
            class: "vxe-default-select",
            value: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent
          }, isViewMode ? renderOptions() : []);
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-input/vxe-input-data.js
var getWidgetVxeInputConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-input",
    query: true,
    options: {
      placeholder: ""
    }
  };
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-input/vxe-input-form.js
var WidgetVxeInputFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-input/vxe-input-view.js
var WidgetVxeInputViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h(input_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-number-input/vxe-number-input-data.js
var getWidgetVxeNumberInputConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-number",
    query: true,
    options: {
      placeholder: ""
    }
  };
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-number-input/vxe-number-input-form.js
var WidgetVxeNumberInputFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-number-input/vxe-number-input-view.js
var WidgetVxeNumberInputViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(number_input_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-date-picker/vxe-date-picker-data.js
var getWidgetVxeDatePickerConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-calendar",
    options: {
      placeholder: "",
      defaultValue: {
        type: "",
        value: ""
      }
    }
  };
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-date-picker/vxe-date-picker-form.js
var WidgetVxeDatePickerFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            // renderDefaultValueFormItem(),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-date-picker/vxe-date-picker-view.js
var WidgetVxeDatePickerViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(date_picker_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-textarea/vxe-textarea-data.js
var getWidgetVxeTextareaConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-textarea",
    options: {
      placeholder: ""
    }
  };
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-textarea/vxe-textarea-form.js
var WidgetVxeTextareaFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-textarea/vxe-textarea-view.js
var WidgetVxeTextareaViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(textarea_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder,
            resize: "node",
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-switch/vxe-switch-data.js
var getWidgetVxeSwitchConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-switch",
    query: true,
    options: {}
  };
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-switch/vxe-switch-form.js
var WidgetVxeSwitchFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-switch/vxe-switch-view.js
var WidgetVxeSwitchViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h(switch_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-select/vxe-select-data.js
var import_xe_utils58 = __toESM(require_xe_utils());
var getWidgetVxeSelectConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-select",
    query: true,
    options: {
      placeholder: "",
      options: import_xe_utils58.default.range(0, 3).map((v, i) => {
        return {
          value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [i + 1])
        };
      }),
      multiple: false
    }
  };
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-select/vxe-select-form.js
var WidgetVxeSelectFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { renderDataSourceFormItem } = useWidgetPropDataSource(props, {
      isSubOption: false
    });
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.multiple"),
              field: "multiple",
              itemRender: { name: "VxeSwitch" }
            }),
            renderDataSourceFormItem(),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-select/vxe-select-view.js
var WidgetVxeSelectViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget, isViewMode } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(select_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder || getI18n("vxe.base.pleaseSelect"),
            options: isViewMode ? options.options : [],
            optionProps: { label: "value", value: "value" },
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-tree-select/vxe-tree-select-data.js
var import_xe_utils59 = __toESM(require_xe_utils());
var getWidgetVxeTreeSelectConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-tree-select",
    query: true,
    options: {
      placeholder: "",
      options: import_xe_utils59.default.range(0, 3).map((v, i) => {
        return {
          value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [i + 1])
        };
      }),
      multiple: false
    }
  };
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-tree-select/vxe-tree-select-form.js
var WidgetVxeTreeSelectFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.multiple"),
              field: "multiple",
              itemRender: { name: "VxeSwitch" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/tree-select/src/tree-select.js
var import_xe_utils61 = __toESM(require_xe_utils());

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/tree/src/tree.js
var import_xe_utils60 = __toESM(require_xe_utils());
function getNodeUniqueId() {
  return import_xe_utils60.default.uniqueId("node_");
}
var tree_default = defineComponent({
  name: "VxeTree",
  props: {
    data: Array,
    height: [String, Number],
    minHeight: {
      type: [String, Number],
      default: () => getConfig().tree.minHeight
    },
    loading: Boolean,
    loadingConfig: Object,
    accordion: {
      type: Boolean,
      default: () => getConfig().tree.accordion
    },
    childrenField: {
      type: String,
      default: () => getConfig().tree.childrenField
    },
    valueField: {
      type: String,
      default: () => getConfig().tree.valueField
    },
    keyField: {
      type: String,
      default: () => getConfig().tree.keyField
    },
    parentField: {
      type: String,
      default: () => getConfig().tree.parentField
    },
    titleField: {
      type: String,
      default: () => getConfig().tree.titleField
    },
    hasChildField: {
      type: String,
      default: () => getConfig().tree.hasChildField
    },
    // mapChildrenField: {
    //   type: String as PropType<VxeTreePropTypes.MapChildrenField>,
    //   default: () => getConfig().tree.mapChildrenField
    // },
    transform: Boolean,
    // 已废弃
    isCurrent: Boolean,
    // 已废弃
    isHover: Boolean,
    expandAll: Boolean,
    showLine: {
      type: Boolean,
      default: () => getConfig().tree.showLine
    },
    trigger: String,
    indent: {
      type: Number,
      default: () => getConfig().tree.indent
    },
    showRadio: {
      type: Boolean,
      default: () => getConfig().tree.showRadio
    },
    checkNodeKey: {
      type: [String, Number],
      default: () => getConfig().tree.checkNodeKey
    },
    radioConfig: Object,
    showCheckbox: {
      type: Boolean,
      default: () => getConfig().tree.showCheckbox
    },
    checkNodeKeys: {
      type: Array,
      default: () => getConfig().tree.checkNodeKeys
    },
    checkboxConfig: Object,
    nodeConfig: Object,
    lazy: Boolean,
    toggleMethod: Function,
    loadMethod: Function,
    showIcon: {
      type: Boolean,
      default: true
    },
    iconOpen: {
      type: String,
      default: () => getConfig().tree.iconOpen
    },
    iconClose: {
      type: String,
      default: () => getConfig().tree.iconClose
    },
    iconLoaded: {
      type: String,
      default: () => getConfig().tree.iconLoaded
    },
    size: {
      type: String,
      default: () => getConfig().tree.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "update:checkNodeKey",
    "update:checkNodeKeys",
    "node-click",
    "node-dblclick",
    "current-change",
    "radio-change",
    "checkbox-change",
    "load-success",
    "load-error"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils60.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({
      currentNode: null,
      nodeMaps: {},
      selectRadioKey: props.checkNodeKey,
      treeList: [],
      treeExpandedMaps: {},
      treeExpandLazyLoadedMaps: {},
      selectCheckboxMaps: {},
      indeterminateCheckboxMaps: {}
    });
    const internalData = {
      // initialized: false
    };
    const refMaps = {
      refElem
    };
    const computeTitleField = computed(() => {
      return props.titleField || "title";
    });
    const computeKeyField = computed(() => {
      return props.keyField || "id";
    });
    const computeValueField = computed(() => {
      const keyField = computeKeyField.value;
      return props.valueField || keyField;
    });
    const computeParentField = computed(() => {
      return props.parentField || "parentId";
    });
    const computeChildrenField = computed(() => {
      return props.childrenField || "children";
    });
    const computeHasChildField = computed(() => {
      return props.hasChildField || "hasChild";
    });
    const computeIsRowCurrent = computed(() => {
      const nodeOpts = computeNodeOpts.value;
      const { isCurrent } = nodeOpts;
      if (import_xe_utils60.default.isBoolean(isCurrent)) {
        return isCurrent;
      }
      return props.isCurrent;
    });
    const computeIsRowHover = computed(() => {
      const nodeOpts = computeNodeOpts.value;
      const { isHover } = nodeOpts;
      if (import_xe_utils60.default.isBoolean(isHover)) {
        return isHover;
      }
      return props.isHover;
    });
    const computeRadioOpts = computed(() => {
      return Object.assign({ showIcon: true }, getConfig().tree.radioConfig, props.radioConfig);
    });
    const computeCheckboxOpts = computed(() => {
      return Object.assign({ showIcon: true }, getConfig().tree.checkboxConfig, props.checkboxConfig);
    });
    const computeNodeOpts = computed(() => {
      return Object.assign({}, getConfig().tree.nodeConfig, props.nodeConfig);
    });
    const computeLoadingOpts = computed(() => {
      return Object.assign({}, getConfig().tree.loadingConfig, props.loadingConfig);
    });
    const computeTreeStyle = computed(() => {
      const { height, minHeight } = props;
      const stys = {};
      if (height) {
        stys.height = toCssUnit(height);
      }
      if (minHeight) {
        stys.minHeight = toCssUnit(minHeight);
      }
      return stys;
    });
    const computeMaps = {
      computeRadioOpts,
      computeCheckboxOpts,
      computeNodeOpts
    };
    const $xeTree = {
      xID,
      props,
      context,
      internalData,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getNodeId = (node) => {
      const valueField = computeValueField.value;
      const nodeid = import_xe_utils60.default.get(node, valueField);
      return import_xe_utils60.default.eqNull(nodeid) ? "" : encodeURIComponent(nodeid);
    };
    const isExpandByNode = (node) => {
      const { treeExpandedMaps } = reactData;
      const nodeid = getNodeId(node);
      return !!treeExpandedMaps[nodeid];
    };
    const isCheckedByRadioNodeId = (nodeid) => {
      const { selectRadioKey } = reactData;
      return selectRadioKey === nodeid;
    };
    const isCheckedByRadioNode = (node) => {
      return isCheckedByRadioNodeId(getNodeId(node));
    };
    const isCheckedByCheckboxNodeId = (nodeid) => {
      const { selectCheckboxMaps } = reactData;
      return !!selectCheckboxMaps[nodeid];
    };
    const isCheckedByCheckboxNode = (node) => {
      return isCheckedByCheckboxNodeId(getNodeId(node));
    };
    const isIndeterminateByCheckboxNodeid = (nodeid) => {
      const { indeterminateCheckboxMaps } = reactData;
      return !!indeterminateCheckboxMaps[nodeid];
    };
    const isIndeterminateByCheckboxNode = (node) => {
      return isIndeterminateByCheckboxNodeid(getNodeId(node));
    };
    const emitCheckboxMode = (value) => {
      emit("update:checkNodeKeys", value);
    };
    const emitRadioMode = (value) => {
      emit("update:checkNodeKey", value);
    };
    const setRadioNode = (node) => {
      if (node) {
        reactData.selectRadioKey = getNodeId(node);
      }
      return nextTick();
    };
    const setCheckboxNode = (nodeList, checked) => {
      if (nodeList) {
        if (!import_xe_utils60.default.isArray(nodeList)) {
          nodeList = [nodeList];
        }
        handleCheckedCheckboxNode(nodeList.map((item) => getNodeId(item)), checked);
      }
      return nextTick();
    };
    const setCheckboxByNodeId = (nodeIds, checked) => {
      if (nodeIds) {
        if (!import_xe_utils60.default.isArray(nodeIds)) {
          nodeIds = [nodeIds];
        }
        handleCheckedCheckboxNode(nodeIds, checked);
      }
      return nextTick();
    };
    const handleCheckedCheckboxNode = (nodeIds, checked) => {
      const selectKeyMaps = Object.assign({}, reactData.selectCheckboxMaps);
      nodeIds.forEach((key) => {
        if (checked) {
          selectKeyMaps[key] = true;
        } else if (selectKeyMaps[key]) {
          delete selectKeyMaps[key];
        }
      });
      reactData.selectCheckboxMaps = selectKeyMaps;
    };
    const updateCheckboxChecked = (nodeIds) => {
      const selectKeyMaps = {};
      if (nodeIds) {
        nodeIds.forEach((key) => {
          selectKeyMaps[key] = true;
        });
      }
      reactData.selectCheckboxMaps = selectKeyMaps;
    };
    const handleSetExpand = (nodeid, expanded, expandedMaps) => {
      if (expanded) {
        if (!expandedMaps[nodeid]) {
          expandedMaps[nodeid] = true;
        }
      } else {
        if (expandedMaps[nodeid]) {
          delete expandedMaps[nodeid];
        }
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tree: $xeTree }, params));
    };
    const createNode = (records) => {
      const valueField = computeValueField.value;
      return Promise.resolve(records.map((obj) => {
        const item = Object.assign({}, obj);
        let nodeid = getNodeId(item);
        if (!nodeid) {
          nodeid = getNodeUniqueId();
          import_xe_utils60.default.set(item, valueField, nodeid);
        }
        return item;
      }));
    };
    const treeMethods = {
      dispatchEvent,
      clearCurrentNode() {
        reactData.currentNode = null;
        return nextTick();
      },
      getCurrentNodeId() {
        const { currentNode } = reactData;
        if (currentNode) {
          return getNodeId(currentNode);
        }
        return null;
      },
      getCurrentNode() {
        const { currentNode, nodeMaps } = reactData;
        if (currentNode) {
          const nodeItem = nodeMaps[getNodeId(currentNode)];
          if (nodeItem) {
            return nodeItem.item;
          }
        }
        return null;
      },
      setCurrentNodeId(nodeKey) {
        const { nodeMaps } = reactData;
        const nodeItem = nodeMaps[nodeKey];
        reactData.currentNode = nodeItem ? nodeItem.item : null;
        return nextTick();
      },
      setCurrentNode(node) {
        reactData.currentNode = node;
        return nextTick();
      },
      clearRadioNode() {
        reactData.selectRadioKey = null;
        return nextTick();
      },
      getRadioNodeId() {
        return reactData.selectRadioKey || null;
      },
      getRadioNode() {
        const { selectRadioKey, nodeMaps } = reactData;
        if (selectRadioKey) {
          const nodeItem = nodeMaps[selectRadioKey];
          if (nodeItem) {
            return nodeItem.item;
          }
        }
        return null;
      },
      setRadioNodeId(nodeKey) {
        reactData.selectRadioKey = nodeKey;
        return nextTick();
      },
      setRadioNode,
      setCheckboxNode,
      setCheckboxByNodeId,
      getCheckboxNodeIds() {
        const { selectCheckboxMaps } = reactData;
        return Object.keys(selectCheckboxMaps);
      },
      getCheckboxNodes() {
        const { nodeMaps, selectCheckboxMaps } = reactData;
        const list = [];
        import_xe_utils60.default.each(selectCheckboxMaps, (item, nodeid) => {
          const nodeItem = nodeMaps[nodeid];
          if (nodeItem) {
            list.push(nodeItem.item);
          }
        });
        return list;
      },
      clearCheckboxNode() {
        reactData.selectCheckboxMaps = {};
        return nextTick();
      },
      setAllCheckboxNode(checked) {
        const selectMaps = {};
        const childrenField = computeChildrenField.value;
        if (checked) {
          import_xe_utils60.default.eachTree(reactData.treeList, (node) => {
            const nodeid = getNodeId(node);
            selectMaps[nodeid] = true;
          }, { children: childrenField });
        }
        reactData.selectCheckboxMaps = selectMaps;
        return nextTick();
      },
      clearExpandNode() {
        return treeMethods.clearAllExpandNode();
      },
      clearAllExpandNode() {
        import_xe_utils60.default.each(reactData.nodeMaps, (nodeItem) => {
          nodeItem.treeLoaded = false;
        });
        reactData.treeExpandedMaps = {};
        return nextTick();
      },
      setExpandByNodeId(nodeids, expanded) {
        const expandedMaps = Object.assign({}, reactData.treeExpandedMaps);
        if (nodeids) {
          if (!import_xe_utils60.default.isArray(nodeids)) {
            nodeids = [nodeids];
          }
          nodeids.forEach((nodeid) => {
            handleSetExpand(nodeid, expanded, expandedMaps);
          });
          reactData.treeExpandedMaps = expandedMaps;
        }
        return nextTick();
      },
      getExpandNodeIds() {
        const { treeExpandedMaps } = reactData;
        return Object.keys(treeExpandedMaps);
      },
      getExpandNodes() {
        const { nodeMaps, treeExpandedMaps } = reactData;
        const list = [];
        import_xe_utils60.default.each(treeExpandedMaps, (item, nodeid) => {
          const nodeItem = nodeMaps[nodeid];
          if (nodeItem) {
            list.push(nodeItem.item);
          }
        });
        return list;
      },
      setExpandNode(nodes, expanded) {
        const expandedMaps = Object.assign({}, reactData.treeExpandedMaps);
        if (nodes) {
          if (!import_xe_utils60.default.isArray(nodes)) {
            nodes = [nodes];
          }
          nodes.forEach((node) => {
            const nodeid = getNodeId(node);
            handleSetExpand(nodeid, expanded, expandedMaps);
          });
          reactData.treeExpandedMaps = expandedMaps;
        }
        return nextTick();
      },
      toggleExpandByNodeId(nodeids) {
        const expandedMaps = Object.assign({}, reactData.treeExpandedMaps);
        if (nodeids) {
          if (!import_xe_utils60.default.isArray(nodeids)) {
            nodeids = [nodeids];
          }
          nodeids.forEach((nodeid) => {
            handleSetExpand(nodeid, !expandedMaps[nodeid], expandedMaps);
          });
          reactData.treeExpandedMaps = expandedMaps;
        }
        return nextTick();
      },
      toggleExpandNode(nodes) {
        const expandedMaps = Object.assign({}, reactData.treeExpandedMaps);
        if (nodes) {
          if (!import_xe_utils60.default.isArray(nodes)) {
            nodes = [nodes];
          }
          nodes.forEach((node) => {
            const nodeid = getNodeId(node);
            handleSetExpand(nodeid, !expandedMaps[nodeid], expandedMaps);
          });
          reactData.treeExpandedMaps = expandedMaps;
        }
        return nextTick();
      },
      setAllExpandNode(expanded) {
        const expandedMaps = {};
        const childrenField = computeChildrenField.value;
        if (expanded) {
          import_xe_utils60.default.eachTree(reactData.treeList, (node) => {
            const childList = import_xe_utils60.default.get(node, childrenField);
            const hasChild = childList && childList.length;
            if (hasChild) {
              const nodeid = getNodeId(node);
              expandedMaps[nodeid] = true;
            }
          }, { children: childrenField });
        }
        reactData.treeExpandedMaps = expandedMaps;
        return nextTick();
      },
      reloadExpandNode(node) {
        const { lazy } = props;
        if (lazy) {
          treeMethods.clearExpandLoaded(node);
          return handleAsyncTreeExpandChilds(node);
        }
        return nextTick();
      },
      clearExpandLoaded(node) {
        const { lazy } = props;
        const { nodeMaps } = reactData;
        if (lazy) {
          const nodeItem = nodeMaps[getNodeId(node)];
          if (nodeItem) {
            nodeItem.treeLoaded = false;
          }
        }
        return nextTick();
      },
      /**
       * 用于树结构，给行数据加载子节点
       */
      loadChildrenNode(node, childRecords) {
        const { lazy, transform } = props;
        const { nodeMaps } = reactData;
        if (!lazy) {
          return Promise.resolve([]);
        }
        const childrenField = computeChildrenField.value;
        const parentNodeItem = nodeMaps[getNodeId(node)];
        const parentLevel = parentNodeItem ? parentNodeItem.level : 0;
        const parentNodes = parentNodeItem ? parentNodeItem.nodes : [];
        return createNode(childRecords).then((nodeList) => {
          import_xe_utils60.default.eachTree(nodeList, (childRow, index, items, path, parent, nodes) => {
            const itemNodeId = getNodeId(childRow);
            nodeMaps[itemNodeId] = {
              item: node,
              itemIndex: -1,
              items,
              parent: parent || parentNodeItem.item,
              nodes: parentNodes.concat(nodes),
              level: parentLevel + nodes.length,
              lineCount: 0,
              treeLoaded: false
            };
          }, { children: childrenField });
          node[childrenField] = nodeList;
          if (transform) {
            node[childrenField] = nodeList;
          }
          updateNodeLine(node);
          return nodeList;
        });
      },
      isExpandByNode,
      isCheckedByRadioNodeId,
      isCheckedByRadioNode,
      isCheckedByCheckboxNodeId,
      isIndeterminateByCheckboxNode,
      isCheckedByCheckboxNode,
      getCheckboxIndeterminateNodes() {
        const { treeList, indeterminateCheckboxMaps } = reactData;
        const indeterminateNodes = [];
        import_xe_utils60.default.eachTree(treeList, (node) => {
          if (indeterminateCheckboxMaps[getNodeId(node)]) {
            indeterminateNodes.push(node);
          }
        });
        return indeterminateNodes;
      }
    };
    const cacheNodeMap = () => {
      const { treeList } = reactData;
      const valueField = computeValueField.value;
      const childrenField = computeChildrenField.value;
      const keyMaps = {};
      import_xe_utils60.default.eachTree(treeList, (item, itemIndex, items, path, parent, nodes) => {
        let nodeid = getNodeId(item);
        if (!nodeid) {
          nodeid = getNodeUniqueId();
          import_xe_utils60.default.set(item, valueField, nodeid);
        }
        keyMaps[nodeid] = {
          item,
          itemIndex,
          items,
          parent,
          nodes,
          level: nodes.length,
          lineCount: 0,
          treeLoaded: false
        };
      }, { children: childrenField });
      reactData.nodeMaps = keyMaps;
    };
    const updateData = (list) => {
      const { expandAll, transform } = props;
      const { initialized } = internalData;
      const keyField = computeKeyField.value;
      const parentField = computeParentField.value;
      const childrenField = computeChildrenField.value;
      if (transform) {
        reactData.treeList = import_xe_utils60.default.toArrayTree(list, { key: keyField, parentKey: parentField, mapChildren: childrenField });
      } else {
        reactData.treeList = list ? list.slice(0) : [];
      }
      cacheNodeMap();
      if (expandAll && !initialized) {
        if (list && list.length) {
          internalData.initialized = true;
          $xeTree.setAllExpandNode(true);
        }
      }
    };
    const handleCountLine = (item, isRoot, nodeItem) => {
      const { treeExpandedMaps } = reactData;
      const childrenField = computeChildrenField.value;
      const nodeid = getNodeId(item);
      nodeItem.lineCount++;
      if (treeExpandedMaps[nodeid]) {
        import_xe_utils60.default.arrayEach(item[childrenField], (childItem, childIndex, childList) => {
          if (!isRoot || childIndex < childList.length - 1) {
            handleCountLine(childItem, false, nodeItem);
          }
        });
      }
    };
    const updateNodeLine = (node) => {
      const { nodeMaps } = reactData;
      if (node) {
        const nodeid = getNodeId(node);
        const nodeItem = nodeMaps[nodeid];
        if (nodeItem) {
          import_xe_utils60.default.lastArrayEach(nodeItem.nodes, (childItem) => {
            const nodeid2 = getNodeId(childItem);
            const nodeItem2 = nodeMaps[nodeid2];
            if (nodeItem2) {
              nodeItem2.lineCount = 0;
              handleCountLine(childItem, true, nodeItem2);
            }
          });
        }
      }
    };
    const handleNodeClickEvent = (evnt, node) => {
      const { showRadio, showCheckbox, trigger } = props;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const isRowCurrent = computeIsRowCurrent.value;
      let triggerCurrent = false;
      let triggerRadio = false;
      let triggerCheckbox = false;
      let triggerExpand = false;
      if (isRowCurrent) {
        triggerCurrent = true;
        changeCurrentEvent(evnt, node);
      } else if (reactData.currentNode) {
        reactData.currentNode = null;
      }
      if (trigger === "node") {
        triggerExpand = true;
        toggleExpandEvent(evnt, node);
      }
      if (showRadio && radioOpts.trigger === "node") {
        triggerRadio = true;
        changeRadioEvent(evnt, node);
      }
      if (showCheckbox && checkboxOpts.trigger === "node") {
        triggerCheckbox = true;
        changeCheckboxEvent(evnt, node);
      }
      dispatchEvent("node-click", { node, triggerCurrent, triggerRadio, triggerCheckbox, triggerExpand }, evnt);
    };
    const handleNodeDblclickEvent = (evnt, node) => {
      dispatchEvent("node-dblclick", { node }, evnt);
    };
    const handleAsyncTreeExpandChilds = (node) => {
      const checkboxOpts = computeCheckboxOpts.value;
      const { loadMethod } = props;
      const { checkStrictly } = checkboxOpts;
      return new Promise((resolve) => {
        if (loadMethod) {
          const tempExpandLazyLoadedMaps = Object.assign({}, reactData.treeExpandLazyLoadedMaps);
          const { nodeMaps } = reactData;
          const nodeid = getNodeId(node);
          const nodeItem = nodeMaps[nodeid];
          tempExpandLazyLoadedMaps[nodeid] = true;
          reactData.treeExpandLazyLoadedMaps = tempExpandLazyLoadedMaps;
          Promise.resolve(loadMethod({ $tree: $xeTree, node })).then((childRecords) => {
            const { treeExpandLazyLoadedMaps } = reactData;
            nodeItem.treeLoaded = true;
            if (treeExpandLazyLoadedMaps[nodeid]) {
              treeExpandLazyLoadedMaps[nodeid] = false;
            }
            if (!import_xe_utils60.default.isArray(childRecords)) {
              childRecords = [];
            }
            if (childRecords) {
              return treeMethods.loadChildrenNode(node, childRecords).then((childRows) => {
                const tempExpandedMaps = Object.assign({}, reactData.treeExpandedMaps);
                if (childRows.length && !tempExpandedMaps[nodeid]) {
                  tempExpandedMaps[nodeid] = true;
                }
                reactData.treeExpandedMaps = tempExpandedMaps;
                if (!checkStrictly && treeMethods.isCheckedByCheckboxNodeId(nodeid)) {
                  handleCheckedCheckboxNode(childRows.map((item) => getNodeId(item)), true);
                }
                updateNodeLine(node);
                dispatchEvent("load-success", { node, data: childRecords }, new Event("load-success"));
                return nextTick();
              });
            } else {
              updateNodeLine(node);
              dispatchEvent("load-success", { node, data: childRecords }, new Event("load-success"));
            }
          }).catch((e) => {
            const { treeExpandLazyLoadedMaps } = reactData;
            nodeItem.treeLoaded = false;
            if (treeExpandLazyLoadedMaps[nodeid]) {
              treeExpandLazyLoadedMaps[nodeid] = false;
            }
            updateNodeLine(node);
            dispatchEvent("load-error", { node, data: e }, new Event("load-error"));
          }).finally(() => {
            return nextTick();
          });
        } else {
          resolve();
        }
      });
    };
    const handleBaseTreeExpand = (nodeList, expanded) => {
      const { lazy, accordion, toggleMethod } = props;
      const { nodeMaps, treeExpandLazyLoadedMaps } = reactData;
      const tempExpandedMaps = Object.assign({}, reactData.treeExpandedMaps);
      const childrenField = computeChildrenField.value;
      const hasChildField = computeHasChildField.value;
      const result = [];
      let validNodes = toggleMethod ? nodeList.filter((node) => toggleMethod({ $tree: $xeTree, expanded, node })) : nodeList;
      if (accordion) {
        validNodes = validNodes.length ? [validNodes[validNodes.length - 1]] : [];
        const nodeid = getNodeId(validNodes[0]);
        const nodeItem = nodeMaps[nodeid];
        if (nodeItem) {
          nodeItem.items.forEach((item) => {
            const itemNodeId = getNodeId(item);
            if (tempExpandedMaps[itemNodeId]) {
              delete tempExpandedMaps[itemNodeId];
            }
          });
        }
      }
      const expandNodes = [];
      if (expanded) {
        validNodes.forEach((item) => {
          const itemNodeId = getNodeId(item);
          if (!tempExpandedMaps[itemNodeId]) {
            const nodeItem = nodeMaps[itemNodeId];
            const isLoad = lazy && item[hasChildField] && !nodeItem.treeLoaded && !treeExpandLazyLoadedMaps[itemNodeId];
            if (isLoad) {
              result.push(handleAsyncTreeExpandChilds(item));
            } else {
              if (item[childrenField] && item[childrenField].length) {
                tempExpandedMaps[itemNodeId] = true;
                expandNodes.push(item);
              }
            }
          }
        });
      } else {
        validNodes.forEach((item) => {
          const itemNodeId = getNodeId(item);
          if (tempExpandedMaps[itemNodeId]) {
            delete tempExpandedMaps[itemNodeId];
            expandNodes.push(item);
          }
        });
      }
      reactData.treeExpandedMaps = tempExpandedMaps;
      expandNodes.forEach(updateNodeLine);
      return Promise.all(result);
    };
    const toggleExpandEvent = (evnt, node) => {
      const { lazy } = props;
      const { treeExpandedMaps, treeExpandLazyLoadedMaps } = reactData;
      const nodeid = getNodeId(node);
      const expanded = !treeExpandedMaps[nodeid];
      evnt.stopPropagation();
      if (!lazy || !treeExpandLazyLoadedMaps[nodeid]) {
        handleBaseTreeExpand([node], expanded);
      }
    };
    const handleNodeCheckboxStatus = (node, selectKeyMaps, indeterminateMaps) => {
      const childrenField = computeChildrenField.value;
      const childList = import_xe_utils60.default.get(node, childrenField);
      const nodeid = getNodeId(node);
      if (childList && childList.length) {
        let checkSome = false;
        let checkSize = 0;
        childList.forEach((childNode) => {
          const childNodeid = getNodeId(childNode);
          const isChecked = selectKeyMaps[childNodeid];
          if (isChecked || indeterminateMaps[childNodeid]) {
            if (isChecked) {
              checkSize++;
            }
            checkSome = true;
          }
        });
        const checkAll = checkSize === childList.length;
        if (checkAll) {
          if (!selectKeyMaps[nodeid]) {
            selectKeyMaps[nodeid] = true;
          }
          if (indeterminateMaps[nodeid]) {
            delete indeterminateMaps[nodeid];
          }
        } else {
          if (selectKeyMaps[nodeid]) {
            delete selectKeyMaps[nodeid];
          }
          indeterminateMaps[nodeid] = checkSome;
        }
      } else {
        if (indeterminateMaps[nodeid]) {
          delete indeterminateMaps[nodeid];
        }
      }
    };
    const updateCheckboxStatus = () => {
      const { treeList } = reactData;
      const childrenField = computeChildrenField.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const { checkStrictly } = checkboxOpts;
      if (!checkStrictly) {
        const selectKeyMaps = Object.assign({}, reactData.selectCheckboxMaps);
        const indeterminateMaps = {};
        import_xe_utils60.default.eachTree(treeList, (node, index, items, path, parent, nodes) => {
          const childList = import_xe_utils60.default.get(node, childrenField);
          if (!childList || !childList.length) {
            handleNodeCheckboxStatus(node, selectKeyMaps, indeterminateMaps);
          }
          if (index === items.length - 1) {
            for (let len = nodes.length - 2; len >= 0; len--) {
              const parentItem = nodes[len];
              handleNodeCheckboxStatus(parentItem, selectKeyMaps, indeterminateMaps);
            }
          }
        });
        reactData.selectCheckboxMaps = selectKeyMaps;
        reactData.indeterminateCheckboxMaps = indeterminateMaps;
      }
    };
    const changeCheckboxEvent = (evnt, node) => {
      evnt.preventDefault();
      evnt.stopPropagation();
      const checkboxOpts = computeCheckboxOpts.value;
      const { checkStrictly, checkMethod } = checkboxOpts;
      let isDisabled = !!checkMethod;
      if (checkMethod) {
        isDisabled = !checkMethod({ node });
      }
      if (isDisabled) {
        return;
      }
      const selectKeyMaps = Object.assign({}, reactData.selectCheckboxMaps);
      const childrenField = computeChildrenField.value;
      const nodeid = getNodeId(node);
      let isChecked = false;
      if (selectKeyMaps[nodeid]) {
        delete selectKeyMaps[nodeid];
      } else {
        isChecked = true;
        selectKeyMaps[nodeid] = isChecked;
      }
      if (!checkStrictly) {
        import_xe_utils60.default.eachTree(import_xe_utils60.default.get(node, childrenField), (childNode) => {
          const childNodeid = getNodeId(childNode);
          if (isChecked) {
            if (!selectKeyMaps[childNodeid]) {
              selectKeyMaps[childNodeid] = true;
            }
          } else {
            if (selectKeyMaps[childNodeid]) {
              delete selectKeyMaps[childNodeid];
            }
          }
        }, { children: childrenField });
      }
      reactData.selectCheckboxMaps = selectKeyMaps;
      updateCheckboxStatus();
      const value = Object.keys(reactData.selectCheckboxMaps);
      emitCheckboxMode(value);
      dispatchEvent("checkbox-change", { node, value, checked: isChecked }, evnt);
    };
    const changeCurrentEvent = (evnt, node) => {
      evnt.preventDefault();
      const nodeOpts = computeNodeOpts.value;
      const { currentMethod, trigger } = nodeOpts;
      const childrenField = computeChildrenField.value;
      const childList = import_xe_utils60.default.get(node, childrenField);
      const hasChild = childList && childList.length;
      let isDisabled = !!currentMethod;
      if (trigger === "child") {
        if (hasChild) {
          return;
        }
      } else if (trigger === "parent") {
        if (!hasChild) {
          return;
        }
      }
      if (currentMethod) {
        isDisabled = !currentMethod({ node });
      }
      if (isDisabled) {
        return;
      }
      const isChecked = true;
      reactData.currentNode = node;
      dispatchEvent("current-change", { node, checked: isChecked }, evnt);
    };
    const changeRadioEvent = (evnt, node) => {
      evnt.preventDefault();
      evnt.stopPropagation();
      const radioOpts = computeRadioOpts.value;
      const { checkMethod } = radioOpts;
      let isDisabled = !!checkMethod;
      if (checkMethod) {
        isDisabled = !checkMethod({ node });
      }
      if (isDisabled) {
        return;
      }
      const isChecked = true;
      const value = getNodeId(node);
      reactData.selectRadioKey = value;
      emitRadioMode(value);
      dispatchEvent("radio-change", { node, value, checked: isChecked }, evnt);
    };
    const treePrivateMethods = {};
    Object.assign($xeTree, treeMethods, treePrivateMethods);
    const renderRadio = (node, nodeid, isChecked) => {
      const { showRadio } = props;
      const radioOpts = computeRadioOpts.value;
      const { showIcon, checkMethod, visibleMethod } = radioOpts;
      const isVisible = !visibleMethod || visibleMethod({ node });
      let isDisabled = !!checkMethod;
      if (showRadio && showIcon && isVisible) {
        if (checkMethod) {
          isDisabled = !checkMethod({ node });
        }
        return h("div", {
          class: ["vxe-tree--radio-option", {
            "is--checked": isChecked,
            "is--disabled": isDisabled
          }],
          onClick: (evnt) => {
            if (!isDisabled) {
              changeRadioEvent(evnt, node);
            }
          }
        }, [
          h("span", {
            class: ["vxe-radio--icon", isChecked ? getIcon().RADIO_CHECKED : getIcon().RADIO_UNCHECKED]
          })
        ]);
      }
      return createCommentVNode();
    };
    const renderCheckbox = (node, nodeid, isChecked) => {
      const { showCheckbox } = props;
      const checkboxOpts = computeCheckboxOpts.value;
      const { showIcon, checkMethod, visibleMethod } = checkboxOpts;
      const isIndeterminate = isIndeterminateByCheckboxNodeid(nodeid);
      const isVisible = !visibleMethod || visibleMethod({ node });
      let isDisabled = !!checkMethod;
      if (showCheckbox && showIcon && isVisible) {
        if (checkMethod) {
          isDisabled = !checkMethod({ node });
        }
        return h("div", {
          class: ["vxe-tree--checkbox-option", {
            "is--checked": isChecked,
            "is--indeterminate": isIndeterminate,
            "is--disabled": isDisabled
          }],
          onClick: (evnt) => {
            if (!isDisabled) {
              changeCheckboxEvent(evnt, node);
            }
          }
        }, [
          h("span", {
            class: ["vxe-checkbox--icon", isIndeterminate ? getIcon().CHECKBOX_INDETERMINATE : isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
          })
        ]);
      }
      return createCommentVNode();
    };
    const renderNode = (node) => {
      const { lazy, showRadio, showCheckbox, showLine, indent, iconOpen, iconClose, iconLoaded, showIcon } = props;
      const { nodeMaps, treeExpandedMaps, currentNode, selectRadioKey, treeExpandLazyLoadedMaps } = reactData;
      const childrenField = computeChildrenField.value;
      const titleField = computeTitleField.value;
      const hasChildField = computeHasChildField.value;
      const childList = import_xe_utils60.default.get(node, childrenField);
      const hasChild = childList && childList.length;
      const iconSlot = slots.icon;
      const titleSlot = slots.title;
      const extraSlot = slots.extra;
      const nodeid = getNodeId(node);
      const isExpand = treeExpandedMaps[nodeid];
      const nodeItem = nodeMaps[nodeid];
      const nodeValue = import_xe_utils60.default.get(node, titleField);
      const childVns = [];
      if (hasChild && treeExpandedMaps[nodeid]) {
        if (showLine) {
          childVns.push(h("div", {
            key: "line",
            class: "vxe-tree--node-child-line",
            style: {
              height: `calc(${nodeItem.lineCount} * var(--vxe-ui-tree-node-height) - var(--vxe-ui-tree-node-height) / 2)`,
              left: `${(nodeItem.level + 1) * (indent || 1)}px`
            }
          }));
        }
        childList.forEach((childItem) => {
          childVns.push(renderNode(childItem));
        });
      }
      let isRadioChecked = false;
      if (showRadio) {
        isRadioChecked = nodeid == selectRadioKey;
      }
      let isCheckboxChecked = false;
      if (showCheckbox) {
        isCheckboxChecked = isCheckedByCheckboxNodeId(nodeid);
      }
      let hasLazyChilds = false;
      let isLazyLoading = false;
      let isLazyLoaded = false;
      if (lazy) {
        isLazyLoading = !!treeExpandLazyLoadedMaps[nodeid];
        hasLazyChilds = node[hasChildField];
        isLazyLoaded = !!nodeItem.treeLoaded;
      }
      return h("div", {
        class: ["vxe-tree--node-wrapper", `node--level-${nodeItem.level}`],
        nodeid
      }, [
        h("div", {
          class: ["vxe-tree--node-item", {
            "is--current": currentNode && nodeid === getNodeId(currentNode),
            "is-radio--checked": isRadioChecked,
            "is-checkbox--checked": isCheckboxChecked
          }],
          style: {
            paddingLeft: `${(nodeItem.level - 1) * (indent || 1)}px`
          },
          onClick(evnt) {
            handleNodeClickEvent(evnt, node);
          },
          onDblclick(evnt) {
            handleNodeDblclickEvent(evnt, node);
          }
        }, [
          showIcon || showLine ? h("div", {
            class: "vxe-tree--node-item-switcher"
          }, showIcon && (lazy ? isLazyLoaded ? hasChild : hasLazyChilds : hasChild) ? [
            h("div", {
              class: "vxe-tree--node-item-icon",
              onClick(evnt) {
                toggleExpandEvent(evnt, node);
              }
            }, iconSlot ? iconSlot({ node, isExpand }) : [
              h("i", {
                class: isLazyLoading ? iconLoaded || getIcon().TREE_NODE_LOADED : isExpand ? iconOpen || getIcon().TREE_NODE_OPEN : iconClose || getIcon().TREE_NODE_CLOSE
              })
            ])
          ] : []) : createCommentVNode(),
          renderRadio(node, nodeid, isRadioChecked),
          renderCheckbox(node, nodeid, isCheckboxChecked),
          h("div", {
            class: "vxe-tree--node-item-inner"
          }, [
            h("div", {
              class: "vxe-tree--node-item-title"
            }, titleSlot ? getSlotVNs(titleSlot({ node, isExpand })) : `${nodeValue}`),
            extraSlot ? h("div", {
              class: "vxe-tree--node-item-extra"
            }, getSlotVNs(extraSlot({ node, isExpand }))) : createCommentVNode()
          ])
        ]),
        hasChild && treeExpandedMaps[nodeid] ? h("div", {
          class: "vxe-tree--node-child-wrapper"
        }, childVns) : createCommentVNode()
      ]);
    };
    const renderNodeList = () => {
      const { treeList } = reactData;
      return h("div", {
        class: "vxe-tree--node-list-wrapper"
      }, treeList.map((node) => renderNode(node)));
    };
    const renderVN = () => {
      const { loading: loading2, trigger, showLine } = props;
      const vSize = computeSize.value;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const treeStyle = computeTreeStyle.value;
      const loadingOpts = computeLoadingOpts.value;
      const isRowHover = computeIsRowHover.value;
      const loadingSlot = slots.loading;
      return h("div", {
        ref: refElem,
        class: ["vxe-tree", {
          [`size--${vSize}`]: vSize,
          "show--line": showLine,
          "checkbox--highlight": checkboxOpts.highlight,
          "radio--highlight": radioOpts.highlight,
          "node--hover": isRowHover,
          "node--trigger": trigger === "node",
          "is--loading": loading2
        }],
        style: treeStyle
      }, [
        renderNodeList(),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-tree--loading",
          modelValue: loading2,
          icon: loadingOpts.icon,
          text: loadingOpts.text
        }, loadingSlot ? {
          default: () => loadingSlot({ $tree: $xeTree })
        } : {})
      ]);
    };
    const dataFlag = ref(0);
    watch(() => props.data ? props.data.length : 0, () => {
      dataFlag.value++;
    });
    watch(() => props.data, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      updateData(props.data || []);
    });
    watch(() => props.checkNodeKey, (val) => {
      reactData.selectRadioKey = val;
    });
    const checkboxFlag = ref(0);
    watch(() => props.checkNodeKeys ? props.checkNodeKeys.length : 0, () => {
      checkboxFlag.value++;
    });
    watch(() => props.checkNodeKeys, () => {
      checkboxFlag.value++;
    });
    watch(checkboxFlag, () => {
      updateCheckboxChecked(props.checkNodeKeys || []);
    });
    onUnmounted(() => {
      reactData.treeList = [];
      reactData.treeExpandedMaps = {};
      reactData.nodeMaps = {};
    });
    updateData(props.data || []);
    updateCheckboxChecked(props.checkNodeKeys || []);
    $xeTree.renderVN = renderVN;
    return $xeTree;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/tree-select/src/tree-select.js
function getOptUniqueId() {
  return import_xe_utils61.default.uniqueId("node_");
}
var tree_select_default = defineComponent({
  name: "VxeTreeSelect",
  props: {
    modelValue: [String, Number, Array],
    clearable: Boolean,
    placeholder: {
      type: String,
      default: () => import_xe_utils61.default.eqNull(getConfig().treeSelect.placeholder) ? getI18n("vxe.base.pleaseSelect") : getConfig().treeSelect.placeholder
    },
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    className: [String, Function],
    popupClassName: [String, Function],
    prefixIcon: String,
    placement: String,
    options: Array,
    optionProps: Object,
    size: {
      type: String,
      default: () => getConfig().select.size || getConfig().size
    },
    remote: Boolean,
    remoteMethod: Function,
    popupConfig: Object,
    treeConfig: Object,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "blur",
    "focus",
    "click",
    "node-click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils61.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refInput = ref();
    const refTreeWrapper = ref();
    const refOptionPanel = ref();
    const reactData = reactive({
      initialized: false,
      fullOptionList: [],
      fullNodeMaps: {},
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      hpTimeout: void 0
    };
    const refMaps = {
      refElem
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().select.transfer;
        if (import_xe_utils61.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computePopupOpts = computed(() => {
      return Object.assign({}, getConfig().treeSelect.popupConfig, props.popupConfig);
    });
    const computeTreeOpts = computed(() => {
      return Object.assign({}, getConfig().treeSelect.treeConfig, props.treeConfig, { data: void 0 });
    });
    const computeTreeNodeOpts = computed(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({ isHover: true }, treeOpts.nodeConfig);
    });
    const computeTreeCheckboxOpts = computed(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({
        showIcon: !!treeOpts.showCheckbox
      }, treeOpts.checkboxConfig, {
        trigger: "node"
      });
    });
    const computeTreeRadioOpts = computed(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({
        showIcon: !!treeOpts.showRadio
      }, treeOpts.radioConfig, {
        trigger: "node"
      });
    });
    const computePropsOpts = computed(() => {
      return props.optionProps || {};
    });
    const computeNodeKeyField = computed(() => {
      const treeOpts = computeTreeOpts.value;
      return treeOpts.keyField || "id";
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeChildrenField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.children || "children";
    });
    const computeParentField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.parent || "parentField";
    });
    const computeHasChildField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.hasChild || "hasChild";
    });
    const computeSelectLabel = computed(() => {
      const { modelValue } = props;
      const { fullNodeMaps } = reactData;
      const labelField = computeLabelField.value;
      return (import_xe_utils61.default.isArray(modelValue) ? modelValue : [modelValue]).map((val) => {
        const cacheItem = fullNodeMaps[val];
        return cacheItem ? cacheItem.item[labelField] : val;
      }).join(", ");
    });
    const computePopupWrapperStyle = computed(() => {
      const popupOpts = computePopupOpts.value;
      const { height, width } = popupOpts;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
        stys.maxHeight = toCssUnit(height);
      }
      return stys;
    });
    const computeMaps = {};
    const $xeTreeSelect = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $treeSelect: $xeTreeSelect }, params));
    };
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const treeSelectMethods = {
      dispatchEvent
    };
    const getNodeid = (option) => {
      const nodeKeyField = computeNodeKeyField.value;
      const nodeid = option[nodeKeyField];
      return nodeid ? encodeURIComponent(nodeid) : "";
    };
    const cacheDataMap = () => {
      const { options } = props;
      const nodeKeyField = computeNodeKeyField.value;
      const childrenField = computeChildrenField.value;
      const valueField = computeValueField.value;
      const nodeMaps = {};
      const keyMaps = {};
      import_xe_utils61.default.eachTree(options, (item, index, items, path, parent, nodes) => {
        let nodeid = getNodeid(item);
        if (!nodeid) {
          nodeid = getOptUniqueId();
        }
        if (keyMaps[nodeid]) {
          errLog("vxe.error.repeatKey", [nodeKeyField, nodeid]);
        }
        keyMaps[nodeid] = true;
        const value = item[valueField];
        if (nodeMaps[value]) {
          errLog("vxe.error.repeatKey", [valueField, value]);
        }
        nodeMaps[value] = { item, index, items, parent, nodes };
      }, { children: childrenField });
      reactData.fullOptionList = options || [];
      reactData.fullNodeMaps = nodeMaps;
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (panelElem && el) {
          const targetHeight = el.offsetHeight;
          const targetWidth = el.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(el);
          let panelPlacement = "bottom";
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showOptionPanel = () => {
      const { loading: loading2 } = props;
      const isDisabled = computeIsDisabled.value;
      if (!loading2 && !isDisabled) {
        clearTimeout(internalData.hpTimeout);
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      internalData.hpTimeout = setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      const { fullNodeMaps } = reactData;
      emitModel(selectValue);
      if (selectValue !== props.modelValue) {
        const cacheItem = fullNodeMaps[selectValue];
        dispatchEvent("change", { value: selectValue, option: cacheItem ? cacheItem.item : null }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue);
      dispatchEvent("clear", { value: selectValue }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      hideOptionPanel();
    };
    const focusEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          showOptionPanel();
          setTimeout(() => {
            reactData.triggerFocusPanel = false;
          }, 150);
        }
      }
      dispatchEvent("focus", {}, evnt);
    };
    const clickEvent = (evnt) => {
      togglePanelEvent(evnt);
      dispatchEvent("click", {}, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      dispatchEvent("blur", {}, evnt);
    };
    const togglePanelEvent = (params) => {
      const { $event } = params;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
      }
    };
    const nodeClickEvent = (params) => {
      const { $event } = params;
      dispatchEvent("node-click", params, $event);
    };
    const radioChangeEvent = (params) => {
      const { value, $event } = params;
      changeEvent($event, value);
      hideOptionPanel();
    };
    const checkboxChangeEvent = (params) => {
      const { value, $event } = params;
      changeEvent($event, value);
    };
    const loadSuccessEvent = () => {
      cacheDataMap();
    };
    const treeSelectPrivateMethods = {};
    Object.assign($xeTreeSelect, treeSelectMethods, treeSelectPrivateMethods);
    const renderVN = () => {
      const { className, modelValue, multiple, options, loading: loading2 } = props;
      const { initialized, isActivated, isAniVisible, visiblePanel } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const selectLabel = computeSelectLabel.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const popupWrapperStyle = computePopupWrapperStyle.value;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      const popupOpts = computePopupOpts.value;
      const popupClassName = popupOpts.className || props.popupClassName;
      const treeOpts = computeTreeOpts.value;
      const treeNodeOpts = computeTreeNodeOpts.value;
      const treeCheckboxOpts = computeTreeCheckboxOpts.value;
      const treeRadioOpts = computeTreeRadioOpts.value;
      const nodeKeyField = computeNodeKeyField.value;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const childrenField = computeChildrenField.value;
      const parentField = computeParentField.value;
      const hasChildField = computeHasChildField.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-tree-select--readonly", className]
        }, [
          h("span", {
            class: "vxe-tree-select-label"
          }, selectLabel)
        ]);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-tree-select", className ? import_xe_utils61.default.isFunction(className) ? className({ $treeSelect: $xeTreeSelect }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--loading": loading2,
          "is--active": isActivated
        }]
      }, [
        h(input_default, {
          ref: refInput,
          clearable: props.clearable,
          placeholder: loading2 ? getI18n("vxe.select.loadingText") : props.placeholder,
          readonly: true,
          disabled: isDisabled,
          type: "text",
          prefixIcon: props.prefixIcon,
          suffixIcon: loading2 ? getIcon().TREE_SELECT_LOADED : visiblePanel ? getIcon().TREE_SELECT_OPEN : getIcon().TREE_SELECT_CLOSE,
          modelValue: loading2 ? "" : selectLabel,
          onClear: clearEvent,
          onClick: clickEvent,
          onFocus: focusEvent,
          onBlur: blurEvent,
          onSuffixClick: togglePanelEvent
        }, prefixSlot ? {
          prefix: () => prefixSlot({})
        } : {}),
        h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-tree-select--panel", popupClassName ? import_xe_utils61.default.isFunction(popupClassName) ? popupClassName({ $treeSelect: $xeTreeSelect }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": !loading2 && isAniVisible,
              "ani--enter": !loading2 && visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, initialized ? [
            h("div", {
              class: "vxe-tree-select--panel-wrapper"
            }, [
              headerSlot ? h("div", {
                class: "vxe-tree-select--panel-header"
              }, headerSlot({})) : renderEmptyElement($xeTreeSelect),
              h("div", {
                class: "vxe-tree-select--panel-body"
              }, [
                h("div", {
                  ref: refTreeWrapper,
                  class: "vxe-tree-select-tree--wrapper",
                  style: popupWrapperStyle
                }, [
                  h(tree_default, {
                    class: "vxe-tree-select--tree",
                    data: options,
                    indent: treeOpts.indent,
                    showRadio: !multiple,
                    radioConfig: treeRadioOpts,
                    checkNodeKey: multiple ? null : modelValue,
                    showCheckbox: !!multiple,
                    checkNodeKeys: multiple ? modelValue : null,
                    checkboxConfig: treeCheckboxOpts,
                    titleField: labelField,
                    valueField,
                    keyField: nodeKeyField,
                    childrenField: treeOpts.childrenField || childrenField,
                    parentField: treeOpts.parentField || parentField,
                    hasChildField: treeOpts.hasChildField || hasChildField,
                    accordion: treeOpts.accordion,
                    expandAll: treeOpts.expandAll,
                    nodeConfig: treeNodeOpts,
                    lazy: treeOpts.lazy,
                    loadMethod: treeOpts.loadMethod,
                    toggleMethod: treeOpts.toggleMethod,
                    transform: treeOpts.transform,
                    trigger: treeOpts.trigger,
                    showIcon: treeOpts.showIcon,
                    showLine: treeOpts.showLine,
                    iconOpen: treeOpts.iconOpen,
                    iconLoaded: treeOpts.iconLoaded,
                    iconClose: treeOpts.iconClose,
                    onNodeClick: nodeClickEvent,
                    onRadioChange: radioChangeEvent,
                    onCheckboxChange: checkboxChangeEvent,
                    onLoadSuccess: loadSuccessEvent
                  })
                ])
              ]),
              footerSlot ? h("div", {
                class: "vxe-tree-select--panel-footer"
              }, footerSlot({})) : renderEmptyElement($xeTreeSelect)
            ])
          ] : [])
        ])
      ]);
    };
    watch(() => props.options, () => {
      cacheDataMap();
    });
    cacheDataMap();
    onMounted(() => {
      globalEvents.on($xeTreeSelect, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeTreeSelect, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeTreeSelect, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeTreeSelect, "mousewheel");
      globalEvents.off($xeTreeSelect, "mousedown");
      globalEvents.off($xeTreeSelect, "blur");
    });
    provide("$xeTreeSelect", $xeTreeSelect);
    $xeTreeSelect.renderVN = renderVN;
    return $xeTreeSelect;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-tree-select/vxe-tree-select-view.js
var WidgetVxeTreeSelectViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(tree_select_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder || getI18n("vxe.base.pleaseSelect"),
            options: options.options,
            optionProps: { label: "value", value: "value" },
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-radio-group/vxe-radio-group-data.js
var import_xe_utils62 = __toESM(require_xe_utils());
var getWidgetVxeRadioGroupConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-radio-checked",
    options: {
      options: import_xe_utils62.default.range(0, 3).map((v, i) => {
        return {
          value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [i + 1])
        };
      })
    }
  };
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-radio-group/vxe-radio-group-form.js
var WidgetVxeRadioGroupFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { renderDataSourceFormItem } = useWidgetPropDataSource(props, {
      isSubOption: false
    });
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            }),
            renderDataSourceFormItem()
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-radio-group/vxe-radio-group-view.js
var WidgetVxeRadioGroupViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(group_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            options: options.options,
            optionProps: { label: "value", value: "value" },
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-checkbox-group/vxe-checkbox-group-data.js
var import_xe_utils63 = __toESM(require_xe_utils());
var getWidgetVxeCheckboxGroupConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-checkbox-checked",
    options: {
      options: import_xe_utils63.default.range(0, 3).map((v, i) => {
        return {
          value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [i + 1])
        };
      })
    }
  };
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-checkbox-group/vxe-checkbox-group-form.js
var WidgetVxeCheckboxGroupFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { renderDataSourceFormItem } = useWidgetPropDataSource(props, {
      isSubOption: false
    });
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            }),
            renderDataSourceFormItem()
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-checkbox-group/vxe-checkbox-group-view.js
var WidgetVxeCheckboxGroupViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(group_default2, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            options: options.options,
            optionProps: { label: "value", value: "value" },
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-file/vxe-upload-file-data.js
function getLimitSizeOptions() {
  const sizeOpts = [
    { label: "无限制", value: "" }
  ];
  const sizeList = [1, 2, 5, 10, 20, 50, 100, 200, 500];
  sizeList.forEach((num) => {
    sizeOpts.push({ label: `${num}M`, value: num });
  });
  return sizeOpts;
}
var getWidgetVxeUploadFileConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-file",
    options: {
      limitCount: "",
      limitSize: 100,
      multiple: false
    }
  };
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-file/vxe-upload-file-form.js
var WidgetVxeUploadFileFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    const limitSizeOptions = ref(getLimitSizeOptions());
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.multiFile"),
              field: "multiple",
              itemRender: { name: "VxeSwitch" }
            }),
            options.multiple ? h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.limitFileCount"),
              field: "limitCount",
              itemRender: { name: "VxeInput", props: { type: "integer", min: 1, clearable: true } }
            }) : createCommentVNode(),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.limitFileSize"),
              field: "limitSize",
              itemRender: { name: "VxeSelect", options: limitSizeOptions.value }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-file/vxe-upload-file-view.js
var WidgetVxeUploadFileViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(upload_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            mode: "all",
            multiple: options.multiple,
            limitCount: options.limitCount,
            limitSize: options.limitSize,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-image/vxe-upload-image-data.js
var getWidgetVxeUploadImageConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-file-image",
    options: {
      limitCount: 9,
      limitSize: 10,
      multiple: false
    }
  };
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-image/vxe-upload-image-form.js
var WidgetVxeUploadImageFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    const limitSizeOptions = ref(getLimitSizeOptions());
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.multiImg"),
              field: "multiple",
              itemRender: { name: "VxeSwitch" }
            }),
            options.multiple ? h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.limitImgCount"),
              field: "limitCount",
              itemRender: { name: "VxeInput", props: { type: "integer", min: 1, clearable: true } }
            }) : createCommentVNode(),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.limitImgSize"),
              field: "limitSize",
              itemRender: { name: "VxeSelect", options: limitSizeOptions.value }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-image/vxe-upload-image-view.js
var WidgetVxeUploadImageViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(upload_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            mode: "image",
            multiple: options.multiple,
            limitCount: options.limitCount,
            limitSize: options.limitSize,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-rate/vxe-rate-data.js
var getWidgetVxeRateConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-star",
    query: true,
    options: {}
  };
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-rate/vxe-rate-form.js
var WidgetVxeRateFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/rate/src/rate.js
var import_xe_utils64 = __toESM(require_xe_utils());
var rate_default = defineComponent({
  name: "VxeRate",
  props: {
    modelValue: [Number, String],
    disabled: {
      type: Boolean,
      default: null
    },
    readonly: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().rate.size || getConfig().size
    },
    status: String
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils64.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({
      activeValue: null
    });
    const refMaps = {
      refElem
    };
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return readonly;
    });
    const computeNumVal = computed(() => {
      const { modelValue } = props;
      const { activeValue } = reactData;
      return import_xe_utils64.default.toNumber(activeValue === null ? modelValue : activeValue);
    });
    const computeItemList = computed(() => {
      return [1, 2, 3, 4, 5].map((num) => {
        return {
          value: num,
          label: num
        };
      });
    });
    const computeMaps = {};
    const $xeRate = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $rate: $xeRate }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const mouseenterEvent = (evnt, item) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!(isDisabled || isReadonly)) {
        const value = item.value;
        reactData.activeValue = value;
      }
    };
    const mouseleaveEvent = () => {
      reactData.activeValue = null;
    };
    const clickEvent = (evnt, item) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!(isDisabled || isReadonly)) {
        const value = item.value;
        emitModel(value);
        dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    Object.assign($xeRate, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const { status } = props;
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      const itemList = computeItemList.value;
      const vSize = computeSize.value;
      const numVal = computeNumVal.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-rate", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--disabled": isDisabled,
          "is--readonly": isReadonly
        }]
      }, itemList.map((item) => {
        const isChecked = numVal >= item.value;
        return h("div", {
          class: ["vxe-rte--item", {
            "is--checked": isChecked
          }],
          onMouseenter(evnt) {
            if (!(isDisabled || isReadonly)) {
              mouseenterEvent(evnt, item);
            }
          },
          onMouseleave: mouseleaveEvent,
          onClick(evnt) {
            if (!(isDisabled || isReadonly)) {
              clickEvent(evnt, item);
            }
          }
        }, [
          h("i", {
            class: isChecked ? getIcon().RATE_CHECKED : getIcon().RATE_UNCHECKED
          })
        ]);
      }));
    };
    $xeRate.renderVN = renderVN;
    return $xeRate;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-rate/vxe-rate-view.js
var WidgetVxeRateViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h(rate_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-slider/vxe-slider-data.js
var getWidgetVxeSliderConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-slider",
    query: true,
    options: {}
  };
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-slider/vxe-slider-form.js
var WidgetVxeSliderFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/slider/src/slider.js
var import_xe_utils65 = __toESM(require_xe_utils());
var slider_default = defineComponent({
  name: "VxeSlider",
  props: {
    modelValue: [String, Number, Array],
    vertical: Boolean,
    max: {
      type: [String, Number],
      default: () => getConfig().slider.max
    },
    min: {
      type: [String, Number],
      default: () => getConfig().slider.min
    },
    step: {
      type: [String, Number],
      default: () => getConfig().slider.step
    },
    size: {
      type: String,
      default: () => getConfig().slider.size || getConfig().size
    },
    range: {
      type: Boolean,
      default: () => getConfig().slider.range
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils65.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refBarElem = ref();
    const refTrackElem = ref();
    const refStartBtnElem = ref();
    const refEndBtnElem = ref();
    const reactData = reactive({
      startValue: 0,
      endValue: 0
    });
    const refMaps = {
      refElem
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeMaxNum = computed(() => {
      return import_xe_utils65.default.toNumber(props.max || 0);
    });
    const computeMinNum = computed(() => {
      return import_xe_utils65.default.toNumber(props.min || 0);
    });
    const computeMaps = {};
    const $xeSlider = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $slider: $xeSlider }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const getStartPercent = (startValue) => {
      const { range } = props;
      const maxNum = computeMaxNum.value;
      const minNum = computeMinNum.value;
      return range ? import_xe_utils65.default.floor((startValue - minNum) / import_xe_utils65.default.toNumber(maxNum - minNum) * 100) : 0;
    };
    const getEndPercent = (startValue, endValue) => {
      const { range } = props;
      const maxNum = computeMaxNum.value;
      const minNum = computeMinNum.value;
      return import_xe_utils65.default.floor((endValue - (range ? startValue : 0) - minNum) / import_xe_utils65.default.toNumber(maxNum - minNum) * 100);
    };
    const updateModel = () => {
      const { modelValue } = props;
      if (import_xe_utils65.default.isArray(modelValue)) {
        const [sVal, eVal] = import_xe_utils65.default.clone(modelValue, true).sort();
        reactData.startValue = import_xe_utils65.default.floor(import_xe_utils65.default.toNumber(sVal || 0));
        reactData.endValue = import_xe_utils65.default.floor(import_xe_utils65.default.toNumber(eVal || 0));
      } else {
        reactData.startValue = 0;
        reactData.endValue = import_xe_utils65.default.floor(import_xe_utils65.default.toNumber(modelValue || 0));
      }
    };
    const updateBarStyle = () => {
      const { startValue, endValue } = reactData;
      const trackElem = refTrackElem.value;
      const startBtnElem = refStartBtnElem.value;
      const endBtnElem = refEndBtnElem.value;
      let startPercent = 0;
      let endPercent = 0;
      if (startValue > endValue) {
        startPercent = getStartPercent(endValue);
        endPercent = getEndPercent(endValue, startValue);
      } else {
        startPercent = getStartPercent(startValue);
        endPercent = getEndPercent(startValue, endValue);
      }
      if (trackElem) {
        trackElem.style.left = `${startPercent}%`;
        trackElem.style.width = `${endPercent}%`;
      }
      if (startBtnElem) {
        startBtnElem.style.left = `${startPercent}%`;
      }
      if (endBtnElem) {
        endBtnElem.style.left = `${import_xe_utils65.default.floor(startPercent + endPercent)}%`;
      }
    };
    const changeEvent = (evnt) => {
      const { range } = props;
      const { startValue, endValue } = reactData;
      const value = range ? [startValue, endValue].sort() : endValue;
      emitModel(value);
      dispatchEvent("change", { value }, evnt);
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const handleMousedownEvent = (evnt, isEnd) => {
      const formReadonly = computeFormReadonly.value;
      const isDisabled = computeIsDisabled.value;
      const maxNum = computeMaxNum.value;
      const minNum = computeMinNum.value;
      if (!(formReadonly || isDisabled)) {
        evnt.preventDefault();
        document.onmousemove = (evnt2) => {
          evnt2.preventDefault();
          const el = refElem.value;
          const barElem = refBarElem.value;
          if (el && barElem) {
            const barRect = barElem.getBoundingClientRect();
            const trackWidth = (evnt2.clientX - barRect.left) / barRect.width;
            if (isEnd) {
              reactData.endValue = import_xe_utils65.default.floor(Math.max(minNum, Math.min(maxNum, trackWidth * (maxNum - minNum) + minNum)));
            } else {
              reactData.startValue = import_xe_utils65.default.floor(Math.max(minNum, Math.min(maxNum, trackWidth * (maxNum - minNum))));
            }
          }
          updateBarStyle();
        };
        document.onmouseup = (evnt2) => {
          document.onmousemove = null;
          document.onmouseup = null;
          changeEvent(evnt2);
          updateBarStyle();
        };
      }
    };
    const handleStartMousedownEvent = (evnt) => {
      const endBtnElem = refEndBtnElem.value;
      const startBtnElem = evnt.currentTarget;
      handleMousedownEvent(evnt, endBtnElem ? endBtnElem.offsetLeft < startBtnElem.offsetLeft : false);
    };
    const handleEndMousedownEvent = (evnt) => {
      const startBtnElem = refStartBtnElem.value;
      const endBtnElem = evnt.currentTarget;
      handleMousedownEvent(evnt, startBtnElem ? endBtnElem.offsetLeft > startBtnElem.offsetLeft : true);
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeSlider, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const { vertical, range } = props;
      const vSize = computeSize.value;
      const formReadonly = computeFormReadonly.value;
      const isDisabled = computeIsDisabled.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-slider", {
          [`size--${vSize}`]: vSize,
          "is--vertical": vertical,
          "is--readonly": formReadonly,
          "is--disabled": isDisabled
        }]
      }, [
        h("div", {
          class: "vxe-slider--inner"
        }, [
          h("div", {
            ref: refBarElem,
            class: "vxe-slider--bar-wrapper"
          }),
          h("div", {
            ref: refTrackElem,
            class: "vxe-slider--bar-track"
          }),
          formReadonly || !range ? renderEmptyElement($xeSlider) : h("div", {
            ref: refStartBtnElem,
            class: "vxe-slider--bar-btn vxe-slider--start-btn",
            onMousedown: handleStartMousedownEvent
          }),
          formReadonly ? renderEmptyElement($xeSlider) : h("div", {
            ref: refEndBtnElem,
            class: "vxe-slider--bar-btn vxe-slider--end-btn",
            onMousedown: handleEndMousedownEvent
          })
        ])
      ]);
    };
    watch(() => props.modelValue, () => {
      updateModel();
    });
    onMounted(() => {
      updateBarStyle();
    });
    updateModel();
    $xeSlider.renderVN = renderVN;
    return $xeSlider;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/widget-vxe-slider/vxe-slider-view.js
var WidgetVxeSliderViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h(slider_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/render/index.js
renderer.mixin({
  text: {
    createFormDesignWidgetConfig: getWidgetTextConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetTextViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetTextFormComponent, { renderOpts, renderParams });
    }
  },
  /**
   * 已废弃
   */
  title: {
    createFormDesignWidgetConfig: getWidgetTextConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetTextViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetTextFormComponent, { renderOpts, renderParams });
    }
  },
  row: {
    createFormDesignWidgetConfig: getWidgetRowConfig,
    renderFormDesignWidgetEdit(renderOpts, renderParams) {
      return h(WidgetRowEditComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetRowViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetRowFormComponent, { renderOpts, renderParams });
    }
  },
  subtable: {
    createFormDesignWidgetConfig: getWidgetSubtableConfig,
    renderFormDesignWidgetEdit(renderOpts, renderParams) {
      return h(WidgetSubtableEditComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetSubtableViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetSubtableFormComponent, { renderOpts, renderParams });
    }
  },
  input: {
    createFormDesignWidgetConfig: getWidgetInputConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetInputViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetInputFormComponent, { renderOpts, renderParams });
    }
  },
  textarea: {
    createFormDesignWidgetConfig: getWidgetTextareaConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetTextareaViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetTextareaFormComponent, { renderOpts, renderParams });
    }
  },
  select: {
    createFormDesignWidgetConfig: getWidgetSelectConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetSelectViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetSelectFormComponent, { renderOpts, renderParams });
    }
  },
  VxeInput: {
    createFormDesignWidgetConfig: getWidgetVxeInputConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeInputViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeInputFormComponent, { renderOpts, renderParams });
    }
  },
  VxeNumberInput: {
    createFormDesignWidgetConfig: getWidgetVxeNumberInputConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeNumberInputViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeNumberInputFormComponent, { renderOpts, renderParams });
    }
  },
  VxeDatePicker: {
    createFormDesignWidgetConfig: getWidgetVxeDatePickerConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeDatePickerViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeDatePickerFormComponent, { renderOpts, renderParams });
    }
  },
  VxeTextarea: {
    createFormDesignWidgetConfig: getWidgetVxeTextareaConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeTextareaViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeTextareaFormComponent, { renderOpts, renderParams });
    }
  },
  VxeSwitch: {
    createFormDesignWidgetConfig: getWidgetVxeSwitchConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeSwitchViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeSwitchFormComponent, { renderOpts, renderParams });
    }
  },
  VxeSelect: {
    createFormDesignWidgetConfig: getWidgetVxeSelectConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeSelectViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeSelectFormComponent, { renderOpts, renderParams });
    }
  },
  VxeTreeSelect: {
    createFormDesignWidgetConfig: getWidgetVxeTreeSelectConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeTreeSelectViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeTreeSelectFormComponent, { renderOpts, renderParams });
    }
  },
  VxeRadioGroup: {
    createFormDesignWidgetConfig: getWidgetVxeRadioGroupConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeRadioGroupViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeRadioGroupFormComponent, { renderOpts, renderParams });
    }
  },
  VxeCheckboxGroup: {
    createFormDesignWidgetConfig: getWidgetVxeCheckboxGroupConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeCheckboxGroupViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeCheckboxGroupFormComponent, { renderOpts, renderParams });
    }
  },
  VxeUploadFile: {
    createFormDesignWidgetConfig: getWidgetVxeUploadFileConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeUploadFileViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeUploadFileFormComponent, { renderOpts, renderParams });
    }
  },
  VxeUploadImage: {
    createFormDesignWidgetConfig: getWidgetVxeUploadImageConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeUploadImageViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeUploadImageFormComponent, { renderOpts, renderParams });
    }
  },
  VxeRate: {
    createFormDesignWidgetConfig: getWidgetVxeRateConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeRateViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeRateFormComponent, { renderOpts, renderParams });
    }
  },
  VxeSlider: {
    createFormDesignWidgetConfig: getWidgetVxeSliderConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeSliderViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeSliderFormComponent, { renderOpts, renderParams });
    }
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-design/index.js
var VxeFormDesign = Object.assign({}, form_design_default, {
  install(app) {
    app.component(form_design_default.name, form_design_default);
  }
});
var formDesignHandle = {
  useWidgetName,
  useWidgetView,
  useSubtableView,
  useWidgetPropDataSource
};
dynamicApp.use(VxeFormDesign);
VxeUI.component(form_design_default);
VxeUI.formDesignHandle = formDesignHandle;
VxeUI.formDesign = formDesignHandle;
var FormDesign = VxeFormDesign;
var form_design_default2 = VxeFormDesign;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-gather/index.js
var VxeFormGatherComponent = Object.assign({}, form_group_default, { name: "VxeFormGather" });
var VxeFormGather = Object.assign(VxeFormGatherComponent, {
  install(app) {
    app.component(VxeFormGatherComponent.name, VxeFormGatherComponent);
  }
});
dynamicApp.use(VxeFormGather);
VxeUI.component(VxeFormGatherComponent);
var FormGather = VxeFormGather;
var form_gather_default = VxeFormGather;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-group/index.js
var VxeFormGroup = Object.assign(form_group_default, {
  install(app) {
    app.component(form_group_default.name, form_group_default);
  }
});
dynamicApp.use(VxeFormGroup);
VxeUI.component(form_group_default);
var FormGroup = VxeFormGroup;
var form_group_default2 = VxeFormGroup;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-item/index.js
var VxeFormItem = Object.assign(form_item_default, {
  install(app) {
    app.component(form_item_default.name, form_item_default);
  }
});
dynamicApp.use(VxeFormItem);
VxeUI.component(form_item_default);
var FormItem = VxeFormItem;
var form_item_default2 = VxeFormItem;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/form-view/index.js
var VxeFormView = Object.assign(form_view_default, {
  install: function(app) {
    app.component(form_view_default.name, form_view_default);
  }
});
dynamicApp.use(VxeFormView);
VxeUI.component(form_view_default);
var FormView = VxeFormView;
var form_view_default2 = VxeFormView;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/icon-picker/src/icon-picker.js
var import_xe_utils66 = __toESM(require_xe_utils());
var icon_picker_default = defineComponent({
  name: "VxeIconPicker",
  props: {
    modelValue: String,
    placeholder: String,
    clearable: Boolean,
    size: {
      type: String,
      default: () => getConfig().iconPicker.size || getConfig().size
    },
    className: [String, Function],
    popupClassName: [String, Function],
    showIconTitle: {
      type: Boolean,
      default: () => getConfig().iconPicker.showIconTitle
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    icons: Array,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils66.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      selectIcon: `${props.modelValue || ""}`,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      // hpTimeout: undefined
    };
    const refElem = ref();
    const refInput = ref();
    const refOptionPanel = ref();
    const refMaps = {
      refElem
    };
    const $xeIconPicker = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let iconPickerMethods = {};
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().iconPicker.transfer;
        if (import_xe_utils66.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().select.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseSelect");
    });
    const computeIconList = computed(() => {
      let { icons } = props;
      if (!icons || !icons.length) {
        icons = getConfig().iconPicker.icons || [];
      }
      return icons.map((item) => {
        if (import_xe_utils66.default.isString(item)) {
          return {
            title: item,
            icon: `vxe-icon-${`${item || ""}`.replace(/^vxe-icon-/, "")}`
          };
        }
        return {
          title: `${item.title || ""}`,
          icon: item.icon || ""
        };
      });
    });
    const computeIconGroupList = computed(() => {
      const iconList = computeIconList.value;
      return import_xe_utils66.default.chunk(iconList, 4);
    });
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (panelElem && el) {
          const targetHeight = el.offsetHeight;
          const targetWidth = el.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(el);
          let panelPlacement = "bottom";
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showOptionPanel = () => {
      const { hpTimeout } = internalData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (hpTimeout) {
          clearTimeout(hpTimeout);
          internalData.hpTimeout = void 0;
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      internalData.hpTimeout = setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      reactData.selectIcon = selectValue;
      if (selectValue !== props.modelValue) {
        emit("update:modelValue", selectValue);
        dispatchEvent("change", { value: selectValue }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const focusEvent = () => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
      }
    };
    const blurEvent = () => {
      reactData.isActivated = false;
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue);
      dispatchEvent("clear", { value: selectValue }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const togglePanelEvent = (evnt) => {
      evnt.preventDefault();
      if (reactData.visiblePanel) {
        hideOptionPanel();
      } else {
        showOptionPanel();
      }
    };
    const clickEvent = (evnt) => {
      togglePanelEvent(evnt);
      dispatchEvent("click", {}, evnt);
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable } = props;
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isSpacebar = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hideOptionPanel();
          } else if (isEnter) {
            evnt.preventDefault();
            evnt.stopPropagation();
          } else if (isUpArrow || isDwArrow) {
            evnt.preventDefault();
          } else if (isSpacebar) {
            evnt.preventDefault();
          }
        } else if ((isUpArrow || isDwArrow || isEnter || isSpacebar) && reactData.isActivated) {
          evnt.preventDefault();
          showOptionPanel();
        }
        if (reactData.isActivated) {
          if (isDel && clearable) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      hideOptionPanel();
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $iconPicker: $xeIconPicker }, params));
    };
    iconPickerMethods = {
      dispatchEvent,
      isPanelVisible() {
        return reactData.visiblePanel;
      },
      togglePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
        return nextTick();
      },
      hidePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        }
        return nextTick();
      },
      showPanel() {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
        return nextTick();
      },
      focus() {
        const $input = refInput.value;
        reactData.isActivated = true;
        if ($input) {
          $input.blur();
        }
        return nextTick();
      },
      blur() {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
        reactData.isActivated = false;
        return nextTick();
      }
    };
    const handleClickIconEvent = (evnt, item) => {
      const value = item.icon;
      changeEvent(evnt, value);
      hideOptionPanel();
    };
    Object.assign($xeIconPicker, iconPickerMethods);
    const renderIconWrapper = () => {
      const { showIconTitle } = props;
      const iconGroupList = computeIconGroupList.value;
      const isDisabled = computeIsDisabled.value;
      return h("div", {
        class: "vxe-ico-picker--list-wrapper"
      }, iconGroupList.map((list) => {
        return h("div", {
          class: "vxe-ico-picker--list"
        }, list.map((item) => {
          return h("div", {
            class: "vxe-ico-picker--item",
            onClick(evnt) {
              if (!isDisabled) {
                handleClickIconEvent(evnt, item);
              }
            }
          }, [
            h("div", {
              class: "vxe-ico-picker--item-icon"
            }, [
              h("i", {
                class: item.icon || ""
              })
            ]),
            showIconTitle ? h("div", {
              class: "vxe-ico-picker--item-title"
            }, `${item.title || ""}`) : createCommentVNode()
          ]);
        }));
      }));
    };
    const renderVN = () => {
      const { className, popupClassName, clearable } = props;
      const { initialized, isActivated, isAniVisible, visiblePanel, selectIcon } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-ico-picker--readonly", className]
        }, [
          h("i", {
            class: selectIcon
          })
        ]);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-ico-picker", className ? import_xe_utils66.default.isFunction(className) ? className({ $iconPicker: $xeIconPicker }) : className : "", {
          [`size--${vSize}`]: vSize,
          "show--clear": clearable && !isDisabled && !!selectIcon,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--active": isActivated
        }]
      }, [
        h("div", {
          class: "vxe-ico-picker--inner",
          onClick: clickEvent
        }, [
          h("input", {
            ref: refInput,
            class: "vxe-ico-picker--input",
            onFocus: focusEvent,
            onBlur: blurEvent
          }),
          selectIcon ? h("div", {
            class: "vxe-ico-picker--icon"
          }, [
            h("i", {
              class: selectIcon
            })
          ]) : h("div", {
            class: "vxe-ico-picker--placeholder"
          }, inpPlaceholder),
          h("div", {
            class: "vxe-ico-picker--suffix"
          }, [
            h("div", {
              class: "vxe-ico-picker--clear-icon",
              onClick: clearEvent
            }, [
              h("i", {
                class: getIcon().INPUT_CLEAR
              })
            ]),
            h("div", {
              class: "vxe-ico-picker--suffix-icon"
            }, [
              h("i", {
                class: visiblePanel ? getIcon().ICON_PICKER_OPEN : getIcon().ICON_PICKER_CLOSE
              })
            ])
          ])
        ]),
        h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-ico-picker--panel", popupClassName ? import_xe_utils66.default.isFunction(popupClassName) ? popupClassName({ $iconPicker: $xeIconPicker }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": isAniVisible,
              "ani--enter": visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, [
            initialized && (visiblePanel || isAniVisible) ? h("div", {
              class: "vxe-ico-picker--panel-wrapper"
            }, [
              renderIconWrapper()
            ]) : createCommentVNode()
          ])
        ])
      ]);
    };
    watch(() => props.modelValue, (val) => {
      reactData.selectIcon = `${val || ""}`;
    });
    onMounted(() => {
      globalEvents.on($xeIconPicker, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeIconPicker, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeIconPicker, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeIconPicker, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeIconPicker, "mousewheel");
      globalEvents.off($xeIconPicker, "mousedown");
      globalEvents.off($xeIconPicker, "keydown");
      globalEvents.off($xeIconPicker, "blur");
    });
    provide("$xeIconPicker", $xeIconPicker);
    $xeIconPicker.renderVN = renderVN;
    return $xeIconPicker;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/icon-picker/index.js
var VxeIconPicker = Object.assign(icon_picker_default, {
  install: function(app) {
    app.component(icon_picker_default.name, icon_picker_default);
  }
});
dynamicApp.use(VxeIconPicker);
VxeUI.component(icon_picker_default);
var IconPicker = VxeIconPicker;
var icon_picker_default2 = VxeIconPicker;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/image/src/image.js
var import_xe_utils69 = __toESM(require_xe_utils());

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/image/src/preview.js
var import_xe_utils67 = __toESM(require_xe_utils());
var preview_default = defineComponent({
  name: "VxeImagePreview",
  props: {
    modelValue: Number,
    urlList: Array,
    urlField: {
      type: String,
      default: () => getConfig().imagePreview.urlField
    },
    maskClosable: {
      type: Boolean,
      default: () => getConfig().imagePreview.maskClosable
    },
    marginSize: {
      type: String,
      default: () => getConfig().imagePreview.marginSize
    },
    showPrintButton: {
      type: Boolean,
      default: () => getConfig().imagePreview.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().imagePreview.showDownloadButton
    },
    beforeDownloadMethod: Function,
    downloadMethod: Function
  },
  emits: [
    "update:modelValue",
    "change",
    "download",
    "download-fail",
    "close"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils67.default.uniqueId();
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const reactData = reactive({
      activeIndex: props.modelValue || 0,
      offsetPct11: false,
      offsetScale: 0,
      offsetRotate: 0,
      offsetLeft: 0,
      offsetTop: 0
    });
    const computeUrlProp = computed(() => {
      return props.urlField || "url";
    });
    const computeMarginSize = computed(() => {
      return import_xe_utils67.default.toNumber(props.marginSize || 0) || 16;
    });
    const computeRotateText = computed(() => {
      const { offsetRotate } = reactData;
      if (offsetRotate) {
        return `${offsetRotate}°`;
      }
      return "0°";
    });
    const computeScaleText = computed(() => {
      const { offsetScale } = reactData;
      if (offsetScale) {
        return `${import_xe_utils67.default.ceil((1 + offsetScale) * 100)}%`;
      }
      return "100%";
    });
    const computeImgList = computed(() => {
      const { urlList } = props;
      const urlProp = computeUrlProp.value;
      if (urlList && urlList.length) {
        return urlList.map((item) => {
          if (import_xe_utils67.default.isString(item)) {
            return item;
          }
          if (item[urlProp]) {
            return item[urlProp];
          }
          return "";
        });
      }
      return [];
    });
    const computeImgTransform = computed(() => {
      let { offsetScale, offsetRotate, offsetLeft, offsetTop } = reactData;
      const stys = [];
      let targetScale = 1;
      if (offsetScale) {
        targetScale = 1 + offsetScale;
        stys.push(`scale(${targetScale})`);
      }
      if (offsetRotate) {
        stys.push(`rotate(${offsetRotate}deg)`);
      }
      if (offsetLeft || offsetTop) {
        offsetLeft /= targetScale;
        offsetTop /= targetScale;
        let targetOffsetLeft = offsetLeft;
        let targetOffsetTop = offsetTop;
        if (offsetRotate) {
          switch (offsetRotate % 360) {
            case 90:
            case -270:
              targetOffsetLeft = offsetTop;
              targetOffsetTop = -offsetLeft;
              break;
            case 180:
            case -180:
              targetOffsetLeft = -offsetLeft;
              targetOffsetTop = -offsetTop;
              break;
            case 270:
            case -90:
              targetOffsetLeft = -offsetTop;
              targetOffsetTop = offsetLeft;
              break;
          }
        }
        stys.push(`translate(${targetOffsetLeft}px, ${targetOffsetTop}px)`);
      }
      return stys.length ? stys.join(" ") : "";
    });
    const computeMaps = {
      computeImgList
    };
    const $xeImagePreview = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $imagePreview: $xeImagePreview }, params));
    };
    const imagePreviewMethods = {
      dispatchEvent
    };
    const emitModel = (value) => {
      reactData.activeIndex = value;
      emit("update:modelValue", value);
    };
    const handleCloseEvent = (evnt) => {
      dispatchEvent("close", {}, evnt);
    };
    const imagePreviewPrivateMethods = {};
    const resetStyle = () => {
      const elem = refElem.value;
      removeClass(elem, "is--move");
      Object.assign(reactData, {
        offsetPct11: false,
        offsetScale: 0,
        offsetRotate: 0,
        offsetLeft: 0,
        offsetTop: 0
      });
    };
    const getOffsetZoomStep = () => {
      const { offsetScale } = reactData;
      let stepNum = 0.02;
      if (offsetScale >= -0.6) {
        stepNum = 0.04;
        if (offsetScale >= -0.4) {
          stepNum = 0.07;
          if (offsetScale >= 0) {
            stepNum = 0.1;
            if (offsetScale >= 3) {
              stepNum = 0.25;
              if (offsetScale >= 8) {
                stepNum = 0.4;
                if (offsetScale >= 16) {
                  stepNum = 0.6;
                  if (offsetScale >= 24) {
                    stepNum = 0.9;
                    if (offsetScale >= 32) {
                      stepNum = 1.3;
                      if (offsetScale >= 39) {
                        stepNum = 1.9;
                        if (offsetScale >= 45) {
                          stepNum = 2.5;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return stepNum;
    };
    const handleZoom = (isAdd) => {
      const { offsetScale } = reactData;
      const stepNum = getOffsetZoomStep();
      if (isAdd) {
        reactData.offsetScale = Number(Math.min(49, offsetScale + stepNum).toFixed(2));
      } else {
        reactData.offsetScale = Number(Math.max(-0.9, offsetScale - stepNum).toFixed(2));
      }
    };
    const handleChange = (isNext) => {
      let activeIndex = reactData.activeIndex || 0;
      const imgList = computeImgList.value;
      if (isNext) {
        if (activeIndex >= imgList.length - 1) {
          activeIndex = 0;
        } else {
          activeIndex++;
        }
      } else {
        if (activeIndex <= 0) {
          activeIndex = imgList.length - 1;
        } else {
          activeIndex--;
        }
      }
      resetStyle();
      reactData.activeIndex = activeIndex;
      emitModel(activeIndex);
    };
    const handleRotateImg = (isRight) => {
      let offsetRotate = reactData.offsetRotate;
      if (isRight) {
        offsetRotate += 90;
      } else {
        offsetRotate -= 90;
      }
      reactData.offsetRotate = offsetRotate;
    };
    const handlePct11 = () => {
      resetStyle();
      reactData.offsetPct11 = true;
    };
    const handlePrintImg = () => {
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      if (VxeUI.print) {
        VxeUI.print({
          align: "center",
          pageBreaks: [
            {
              bodyHtml: `<img src="${imgUrl}" style="max-width:100%;max-height:100%;">`
            }
          ]
        });
      }
    };
    const handleDownloadEvent = (evnt, imgUrl) => {
      dispatchEvent("download", { url: imgUrl }, evnt);
    };
    const handleDefaultDownload = (evnt, imgUrl) => {
      if (VxeUI.saveFile) {
        fetch(imgUrl).then((res) => {
          return res.blob().then((blob) => {
            VxeUI.saveFile({
              filename: imgUrl,
              content: blob
            });
            handleDownloadEvent(evnt, imgUrl);
          });
        }).catch(() => {
          if (VxeUI.modal) {
            VxeUI.modal.message({
              content: getI18n("vxe.error.downErr"),
              status: "error"
            });
          }
        });
      }
    };
    const handleDownloadImg = (evnt) => {
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      const beforeDownloadFn = props.beforeDownloadMethod || getConfig().imagePreview.beforeDownloadMethod;
      const downloadFn = props.downloadMethod || getConfig().imagePreview.downloadMethod;
      Promise.resolve(beforeDownloadFn ? beforeDownloadFn({
        $imagePreview: $xeImagePreview,
        url: imgUrl,
        index: activeIndex || 0
      }) : true).then((status) => {
        if (status) {
          if (downloadFn) {
            Promise.resolve(downloadFn({
              $imagePreview: $xeImagePreview,
              url: imgUrl,
              index: activeIndex || 0
            })).then(() => {
              handleDownloadEvent(evnt, imgUrl);
            }).catch((e) => e);
          } else {
            handleDefaultDownload(evnt, imgUrl);
          }
        }
      });
    };
    const handleOperationBtn = (evnt, code) => {
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      if (imgUrl) {
        switch (code) {
          case "zoomOut":
            handleZoom(false);
            break;
          case "zoomIn":
            handleZoom(true);
            break;
          case "pctFull":
            resetStyle();
            break;
          case "pct11":
            handlePct11();
            break;
          case "rotateLeft":
            handleRotateImg(false);
            break;
          case "rotateRight":
            handleRotateImg(true);
            break;
          case "print":
            handlePrintImg();
            break;
          case "download":
            handleDownloadImg(evnt);
            break;
        }
      }
    };
    const wheelEvent = (evnt) => {
      const delta = evnt.deltaY;
      if (delta > 0) {
        handleZoom(false);
      } else if (delta < 0) {
        handleZoom(true);
      }
    };
    const moveEvent = (evnt) => {
      const { offsetTop, offsetLeft } = reactData;
      const elem = refElem.value;
      evnt.preventDefault();
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const startX = evnt.pageX;
      const startY = evnt.pageY;
      const marginSize = computeMarginSize.value;
      document.onmousemove = (et) => {
        const { pageX, pageY } = et;
        const { visibleHeight, visibleWidth } = getDomNode();
        et.preventDefault();
        addClass(elem, "is--move");
        if (pageX > marginSize && pageY > marginSize && pageX < visibleWidth - marginSize && pageY < visibleHeight - marginSize) {
          reactData.offsetLeft = offsetLeft + pageX - startX;
          reactData.offsetTop = offsetTop + pageY - startY;
        }
      };
      document.onmouseup = () => {
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        removeClass(elem, "is--move");
      };
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const isControlKey = hasControlKey(evnt);
      const hasShiftKey = evnt.shiftKey;
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDownArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
      const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
      const isR = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.R);
      const isP = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.P);
      if (isUpArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetTop -= 1;
        } else {
          handleZoom(true);
        }
      } else if (isDownArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetTop += 1;
        } else {
          handleZoom(false);
        }
      } else if (isLeftArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetLeft -= 1;
        } else {
          handleChange(false);
        }
      } else if (isRightArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetLeft += 1;
        } else {
          handleChange(true);
        }
      } else if (isR && isControlKey) {
        evnt.preventDefault();
        if (hasShiftKey) {
          handleRotateImg(false);
        } else {
          handleRotateImg(true);
        }
      } else if (isP && isControlKey) {
        evnt.preventDefault();
        handlePrintImg();
      }
    };
    const handleClickMaskEvent = (evnt) => {
      if (props.maskClosable) {
        if (evnt.target === evnt.currentTarget) {
          dispatchEvent("close", {}, evnt);
        }
      }
    };
    Object.assign($xeImagePreview, imagePreviewMethods, imagePreviewPrivateMethods);
    const renderImgWrapper = () => {
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const imgTransform = computeImgTransform.value;
      return h("div", {
        class: "vxe-image-preview--img-list",
        onClick: handleClickMaskEvent
      }, imgList.map((url, index) => {
        const isActive = activeIndex === index;
        return h("img", {
          class: ["vxe-image-preview--img-item", {
            "is--active": isActive
          }],
          src: url,
          style: isActive ? {
            transform: imgTransform
          } : null,
          onMousedown(evnt) {
            moveEvent(evnt);
          }
        });
      }));
    };
    const renderOperationBtn = (code, icon) => {
      return h("div", {
        class: "vxe-image-preview--operation-btn",
        title: getI18n(`vxe.imagePreview.operBtn.${code}`),
        onClick(evnt) {
          handleOperationBtn(evnt, code);
        }
      }, [
        h("i", {
          class: getIcon()[icon]
        })
      ]);
    };
    const renderBtnWrapper = () => {
      const { showPrintButton, showDownloadButton } = props;
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const rotateText = computeRotateText.value;
      const scaleText = computeScaleText.value;
      return h("div", {
        class: "vxe-image-preview--btn-wrapper"
      }, [
        h("div", {
          class: "vxe-image-preview--close-wrapper"
        }, [
          h("div", {
            class: "vxe-image-preview--close-btn",
            onClick: handleCloseEvent
          }, [
            h("i", {
              class: getIcon().IMAGE_PREVIEW_CLOSE
            })
          ]),
          h("div", {
            class: "vxe-image-preview--close-bg"
          })
        ]),
        imgList.length > 1 ? h("div", {
          class: "vxe-image-preview--previous-btn",
          onClick() {
            handleChange(false);
          }
        }, [
          h("i", {
            class: getIcon().IMAGE_PREVIEW_PREVIOUS
          })
        ]) : createCommentVNode(),
        imgList.length > 1 ? h("div", {
          class: "vxe-image-preview--next-btn",
          onClick() {
            handleChange(true);
          }
        }, [
          h("i", {
            class: getIcon().IMAGE_PREVIEW_NEXT
          })
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-image-preview--operation-info"
        }, [
          h("div", {
            class: "vxe-image-preview--operation-deg"
          }, rotateText),
          h("div", {
            class: "vxe-image-preview--operation-pct"
          }, scaleText)
        ]),
        h("div", {
          class: "vxe-image-preview--operation-wrapper"
        }, [
          h("div", {
            class: "vxe-image-preview--operation-active-count"
          }, [
            h("span", {
              class: "vxe-image-preview--operation-active-current"
            }, `${(activeIndex || 0) + 1}`),
            h("span", {
              class: "vxe-image-preview--operation-active-total"
            }, `/${imgList.length}`)
          ]),
          renderOperationBtn("zoomOut", "IMAGE_PREVIEW_ZOOM_OUT"),
          renderOperationBtn("zoomIn", "IMAGE_PREVIEW_ZOOM_IN"),
          renderOperationBtn("pctFull", "IMAGE_PREVIEW_PCT_FULL"),
          renderOperationBtn("pct11", "IMAGE_PREVIEW_PCT_1_1"),
          renderOperationBtn("rotateLeft", "IMAGE_PREVIEW_ROTATE_LEFT"),
          renderOperationBtn("rotateRight", "IMAGE_PREVIEW_ROTATE_RIGHT"),
          showPrintButton ? renderOperationBtn("print", "IMAGE_PREVIEW_PRINT") : createCommentVNode(),
          showDownloadButton ? renderOperationBtn("download", "IMAGE_PREVIEW_DOWNLOAD") : createCommentVNode()
        ])
      ]);
    };
    const renderVN = () => {
      const { offsetPct11 } = reactData;
      return h("div", {
        ref: refElem,
        class: ["vxe-image-preview", {
          "is--pct11": offsetPct11
        }],
        onWheel: wheelEvent
      }, [
        renderImgWrapper(),
        renderBtnWrapper()
      ]);
    };
    watch(() => props.modelValue, (val) => {
      reactData.activeIndex = val;
      resetStyle();
    });
    onMounted(() => {
      globalEvents.on($xeImagePreview, "keydown", handleGlobalKeydownEvent);
    });
    onBeforeUnmount(() => {
      const elem = refElem.value;
      if (elem) {
        removeClass(elem, "is--move");
      }
    });
    onUnmounted(() => {
      globalEvents.off($xeImagePreview, "keydown");
    });
    provide("$xeImagePreview", $xeImagePreview);
    $xeImagePreview.renderVN = renderVN;
    return renderVN;
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/image/src/util.js
var import_xe_utils68 = __toESM(require_xe_utils());
var openPreviewImage = (options) => {
  if (VxeUI.modal) {
    const opts = Object.assign({
      escClosable: true
    }, options);
    const { urlList, activeIndex } = opts;
    const modalId = import_xe_utils68.default.uniqueId("image-preview");
    VxeUI.modal.open({
      id: modalId,
      title: "预览",
      width: "100%",
      height: "100%",
      showHeader: false,
      showFooter: false,
      padding: false,
      escClosable: opts.escClosable,
      className: "vxe-image-preview-popup-wrapper",
      slots: {
        default() {
          return h(preview_default, {
            modelValue: activeIndex,
            urlList,
            urlField: opts.urlField,
            marginSize: opts.marginSize,
            maskClosable: opts.maskClosable,
            showPrintButton: opts.showPrintButton,
            showDownloadButton: opts.showDownloadButton,
            beforeDownloadMethod: opts.beforeDownloadMethod,
            downloadMethod: opts.downloadMethod,
            onClose() {
              VxeUI.modal.close(modalId);
            }
          });
        }
      }
    });
  }
  return Promise.resolve();
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/image/src/image.js
var image_default = defineComponent({
  name: "VxeImage",
  props: {
    src: [String, Array],
    alt: [String, Number],
    loading: String,
    title: [String, Number],
    width: [String, Number],
    height: [String, Number],
    circle: Boolean,
    maskClosable: {
      type: Boolean,
      default: () => getConfig().image.maskClosable
    },
    showPreview: {
      type: Boolean,
      default: () => getConfig().image.showPreview
    },
    showPrintButton: {
      type: Boolean,
      default: () => getConfig().image.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().image.showDownloadButton
    },
    size: { type: String, default: () => getConfig().image.size || getConfig().size }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils69.default.uniqueId();
    const $xeImageGroup = inject("$xeImageGroup", null);
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeImgStyle = computed(() => {
      const { width, height } = props;
      const style = {};
      if (width && height) {
        style.maxWidth = toCssUnit(width);
        style.maxHeight = toCssUnit(height);
      } else {
        if (width) {
          style.width = toCssUnit(width);
        }
        if (height) {
          style.height = toCssUnit(height);
        }
      }
      return style;
    });
    const computeImgList = computed(() => {
      const { src } = props;
      if (src) {
        return (import_xe_utils69.default.isArray(src) ? src : [src]).map((item) => {
          if (import_xe_utils69.default.isString(item)) {
            return {
              url: item,
              alt: ""
            };
          }
          return {
            url: item.url,
            alt: item.alt
          };
        });
      }
      return [];
    });
    const computeImgItem = computed(() => {
      const imgList = computeImgList.value;
      return imgList[0];
    });
    const computeImgUrl = computed(() => {
      const imgItem = computeImgItem.value;
      return imgItem ? `${imgItem.url || ""}` : "";
    });
    const computeMaps = {
      computeSize
    };
    const $xeImage = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const imageMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $image: $xeImage }, params));
      }
    };
    const clickEvent = (evnt) => {
      const { showPreview, showPrintButton, showDownloadButton, maskClosable } = props;
      const imgList = computeImgList.value;
      const imgUrl = computeImgUrl.value;
      if ($xeImageGroup) {
        $xeImageGroup.handleClickImgEvent(evnt, { url: imgUrl });
      } else {
        if (showPreview && imgUrl) {
          openPreviewImage({
            urlList: imgList,
            showPrintButton,
            showDownloadButton,
            maskClosable
          });
        }
        imageMethods.dispatchEvent("click", { url: imgUrl }, evnt);
      }
    };
    const imagePrivateMethods = {};
    Object.assign($xeImage, imageMethods, imagePrivateMethods);
    const renderVN = () => {
      const { alt, loading: loading2, circle } = props;
      const imgStyle = computeImgStyle.value;
      const imgUrl = computeImgUrl.value;
      const vSize = computeSize.value;
      return h("img", {
        ref: refElem,
        class: ["vxe-image", {
          [`size--${vSize}`]: vSize,
          "is--circle": circle
        }],
        src: imgUrl,
        alt,
        loading: loading2,
        style: imgStyle,
        onClick: clickEvent
      });
    };
    $xeImage.renderVN = renderVN;
    return $xeImage;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/image/index.js
var VxeImage = Object.assign({}, image_default, {
  install(app) {
    app.component(image_default.name, image_default);
  }
});
dynamicApp.use(VxeImage);
VxeUI.component(image_default);
var Image = VxeImage;
var image_default2 = VxeImage;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/image/src/group.js
var import_xe_utils70 = __toESM(require_xe_utils());
var group_default3 = defineComponent({
  name: "VxeImageGroup",
  props: {
    urlList: [Array, String],
    showPreview: {
      type: Boolean,
      default: () => getConfig().imageGroup.showPreview
    },
    imageStyle: Object,
    size: { type: String, default: () => getConfig().imageGroup.size || getConfig().size },
    showPrintButton: {
      type: Boolean,
      default: () => getConfig().imageGroup.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().imageGroup.showDownloadButton
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils70.default.uniqueId();
    const { computeSize } = useSize(props);
    const computeImgList = computed(() => {
      const { urlList } = props;
      if (urlList) {
        return (import_xe_utils70.default.isArray(urlList) ? urlList : [urlList]).map((item) => {
          if (import_xe_utils70.default.isString(item)) {
            return {
              url: item,
              alt: ""
            };
          }
          return {
            url: item.url,
            alt: item.alt
          };
        });
      }
      return [];
    });
    const computeImgStyleOpts = computed(() => {
      return Object.assign({}, getConfig().imageGroup.imageStyle, props.imageStyle);
    });
    const computeMaps = {
      computeSize
    };
    const $xeImageGroup = {
      xID,
      props,
      context,
      getComputeMaps: () => computeMaps
    };
    const imageGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $imageGroup: $xeImageGroup }, params));
      }
    };
    const imageGroupPrivateMethods = {
      handleClickImgEvent(evnt, params) {
        const { showPreview, showPrintButton, showDownloadButton } = props;
        const { url } = params;
        const imgList = computeImgList.value;
        if (showPreview && url) {
          openPreviewImage({
            activeIndex: Math.max(0, import_xe_utils70.default.findIndexOf(imgList, (item) => item.url === url)),
            urlList: imgList,
            showPrintButton,
            showDownloadButton
          });
        }
        imageGroupMethods.dispatchEvent("click", { url, urlList: imgList }, evnt);
      }
    };
    Object.assign($xeImageGroup, imageGroupMethods, imageGroupPrivateMethods);
    const renderVN = () => {
      const imgList = computeImgList.value;
      const vSize = computeSize.value;
      const imgStyleOpts = computeImgStyleOpts.value;
      return h("div", {
        class: ["vxe-image-group", {
          [`size--${vSize}`]: vSize
        }]
      }, imgList ? imgList.map((item, index) => {
        return h(image_default, {
          key: index,
          src: item.url,
          alt: item.alt,
          width: imgStyleOpts.width,
          height: imgStyleOpts.height
        });
      }) : []);
    };
    $xeImageGroup.renderVN = renderVN;
    provide("$xeImageGroup", $xeImageGroup);
    return $xeImageGroup;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/image-group/index.js
var VxeImageGroup = Object.assign({}, group_default3, {
  install(app) {
    app.component(group_default3.name, group_default3);
  }
});
dynamicApp.use(VxeImageGroup);
VxeUI.component(group_default3);
var ImageGroup = VxeImageGroup;
var image_group_default = VxeImageGroup;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/image-preview/index.js
var VxeImagePreview = Object.assign(preview_default, {
  install(app) {
    app.component(preview_default.name, preview_default);
    VxeUI.previewImage = openPreviewImage;
  }
});
dynamicApp.use(VxeImagePreview);
VxeUI.component(preview_default);
var ImagePreview = VxeImagePreview;
var image_preview_default = VxeImagePreview;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/layout-aside/src/layout-aside.js
var import_xe_utils71 = __toESM(require_xe_utils());
var layout_aside_default = defineComponent({
  name: "VxeLayoutAside",
  props: {
    width: [String, Number],
    collapsed: Boolean,
    collapseWidth: [String, Number],
    loading: Boolean,
    padding: Boolean,
    size: {
      type: String,
      default: () => getConfig().layoutAside.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils71.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeWrapperWidth = computed(() => {
      const { width, collapsed, collapseWidth } = props;
      if (collapsed) {
        if (collapseWidth) {
          return toCssUnit(collapseWidth);
        }
      } else {
        if (width) {
          return toCssUnit(width);
        }
      }
      return "";
    });
    const computeMaps = {
      computeSize
    };
    const $xeLayoutAside = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $layoutAside: $xeLayoutAside }, params));
    };
    const layoutAsideMethods = {
      dispatchEvent
    };
    const layoutAsidePrivateMethods = {};
    Object.assign($xeLayoutAside, layoutAsideMethods, layoutAsidePrivateMethods);
    const renderVN = () => {
      const { width, collapsed, loading: loading2, padding } = props;
      const wrapperWidth = computeWrapperWidth.value;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      return h("aside", {
        ref: refElem,
        class: ["vxe-layout-aside", {
          [`size--${vSize}`]: vSize,
          "is--padding": padding,
          "is--default-width": !width,
          "is--collapse": collapsed,
          "is--loading": loading2
        }],
        style: wrapperWidth ? {
          width: wrapperWidth
        } : null
      }, [
        h("div", {
          class: "vxe-layout-aside--inner"
        }, defaultSlot ? defaultSlot({}) : []),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-list-view--loading",
          modelValue: loading2
        })
      ]);
    };
    provide("$xeLayoutAside", $xeLayoutAside);
    $xeLayoutAside.renderVN = renderVN;
    return $xeLayoutAside;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/layout-aside/index.js
var VxeLayoutAside = Object.assign({}, layout_aside_default, {
  install(app) {
    app.component(layout_aside_default.name, layout_aside_default);
  }
});
dynamicApp.use(VxeLayoutAside);
VxeUI.component(layout_aside_default);
var LayoutAside = VxeLayoutAside;
var layout_aside_default2 = VxeLayoutAside;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/layout-body/src/layout-body.js
var import_xe_utils72 = __toESM(require_xe_utils());
var layout_body_default = defineComponent({
  name: "VxeLayoutBody",
  props: {
    loading: Boolean,
    padding: Boolean,
    size: {
      type: String,
      default: () => getConfig().layoutBody.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils72.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize
    };
    const $xeLayoutBody = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $layoutBody: $xeLayoutBody }, params));
    };
    const layoutBodyMethods = {
      dispatchEvent
    };
    const layoutBodyPrivateMethods = {};
    Object.assign($xeLayoutBody, layoutBodyMethods, layoutBodyPrivateMethods);
    const renderVN = () => {
      const { loading: loading2, padding } = props;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-layout-body", {
          [`size--${vSize}`]: vSize,
          "is--loading": loading2,
          "is--padding": padding
        }]
      }, [
        h("div", {
          class: "vxe-layout-body--inner"
        }, defaultSlot ? defaultSlot({}) : []),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-list-view--loading",
          modelValue: loading2
        })
      ]);
    };
    $xeLayoutBody.renderVN = renderVN;
    return $xeLayoutBody;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/layout-body/index.js
var VxeLayoutBody = Object.assign({}, layout_body_default, {
  install(app) {
    app.component(layout_body_default.name, layout_body_default);
  }
});
dynamicApp.use(VxeLayoutBody);
VxeUI.component(layout_body_default);
var LayoutBody = VxeLayoutBody;
var layout_body_default2 = VxeLayoutBody;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/layout-container/src/layout-container.js
var import_xe_utils73 = __toESM(require_xe_utils());
var layout_container_default = defineComponent({
  name: "VxeLayoutContainer",
  props: {
    vertical: Boolean,
    size: {
      type: String,
      default: () => getConfig().layoutContainer.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils73.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize
    };
    const $xeLayoutContainer = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $layoutContainer: $xeLayoutContainer }, params));
    };
    const layoutContainerMethods = {
      dispatchEvent
    };
    const layoutContainerPrivateMethods = {};
    Object.assign($xeLayoutContainer, layoutContainerMethods, layoutContainerPrivateMethods);
    const renderVN = () => {
      const { vertical } = props;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-layout-container", {
          [`size--${vSize}`]: vSize,
          "is--vertical": vertical
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutContainer.renderVN = renderVN;
    return $xeLayoutContainer;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/layout-container/index.js
var VxeLayoutContainer = Object.assign({}, layout_container_default, {
  install(app) {
    app.component(layout_container_default.name, layout_container_default);
  }
});
dynamicApp.use(VxeLayoutContainer);
VxeUI.component(layout_container_default);
var LayoutContainer = VxeLayoutContainer;
var layout_container_default2 = VxeLayoutContainer;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/layout-footer/src/layout-footer.js
var import_xe_utils74 = __toESM(require_xe_utils());
var layout_footer_default = defineComponent({
  name: "VxeLayoutFooter",
  props: {
    fixed: Boolean,
    align: String
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils74.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLayoutFooter = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $layoutFooter: $xeLayoutFooter }, params));
    };
    const layoutFooterMethods = {
      dispatchEvent
    };
    const layoutFooterPrivateMethods = {};
    Object.assign($xeLayoutFooter, layoutFooterMethods, layoutFooterPrivateMethods);
    const renderVN = () => {
      const { fixed, align } = props;
      const defaultSlot = slots.default;
      return h("footer", {
        ref: refElem,
        class: ["vxe-layout-footer", align ? `align--${align}` : "", {
          "is--fixed": fixed
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutFooter.renderVN = renderVN;
    return $xeLayoutFooter;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/layout-footer/index.js
var VxeLayoutFooter = Object.assign({}, layout_footer_default, {
  install(app) {
    app.component(layout_footer_default.name, layout_footer_default);
  }
});
dynamicApp.use(VxeLayoutFooter);
VxeUI.component(layout_footer_default);
var LayoutFooter = VxeLayoutFooter;
var layout_footer_default2 = VxeLayoutFooter;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/layout-header/src/layout-header.js
var import_xe_utils75 = __toESM(require_xe_utils());
var layout_header_default = defineComponent({
  name: "VxeLayoutHeader",
  props: {
    fixed: Boolean
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils75.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLayoutHeader = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $layoutHeader: $xeLayoutHeader }, params));
    };
    const layoutHeaderMethods = {
      dispatchEvent
    };
    const layoutHeaderPrivateMethods = {};
    Object.assign($xeLayoutHeader, layoutHeaderMethods, layoutHeaderPrivateMethods);
    const renderVN = () => {
      const { fixed } = props;
      const defaultSlot = slots.default;
      return h("header", {
        ref: refElem,
        class: ["vxe-layout-header", {
          "is--fixed": fixed
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutHeader.renderVN = renderVN;
    return $xeLayoutHeader;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/layout-header/index.js
var VxeLayoutHeader = Object.assign({}, layout_header_default, {
  install(app) {
    app.component(layout_header_default.name, layout_header_default);
  }
});
dynamicApp.use(VxeLayoutHeader);
VxeUI.component(layout_header_default);
var LayoutHeader = VxeLayoutHeader;
var layout_header_default2 = VxeLayoutHeader;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/link/src/link.js
var import_xe_utils76 = __toESM(require_xe_utils());
var link_default = defineComponent({
  name: "VxeLink",
  props: {
    href: String,
    target: String,
    status: String,
    title: [String, Number],
    icon: String,
    routerLink: Object,
    underline: {
      type: Boolean,
      default: () => getConfig().link.underline
    },
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    content: [String, Number],
    size: {
      type: String,
      default: () => getConfig().link.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils76.default.uniqueId();
    const { computeSize } = useSize(props);
    const { computePermissionInfo } = usePermission(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLink = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $link: $xeLink }, params));
    };
    const linkMethods = {
      dispatchEvent
    };
    const linkPrivateMethods = {};
    const clickEvent = (evnt) => {
      dispatchEvent("click", {}, evnt);
    };
    Object.assign($xeLink, linkMethods, linkPrivateMethods);
    const renderContent = () => {
      const { icon, content } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      const textContent = import_xe_utils76.default.toValueString(content);
      return [
        iconSlot || icon ? h("span", {
          class: "vxe-link--icon"
        }, iconSlot ? getSlotVNs(iconSlot({})) : [
          h("i", {
            class: icon
          })
        ]) : renderEmptyElement($xeLink),
        defaultSlot || textContent ? h("span", {
          class: "vxe-link--content"
        }, defaultSlot ? defaultSlot({}) : textContent) : renderEmptyElement($xeLink)
      ];
    };
    const renderVN = () => {
      const { status, target, href, title, underline, routerLink } = props;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      if (!permissionInfo.visible) {
        return renderEmptyElement($xeLink);
      }
      if (routerLink) {
        return h(resolveComponent("router-link"), {
          class: ["vxe-link", {
            [`size--${vSize}`]: vSize,
            [`theme--${status}`]: status,
            "is--underline": underline
          }],
          title,
          target,
          to: routerLink,
          onClick: clickEvent
        }, {
          default() {
            return renderContent();
          }
        });
      }
      return h("a", {
        ref: refElem,
        class: ["vxe-link", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--underline": underline
        }],
        href,
        target,
        title,
        onClick: clickEvent
      }, renderContent());
    };
    $xeLink.renderVN = renderVN;
    return $xeLink;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/link/index.js
var VxeLink = Object.assign({}, link_default, {
  install(app) {
    app.component(link_default.name, link_default);
  }
});
dynamicApp.use(VxeLink);
VxeUI.component(link_default);
var Link = VxeLink;
var link_default2 = VxeLink;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/list-design/src/list-design.js
var import_xe_utils79 = __toESM(require_xe_utils());

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/list-design/render/util.js
var createListDesignActionButton = (btnObj) => {
  return Object.assign({
    name: "",
    icon: "",
    type: "",
    classify: "",
    code: "",
    status: "",
    permissionCode: ""
  }, btnObj);
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/list-design/src/default-setting-data.js
var getDefaultSettingFormData2 = () => {
  return {
    listView: {
      enabled: true
    },
    ganttView: {
      enabled: false
    },
    chartView: {
      enabled: false
    },
    autoFoldFilter: true,
    showCheckbox: "auto",
    showSeq: true,
    showStatistics: true,
    mobileDefaultView: "list",
    pcDefaultView: "list",
    actionButtonList: []
  };
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/list-design/src/layout-preview.js
var import_xe_utils77 = __toESM(require_xe_utils());
var layout_preview_default2 = defineComponent({
  name: "ListDesignLayoutView",
  props: {},
  emits: [],
  setup() {
    const VxeTableGridComponent = VxeUI.getComponent("VxeGrid");
    const $xeListDesign = inject("$xeListDesign", null);
    if (!$xeListDesign) {
      return () => [];
    }
    const { reactData: listDesignReactData } = $xeListDesign;
    const refGrid = ref();
    const tableData = ref([]);
    const computeFormItems = computed(() => {
      const { searchFormItems } = listDesignReactData;
      if (searchFormItems.length) {
        return searchFormItems.concat([
          {
            field: "active",
            title: "",
            folding: false,
            collapseNode: searchFormItems.some((item) => item.folding),
            itemRender: {
              name: "VxeButtonGroup",
              options: [
                { content: "查询", icon: "vxe-icon-search", status: "primary", type: "submit" },
                { content: "重置", icon: "vxe-icon-repeat", type: "reset" }
              ]
            }
          }
        ]);
      }
      return searchFormItems;
    });
    const computeTableColumn = computed(() => {
      const { formData, listTableColumns } = listDesignReactData;
      const { showSeq, actionButtonList } = formData;
      const columns = [];
      if (showSeq) {
        columns.push({
          type: "seq",
          field: "_seq",
          width: 70
        });
      }
      listTableColumns.forEach((item) => {
        columns.push({
          field: item.field,
          title: item.title,
          visible: item.visible,
          width: item.width
        });
      });
      if (actionButtonList && actionButtonList.length) {
        columns.push({
          field: "_active",
          title: getI18n("vxe.table.actionTitle"),
          fixed: "right",
          width: "auto",
          cellRender: {
            name: "VxeButtonGroup",
            options: []
          }
        });
      }
      return columns;
    });
    const updateColumnWidthEvent = ({ column, resizeWidth }) => {
      const { listTableColumns } = listDesignReactData;
      const rest = import_xe_utils77.default.findTree(listTableColumns, (item) => item.field === column.field, { children: "children" });
      if (rest) {
        const { item } = rest;
        item.width = resizeWidth;
      }
    };
    const updateTableData = () => {
      const { listTableColumns } = listDesignReactData;
      const data = [{}, {}];
      data.forEach((row) => {
        listTableColumns.forEach((column) => {
          row[column.field] = "-";
        });
      });
      tableData.value = data;
    };
    const dataFlag = ref(0);
    watch(() => listDesignReactData.listTableColumns ? listDesignReactData.listTableColumns.length : -1, () => {
      dataFlag.value++;
    });
    watch(() => listDesignReactData.listTableColumns, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      updateTableData();
    });
    onMounted(() => {
      updateTableData();
    });
    if (true) {
      nextTick(() => {
        if (!VxeTableGridComponent) {
          errLog("vxe.error.reqComp", ["vxe-grid"]);
        }
      });
    }
    return () => {
      const { searchFormData, searchFormItems } = listDesignReactData;
      const formItems = computeFormItems.value;
      const tableColumn = computeTableColumn.value;
      return h("div", {
        class: "vxe-list-design--preview"
      }, [
        h("div", {
          class: "vxe-list-design--preview-wrapper"
        }, [
          h("div", {
            class: "vxe-list-design--preview-search"
          }, [
            h("div", {
              class: "vxe-list-design--preview-title"
            }, getI18n("vxe.listDesign.searchTitle")),
            searchFormItems.length ? h(form_default, {
              data: searchFormData,
              items: formItems
            }) : h("div", {
              class: "vxe-list-design--field-configs-empty-data"
            }, [
              h("span", {}, getI18n("vxe.listDesign.search.emptyText"))
            ])
          ]),
          h("div", {
            class: "vxe-list-design--preview-table"
          }, [
            h("div", {
              class: "vxe-list-design--preview-title"
            }, getI18n("vxe.listDesign.listTitle")),
            VxeTableGridComponent ? h(VxeTableGridComponent, {
              ref: refGrid,
              columns: tableColumn,
              data: tableData.value,
              showOverflow: true,
              border: true,
              columnConfig: {
                minWidth: "auto",
                resizable: true
              },
              rowConfig: {
                isHover: true
              },
              scrollX: {
                enabled: false
              },
              scrollY: {
                enabled: false
              },
              onResizableChange: updateColumnWidthEvent
            }) : createCommentVNode()
          ])
        ])
      ]);
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/list-design/src/default-setting-form.js
var import_xe_utils78 = __toESM(require_xe_utils());
var refWidgetReactConfigMaps2 = ref({});
var DefaultFieldSettingFormComponent = defineComponent({
  name: "DefaultFieldSettingForm",
  props: {},
  emits: [],
  setup() {
    const $xeListDesign = inject("$xeListDesign", null);
    if (!$xeListDesign) {
      return () => [];
    }
    const { reactData: listDesignReactData } = $xeListDesign;
    const refIsAllChecked = ref(false);
    const refIsAllIndeterminate = ref(false);
    const changeVisible = (item) => {
      item.visible = !item.visible;
      listDesignReactData.listTableColumns = listDesignReactData.listTableColumns.slice(0);
    };
    const removeSearchItem = (item) => {
      const { searchFormItems } = listDesignReactData;
      listDesignReactData.searchFormItems = searchFormItems.filter((obj) => obj.field !== item.field);
    };
    const addSearchEvent = () => {
      const { listTableColumns, searchFormItems } = listDesignReactData;
      const widgetReactConfigMaps = refWidgetReactConfigMaps2.value;
      const allFormItemList = [];
      listTableColumns.forEach((item) => {
        const { cellRender } = item;
        if (cellRender) {
          const conf = searchFormItems.find((conf2) => conf2.field === item.field);
          const name = cellRender.name || "";
          let widgetConfig = widgetReactConfigMaps[name];
          if (!widgetConfig) {
            const compConf = renderer.get(name);
            if (compConf) {
              const createWidgetFormConfig = compConf.createFormDesignWidgetConfig;
              if (createWidgetFormConfig) {
                const params = { name, $formDesign: null };
                widgetConfig = createWidgetFormConfig(params) || {};
                widgetReactConfigMaps[name] = widgetConfig;
              }
            }
          }
          if (widgetConfig.query) {
            allFormItemList.push(Object.assign(Object.assign({}, item), { checked: !!conf, isHalf: false, folding: conf ? !!conf.folding : false }));
          }
        }
      });
      refWidgetReactConfigMaps2.value = Object.assign({}, widgetReactConfigMaps);
      const refAllFormItemList = ref(allFormItemList);
      const checkOptionStatus = () => {
        const allFormItemList2 = refAllFormItemList.value;
        refIsAllChecked.value = allFormItemList2.every((item) => item.checked);
        refIsAllIndeterminate.value = !refIsAllChecked.value && allFormItemList2.some((item) => item.checked || item.isHalf);
      };
      const handleOptionCheck = (item) => {
        const allFormItemList2 = refAllFormItemList.value;
        const matchObj = import_xe_utils78.default.findTree(allFormItemList2, (obj) => obj === item);
        if (matchObj && matchObj.parent) {
          const { parent } = matchObj;
          if (parent.children && parent.children.length) {
            parent.checked = parent.children.every((obj) => obj.checked);
            parent.isHalf = !parent.checked && parent.children.some((obj) => obj.checked || obj.isHalf);
            handleOptionCheck(parent);
          }
        }
      };
      const changeCheckboxOption = (item) => {
        const isChecked = !item.checked;
        import_xe_utils78.default.eachTree([item], (obj) => {
          obj.checked = isChecked;
          obj.isHalf = false;
        });
        handleOptionCheck(item);
        checkOptionStatus();
      };
      const allOptionEvent = () => {
        const allFormItemList2 = refAllFormItemList.value;
        const isAll = !refIsAllChecked.value;
        import_xe_utils78.default.eachTree(allFormItemList2, (item) => {
          item.checked = isAll;
          item.isHalf = false;
        });
        refIsAllChecked.value = isAll;
        checkOptionStatus();
      };
      const confirmEvent = () => {
        const allFormItemList2 = refAllFormItemList.value;
        const searchItems = [];
        allFormItemList2.forEach((item) => {
          if (item.checked) {
            searchItems.push({
              field: item.field,
              title: item.title,
              folding: item.folding,
              itemRender: Object.assign({}, item.cellRender)
            });
          }
        });
        $xeListDesign.setSearchItems(searchItems);
      };
      VxeUI.modal.open({
        title: getI18n("vxe.listDesign.search.editPopupTitle"),
        width: 680,
        height: 500,
        showFooter: true,
        escClosable: true,
        showCancelButton: true,
        showConfirmButton: true,
        confirmButtonText: getI18n("vxe.listDesign.searchPopup.saveBtn"),
        showZoom: true,
        resize: true,
        onConfirm: confirmEvent,
        slots: {
          default() {
            const isAllChecked = refIsAllChecked.value;
            const isAllIndeterminate = refIsAllIndeterminate.value;
            const allFormItemList2 = refAllFormItemList.value;
            return h("div", {
              class: "vxe-list-design--field-search-popup"
            }, [
              h("table", {}, [
                h("colgroup", {}, [
                  h("col", {
                    style: {
                      width: "80px"
                    }
                  }),
                  h("col")
                  // h('col', {
                  //   style: {
                  //     width: '140px'
                  //   }
                  // })
                ]),
                h("thead", {}, [
                  h("th", {}, [
                    h("div", {
                      class: ["vxe-list-design--field-search-checkbox-option", {
                        "is--checked": isAllChecked,
                        "is--indeterminate": isAllIndeterminate
                      }],
                      title: getI18n("vxe.table.allTitle"),
                      onClick: allOptionEvent
                    }, [
                      h("span", {
                        class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon().CHECKBOX_INDETERMINATE : isAllChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
                      }),
                      h("span", {
                        class: "vxe-checkbox--label"
                      }, getI18n("vxe.toolbar.customAll"))
                    ])
                  ]),
                  h("th", {}, getI18n("vxe.listDesign.searchPopup.colTitle"))
                  // h('th', {}, '展开/折叠')
                ]),
                h("tbody", {}, allFormItemList2.map((item) => {
                  const isChecked = item.checked;
                  const isIndeterminate = item.isHalf;
                  return h("tr", {}, [
                    h("td", {
                      class: "vxe-list-design--field-search-option-item col--visible"
                    }, [
                      h("div", {
                        class: ["vxe-list-design--field-search-checkbox-option", {
                          "is--checked": isChecked,
                          "is--indeterminate": isIndeterminate
                        }],
                        title: getI18n("vxe.custom.setting.colVisible"),
                        onClick: () => {
                          changeCheckboxOption(item);
                        }
                      }, [
                        h("span", {
                          class: ["vxe-checkbox--icon", isIndeterminate ? getIcon().CHECKBOX_INDETERMINATE : isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
                        })
                      ])
                    ]),
                    h("td", {
                      class: "vxe-list-design--field-search-option-item"
                    }, `${item.title || ""}`)
                    // h('td', {}, [
                    //   h(VxeRadioGroupComponent, {
                    //     modelValue: item.folding,
                    //     type: 'button',
                    //     options: foldOptions.value,
                    //     size: 'mini',
                    //     'onUpdate:modelValue' (val) {
                    //       item.folding = val
                    //     }
                    //   })
                    // ])
                  ]);
                }))
              ])
            ]);
          }
        }
      });
    };
    const renderChildOptions = (item) => {
      const { children } = item;
      if (children && children.length) {
        return h("div", {
          class: "vxe-list-design--field-option-inner"
        }, [
          h("div", {
            class: "vxe-list-design--field-sub-option",
            onClick() {
              changeVisible(item);
            }
          }, children.map((child) => {
            const { title, visible: isChecked } = child;
            return h("div", {
              class: ["vxe-list-design--field-checkbox-option", {
                "is--checked": isChecked
              }],
              onClick() {
                changeVisible(child);
              }
            }, [
              h("span", {
                class: ["vxe-checkbox--icon", isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
              }),
              h("span", {
                class: "vxe-checkbox--label"
              }, `${title}`)
            ]);
          }))
        ]);
      }
      return createCommentVNode();
    };
    const renderFieldOptions = () => {
      const { listTableColumns } = listDesignReactData;
      return listTableColumns.map((item) => {
        const { title, visible: isChecked } = item;
        return h("div", {
          class: "vxe-list-design--field-option"
        }, [
          h("div", {
            class: "vxe-list-design--field-option-inner"
          }, [
            h("div", {
              class: ["vxe-list-design--field-checkbox-option", {
                "is--checked": isChecked
              }],
              onClick() {
                changeVisible(item);
              }
            }, [
              h("span", {
                class: ["vxe-checkbox--icon", isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
              }),
              h("span", {
                class: "vxe-checkbox--label"
              }, `${title}`)
            ])
          ]),
          renderChildOptions(item)
        ]);
      });
    };
    return () => {
      return h(form_default, {
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.listDesign.searchField")
            }, {
              extra() {
                return h(button_default, {
                  mode: "text",
                  status: "primary",
                  icon: getIcon().FORM_DESIGN_PROPS_EDIT,
                  content: getI18n("vxe.listDesign.search.addBtn"),
                  onClick: addSearchEvent
                });
              },
              default() {
                const { searchFormItems } = listDesignReactData;
                return [
                  searchFormItems.length ? h("div", {
                    class: "vxe-list-design--search-item-wrapper"
                  }, [
                    h("div", {
                      class: "vxe-list-design--search-item-list"
                    }, searchFormItems.map((item) => {
                      return h("div", {
                        key: item.field,
                        class: "vxe-list-design--search-item"
                      }, [
                        h("div", {
                          class: "vxe-list-design--search-item-title"
                        }, `${item.title || ""}`),
                        h("div", {
                          class: "vxe-list-design--search-item-btn"
                        }, [
                          h(button_default, {
                            icon: getIcon().LIST_DESIGN_LIST_SETTING_SEARCH_DELETE,
                            mode: "text",
                            status: "error",
                            onClick() {
                              removeSearchItem(item);
                            }
                          })
                        ])
                      ]);
                    }))
                  ]) : h("div", {
                    class: "vxe-list-design--field-configs-empty-data"
                  }, [
                    h("span", {}, getI18n("vxe.listDesign.search.emptyText"))
                  ])
                ];
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.listDesign.listField")
            }, {
              default() {
                return renderFieldOptions();
              }
            })
          ];
        }
      });
    };
  }
});
var DefaultParameterSettingFormComponent = defineComponent({
  name: "DefaultListSettingTabComponent",
  props: {},
  emits: [],
  setup() {
    const $xeListDesign = inject("$xeListDesign", null);
    if (!$xeListDesign) {
      return () => [];
    }
    const { props: listDesignProps, reactData: listDesignReactData } = $xeListDesign;
    const systemConfigList = [];
    const customConfigList = [];
    renderer.forEach((item, name) => {
      const { createListDesignSettingActionButtonConfig } = item;
      if (createListDesignSettingActionButtonConfig) {
        const params = { name };
        const btnConfig = Object.assign(createListDesignActionButton({ code: name }), createListDesignSettingActionButtonConfig(params));
        if (btnConfig.type === "custom") {
          customConfigList.push(btnConfig);
        } else {
          systemConfigList.push(btnConfig);
        }
      }
    });
    const renderViewList = ref([
      { label: "列表视图", value: "list", isExpand: false }
    ]);
    const refSeqOpts = ref([
      { label: "显示", value: true },
      { label: "隐藏", value: false }
    ]);
    const refCheckboxOpts = ref([
      { label: "默认", value: "auto" },
      { label: "允许", value: true },
      { label: "不允许", value: false }
    ]);
    const disableView = computed(() => {
      const { formData } = listDesignReactData;
      return [formData.listView.enabled, formData.ganttView.enabled, formData.chartView.enabled].filter((enabled) => enabled).length <= 1;
    });
    const openActiveBtnPopup = (activeBtnObj) => {
      const { formData } = listDesignReactData;
      const { actionCodes } = listDesignProps;
      let btnList = formData.actionButtonList;
      if (!btnList) {
        btnList = [];
      }
      const activeBtnItem = reactive(createListDesignActionButton(activeBtnObj));
      const systemBtnList = systemConfigList.filter((item) => {
        if (actionCodes && actionCodes.length) {
          if (!actionCodes.some((conf) => import_xe_utils78.default.isString(conf) ? item.code === conf : conf.code === item.code)) {
            return false;
          }
        }
        return !btnList.some((obj) => obj.code === item.code);
      });
      const customBtnList = customConfigList.filter((item) => !btnList.some((obj) => obj.code === item.code));
      const btOptions = [];
      if (systemBtnList.length) {
        if (!activeBtnItem.type) {
          activeBtnItem.type = "";
        }
        btOptions.push({ value: "", label: "系统按钮" });
      }
      if (customBtnList.length) {
        if (!activeBtnItem.type) {
          activeBtnItem.type = "custom";
        }
        btOptions.push({ value: "custom", label: "自定义按钮" });
      }
      const refSystemConfigOptions = computed(() => {
        return systemBtnList.map((item) => {
          const nameConfig = item.name;
          return {
            label: import_xe_utils78.default.toValueString(import_xe_utils78.default.isFunction(nameConfig) ? nameConfig({ name: item.code || "" }) : nameConfig),
            value: item.code
          };
        });
      });
      const refBtnTypeOptions = ref(btOptions);
      VxeUI.modal.open({
        title: "添加按钮",
        width: 600,
        height: 400,
        showFooter: true,
        showCancelButton: true,
        showConfirmButton: true,
        confirmButtonText: "保存",
        onConfirm() {
          if (activeBtnItem.type === "custom") {
            btnList.push(activeBtnItem);
          } else {
            btnList.push(activeBtnItem);
          }
          formData.actionButtonList = [...btnList];
        },
        slots: {
          default() {
            return h(form_default, {
              vertical: true,
              titleBold: true
            }, {
              default() {
                return [
                  h(form_item_default, {
                    title: "按钮类型",
                    span: 24
                  }, {
                    default() {
                      return h(select_default, {
                        modelValue: activeBtnItem.type,
                        options: refBtnTypeOptions.value,
                        "onUpdate:modelValue"(val) {
                          activeBtnItem.type = val;
                        }
                      });
                    }
                  }),
                  h(form_item_default, {
                    title: "选择系统按钮",
                    span: 24
                  }, {
                    default() {
                      return h(select_default, {
                        modelValue: activeBtnItem.code,
                        options: refSystemConfigOptions.value,
                        "onUpdate:modelValue"(val) {
                          activeBtnItem.code = val;
                        }
                      });
                    }
                  })
                  // h(VxeFormItemComponent, {
                  //   title: '按钮位置',
                  //   span: 24
                  // }, {
                  //   default () {
                  //     return h(VxeSelectComponent, {
                  //       modelValue: activeBtnItem.classify,
                  //       options: refBtnClassifyOptions.value,
                  //       'onUpdate:modelValue' (val) {
                  //         activeBtnItem.classify = val
                  //       }
                  //     })
                  //   }
                  // })
                ];
              }
            });
          }
        }
      });
    };
    const renderDefaultCellActionButton = () => {
      return h(form_item_default, {
        title: "功能按钮"
      }, {
        extra() {
          return h(button_default, {
            mode: "text",
            status: "primary",
            icon: getIcon().FORM_DESIGN_PROPS_ADD,
            content: "新增",
            onClick() {
              openActiveBtnPopup();
            }
          });
        },
        default() {
          const { formData } = listDesignReactData;
          const btnList = formData.actionButtonList;
          return btnList && btnList.length ? h("div", {
            class: "vxe-list-design--field-configs-wrapper"
          }, btnList.map((btnItem) => {
            let btnIcon = "";
            let btnName = "";
            if (btnItem.type === "custom") {
              btnIcon = btnItem.icon;
              btnName = btnItem.name;
            } else {
              const btnConfig = systemConfigList.find((item) => item.code === btnItem.code);
              if (btnConfig) {
                const nameConfig = btnConfig.name;
                btnIcon = btnConfig.icon || "";
                btnName = import_xe_utils78.default.toValueString(import_xe_utils78.default.isFunction(nameConfig) ? nameConfig({ name: btnConfig.code || "" }) : nameConfig);
              }
            }
            return h("div", {
              class: "vxe-list-design--field-configs-item"
            }, [
              btnIcon ? h("div", {
                class: "vxe-list-design--field-configs-item-icon"
              }, [
                h("i", {
                  class: btnIcon
                })
              ]) : createCommentVNode(),
              h("div", {
                class: "vxe-list-design--field-configs-item-title"
              }, `${btnName || ""}`),
              h("div", {
                class: "vxe-list-design--field-configs-item-btn"
              }, [
                h(button_default, {
                  icon: getIcon().LIST_DESIGN_LIST_SETTING_ACTIVE_DELETE,
                  mode: "text",
                  status: "error",
                  onClick() {
                    formData.actionButtonList = btnList.filter((item) => item !== btnItem);
                  }
                })
              ])
            ]);
          })) : h("div", {
            class: "vxe-list-design--field-configs-empty-data"
          }, [
            h("span", {}, "无操作按钮")
          ]);
        }
      });
    };
    return () => {
      const { showPc, showMobile } = listDesignProps;
      const { formData } = listDesignReactData;
      return h(form_default, {
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          return [
            h(form_item_default, {
              title: "视图配置"
            }, {
              default() {
                return h("div", {
                  class: "vxe-form-design--widget-form-item-render-view"
                }, renderViewList.value.map((item) => {
                  return h("div", {
                    key: item.value,
                    class: "vxe-form-design--widget-form-item-render-view-item"
                  }, [
                    h(switch_default, {
                      modelValue: formData.listView.enabled,
                      disabled: disableView.value,
                      "onUpdate:modelValue"(val) {
                        formData.listView.enabled = val;
                      }
                    }),
                    h(text_default, {
                      content: item.label,
                      icon: "vxe-icon-table"
                    })
                  ]);
                }));
              }
            }),
            h(form_item_default, {
              title: "默认视图"
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-devices"
                  }, [
                    showPc ? h("div", {
                      class: "vxe-form-design--widget-form-item-devices-item"
                    }, [
                      h("div", {
                        class: "vxe-form-design--widget-form-item-devices-left"
                      }, [
                        h(text_default, {
                          icon: getIcon().FORM_DESIGN_PROPS_PC,
                          content: getI18n("vxe.formDesign.widgetProp.displaySetting.pc")
                        })
                      ]),
                      h(select_default, {
                        modelValue: formData.pcDefaultView,
                        className: "vxe-form-design--widget-form-item-devices-select",
                        options: renderViewList.value,
                        "onUpdate:modelValue"(val) {
                          formData.pcDefaultView = val;
                        }
                      })
                    ]) : createCommentVNode(),
                    showMobile ? h("div", {
                      class: "vxe-form-design--widget-form-item-devices-item"
                    }, [
                      h("div", {
                        class: "vxe-form-design--widget-form-item-devices-left"
                      }, [
                        h(text_default, {
                          icon: getIcon().FORM_DESIGN_PROPS_MOBILE,
                          content: getI18n("vxe.formDesign.widgetProp.displaySetting.mobile")
                        })
                      ]),
                      h(select_default, {
                        modelValue: formData.mobileDefaultView,
                        className: "vxe-form-design--widget-form-item-devices-select",
                        options: renderViewList.value,
                        "onUpdate:modelValue"(val) {
                          formData.mobileDefaultView = val;
                        }
                      })
                    ]) : createCommentVNode()
                  ])
                ];
              }
            }),
            // h(VxeFormItemComponent, {
            //   title: '查询配置'
            // }, {
            //   default () {
            //     const { formData } = listDesignReactData
            //     return [
            //       h('div', {
            //         class: 'vxe-list-design--widget-form-item-prop-list'
            //       }, [
            //         h('span', {}, '折叠字段'),
            //         h(VxeRadioGroupComponent, {
            //           modelValue: formData.autoFoldFilter,
            //           options: refFoldOpts.value,
            //           'onUpdate:modelValue' (val) {
            //             formData.autoFoldFilter = val
            //           }
            //         })
            //       ])
            //     ]
            //   }
            // }),
            h(form_item_default, {
              title: "列配置"
            }, {
              default() {
                const { formData: formData2 } = listDesignReactData;
                return [
                  h("div", {
                    class: "vxe-list-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, "显示序号"),
                    h(group_default, {
                      modelValue: formData2.showSeq,
                      options: refSeqOpts.value,
                      "onUpdate:modelValue"(val) {
                        formData2.showSeq = val;
                      }
                    })
                  ]),
                  h("div", {
                    class: "vxe-list-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, "表尾统计"),
                    h(group_default, {
                      modelValue: formData2.showStatistics,
                      options: refSeqOpts.value,
                      "onUpdate:modelValue"(val) {
                        formData2.showStatistics = val;
                      }
                    })
                  ])
                ];
              }
            }),
            h(form_item_default, {
              title: "批量操作"
            }, {
              default() {
                const { formData: formData2 } = listDesignReactData;
                return h(group_default, {
                  modelValue: formData2.showCheckbox,
                  options: refCheckboxOpts.value,
                  "onUpdate:modelValue"(val) {
                    formData2.showCheckbox = val;
                  }
                });
              }
            }),
            systemConfigList.length || customConfigList.length ? renderDefaultCellActionButton() : createCommentVNode()
          ];
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/list-design/src/layout-setting.js
var layout_setting_default2 = defineComponent({
  name: "ListDesignLayoutSetting",
  props: {},
  emits: [],
  setup() {
    const activeTab = ref(1);
    return () => {
      return h("div", {
        class: "vxe-list-design--setting"
      }, [
        h("div", {
          class: "vxe-list-design--setting-form"
        }, [
          h(tabs_default, {
            modelValue: activeTab.value,
            titleWidth: "50%",
            titleAlign: "center",
            padding: true,
            class: "vxe-list-design--setting-form-tabs",
            "onUpdate:modelValue"(val) {
              activeTab.value = val;
            }
          }, {
            default() {
              return [
                h(tab_pane_default, {
                  title: getI18n("vxe.listDesign.fieldSettingTab"),
                  icon: getIcon().LIST_DESIGN_FIELD_SETTING,
                  name: 1
                }, {
                  default() {
                    return h(DefaultFieldSettingFormComponent);
                  }
                }),
                h(tab_pane_default, {
                  title: getI18n("vxe.listDesign.listSettingTab"),
                  icon: getIcon().LIST_DESIGN_LIST_SETTING,
                  name: 2
                }, {
                  default() {
                    return h(DefaultParameterSettingFormComponent);
                  }
                })
              ];
            }
          })
        ])
      ]);
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/list-design/src/list-design.js
var list_design_default = defineComponent({
  name: "VxeListDesign",
  props: {
    size: {
      type: String,
      default: () => getConfig().listDesign.size || getConfig().size
    },
    height: {
      type: [String, Number],
      default: () => getConfig().listDesign.height
    },
    config: Object,
    showPc: {
      type: Boolean,
      default: () => getConfig().listDesign.showPc
    },
    showMobile: {
      type: Boolean,
      default: () => getConfig().listDesign.showMobile
    },
    actionCodes: Array,
    formRender: Object
  },
  emits: [],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils79.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      formData: {},
      searchFormData: {},
      searchFormItems: [],
      listTableColumns: []
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize
    };
    const $xeListDesign = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const systemConfigList = [];
    const customConfigList = [];
    renderer.forEach((item, name) => {
      const { createListDesignSettingActionButtonConfig } = item;
      if (createListDesignSettingActionButtonConfig) {
        const params = { name };
        const btnConfig = Object.assign(createListDesignActionButton({ code: name }), createListDesignSettingActionButtonConfig(params));
        if (btnConfig.type === "custom") {
          customConfigList.push(btnConfig);
        } else {
          systemConfigList.push(btnConfig);
        }
      }
    });
    const parseWidgetColumn = (widget) => {
      return {
        title: widget.title,
        field: widget.field,
        visible: !widget.hidden,
        width: "",
        cellRender: {
          name: widget.name,
          props: widget.options
        }
      };
    };
    const parseFormDesignColumns = (config2) => {
      const tableColumns = [];
      if (config2) {
        const { widgetData } = config2;
        if (widgetData) {
          widgetData.forEach((item) => {
            const { name } = item;
            if (name) {
              if (name === "row") {
                item.children.forEach((childItem) => {
                  if (childItem.name) {
                    tableColumns.push(parseWidgetColumn(childItem));
                  }
                });
              } else if (name === "subtable") {
              } else {
                tableColumns.push(parseWidgetColumn(item));
              }
            }
          });
        }
      }
      return tableColumns;
    };
    const configToSearchItems = (searchItems) => {
      if (searchItems) {
        const data = {};
        const items = searchItems.map((item) => {
          data[item.field] = null;
          return {
            field: item.field,
            title: item.title,
            folding: item.folding,
            itemRender: item.itemRender
          };
        });
        return {
          items,
          data
        };
      }
      return { items: [], data: {} };
    };
    const configToListColumns = (listColumns) => {
      if (listColumns) {
        return listColumns.map((item) => {
          return {
            field: item.field,
            title: item.title,
            visible: !!item.visible,
            width: item.width,
            cellRender: import_xe_utils79.default.clone(item.cellRender)
          };
        });
      }
      return [];
    };
    const loadConfig = (config2) => {
      const { formConfig, searchItems, listColumns } = config2;
      if (formConfig) {
        loadFormConfig(formConfig);
      }
      if (searchItems) {
        setSearchItems(searchItems);
      }
      if (listColumns) {
        reactData.listTableColumns = parseColumnConfigs(listColumns);
      }
      return nextTick();
    };
    const parseColumnConfigs = (listColumns) => {
      return configToListColumns(listColumns);
    };
    const loadFormConfig = (data) => {
      reactData.formData = Object.assign({}, createSettingForm(), data);
      return nextTick();
    };
    const getSearchItems = () => {
      return reactData.searchFormItems;
    };
    const setSearchItems = (searchItems) => {
      const { data, items } = configToSearchItems(searchItems);
      reactData.searchFormData = data;
      reactData.searchFormItems = items;
      return nextTick();
    };
    const getListColumns = () => {
      return reactData.listTableColumns;
    };
    const setListColumns = (listColumns) => {
      reactData.listTableColumns = parseColumnConfigs(listColumns);
      return nextTick();
    };
    const createSettingForm = () => {
      const { actionCodes, formRender } = props;
      let conf = getDefaultSettingFormData2();
      if (actionCodes && actionCodes.length) {
        if (!conf.actionButtonList || !conf.actionButtonList.length) {
          const defActionBtnList = [];
          actionCodes.forEach((item) => {
            if (import_xe_utils79.default.isObject(item) && item.default) {
              const sysItem = systemConfigList.find((obj) => obj.code === item.code);
              if (sysItem) {
                defActionBtnList.push(createListDesignActionButton({
                  type: sysItem.type,
                  code: sysItem.code
                }));
              }
            }
          });
          conf.actionButtonList = defActionBtnList;
        }
      }
      if (formRender && formRender.name) {
        const compConf = renderer.get(formRender.name);
        const createFormConfig = compConf ? compConf.createListDesignSettingFormConfig : null;
        const params = { name: formRender.name };
        conf = (createFormConfig ? createFormConfig(params) : {}) || {};
      }
      return conf;
    };
    const initSettingForm = () => {
      reactData.formData = createSettingForm();
    };
    const clearConfig = () => {
      loadConfig({
        searchItems: [],
        listColumns: []
      });
      initSettingForm();
      return nextTick();
    };
    const listDesignMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $listDesign: $xeListDesign }, params));
      },
      loadFormDesignConfig(config2) {
        const { listTableColumns } = reactData;
        const oldMaps = {};
        import_xe_utils79.default.eachTree(listTableColumns, (item) => {
          oldMaps[item.field] = item;
        }, { children: "children" });
        const columns = parseFormDesignColumns(config2);
        import_xe_utils79.default.eachTree(columns, (item) => {
          const oldItem = oldMaps[item.field];
          if (oldItem) {
            if (oldItem.width) {
              item.width = oldItem.width;
            }
            item.visible = oldItem.visible;
          }
        }, { children: "children" });
        reactData.listTableColumns = columns;
        return nextTick();
      },
      reloadFormDesignConfig(config2) {
        reactData.listTableColumns = parseFormDesignColumns(config2);
        return nextTick();
      },
      getSearchItems,
      setSearchItems,
      getListColumns,
      setListColumns,
      getConfig() {
        return {
          formConfig: reactData.formData,
          searchItems: getSearchItems(),
          listColumns: getListColumns()
        };
      },
      loadConfig,
      reloadConfig(config2) {
        clearConfig();
        return loadConfig(config2);
      },
      clearConfig
    };
    const listDesignPrivateMethods = {};
    Object.assign($xeListDesign, listDesignMethods, listDesignPrivateMethods);
    const renderVN = () => {
      const { height } = props;
      const vSize = computeSize.value;
      const headerSlot = slots.header;
      return h("div", {
        ref: refElem,
        class: ["vxe-list-design", {
          [`size--${vSize}`]: vSize
        }],
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [
        h("div", {
          class: "vxe-list-design--header"
        }, headerSlot ? headerSlot({}) : []),
        h("div", {
          class: "vxe-list-design--body"
        }, [
          h(layout_preview_default2),
          h(layout_setting_default2)
        ])
      ]);
    };
    provide("$xeListDesign", $xeListDesign);
    watch(() => props.config, (value) => {
      loadConfig(value || {});
    });
    initSettingForm();
    if (props.config) {
      loadConfig(props.config);
    }
    $xeListDesign.renderVN = renderVN;
    return $xeListDesign;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/list-design/render/index.js
renderer.mixin({
  // ActionButtonUpdate: {
  //   createListDesignSettingActionButtonConfig () {
  //     return {
  //       name: handleGetListDesignActionButtonName,
  //       icon: 'vxe-icon-edit',
  //       status: 'primary'
  //     }
  //   }
  // },
  // ActionButtonDelete: {
  //   createListDesignSettingActionButtonConfig () {
  //     return {
  //       name: handleGetListDesignActionButtonName,
  //       icon: 'vxe-icon-delete',
  //       status: 'error'
  //     }
  //   }
  // }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/list-design/index.js
var VxeListDesign = Object.assign({}, list_design_default, {
  install(app) {
    app.component(list_design_default.name, list_design_default);
  }
});
var listDesignHandle = {};
dynamicApp.use(VxeListDesign);
VxeUI.component(list_design_default);
VxeUI.listDesignHandle = listDesignHandle;
var ListDesign = VxeListDesign;
var list_design_default2 = VxeListDesign;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/list-design/src/list-view.js
var import_xe_utils80 = __toESM(require_xe_utils());
var list_view_default = defineComponent({
  name: "VxeListView",
  props: {
    size: {
      type: String,
      default: () => getConfig().listView.size || getConfig().size
    },
    config: Object,
    height: {
      type: [String, Number],
      default: () => getConfig().listView.height
    },
    loading: Boolean,
    formData: Object,
    actionButtons: Array,
    gridOptions: Object,
    gridEvents: Object,
    viewRender: Object
  },
  emits: [
    "cell-action",
    "update:formData",
    "update:actionButtons"
  ],
  setup(props, context) {
    const VxeTableGridComponent = VxeUI.getComponent("VxeGrid");
    const { emit, slots } = context;
    const xID = import_xe_utils80.default.uniqueId();
    const refElem = ref();
    const refGrid = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      formConfig: {},
      searchFormData: {},
      searchFormItems: [],
      listTableColumns: [],
      tableColumns: [],
      footerData: [
        {}
        // 默认一行合计
      ]
    });
    const computeGridOptions = computed(() => {
      const { gridOptions } = props;
      const { formConfig, tableColumns, searchFormData, searchFormItems, footerData } = reactData;
      const { showStatistics } = formConfig;
      const gridOpts = gridOptions || {};
      const columnOpts = Object.assign({
        minWidth: 120
      }, gridOpts.columnConfig);
      let proxyOpts;
      if (gridOpts.proxyConfig) {
        proxyOpts = Object.assign({ autoLoad: false }, gridOpts.proxyConfig);
      }
      return Object.assign({}, gridOpts, {
        columns: tableColumns,
        columnConfig: columnOpts,
        showFooter: showStatistics,
        footerData: showStatistics ? footerData : null,
        formConfig: {
          data: searchFormData,
          items: searchFormItems
        },
        proxyConfig: proxyOpts
      });
    });
    const computeGridEvents = computed(() => {
      const { gridEvents } = props;
      const ons = {};
      import_xe_utils80.default.each(gridEvents, (fn, key) => {
        ons[import_xe_utils80.default.camelCase(`on-${key}`)] = fn;
      });
      return ons;
    });
    const refMaps = {
      refElem,
      refGrid
    };
    const computeMaps = {
      computeSize
    };
    const $xeListView = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const systemConfigList = [];
    const customConfigList = [];
    renderer.forEach((item, name) => {
      const { createListDesignSettingActionButtonConfig } = item;
      if (createListDesignSettingActionButtonConfig) {
        const params = { name };
        const btnConfig = Object.assign(createListDesignActionButton({ code: name }), createListDesignSettingActionButtonConfig(params));
        if (btnConfig.type === "custom") {
          customConfigList.push(btnConfig);
        } else {
          systemConfigList.push(btnConfig);
        }
      }
    });
    const configToSearchItems = (searchItems) => {
      if (searchItems && searchItems.length) {
        const data = {};
        const items = searchItems.map((item) => {
          data[item.field] = null;
          return {
            field: item.field,
            title: item.title,
            folding: item.folding,
            itemRender: item.itemRender
          };
        });
        items.push({
          field: "active",
          title: "",
          folding: false,
          collapseNode: searchItems.some((item) => item.folding),
          itemRender: {
            name: "VxeButtonGroup",
            options: [
              { content: "查询", icon: "vxe-icon-search", status: "primary", type: "submit" },
              { content: "重置", icon: "vxe-icon-repeat", type: "reset" }
            ]
          }
        });
        return {
          items,
          data
        };
      }
      return { items: [], data: {} };
    };
    const configToListColumns = (listColumns) => {
      if (listColumns) {
        return listColumns.map((item) => {
          return {
            field: item.field,
            title: item.title,
            visible: !!item.visible,
            width: item.width,
            cellRender: import_xe_utils80.default.clone(item.cellRender)
          };
        });
      }
      return [];
    };
    const clearConfig = () => {
      emit("update:formData", {});
      Object.assign(reactData, {
        formConfig: {},
        searchFormData: {},
        searchFormItems: [],
        listTableColumns: [],
        tableColumns: [],
        footerData: [
          {}
          // 默认一行合计
        ]
      });
      return nextTick();
    };
    const loadConfig = (config2) => {
      if (config2) {
        const { formConfig, searchItems, listColumns } = config2;
        reactData.formConfig = formConfig || {};
        setSearchItems(searchItems || []);
        loadListColumns(listColumns || []);
      }
      return nextTick();
    };
    const parseForm = (searchItems) => {
      return configToSearchItems(searchItems || []);
    };
    const parseTableColumn = (listColumns, formConfig) => {
      const formOpts = Object.assign({}, formConfig);
      const { showSeq, actionButtonList } = formOpts;
      const columns = [];
      const rowRecord = {};
      const cellActionSlot = slots.cellAction;
      const footerCellSlot = slots.footerCell;
      if (showSeq) {
        columns.push({
          type: "seq",
          field: "_seq",
          fixed: "left",
          width: 70
        });
      }
      configToListColumns(listColumns || []).forEach((conf) => {
        const columnConf = Object.assign({}, conf);
        if (formOpts.showStatistics && footerCellSlot) {
          columnConf.slots = {
            footer: (params) => {
              return footerCellSlot(Object.assign({}, params));
            }
          };
        }
        if (columnConf.field) {
          rowRecord[columnConf.field] = null;
        }
        columns.push(columnConf);
      });
      if (actionButtonList && actionButtonList.length) {
        const actionColumn = {
          field: "_active",
          title: getI18n("vxe.table.actionTitle"),
          fixed: "right",
          width: "auto"
        };
        const btnOptions = [];
        actionButtonList.forEach((btnItem) => {
          if (btnItem.type === "custom") {
            return {
              content: btnItem.name,
              name: btnItem.code,
              icon: btnItem.icon
            };
          }
          const btnConfig = systemConfigList.find((item) => item.code === btnItem.code);
          let btnName = btnItem.name;
          let btnIcon = btnItem.icon;
          let btnStatus = btnItem.status;
          let btnPermissionCode = btnItem.permissionCode;
          let btnClassify = btnItem.classify;
          if (btnConfig) {
            const nameConfig = btnConfig.name;
            btnIcon = btnConfig.icon || "";
            btnStatus = btnConfig.status || "";
            btnPermissionCode = btnConfig.permissionCode || "";
            btnClassify = btnConfig.classify || "";
            btnName = import_xe_utils80.default.toValueString(import_xe_utils80.default.isFunction(nameConfig) ? nameConfig({ name: btnConfig.code || "" }) : nameConfig);
          }
          if (!btnClassify || btnClassify === "cellButton") {
            btnOptions.push({
              content: btnName,
              name: btnItem.code,
              icon: btnIcon,
              status: btnStatus,
              permissionCode: btnPermissionCode
            });
          }
        });
        if (cellActionSlot) {
          actionColumn.slots = {
            default(params) {
              return cellActionSlot(Object.assign(Object.assign({}, params), { buttons: btnOptions }));
            }
          };
        } else {
          actionColumn.cellRender = {
            name: "VxeButtonGroup",
            props: {
              mode: "text"
            },
            options: btnOptions,
            events: {
              click(params, btnParams) {
                const { option } = btnParams;
                dispatchEvent("cell-action", Object.assign(Object.assign({}, params), { button: option }), btnParams.$event);
              }
            }
          };
        }
        columns.push(actionColumn);
      }
      return { rowRecord, columns, actionButtons: actionButtonList };
    };
    const parseConfig = (config2) => {
      const { formConfig, searchItems, listColumns } = config2 || {};
      const { columns, rowRecord, actionButtons } = parseTableColumn(listColumns || [], formConfig || reactData.formConfig);
      const { data, items } = parseForm(searchItems || []);
      return {
        formData: data,
        formItems: items,
        tableColumns: columns,
        tableRecord: rowRecord,
        actionButtons
      };
    };
    const getTableRecord = (configOrListColumns) => {
      if (import_xe_utils80.default.isArray(configOrListColumns)) {
        const { rowRecord } = parseTableColumn(configOrListColumns, reactData.formConfig);
        return rowRecord;
      }
      if (configOrListColumns) {
        const { formConfig, listColumns } = configOrListColumns;
        const { rowRecord } = parseTableColumn(listColumns || [], formConfig || reactData.formConfig);
        return rowRecord;
      }
      return {};
    };
    const getQueryFilter = () => {
      const { searchFormData, searchFormItems } = reactData;
      const items = [];
      const rest = {
        items,
        type: "and"
      };
      const $grid = refGrid.value;
      if (!$grid) {
        return rest;
      }
      searchFormItems.forEach((item) => {
        const { field } = item;
        const itemValue = searchFormData[field];
        if (itemValue) {
          const condition = [];
          condition.push({
            field,
            value: itemValue,
            match: "exact",
            type: import_xe_utils80.default.isArray(itemValue) ? "array" : ""
          });
          items.push({
            condition,
            type: "and"
          });
        }
      });
      return rest;
    };
    const commitProxy = (code, ...args) => {
      const $grid = refGrid.value;
      if ($grid) {
        return $grid.commitProxy(code, ...args);
      }
      return Promise.resolve();
    };
    const loadListColumns = (listColumns) => {
      const { formConfig } = reactData;
      const listTableColumns = listColumns || [];
      const { columns, actionButtons } = parseTableColumn(listTableColumns, formConfig);
      reactData.listTableColumns = listTableColumns;
      reactData.tableColumns = columns;
      emit("update:actionButtons", actionButtons);
      nextTick(() => {
        const gridOptions = computeGridOptions.value;
        if (gridOptions.proxyConfig) {
          commitProxy("reload");
        }
      });
    };
    const setSearchItems = (searchItems) => {
      const { data, items } = configToSearchItems(searchItems);
      reactData.searchFormData = data;
      reactData.searchFormItems = items;
      emit("update:formData", data);
      return nextTick();
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $listView: $xeListView }, params));
    };
    const listViewMethods = {
      dispatchEvent,
      clearConfig,
      loadConfig,
      parseConfig,
      getTableRecord,
      getQueryFilter,
      commitProxy
    };
    const listViewPrivateMethods = {};
    Object.assign($xeListView, listViewMethods, listViewPrivateMethods);
    const renderVN = () => {
      const { height, loading: loading2 } = props;
      const vSize = computeSize.value;
      const gridSlot = slots.grid;
      const gridOptions = computeGridOptions.value;
      const gridEvents = computeGridEvents.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-list-view", {
          [`size--${vSize}`]: vSize,
          "is--loading": loading2
        }],
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [
        h("div", {
          class: "vxe-list-view--body"
        }, [
          gridSlot ? h("div", {
            class: "vxe-list-view--grid-wrapper"
          }, getSlotVNs(gridSlot({ $listView: $xeListView }))) : VxeTableGridComponent ? h(VxeTableGridComponent, Object.assign({}, gridOptions, gridEvents, {
            ref: refGrid
          }), Object.assign({}, slots, {
            default: void 0
          })) : createCommentVNode()
        ]),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-list-view--loading",
          modelValue: loading2
        })
      ]);
    };
    watch(() => props.config, (value) => {
      loadConfig(value || {});
    });
    if (props.config) {
      loadConfig(props.config);
    }
    provide("$xeListView", $xeListView);
    if (true) {
      nextTick(() => {
        if (!VxeTableGridComponent) {
          errLog("vxe.error.reqComp", ["vxe-grid"]);
        }
      });
    }
    $xeListView.renderVN = renderVN;
    return $xeListView;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/list-view/index.js
var VxeListView = Object.assign(list_view_default, {
  install: function(app) {
    app.component(list_view_default.name, list_view_default);
  }
});
dynamicApp.use(VxeListView);
VxeUI.component(list_view_default);
var ListView = VxeListView;
var list_view_default2 = VxeListView;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/list/src/list.js
var import_xe_utils81 = __toESM(require_xe_utils());
var list_default = defineComponent({
  name: "VxeList",
  props: {
    data: Array,
    height: [Number, String],
    maxHeight: [Number, String],
    loading: Boolean,
    className: [String, Function],
    size: { type: String, default: () => getConfig().list.size || getConfig().size },
    autoResize: { type: Boolean, default: () => getConfig().list.autoResize },
    syncResize: [Boolean, String, Number],
    virtualYConfig: Object,
    scrollY: Object
  },
  emits: [
    "scroll"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils81.default.uniqueId();
    const browseObj2 = import_xe_utils81.default.browse();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      scrollYLoad: false,
      bodyHeight: 0,
      customHeight: 0,
      customMaxHeight: 0,
      parentHeight: 0,
      topSpaceHeight: 0,
      items: []
    });
    const internalData = {
      resizeObserver: void 0,
      fullData: [],
      lastScrollLeft: 0,
      lastScrollTop: 0,
      scrollYStore: {
        startIndex: 0,
        endIndex: 0,
        visibleSize: 0,
        offsetSize: 0,
        rowHeight: 0
      }
    };
    const refElem = ref();
    const refVirtualWrapper = ref();
    const refVirtualBody = ref();
    const refMaps = {
      refElem
    };
    const $xeList = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const computeSYOpts = computed(() => {
      return Object.assign({}, getConfig().list.virtualYConfig || getConfig().list.scrollY, props.virtualYConfig || props.scrollY);
    });
    const computeStyles = computed(() => {
      const { height, maxHeight } = props;
      const { customHeight, customMaxHeight } = reactData;
      const style = {};
      if (height) {
        style.height = `${customHeight}px`;
      } else if (maxHeight) {
        style.height = "auto";
        style.maxHeight = `${customMaxHeight}px`;
      }
      return style;
    });
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $list: $xeList }, params));
    };
    const calcTableHeight = (key) => {
      const { parentHeight } = reactData;
      const val = props[key];
      let num = 0;
      if (val) {
        if (val === "100%" || val === "auto") {
          num = parentHeight;
        } else {
          if (isScale(val)) {
            num = Math.floor((import_xe_utils81.default.toInteger(val) || 1) / 100 * parentHeight);
          } else {
            num = import_xe_utils81.default.toNumber(val);
          }
          num = Math.max(40, num);
        }
      }
      return num;
    };
    const updateHeight = () => {
      reactData.customHeight = calcTableHeight("height");
      reactData.customMaxHeight = calcTableHeight("maxHeight");
    };
    const updateYSpace = () => {
      const { scrollYLoad } = reactData;
      const { scrollYStore, fullData } = internalData;
      reactData.bodyHeight = scrollYLoad ? fullData.length * scrollYStore.rowHeight : 0;
      reactData.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;
    };
    const handleData = () => {
      const { scrollYLoad } = reactData;
      const { fullData, scrollYStore } = internalData;
      reactData.items = scrollYLoad ? fullData.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullData.slice(0);
      return nextTick();
    };
    const updateYData = () => {
      handleData();
      updateYSpace();
    };
    const computeScrollLoad = () => {
      return nextTick().then(() => {
        const { scrollYLoad } = reactData;
        const { scrollYStore } = internalData;
        const virtualBodyElem = refVirtualBody.value;
        const sYOpts = computeSYOpts.value;
        let rowHeight = 0;
        let firstItemElem;
        if (virtualBodyElem) {
          if (sYOpts.sItem) {
            firstItemElem = virtualBodyElem.querySelector(sYOpts.sItem);
          }
          if (!firstItemElem) {
            firstItemElem = virtualBodyElem.children[0];
          }
        }
        if (firstItemElem) {
          rowHeight = firstItemElem.offsetHeight;
        }
        rowHeight = Math.max(12, rowHeight);
        scrollYStore.rowHeight = rowHeight;
        if (scrollYLoad) {
          const scrollBodyElem = refVirtualWrapper.value;
          const visibleYSize = Math.max(8, Math.ceil(scrollBodyElem.clientHeight / rowHeight));
          const offsetYSize = sYOpts.oSize ? import_xe_utils81.default.toNumber(sYOpts.oSize) : browseObj2.edge ? 10 : 0;
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex + visibleYSize + offsetYSize, scrollYStore.endIndex);
          updateYData();
        } else {
          updateYSpace();
        }
      });
    };
    const clearScroll = () => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        scrollBodyElem.scrollTop = 0;
      }
      return nextTick();
    };
    const scrollTo = (scrollLeft, scrollTop) => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (import_xe_utils81.default.isNumber(scrollLeft)) {
        scrollBodyElem.scrollLeft = scrollLeft;
      }
      if (import_xe_utils81.default.isNumber(scrollTop)) {
        scrollBodyElem.scrollTop = scrollTop;
      }
      if (reactData.scrollYLoad) {
        return new Promise((resolve) => {
          setTimeout(() => {
            nextTick(() => {
              resolve();
            });
          }, 50);
        });
      }
      return nextTick();
    };
    const refreshScroll = () => {
      const { lastScrollLeft, lastScrollTop } = internalData;
      return clearScroll().then(() => {
        if (lastScrollLeft || lastScrollTop) {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          return scrollTo(lastScrollLeft, lastScrollTop);
        }
      });
    };
    const recalculate = () => {
      const el = refElem.value;
      if (el) {
        const parentEl = el.parentElement;
        reactData.parentHeight = parentEl ? parentEl.clientHeight : 0;
        updateHeight();
        if (el.clientWidth && el.clientHeight) {
          return computeScrollLoad();
        }
      }
      return nextTick();
    };
    const loadYData = (evnt) => {
      const { scrollYStore } = internalData;
      const { startIndex, endIndex, visibleSize, offsetSize, rowHeight } = scrollYStore;
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);
      const offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          updateYData();
        }
      }
    };
    const scrollEvent = (evnt) => {
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = scrollBodyElem.scrollLeft;
      const isX = scrollLeft !== internalData.lastScrollLeft;
      const isY = scrollTop !== internalData.lastScrollTop;
      internalData.lastScrollTop = scrollTop;
      internalData.lastScrollLeft = scrollLeft;
      if (reactData.scrollYLoad) {
        loadYData(evnt);
      }
      dispatchEvent("scroll", { scrollLeft, scrollTop, isX, isY }, evnt);
    };
    const loadData = (datas) => {
      const { scrollYStore } = internalData;
      const sYOpts = computeSYOpts.value;
      const fullData = datas || [];
      Object.assign(scrollYStore, {
        startIndex: 0,
        endIndex: 1,
        visibleSize: 0
      });
      internalData.fullData = fullData;
      reactData.scrollYLoad = !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt <= fullData.length);
      handleData();
      return computeScrollLoad().then(() => {
        refreshScroll();
      });
    };
    const listMethods = {
      dispatchEvent,
      loadData,
      /**
       * 重新加载数据
       * @param {Array} datas 数据
       */
      reloadData(datas) {
        clearScroll();
        return loadData(datas);
      },
      recalculate,
      scrollTo,
      refreshScroll,
      clearScroll
    };
    Object.assign($xeList, listMethods);
    const dataFlag = ref(0);
    watch(() => props.data ? props.data.length : -1, () => {
      dataFlag.value++;
    });
    watch(() => props.data, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      loadData(props.data || []);
    });
    watch(() => props.height, () => {
      recalculate();
    });
    watch(() => props.maxHeight, () => {
      recalculate();
    });
    watch(() => props.syncResize, (value) => {
      if (value) {
        recalculate();
        nextTick(() => setTimeout(() => recalculate()));
      }
    });
    onActivated(() => {
      recalculate().then(() => refreshScroll());
    });
    nextTick(() => {
      loadData(props.data || []);
    });
    onMounted(() => {
      recalculate();
      if (props.autoResize) {
        const el = refElem.value;
        const resizeObserver = globalResize.create(() => recalculate());
        resizeObserver.observe(el);
        if (el) {
          resizeObserver.observe(el.parentElement);
        }
        internalData.resizeObserver = resizeObserver;
      }
      globalEvents.on($xeList, "resize", recalculate);
    });
    onUnmounted(() => {
      const { resizeObserver } = internalData;
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      globalEvents.off($xeList, "resize");
    });
    const renderVN = () => {
      const { className, loading: loading2 } = props;
      const { bodyHeight, topSpaceHeight, items } = reactData;
      const defaultSlot = slots.default;
      const vSize = computeSize.value;
      const styles = computeStyles.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-list", className ? import_xe_utils81.default.isFunction(className) ? className({ $list: $xeList }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--loading": loading2
        }]
      }, [
        h("div", {
          ref: refVirtualWrapper,
          class: "vxe-list--virtual-wrapper",
          style: styles,
          onScroll: scrollEvent
        }, [
          h("div", {
            class: "vxe-list--y-space",
            style: {
              height: bodyHeight ? `${bodyHeight}px` : ""
            }
          }),
          h("div", {
            ref: refVirtualBody,
            class: "vxe-list--body",
            style: {
              marginTop: topSpaceHeight ? `${topSpaceHeight}px` : ""
            }
          }, defaultSlot ? defaultSlot({ items, $list: $xeList }) : [])
        ]),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-list--loading",
          modelValue: loading2
        })
      ]);
    };
    $xeList.renderVN = renderVN;
    return $xeList;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/list/index.js
var VxeList = Object.assign(list_default, {
  install(app) {
    app.component(list_default.name, list_default);
  }
});
dynamicApp.use(VxeList);
VxeUI.component(list_default);
var List = VxeList;
var list_default2 = VxeList;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/menu/src/menu.js
var import_xe_utils82 = __toESM(require_xe_utils());
var menu_default = defineComponent({
  name: "VxeMenu",
  props: {
    modelValue: [String, Number],
    expandAll: Boolean,
    collapsed: {
      type: Boolean,
      default: null
    },
    collapseFixed: Boolean,
    loading: Boolean,
    options: {
      type: Array,
      default: () => []
    },
    size: {
      type: String,
      default: () => getConfig().image.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils82.default.uniqueId();
    const $xeLayoutAside = inject("$xeLayoutAside", null);
    const refElem = ref();
    const refCollapseElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: !!props.collapsed,
      isEnterCollapse: false,
      collapseStyle: {},
      collapseZindex: 0,
      activeName: props.modelValue,
      menuList: [],
      itemHeight: 1
    });
    const refMaps = {
      refElem
    };
    const computeIsCollapsed = computed(() => {
      const { collapsed } = props;
      if (import_xe_utils82.default.isBoolean(collapsed)) {
        return collapsed;
      }
      if ($xeLayoutAside) {
        return !!$xeLayoutAside.props.collapsed;
      }
      return false;
    });
    const computeCollapseWidth = computed(() => {
      let collapseWidth = "";
      if ($xeLayoutAside) {
        collapseWidth = $xeLayoutAside.props.collapseWidth || "";
      }
      return collapseWidth;
    });
    const computeCollapseEnterWidth = computed(() => {
      let width = "";
      if ($xeLayoutAside) {
        width = $xeLayoutAside.props.width || "";
      }
      return width;
    });
    const computeMaps = {
      computeSize
    };
    const $xeMenu = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getMenuTitle = (item) => {
      return `${item.title || item.name}`;
    };
    const updateZindex = () => {
      if (reactData.collapseZindex < getLastZIndex()) {
        reactData.collapseZindex = nextZIndex();
      }
    };
    const updateActiveMenu = (isDefExpand) => {
      const { activeName } = reactData;
      import_xe_utils82.default.eachTree(reactData.menuList, (item, index, items, path, parent, nodes) => {
        if (item.itemKey === activeName) {
          nodes.forEach((obj) => {
            obj.isActive = true;
            if (isDefExpand) {
              obj.isExpand = true;
            }
          });
          item.isExactActive = true;
        } else {
          item.isExactActive = false;
          item.isActive = false;
        }
      }, { children: "childList" });
    };
    const updateMenuConfig = () => {
      const { options, expandAll } = props;
      reactData.menuList = import_xe_utils82.default.mapTree(options, (item, index, items, path, parent) => {
        const objItem = Object.assign(Object.assign({}, item), { parentKey: parent ? parent.name || path.slice(0, path.length - 1).join(",") : "", level: path.length, itemKey: item.name || path.join(","), isExactActive: false, isActive: false, isExpand: import_xe_utils82.default.isBoolean(item.expanded) ? item.expanded : !!expandAll, hasChild: item.children && item.children.length > 0 });
        return objItem;
      }, { children: "children", mapChildren: "childList" });
    };
    const updateCollapseStyle = () => {
      const { collapseFixed } = props;
      if (collapseFixed) {
        nextTick(() => {
          const { isEnterCollapse } = reactData;
          const isCollapsed = computeIsCollapsed.value;
          const collapseEnterWidth = computeCollapseEnterWidth.value;
          const collapseWidth = computeCollapseWidth.value;
          const el = refElem.value;
          if (el) {
            const clientRect = el.getBoundingClientRect();
            const parentNode = el.parentNode;
            reactData.collapseStyle = isCollapsed ? {
              top: toCssUnit(clientRect.top),
              left: toCssUnit(clientRect.left),
              height: toCssUnit(parentNode.clientHeight),
              width: isEnterCollapse ? collapseEnterWidth ? toCssUnit(collapseEnterWidth) : "" : collapseWidth ? toCssUnit(collapseWidth) : "",
              zIndex: reactData.collapseZindex
            } : {};
          }
        });
      }
    };
    const handleCollapseMenu = () => {
      const { collapseFixed } = props;
      if (collapseFixed) {
        const { initialized } = reactData;
        const isCollapsed = computeIsCollapsed.value;
        if (isCollapsed) {
          if (!initialized) {
            reactData.initialized = true;
            nextTick(() => {
              const collapseEl = refCollapseElem.value;
              if (collapseEl) {
                document.body.appendChild(collapseEl);
              }
            });
          }
        }
        reactData.isEnterCollapse = false;
        updateZindex();
        updateCollapseStyle();
      }
    };
    const handleClickIconCollapse = (evnt, item) => {
      const { hasChild, isExpand } = item;
      if (hasChild) {
        evnt.stopPropagation();
        evnt.preventDefault();
        item.isExpand = !isExpand;
      }
    };
    const emitModel = (value) => {
      reactData.activeName = value;
      emit("update:modelValue", value);
    };
    const handleClickMenu = (evnt, item) => {
      const { itemKey, routerLink, hasChild } = item;
      if (routerLink) {
        emitModel(itemKey);
        handleMenuMouseleave();
      } else {
        if (hasChild) {
          handleClickIconCollapse(evnt, item);
        } else {
          emitModel(itemKey);
          handleMenuMouseleave();
        }
      }
      dispatchEvent("click", { menu: item }, evnt);
    };
    const handleMenuMouseenter = () => {
      const { collapseStyle } = reactData;
      const collapseEnterWidth = computeCollapseEnterWidth.value;
      reactData.collapseStyle = Object.assign({}, collapseStyle, {
        width: collapseEnterWidth ? toCssUnit(collapseEnterWidth) : ""
      });
      reactData.isEnterCollapse = true;
    };
    const handleMenuMouseleave = () => {
      const { collapseStyle } = reactData;
      const el = refElem.value;
      reactData.collapseStyle = Object.assign({}, collapseStyle, {
        width: el ? toCssUnit(el.offsetWidth) : ""
      });
      reactData.isEnterCollapse = false;
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils82.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils82.default.isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $menu: $xeMenu }, params));
    };
    const menuMethods = {
      dispatchEvent
    };
    const menuPrivateMethods = {};
    Object.assign($xeMenu, menuMethods, menuPrivateMethods);
    const renderMenuTitle = (item) => {
      const { icon, isExpand, hasChild, slots: itemSlots } = item;
      const optionSlot = itemSlots ? itemSlots.default : slots.option;
      const title = getMenuTitle(item);
      const isCollapsed = computeIsCollapsed.value;
      return [
        h("div", {
          class: "vxe-menu--item-link-icon"
        }, icon ? [
          h("i", {
            class: icon
          })
        ] : []),
        optionSlot ? h("div", {
          class: "vxe-menu--item-custom-title"
        }, callSlot(optionSlot, {
          option: item,
          collapsed: isCollapsed
        })) : h("div", {
          class: "vxe-menu--item-link-title",
          title
        }, title),
        hasChild ? h("div", {
          class: "vxe-menu--item-link-collapse",
          onClick(evnt) {
            handleClickIconCollapse(evnt, item);
          }
        }, [
          h("i", {
            class: isExpand ? getIcon().MENU_ITEM_EXPAND_OPEN : getIcon().MENU_ITEM_EXPAND_CLOSE
          })
        ]) : createCommentVNode()
      ];
    };
    const renderDefaultChildren = (item) => {
      const { itemKey, level, hasChild, isActive, isExactActive, isExpand, routerLink, childList } = item;
      const { isEnterCollapse } = reactData;
      const isCollapsed = computeIsCollapsed.value;
      if (item.permissionCode) {
        if (!permission.checkVisible(item.permissionCode)) {
          return createCommentVNode();
        }
      }
      return h("div", {
        key: itemKey,
        class: ["vxe-menu--item-wrapper", `vxe-menu--item-level${level}`, {
          "is--exact-active": isExactActive,
          "is--active": isActive,
          "is--expand": (!isCollapsed || isEnterCollapse) && isExpand
        }]
      }, [
        routerLink ? h(resolveComponent("router-link"), {
          class: "vxe-menu--item-link",
          to: routerLink,
          onClick(evnt) {
            handleClickMenu(evnt, item);
          }
        }, {
          default: () => renderMenuTitle(item)
        }) : h("div", {
          class: "vxe-menu--item-link",
          onClick(evnt) {
            handleClickMenu(evnt, item);
          }
        }, renderMenuTitle(item)),
        hasChild ? h("div", {
          class: "vxe-menu--item-group"
        }, childList.map((child) => renderDefaultChildren(child))) : createCommentVNode()
      ]);
    };
    const renderCollapseChildren = (item) => {
      const { itemKey, level, hasChild, isActive, isExactActive, routerLink, childList } = item;
      if (item.permissionCode) {
        if (!permission.checkVisible(item.permissionCode)) {
          return createCommentVNode();
        }
      }
      return h("div", {
        key: itemKey,
        class: ["vxe-menu--item-wrapper", `vxe-menu--item-level${level}`, {
          "is--exact-active": isExactActive,
          "is--active": isActive
        }]
      }, [
        routerLink ? h(resolveComponent("router-link"), {
          class: "vxe-menu--item-link",
          to: routerLink,
          onClick(evnt) {
            handleClickMenu(evnt, item);
          }
        }, {
          default: () => renderMenuTitle(item)
        }) : h("div", {
          class: "vxe-menu--item-link",
          onClick(evnt) {
            handleClickMenu(evnt, item);
          }
        }, renderMenuTitle(item)),
        hasChild ? h("div", {
          class: "vxe-menu--item-group"
        }, childList.map((child) => renderDefaultChildren(child))) : createCommentVNode()
      ]);
    };
    const renderVN = () => {
      const { loading: loading2 } = props;
      const { initialized, menuList, collapseStyle, isEnterCollapse } = reactData;
      const vSize = computeSize.value;
      const isCollapsed = computeIsCollapsed.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-menu", {
          [`size--${vSize}`]: vSize,
          "is--collapsed": isCollapsed,
          "is--loading": loading2
        }]
      }, [
        h("div", {
          class: "vxe-menu--item-list"
        }, menuList.map((child) => isCollapsed ? renderCollapseChildren(child) : renderDefaultChildren(child))),
        initialized ? h("div", {
          ref: refCollapseElem,
          class: ["vxe-menu--collapse-wrapper", {
            [`size--${vSize}`]: vSize,
            "is--collapsed": isCollapsed,
            "is--enter": isEnterCollapse,
            "is--loading": loading2
          }],
          style: collapseStyle,
          onMouseenter: handleMenuMouseenter,
          onMouseleave: handleMenuMouseleave
        }, [
          isCollapsed ? h("div", {
            class: "vxe-menu--item-list"
          }, menuList.map((child) => renderDefaultChildren(child))) : createCommentVNode()
        ]) : createCommentVNode(),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-list-view--loading",
          modelValue: loading2
        })
      ]);
    };
    const optFlag = ref(0);
    watch(() => props.options ? props.options.length : -1, () => {
      optFlag.value++;
    });
    watch(() => props.options, () => {
      optFlag.value++;
    });
    watch(optFlag, () => {
      updateMenuConfig();
      updateActiveMenu(true);
    });
    watch(() => props.modelValue, (val) => {
      reactData.activeName = val;
    });
    watch(() => reactData.activeName, () => {
      updateActiveMenu(true);
    });
    watch(computeIsCollapsed, () => {
      handleCollapseMenu();
    });
    onMounted(() => {
      globalEvents.on($xeMenu, "resize", updateCollapseStyle);
      updateCollapseStyle();
    });
    onBeforeUnmount(() => {
      globalEvents.off($xeMenu, "resize");
      const collapseEl = refCollapseElem.value;
      if (collapseEl) {
        const parentNode = collapseEl.parentNode;
        if (parentNode) {
          parentNode.removeChild(collapseEl);
        }
      }
    });
    updateMenuConfig();
    updateActiveMenu(true);
    $xeMenu.renderVN = renderVN;
    return $xeMenu;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/menu/index.js
var VxeMenu = Object.assign({}, menu_default, {
  install(app) {
    app.component(menu_default.name, menu_default);
  }
});
dynamicApp.use(VxeMenu);
VxeUI.component(menu_default);
var Menu = VxeMenu;
var menu_default2 = VxeMenu;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/notice-bar/src/notice-bar.js
var import_xe_utils83 = __toESM(require_xe_utils());
var notice_bar_default = defineComponent({
  name: "VxeNoticeBar",
  props: {
    duration: [String, Number],
    direction: {
      type: String,
      default: () => getConfig().noticeBar.direction
    },
    speed: {
      type: String,
      default: () => getConfig().noticeBar.speed
    },
    content: String,
    vertical: Boolean,
    loop: {
      type: Boolean
    },
    size: {
      type: String,
      default: () => getConfig().noticeBar.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils83.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refContentElem = ref();
    const reactData = reactive({
      animationDuration: 0
    });
    const refMaps = {
      refElem
    };
    const computeNoticeText = computed(() => {
      const { content } = props;
      return `${content || ""}`;
    });
    const computeMaps = {};
    const $xeNoticeBar = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $noticeBar: $xeNoticeBar }, params));
    };
    const noticeBarMethods = {
      dispatchEvent
    };
    const noticeBarPrivateMethods = {};
    const updateAnimationStyle = () => {
      const { speed } = props;
      const contEl = refContentElem.value;
      if (contEl) {
        let sRate = 46;
        if (speed === "fast") {
          sRate = 118;
        } else if (speed === "slow") {
          sRate = 18;
        }
        reactData.animationDuration = Math.ceil(contEl.scrollWidth / sRate);
      }
    };
    Object.assign($xeNoticeBar, noticeBarMethods, noticeBarPrivateMethods);
    const renderVN = () => {
      const { vertical, duration, direction } = props;
      const { animationDuration } = reactData;
      const vSize = computeSize.value;
      const noticeText = computeNoticeText.value;
      const defaultSlot = slots.default;
      const prefixSlot = slots.prefix;
      const suffixSlot = slots.suffix;
      return h("div", {
        ref: refElem,
        class: ["vxe-notice-bar", `is--${vertical ? "vertical" : "horizontal"}`, `dir--${direction || "left"}`, {
          [`size--${vSize}`]: vSize
        }]
      }, [
        prefixSlot ? h("div", {
          class: "vxe-notice-bar--prefix"
        }, prefixSlot({})) : renderEmptyElement($xeNoticeBar),
        h("div", {
          class: "vxe-notice-bar--content"
        }, [
          h("div", {
            ref: refContentElem,
            class: "vxe-notice-bar--inner"
          }, [
            h("div", {
              class: "vxe-notice-bar--wrapper",
              style: {
                animationDuration: `${duration ? toCssUnit(duration, "s") : animationDuration}s`
              }
            }, defaultSlot ? defaultSlot({}) : noticeText)
          ])
        ]),
        suffixSlot ? h("div", {
          class: "vxe-notice-bar--suffix"
        }, suffixSlot({})) : renderEmptyElement($xeNoticeBar)
      ]);
    };
    $xeNoticeBar.renderVN = renderVN;
    onMounted(() => {
      globalEvents.on($xeNoticeBar, "resize", updateAnimationStyle);
      updateAnimationStyle();
    });
    onBeforeUnmount(() => {
      globalEvents.off($xeNoticeBar, "resize");
    });
    return $xeNoticeBar;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/notice-bar/index.js
var VxeNoticeBar = Object.assign({}, notice_bar_default, {
  install(app) {
    app.component(notice_bar_default.name, notice_bar_default);
  }
});
dynamicApp.use(VxeNoticeBar);
VxeUI.component(notice_bar_default);
var NoticeBar = VxeNoticeBar;
var notice_bar_default2 = VxeNoticeBar;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/select/src/util.js
var import_xe_utils85 = __toESM(require_xe_utils());

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/select/src/option-info.js
var import_xe_utils84 = __toESM(require_xe_utils());
var OptionInfo = class {
  constructor($xeselect, _vm) {
    Object.assign(this, {
      id: import_xe_utils84.default.uniqueId("option_"),
      value: _vm.value,
      label: _vm.label,
      visible: _vm.visible,
      className: _vm.className,
      disabled: _vm.disabled
    });
  }
  update(name, value) {
    this[name] = value;
  }
};

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/select/src/util.js
function isOption(option) {
  return option instanceof OptionInfo;
}
function createOption($xeSelect, _vm) {
  return isOption(_vm) ? _vm : new OptionInfo($xeSelect, _vm);
}
function watchOption(props, option) {
  Object.keys(props).forEach((name) => {
    watch(() => props[name], (value) => {
      option.update(name, value);
    });
  });
}
function assembleOption($xeSelect, el, option, $xeOptgroup) {
  const { reactData } = $xeSelect;
  const { staticOptions } = reactData;
  const parentElem = el.parentNode;
  const parentOption = $xeOptgroup ? $xeOptgroup.optionConfig : null;
  const parentCols = parentOption ? parentOption.options : staticOptions;
  if (parentElem && parentCols) {
    parentCols.splice(import_xe_utils85.default.arrayIndexOf(parentElem.children, el), 0, option);
    reactData.staticOptions = staticOptions.slice(0);
  }
}
function destroyOption($xeSelect, option) {
  const { reactData } = $xeSelect;
  const { staticOptions } = reactData;
  const matchObj = import_xe_utils85.default.findTree(staticOptions, (item) => item.id === option.id, { children: "options" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  reactData.staticOptions = staticOptions.slice(0);
}

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/select/src/optgroup.js
var optgroup_default = defineComponent({
  name: "VxeOptgroup",
  props: {
    label: {
      type: [String, Number, Boolean],
      default: ""
    },
    visible: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    disabled: Boolean
  },
  emits: [],
  setup(props, { slots }) {
    const elem = ref();
    const $xeSelect = inject("$xeSelect", {});
    const optionConfig = createOption($xeSelect, props);
    const $xeOptgroup = { optionConfig };
    optionConfig.options = [];
    provide("$xeOptgroup", $xeOptgroup);
    watchOption(props, optionConfig);
    onMounted(() => {
      const el = elem.value;
      assembleOption($xeSelect, el, optionConfig);
    });
    onUnmounted(() => {
      destroyOption($xeSelect, optionConfig);
    });
    return () => {
      const defaultSlot = slots.default;
      return h("div", {
        ref: elem
      }, defaultSlot ? defaultSlot({}) : []);
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/optgroup/index.js
var VxeOptgroup = Object.assign(optgroup_default, {
  install: function(app) {
    app.component(optgroup_default.name, optgroup_default);
  }
});
dynamicApp.use(VxeOptgroup);
VxeUI.component(optgroup_default);
var Optgroup = VxeOptgroup;
var optgroup_default2 = VxeOptgroup;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/select/src/option.js
var option_default = defineComponent({
  name: "VxeOption",
  props: {
    value: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: ""
    },
    visible: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    disabled: Boolean
  },
  emits: [],
  setup(props, { slots }) {
    const elem = ref();
    const $xeSelect = inject("$xeSelect", {});
    const $xeOptgroup = inject("$xeOptgroup", null);
    const optionConfig = createOption($xeSelect, props);
    optionConfig.slots = slots;
    watchOption(props, optionConfig);
    onMounted(() => {
      const el = elem.value;
      assembleOption($xeSelect, el, optionConfig, $xeOptgroup);
    });
    onUnmounted(() => {
      destroyOption($xeSelect, optionConfig);
    });
    return () => {
      return h("div", {
        ref: elem
      });
    };
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/option/index.js
var VxeOption = Object.assign(option_default, {
  install: function(app) {
    app.component(option_default.name, option_default);
  }
});
dynamicApp.use(VxeOption);
VxeUI.component(option_default);
var Option = VxeOption;
var option_default2 = VxeOption;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/password-input/src/password-input.js
var import_xe_utils86 = __toESM(require_xe_utils());
var password_input_default = defineComponent({
  name: "VxePasswordInput",
  props: {
    modelValue: String,
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    clearable: {
      type: Boolean,
      default: () => getConfig().passwordInput.clearable
    },
    readonly: Boolean,
    disabled: Boolean,
    maxLength: [String, Number],
    placeholder: String,
    autoComplete: {
      type: String,
      default: "off"
    },
    className: String,
    size: {
      type: String,
      default: () => getConfig().passwordInput.size || getConfig().size
    },
    prefixIcon: String,
    suffixIcon: String,
    controls: {
      type: Boolean,
      default: () => getConfig().passwordInput.controls
    },
    // 已废弃
    autocomplete: String
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "click",
    "focus",
    "blur",
    "clear",
    "toggle-visible",
    "prefix-click",
    "suffix-click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils86.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      showPwd: false,
      isActivated: false,
      inputValue: props.modelValue
    });
    const refElem = ref();
    const refInputTarget = ref();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xePasswordInput = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let passwordInputMethods = {};
    const computeIsClearable = computed(() => {
      return props.clearable;
    });
    const computeInpReadonly = computed(() => {
      const { readonly } = props;
      return readonly;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().passwordInput.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseInput");
    });
    const computeInputType = computed(() => {
      const { showPwd } = reactData;
      if (showPwd) {
        return "text";
      }
      return "password";
    });
    const computeInpImmediate = computed(() => {
      const { immediate } = props;
      return immediate;
    });
    const triggerEvent = (evnt) => {
      const { inputValue } = reactData;
      passwordInputMethods.dispatchEvent(evnt.type, { value: inputValue }, evnt);
    };
    const emitInputEvent = (value, evnt) => {
      const inpImmediate = computeInpImmediate.value;
      reactData.inputValue = value;
      if (inpImmediate) {
        handleChange(value, evnt);
      } else {
        passwordInputMethods.dispatchEvent("input", { value }, evnt);
      }
    };
    const inputEvent = (evnt) => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      passwordInputMethods.dispatchEvent("input", { value }, evnt);
      if (import_xe_utils86.default.toValueString(props.modelValue) !== value) {
        passwordInputMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const changeEvent = (evnt) => {
      triggerEvent(evnt);
      const { inputValue } = reactData;
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, inputValue);
      }
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      triggerEvent(evnt);
    };
    const blurEvent = (evnt) => {
      const { inputValue } = reactData;
      const value = inputValue;
      passwordInputMethods.dispatchEvent("blur", { value }, evnt);
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const passwordToggleEvent = (evnt) => {
      const { readonly, disabled } = props;
      const { showPwd } = reactData;
      if (!disabled && !readonly) {
        reactData.showPwd = !showPwd;
      }
      passwordInputMethods.dispatchEvent("toggle-visible", { visible: reactData.showPwd }, evnt);
    };
    const clickEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const clearValueEvent = (evnt, value) => {
      focus();
      handleChange("", evnt);
      passwordInputMethods.dispatchEvent("clear", { value }, evnt);
    };
    const clickSuffixEvent = (evnt) => {
      const { disabled } = props;
      if (!disabled) {
        const { inputValue } = reactData;
        passwordInputMethods.dispatchEvent("suffix-click", { value: inputValue }, evnt);
      }
    };
    const clickPrefixEvent = (evnt) => {
      const { disabled } = props;
      if (!disabled) {
        const { inputValue } = reactData;
        passwordInputMethods.dispatchEvent("prefix-click", { value: inputValue }, evnt);
      }
    };
    const renderPasswordIcon = () => {
      const { showPwd } = reactData;
      return h("div", {
        class: "vxe-password-input--control-icon",
        onClick: passwordToggleEvent
      }, [
        h("i", {
          class: ["vxe-password-input--password-icon", showPwd ? getIcon().PASSWORD_INPUT_SHOW_PWD : getIcon().PASSWORD_INPUT_HIDE_PWD]
        })
      ]);
    };
    const renderPrefixIcon2 = () => {
      const { prefixIcon } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? h("div", {
        class: "vxe-password-input--prefix",
        onClick: clickPrefixEvent
      }, [
        h("div", {
          class: "vxe-password-input--prefix-icon"
        }, prefixSlot ? getSlotVNs(prefixSlot({})) : [
          h("i", {
            class: prefixIcon
          })
        ])
      ]) : null;
    };
    const renderSuffixIcon2 = () => {
      const { disabled, suffixIcon, controls } = props;
      const { inputValue } = reactData;
      const suffixSlot = slots.suffix;
      const isClearable = computeIsClearable.value;
      return isClearable || controls || suffixSlot || suffixIcon ? h("div", {
        class: ["vxe-password-input--suffix", {
          "is--clear": isClearable && !disabled && !(inputValue === "" || import_xe_utils86.default.eqNull(inputValue))
        }]
      }, [
        isClearable ? h("div", {
          class: "vxe-password-input--clear-icon",
          onClick: clearValueEvent
        }, [
          h("i", {
            class: getIcon().INPUT_CLEAR
          })
        ]) : createCommentVNode(),
        controls ? renderPasswordIcon() : createCommentVNode(),
        suffixSlot || suffixIcon ? h("div", {
          class: "vxe-password-input--suffix-icon",
          onClick: clickSuffixEvent
        }, suffixSlot ? getSlotVNs(suffixSlot({})) : [
          h("i", {
            class: suffixIcon
          })
        ]) : createCommentVNode()
      ]) : null;
    };
    passwordInputMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $passwordInput: $xePasswordInput }, params));
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return nextTick();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return nextTick();
      }
    };
    Object.assign($xePasswordInput, passwordInputMethods);
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
    });
    const renderVN = () => {
      const { className, name, disabled, readonly, autocomplete, autoComplete, maxLength } = props;
      const { inputValue, isActivated } = reactData;
      const vSize = computeSize.value;
      const inpReadonly = computeInpReadonly.value;
      const inputType = computeInputType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon2();
      const suffix = renderSuffixIcon2();
      return h("div", {
        ref: refElem,
        class: ["vxe-password-input", className, {
          [`size--${vSize}`]: vSize,
          "is--prefix": !!prefix,
          "is--suffix": !!suffix,
          "is--readonly": readonly,
          "is--disabled": disabled,
          "is--active": isActivated,
          "show--clear": isClearable && !disabled && !(inputValue === "" || import_xe_utils86.default.eqNull(inputValue))
        }],
        spellcheck: false
      }, [
        prefix || createCommentVNode(),
        h("div", {
          class: "vxe-password-input--wrapper"
        }, [
          h("input", {
            ref: refInputTarget,
            class: "vxe-password-input--inner",
            value: inputValue,
            name,
            type: inputType,
            placeholder: inpPlaceholder,
            readonly: inpReadonly,
            disabled,
            autocomplete: autocomplete || autoComplete,
            maxlength: maxLength,
            onClick: clickEvent,
            onInput: inputEvent,
            onChange: changeEvent,
            onFocus: focusEvent,
            onBlur: blurEvent
          })
        ]),
        suffix || createCommentVNode()
      ]);
    };
    $xePasswordInput.renderVN = renderVN;
    return $xePasswordInput;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/password-input/index.js
var VxePasswordInput = Object.assign({}, password_input_default, {
  install(app) {
    app.component(password_input_default.name, password_input_default);
  }
});
dynamicApp.use(VxePasswordInput);
VxeUI.component(password_input_default);
var PasswordInput = VxePasswordInput;
var password_input_default2 = VxePasswordInput;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/print/src/page-break.js
var import_xe_utils88 = __toESM(require_xe_utils());

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/print/src/util.js
var import_xe_utils87 = __toESM(require_xe_utils());
var browseObj = import_xe_utils87.default.browse();
var printFrame;
var defaultHtmlStyle = 'body{margin:0;padding:0;color:#000000;font-size:14px;font-family:"Microsoft YaHei",微软雅黑,"MicrosoftJhengHei",华文细黑,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type="checkbox"]{margin:0}.vxe-table input[type="checkbox"],.vxe-table input[type="radio"],.vxe-table input[type="checkbox"]+span,.vxe-table input[type="radio"]+span{vertical-align:middle;padding-left:0.4em}';
function createPrintFrame() {
  const frame = document.createElement("iframe");
  frame.className = "vxe-table--print-frame";
  return frame;
}
function appendPrintFrame() {
  if (!printFrame.parentNode) {
    document.body.appendChild(printFrame);
  }
}
function afterPrintEvent() {
  requestAnimationFrame(removeFrame);
}
function removeFrame() {
  if (printFrame) {
    if (printFrame.parentNode) {
      try {
        printFrame.contentDocument.write("");
      } catch (e) {
      }
      printFrame.parentNode.removeChild(printFrame);
    }
    printFrame = null;
  }
}
function getExportBlobByString(str, type) {
  return new Blob([str], { type: `text/${type};charset=utf-8;` });
}
var printMargin = 80;
function createHtmlPage(opts, printHtml2) {
  const { customStyle } = opts;
  return [
    "<!DOCTYPE html><html>",
    "<head>",
    '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">',
    `<title>${opts.title || ""}</title>`,
    opts._pageBreaks || opts.pageBreaks && opts.pageBreaks.length ? '<style media="print">@page {size: auto;margin: 0mm;}</style>' : "",
    `<style>.vxe-print-slots{display: none;}.vxe-print-page-break.align--center{text-align:center;}.vxe-print-page-break.align--left{text-align:left;}.vxe-print-page-break.align--right{text-align:right;}.vxe-print-page-break--header-title{font-size:1.8em;text-align:center;line-height:${printMargin}px;}.vxe-print-page-break{page-break-before:always;display:flex;flex-direction:column;height:100vh;overflow:hidden;}.vxe-print-page-break--body{display:flex;flex-direction:row;flex-grow:1;overflow: hidden;}.vxe-print-page-break--left,.vxe-print-page-break--right{flex-shrink:0;width:${printMargin}px;height:100%;}.vxe-print-page-break--header,.vxe-print-page-break--footer{flex-shrink:0;height:${printMargin}px;width:100%;}.vxe-print-page-break--content{flex-grow: 1;overflow: hidden;}.vxe-print-page-break--footer-page-number{line-height:${printMargin}px;text-align:center;}</style>`,
    "<style>.vxe-table{white-space:pre;}</style>",
    `<style>${defaultHtmlStyle}</style>`,
    customStyle ? `<style>${customStyle}</style>` : "",
    "</head>",
    "<body>",
    `${printHtml2}`,
    "</body>",
    "</html>"
  ].join("");
}
function handlePrint(opts, printHtml2 = "") {
  const { beforeMethod } = opts;
  if (beforeMethod) {
    printHtml2 = beforeMethod({ content: printHtml2, html: printHtml2, options: opts }) || "";
  }
  printHtml2 = createHtmlPage(opts, printHtml2);
  const blob = getExportBlobByString(printHtml2, "html");
  return new Promise((resolve) => {
    if (browseObj.msie) {
      removeFrame();
      printFrame = createPrintFrame();
      appendPrintFrame();
      printFrame.contentDocument.write(printHtml2);
      printFrame.contentDocument.execCommand("print");
      setTimeout(() => {
        resolve({
          status: true
        });
      }, 300);
    } else {
      if (!printFrame) {
        printFrame = createPrintFrame();
        printFrame.onload = (evnt) => {
          if (evnt.target.src) {
            evnt.target.contentWindow.onafterprint = afterPrintEvent;
            evnt.target.contentWindow.print();
          }
          resolve({
            status: true
          });
        };
        printFrame.onerror = () => {
          resolve({
            status: false
          });
        };
      }
      appendPrintFrame();
      printFrame.src = URL.createObjectURL(blob);
    }
  });
}
function createPageBreak(opts) {
  const { title, showPageNumber, align, headerAlign, footerAlign, showAllPageTitle } = opts;
  const pageBreaks = opts.pageBreaks || [];
  const pageCount = pageBreaks.length;
  return pageBreaks.map((item, index) => {
    const bodyHtml = item.bodyHtml;
    const headerHtml = item.headerHtml || opts.headerHtml;
    const footerHtml = item.footerHtml || opts.footerHtml;
    const leftHtml = item.leftHtml || opts.leftHtml;
    const rightHtml = item.rightHtml || opts.rightHtml;
    const currentPage = index + 1;
    const params = {
      currentPage,
      pageCount
    };
    return [
      `<div class="${["vxe-print-page-break", align ? `align--${align}` : ""].join(" ")}">`,
      `<div class="${["vxe-print-page-break--header", headerAlign ? `align--${headerAlign}` : ""].join(" ")}">`,
      headerHtml ? `${import_xe_utils87.default.isFunction(headerHtml) ? headerHtml(params) : headerHtml || ""}` : title && (showAllPageTitle || !index) ? `<div class="vxe-print-page-break--header-title">${title || ""}</div>` : "",
      "</div>",
      '<div class="vxe-print-page-break--body">',
      `<div class="vxe-print-page-break--left">${import_xe_utils87.default.isFunction(leftHtml) ? leftHtml(params) : leftHtml || ""}</div>`,
      `<div class="vxe-print-page-break--content">${import_xe_utils87.default.isFunction(bodyHtml) ? bodyHtml(params) : bodyHtml || ""}</div>`,
      `<div class="vxe-print-page-break--right">${import_xe_utils87.default.isFunction(rightHtml) ? rightHtml(params) : rightHtml || ""}</div>`,
      "</div>",
      `<div class="${["vxe-print-page-break--footer", footerAlign ? `align--${footerAlign}` : ""].join(" ")}">`,
      footerHtml ? `${import_xe_utils87.default.isFunction(footerHtml) ? footerHtml(params) : footerHtml || ""}` : showPageNumber ? `<div class="vxe-print-page-break--footer-page-number">${currentPage}/${pageCount}</div>` : "",
      "</div>",
      "</div>"
    ].join("");
  }).join("");
}
var printHtml = (options) => {
  const opts = Object.assign({ _pageBreaks: false, customLayout: true }, options);
  if (opts.sheetName) {
    opts.title = opts.title || opts.sheetName;
  }
  if (opts.style) {
    opts.customStyle = opts.customStyle || opts.style;
  }
  if (opts.beforePrintMethod) {
    opts.beforeMethod = opts.beforeMethod || opts.beforePrintMethod;
  }
  if (opts.pageBreaks && opts.pageBreaks.length) {
    return handlePrint(opts, createPageBreak(opts));
  }
  const printHtml2 = opts.html || opts.content;
  return handlePrint(opts, printHtml2);
};
function assemblePageBreak($xePageBreak, elem, pageBreakConfig) {
  const staticPageBreaks = $xePageBreak.reactData.staticPageBreaks;
  const parentElem = elem.parentNode;
  if (parentElem && staticPageBreaks) {
    staticPageBreaks.splice(import_xe_utils87.default.arrayIndexOf(parentElem.children, elem), 0, pageBreakConfig);
    $xePageBreak.reactData.staticPageBreaks = staticPageBreaks.slice(0);
  }
}
function destroyPageBreak($xePageBreak, pageBreakConfig) {
  $xePageBreak.reactData.staticPageBreaks = $xePageBreak.reactData.staticPageBreaks.filter((item) => item.id !== pageBreakConfig.id);
}

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/print/src/page-break.js
var page_break_default = defineComponent({
  name: "VxePrintPageBreak",
  props: {},
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils88.default.uniqueId();
    const $xePrint = inject("$xePrint", null);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const pageBreakConfig = reactive({
      id: xID,
      slots
    });
    const $xePrintPageBreak = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $print: $xePrint }, params));
    };
    const printPageBreakMethods = {
      dispatchEvent
    };
    const printPageBreakPrivateMethods = {};
    Object.assign($xePrintPageBreak, printPageBreakMethods, printPageBreakPrivateMethods);
    if (!$xePrint) {
      $xePrintPageBreak.renderVN = () => {
        return createCommentVNode();
      };
      return $xePrintPageBreak;
    }
    const renderVN = () => {
      return h("div", {
        ref: refElem
      });
    };
    onMounted(() => {
      const elem = refElem.value;
      if ($xePrint && elem) {
        assemblePageBreak($xePrint, elem, pageBreakConfig);
      }
    });
    onUnmounted(() => {
      if ($xePrint) {
        destroyPageBreak($xePrint, pageBreakConfig);
      }
    });
    $xePrintPageBreak.renderVN = renderVN;
    return $xePrintPageBreak;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/print-page-break/index.js
var VxePrintPageBreak = Object.assign({}, page_break_default, {
  install(app) {
    app.component(page_break_default.name, page_break_default);
  }
});
dynamicApp.use(VxePrintPageBreak);
VxeUI.component(page_break_default);
var PrintPageBreak = VxePrintPageBreak;
var print_page_break_default = VxePrintPageBreak;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/print/src/print.js
var import_xe_utils89 = __toESM(require_xe_utils());
var print_default = defineComponent({
  name: "VxePrint",
  props: {
    align: {
      type: String,
      default: () => getConfig().print.align
    },
    title: String,
    headerAlign: {
      type: String,
      default: () => getConfig().print.headerAlign
    },
    footerAlign: {
      type: String,
      default: () => getConfig().print.footerAlign
    },
    showPageNumber: {
      type: Boolean,
      default: () => getConfig().print.showPageNumber
    },
    customLayout: Boolean,
    pageBreaks: Array,
    content: String,
    html: String,
    headerHtml: String,
    footerHtml: String,
    leftHtml: String,
    rightHtml: String,
    showAllPageTitle: {
      type: Boolean,
      default: () => getConfig().print.showAllPageTitle
    },
    customStyle: {
      type: String,
      default: () => getConfig().print.customStyle
    },
    beforeMethod: Function
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils89.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({
      staticPageBreaks: []
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xePrint = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $print: $xePrint }, params));
    };
    const printMethods = {
      dispatchEvent,
      print() {
        const elem = refElem.value;
        return printHtml(Object.assign({}, props, {
          _pageBreaks: !!reactData.staticPageBreaks.length,
          html: (elem ? elem.outerHTML : "") || props.html || props.content || ""
        }));
      }
    };
    const printPrivateMethods = {};
    Object.assign($xePrint, printMethods, printPrivateMethods);
    const renderPageConfigLayouts = () => {
      const { title, showPageNumber, showAllPageTitle, align, headerAlign, footerAlign } = props;
      const pageBreaks = props.pageBreaks || [];
      const pageCount = pageBreaks.length;
      return pageBreaks.map((item, index) => {
        const bodyHtml = item.bodyHtml;
        const headerHtml = item.headerHtml || props.headerHtml;
        const footerHtml = item.footerHtml || props.footerHtml;
        const leftHtml = item.leftHtml || props.leftHtml;
        const rightHtml = item.rightHtml || props.rightHtml;
        const currentPage = index + 1;
        const params = {
          currentPage,
          pageCount
        };
        return h("div", {
          class: ["vxe-print-page-break", align ? `align--${align}` : ""]
        }, [
          h("div", {
            class: ["vxe-print-page-break--header", headerAlign ? `align--${headerAlign}` : ""]
          }, headerHtml ? `${import_xe_utils89.default.isFunction(headerHtml) ? headerHtml(params) : headerHtml || ""}` : [
            title && (showAllPageTitle || !index) ? h("div", {
              class: "vxe-print-page-break--header-title"
            }, `${title || ""}`) : createCommentVNode()
          ]),
          h("div", {
            class: "vxe-print-page-break--body"
          }, [
            h("div", {
              class: "vxe-print-page-break--left"
            }, `${import_xe_utils89.default.isFunction(leftHtml) ? leftHtml(params) : leftHtml || ""}`),
            h("div", {
              class: "vxe-print-page-break--content"
            }, `${import_xe_utils89.default.isFunction(bodyHtml) ? bodyHtml(params) : bodyHtml || ""}`),
            h("div", {
              class: "vxe-print-page-break--right"
            }, `${import_xe_utils89.default.isFunction(rightHtml) ? rightHtml(params) : rightHtml || ""}`)
          ]),
          h("div", {
            class: ["vxe-print-page-break--footer", footerAlign ? `align--${footerAlign}` : ""]
          }, footerHtml ? `${import_xe_utils89.default.isFunction(footerHtml) ? footerHtml(params) : footerHtml || ""}` : [
            showPageNumber ? h("div", {
              class: "vxe-print-page-break--footer-page-number"
            }, `${currentPage}/${pageCount}`) : createCommentVNode()
          ])
        ]);
      });
    };
    const renderPageStaticLayouts = () => {
      const { title, showPageNumber, showAllPageTitle, align, headerAlign, footerAlign } = props;
      const { staticPageBreaks } = reactData;
      const pageCount = staticPageBreaks.length;
      return staticPageBreaks.map((item, index) => {
        const itemSlots = item.slots || {};
        const currentPage = index + 1;
        const defaultSlot = itemSlots.default;
        const headerSlot = itemSlots.header || slots.header;
        const footerSlot = itemSlots.footer || slots.footer;
        const leftSlot = itemSlots.left || slots.left;
        const rightSlot = itemSlots.right || slots.right;
        const params = {
          currentPage,
          pageCount
        };
        return h("div", {
          class: ["vxe-print-page-break", align ? `align--${align}` : ""]
        }, [
          h("div", {
            class: ["vxe-print-page-break--header", headerAlign ? `align--${headerAlign}` : ""]
          }, headerSlot ? getSlotVNs(headerSlot(params)) : [
            title && (showAllPageTitle || !index) ? h("div", {
              class: "vxe-print-page-break--header-title"
            }, `${title || ""}`) : createCommentVNode()
          ]),
          h("div", {
            class: "vxe-print-page-break--body"
          }, [
            h("div", {
              class: "vxe-print-page-break--left"
            }, leftSlot ? getSlotVNs(leftSlot(params)) : []),
            h("div", {
              class: "vxe-print-page-break--content"
            }, defaultSlot ? getSlotVNs(defaultSlot(params)) : []),
            h("div", {
              class: "vxe-print-page-break--right"
            }, rightSlot ? getSlotVNs(rightSlot(params)) : [])
          ]),
          h("div", {
            class: ["vxe-print-page-break--footer", footerAlign ? `align--${footerAlign}` : ""]
          }, footerSlot ? getSlotVNs(footerSlot(params)) : [
            showPageNumber ? h("div", {
              class: "vxe-print-page-break--footer-page-number"
            }, `${currentPage}/${pageCount}`) : createCommentVNode()
          ])
        ]);
      });
    };
    const renderVN = () => {
      const { customLayout } = props;
      const { staticPageBreaks } = reactData;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-print"]
      }, customLayout ? defaultSlot ? getSlotVNs(defaultSlot({})) : [] : [
        h("div", {
          key: "slot",
          class: "vxe-print-slots"
        }, defaultSlot ? getSlotVNs(defaultSlot({})) : [])
      ].concat(staticPageBreaks.length ? renderPageStaticLayouts() : renderPageConfigLayouts()));
    };
    $xePrint.renderVN = renderVN;
    provide("$xePrint", $xePrint);
    return $xePrint;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/print/index.js
var VxePrint = Object.assign({}, print_default, {
  install(app) {
    app.component(print_default.name, print_default);
  }
});
dynamicApp.use(VxePrint);
VxeUI.component(print_default);
VxeUI.print = printHtml;
var Print = VxePrint;
var print_default2 = VxePrint;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/pulldown/src/pulldown.js
var import_xe_utils90 = __toESM(require_xe_utils());
var pulldown_default = defineComponent({
  name: "VxePulldown",
  props: {
    modelValue: Boolean,
    disabled: Boolean,
    placement: String,
    trigger: {
      type: String,
      default: getConfig().pulldown.trigger
    },
    size: { type: String, default: () => getConfig().size },
    options: Array,
    className: {
      type: [String, Function],
      default: getConfig().pulldown.className
    },
    popupClassName: [String, Function],
    showPopupShadow: Boolean,
    destroyOnClose: {
      type: Boolean,
      default: getConfig().pulldown.destroyOnClose
    },
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "click",
    "option-click",
    "show-panel",
    "hide-panel",
    "visible-change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const xID = import_xe_utils90.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      hpTimeout: void 0
    };
    const refElem = ref();
    const refPulldownContent = ref();
    const refPulldownPanel = ref();
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().pulldown.transfer;
        if (import_xe_utils90.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const refMaps = {
      refElem
    };
    const $xePulldown = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let pulldownMethods = {};
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const isPanelVisible = () => {
      return reactData.visiblePanel;
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex, visiblePanel } = reactData;
        const btnTransfer = computeBtnTransfer.value;
        if (visiblePanel) {
          const targetElem = refPulldownContent.value;
          const panelElem = refPulldownPanel.value;
          if (panelElem && targetElem) {
            const targetHeight = targetElem.offsetHeight;
            const targetWidth = targetElem.offsetWidth;
            const panelHeight = panelElem.offsetHeight;
            const panelWidth = panelElem.offsetWidth;
            const marginSize = 5;
            const panelStyle = {
              zIndex: panelIndex
            };
            const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(targetElem);
            let panelPlacement = "bottom";
            if (btnTransfer) {
              let left = boundingLeft;
              let top = boundingTop + targetHeight;
              if (placement === "top") {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              } else if (!placement) {
                if (top + panelHeight + marginSize > visibleHeight) {
                  panelPlacement = "top";
                  top = boundingTop - panelHeight;
                }
                if (top < marginSize) {
                  panelPlacement = "bottom";
                  top = boundingTop + targetHeight;
                }
              }
              if (left + panelWidth + marginSize > visibleWidth) {
                left -= left + panelWidth + marginSize - visibleWidth;
              }
              if (left < marginSize) {
                left = marginSize;
              }
              Object.assign(panelStyle, {
                left: `${left}px`,
                top: `${top}px`,
                minWidth: `${targetWidth}px`
              });
            } else {
              if (placement === "top") {
                panelPlacement = "top";
                panelStyle.bottom = `${targetHeight}px`;
              } else if (!placement) {
                if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                  if (boundingTop - targetHeight - panelHeight > marginSize) {
                    panelPlacement = "top";
                    panelStyle.bottom = `${targetHeight}px`;
                  }
                }
              }
            }
            reactData.panelStyle = panelStyle;
            reactData.panelPlacement = panelPlacement;
          }
        }
        return nextTick();
      });
    };
    const showPanel = () => {
      if (!reactData.initialized) {
        reactData.initialized = true;
      }
      return new Promise((resolve) => {
        if (!props.disabled) {
          if (internalData.hpTimeout) {
            clearTimeout(internalData.hpTimeout);
          }
          reactData.isActivated = true;
          reactData.isAniVisible = true;
          setTimeout(() => {
            reactData.visiblePanel = true;
            emit("update:modelValue", true);
            updatePlacement();
            setTimeout(() => {
              resolve(updatePlacement());
            }, 40);
          }, 10);
          updateZindex();
          dispatchEvent("visible-change", { visible: true }, null);
        } else {
          nextTick(() => {
            resolve();
          });
        }
      });
    };
    const hidePanel = () => {
      reactData.visiblePanel = false;
      dispatchEvent("visible-change", { visible: false }, null);
      emit("update:modelValue", false);
      return new Promise((resolve) => {
        if (reactData.isAniVisible) {
          internalData.hpTimeout = setTimeout(() => {
            reactData.isAniVisible = false;
            nextTick(() => {
              resolve();
            });
          }, 350);
        } else {
          nextTick(() => {
            resolve();
          });
        }
      });
    };
    const togglePanel = () => {
      if (reactData.visiblePanel) {
        return hidePanel();
      }
      return showPanel();
    };
    const handleOptionEvent = (evnt, option) => {
      if (!option.disabled) {
        if (reactData.visiblePanel) {
          hidePanel();
          dispatchEvent("hide-panel", {}, evnt);
        }
        dispatchEvent("option-click", { option }, evnt);
      }
    };
    const clickTargetEvent = (evnt) => {
      const { trigger } = props;
      if (trigger === "click") {
        if (reactData.visiblePanel) {
          hidePanel();
          dispatchEvent("hide-panel", {}, evnt);
        } else {
          showPanel();
          dispatchEvent("show-panel", {}, evnt);
        }
      }
      dispatchEvent("click", { $pulldown: $xePulldown }, evnt);
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      const panelElem = refPulldownPanel.value;
      if (!disabled) {
        if (visiblePanel) {
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            dispatchEvent("hide-panel", {}, evnt);
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      const el = refElem.value;
      const panelElem = refPulldownPanel.value;
      if (!disabled) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hidePanel();
          dispatchEvent("hide-panel", {}, evnt);
        }
      }
    };
    const handleGlobalBlurEvent = (evnt) => {
      if (reactData.visiblePanel) {
        reactData.isActivated = false;
        hidePanel();
        dispatchEvent("hide-panel", {}, evnt);
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $pulldown: $xePulldown }, params));
    };
    pulldownMethods = {
      dispatchEvent,
      isPanelVisible,
      togglePanel,
      showPanel,
      hidePanel
    };
    Object.assign($xePulldown, pulldownMethods);
    watch(() => props.modelValue, (value) => {
      reactData.isActivated = !!value;
      if (value) {
        showPanel();
      } else {
        hidePanel();
      }
    });
    nextTick(() => {
      if (props.modelValue) {
        showPanel();
      }
      globalEvents.on($xePulldown, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xePulldown, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xePulldown, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xePulldown, "mousewheel");
      globalEvents.off($xePulldown, "mousedown");
      globalEvents.off($xePulldown, "blur");
    });
    const renderDefaultPanel = (options) => {
      const optionSlot = slots.option;
      return h("div", {
        class: "vxe-pulldown--panel-list"
      }, options ? options.map((item) => {
        return h("div", {
          class: "vxe-pulldown--panel-item",
          onClick(evnt) {
            handleOptionEvent(evnt, item);
          }
        }, optionSlot ? optionSlot({ $pulldown: $xePulldown, option: item }) : `${item.label || ""}`);
      }) : []);
    };
    const renderVN = () => {
      const { className, options, popupClassName, showPopupShadow, destroyOnClose, disabled } = props;
      const { initialized, isActivated, isAniVisible, visiblePanel, panelStyle, panelPlacement } = reactData;
      const btnTransfer = computeBtnTransfer.value;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const dropdownSlot = slots.dropdown;
      return h("div", {
        ref: refElem,
        class: ["vxe-pulldown", className ? import_xe_utils90.default.isFunction(className) ? className({ $pulldown: $xePulldown }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--visible": visiblePanel,
          "is--disabled": disabled,
          "is--active": isActivated
        }]
      }, [
        h("div", {
          ref: refPulldownContent,
          class: "vxe-pulldown--content",
          onClick: clickTargetEvent
        }, defaultSlot ? defaultSlot({ $pulldown: $xePulldown }) : []),
        h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refPulldownPanel,
            class: ["vxe-table--ignore-clear vxe-pulldown--panel", popupClassName ? import_xe_utils90.default.isFunction(popupClassName) ? popupClassName({ $pulldown: $xePulldown }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--shadow": showPopupShadow,
              "is--transfer": btnTransfer,
              "ani--leave": isAniVisible,
              "ani--enter": visiblePanel
            }],
            placement: panelPlacement,
            style: panelStyle
          }, [
            h("div", {
              class: "vxe-pulldown--panel-wrapper"
            }, initialized && (destroyOnClose ? visiblePanel || isAniVisible : true) ? [
              headerSlot ? h("div", {
                class: "vxe-pulldown--panel-header"
              }, headerSlot({ $pulldown: $xePulldown })) : createCommentVNode(),
              h("div", {
                class: "vxe-pulldown--panel-body"
              }, dropdownSlot ? dropdownSlot({ $pulldown: $xePulldown }) : [
                renderDefaultPanel(options)
              ]),
              footerSlot ? h("div", {
                class: "vxe-pulldown--panel-footer"
              }, footerSlot({ $pulldown: $xePulldown })) : createCommentVNode()
            ] : [])
          ])
        ])
      ]);
    };
    $xePulldown.renderVN = renderVN;
    return $xePulldown;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/pulldown/index.js
var VxePulldown = Object.assign(pulldown_default, {
  install: function(app) {
    app.component(pulldown_default.name, pulldown_default);
  }
});
dynamicApp.use(VxePulldown);
VxeUI.component(pulldown_default);
var Pulldown = VxePulldown;
var pulldown_default2 = VxePulldown;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/radio/index.js
var VxeRadio = Object.assign(radio_default, {
  install: function(app) {
    app.component(radio_default.name, radio_default);
  }
});
dynamicApp.use(VxeRadio);
VxeUI.component(radio_default);
var Radio = VxeRadio;
var radio_default2 = VxeRadio;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/radio-button/index.js
var VxeRadioButton = Object.assign(button_default3, {
  install: function(app) {
    app.component(button_default3.name, button_default3);
  }
});
dynamicApp.use(VxeRadioButton);
VxeUI.component(button_default3);
var RadioButton = VxeRadioButton;
var radio_button_default = VxeRadioButton;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/rate/index.js
var VxeRate = Object.assign({}, rate_default, {
  install(app) {
    app.component(rate_default.name, rate_default);
  }
});
dynamicApp.use(VxeRate);
VxeUI.component(rate_default);
var Rate = VxeRate;
var rate_default2 = VxeRate;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/result/src/result.js
var import_xe_utils91 = __toESM(require_xe_utils());
var result_default = defineComponent({
  name: "VxeResult",
  props: {
    imageUrl: String,
    imageStyle: Object,
    icon: String,
    type: [String, Number],
    status: [String, Number],
    title: [String, Number],
    content: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils91.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeResult = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $result: $xeResult }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeResult, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const { imageUrl, imageStyle, icon, title, type, content } = props;
      const status = props.status || type;
      const slotExtra = slots.extra;
      return h("div", {
        ref: "refElem",
        class: ["vxe-result", {
          [`theme--${status}`]: status
        }]
      }, [
        h("div", {
          class: "vxe-result--inner"
        }, [
          imageUrl ? h("div", {
            class: "vxe-result--img-wrapper"
          }, [
            h("img", {
              src: imageUrl,
              style: imageStyle
            })
          ]) : h("div", {
            class: "vxe-result--icon-wrapper"
          }, [
            h("i", {
              class: [icon, type ? getIcon()[`RESULT_${type}`.toLocaleUpperCase()] : ""]
            })
          ]),
          h("div", {
            class: "vxe-result--title-wrapper"
          }, `${title || ""}`),
          h("div", {
            class: "vxe-result--content-wrapper"
          }, `${content || ""}`),
          slotExtra ? h("div", {
            class: "vxe-result--extra-wrapper"
          }, slotExtra({})) : renderEmptyElement($xeResult)
        ])
      ]);
    };
    $xeResult.renderVN = renderVN;
    return $xeResult;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/result/index.js
var VxeResult = Object.assign({}, result_default, {
  install(app) {
    app.component(result_default.name, result_default);
  }
});
dynamicApp.use(VxeResult);
VxeUI.component(result_default);
var Result = VxeResult;
var result_default2 = VxeResult;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/row/index.js
var VxeRow = Object.assign({}, row_default, {
  install(app) {
    app.component(row_default.name, row_default);
  }
});
dynamicApp.use(VxeRow);
VxeUI.component(row_default);
var Row = VxeRow;
var row_default2 = VxeRow;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/split/src/split.js
var import_xe_utils92 = __toESM(require_xe_utils());
var split_default = defineComponent({
  name: "VxeSplit",
  props: {
    width: [Number, String],
    height: [Number, String],
    vertical: {
      type: Boolean,
      default: () => getConfig().split.vertical
    },
    border: {
      type: Boolean,
      default: () => getConfig().split.border
    },
    padding: {
      type: Boolean,
      default: () => getConfig().split.padding
    },
    resize: {
      type: Boolean,
      default: () => getConfig().split.resize
    },
    items: Array,
    itemConfig: Object,
    barConfig: Object,
    actionConfig: Object
  },
  emits: [
    "action-dblclick",
    "action-click",
    "toggle-expand",
    "resize-start",
    "resize-drag",
    "resize-end"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils92.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({
      staticItems: [],
      itemList: []
    });
    const internalData = {};
    const computeItemOpts = computed(() => {
      return Object.assign({}, getConfig().split.itemConfig, props.itemConfig);
    });
    const computeBarOpts = computed(() => {
      return Object.assign({}, getConfig().split.barConfig, props.barConfig);
    });
    const computeActionOpts = computed(() => {
      return Object.assign({}, getConfig().split.actionConfig, props.actionConfig);
    });
    const computeIsFoldNext = computed(() => {
      const actionOpts = computeActionOpts.value;
      return actionOpts.direction === "next";
    });
    const computeVisibleItems = computed(() => {
      return reactData.itemList.filter((item) => item.isVisible);
    });
    const computeAutoItems = computed(() => {
      const { vertical } = props;
      return reactData.itemList.filter((item) => vertical ? !item.height : !item.width);
    });
    const computeBarStyle = computed(() => {
      const barOpts = computeBarOpts.value;
      const { width, height } = barOpts;
      const stys = {};
      if (height) {
        stys.height = toCssUnit(height);
      }
      if (width) {
        stys.width = toCssUnit(width);
      }
      return stys;
    });
    const computeMaps = {
      computeItemOpts,
      computeBarOpts,
      computeActionOpts,
      computeIsFoldNext
    };
    const refMaps = {
      refElem
    };
    const $xeSplit = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $split: $xeSplit }, params));
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils92.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils92.default.isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const getDefaultActionIcon = (item) => {
      const { vertical } = props;
      const { showAction, isExpand } = item;
      const isFoldNext = computeIsFoldNext.value;
      const topIcon = "SPLIT_TOP_ACTION";
      const bottomIcon = "SPLIT_BOTTOM_ACTION";
      const leftIcon = "SPLIT_LEFT_ACTION";
      const rightIcon = "SPLIT_RIGHT_ACTION";
      if (showAction) {
        let iconName = "";
        if (isFoldNext) {
          if (vertical) {
            iconName = isExpand ? bottomIcon : topIcon;
          } else {
            iconName = isExpand ? rightIcon : leftIcon;
          }
        } else {
          if (vertical) {
            iconName = isExpand ? topIcon : bottomIcon;
          } else {
            iconName = isExpand ? leftIcon : rightIcon;
          }
        }
        if (iconName) {
          return getIcon()[iconName];
        }
      }
      return "";
    };
    const reset = () => {
      const { itemList } = reactData;
      itemList.forEach((item) => {
        item.isExpand = true;
        item.isVisible = true;
        item.foldHeight = 0;
        item.foldWidth = 0;
        item.resizeHeight = 0;
        item.resizeWidth = 0;
      });
      return nextTick();
    };
    const handleLoadItem = (list, isReset) => {
      const { staticItems } = reactData;
      const itemDef = {
        isVisible: true,
        isExpand: true,
        renderWidth: 0,
        resizeWidth: 0,
        foldWidth: 0,
        renderHeight: 0,
        resizeHeight: 0,
        foldHeight: 0
      };
      reactData.itemList = list.map((item) => {
        if (item.slots) {
          import_xe_utils92.default.each(item.slots, (func) => {
            if (!import_xe_utils92.default.isFunction(func)) {
              if (!slots[func]) {
                errLog("vxe.error.notSlot", [func]);
              }
            }
          });
        }
        return Object.assign({}, isReset ? null : itemDef, item, isReset ? itemDef : null, {
          id: import_xe_utils92.default.uniqueId()
        });
      });
      if (staticItems.length) {
        errLog("vxe.error.errConflicts", ["<vxe-split-pane ...>", "items"]);
      }
      return recalculate();
    };
    const loadItem = (list) => {
      return handleLoadItem(list || [], false);
    };
    const reloadItem = (list) => {
      return handleLoadItem(list || [], true);
    };
    const recalculate = () => {
      return nextTick().then(() => {
        const { vertical } = props;
        const { itemList } = reactData;
        const el = refElem.value;
        if (!el) {
          return;
        }
        const wrapperWidth = el.clientWidth;
        const wrapperHeight = el.clientHeight;
        if (!wrapperWidth || !wrapperHeight) {
          return;
        }
        const itemOpts = computeItemOpts.value;
        const allMinWidth = import_xe_utils92.default.toNumber(itemOpts.minWidth);
        const allMinHeight = import_xe_utils92.default.toNumber(itemOpts.minHeight);
        const residueItems = [];
        if (vertical) {
          let countHeight = 0;
          itemList.forEach((item) => {
            const { height } = item;
            let itemHeight = 0;
            if (height) {
              if (isScale(height)) {
                itemHeight = wrapperHeight * import_xe_utils92.default.toNumber(height);
              } else {
                itemHeight = import_xe_utils92.default.toNumber(height);
              }
              item.renderHeight = itemHeight;
            } else {
              residueItems.push(item);
            }
            countHeight += itemHeight;
          });
          if (residueItems.length) {
            const reMeanHeight = (wrapperHeight - countHeight) / residueItems.length;
            residueItems.forEach((item) => {
              item.renderHeight = Math.max(import_xe_utils92.default.toNumber(getGlobalDefaultConfig(item.minHeight, allMinHeight)), reMeanHeight);
            });
          }
        } else {
          let countWidth = 0;
          itemList.forEach((item) => {
            const { width } = item;
            let itemWidth = 0;
            if (width) {
              if (isScale(width)) {
                itemWidth = wrapperWidth * import_xe_utils92.default.toNumber(width);
              } else {
                itemWidth = import_xe_utils92.default.toNumber(width);
              }
              item.renderWidth = itemWidth;
            } else {
              residueItems.push(item);
            }
            countWidth += itemWidth;
          });
          if (residueItems.length) {
            const reMeanWidth = (wrapperWidth - countWidth) / residueItems.length;
            residueItems.forEach((item) => {
              item.renderWidth = Math.max(import_xe_utils92.default.toNumber(getGlobalDefaultConfig(item.minWidth, allMinWidth)), reMeanWidth);
            });
          }
        }
      });
    };
    const dragEvent = (evnt) => {
      const { resize, vertical } = props;
      const { itemList } = reactData;
      if (!resize) {
        return;
      }
      evnt.preventDefault();
      const barEl = evnt.currentTarget;
      const handleEl = barEl.parentElement;
      const el = refElem.value;
      if (!el) {
        return;
      }
      const itemId = handleEl.getAttribute("itemid");
      const itemIndex = import_xe_utils92.default.findIndexOf(itemList, (item2) => item2.id === itemId);
      const item = itemList[itemIndex];
      if (!item) {
        return;
      }
      if (!item.isExpand) {
        return;
      }
      const isFoldNext = computeIsFoldNext.value;
      const itemOpts = computeItemOpts.value;
      const allMinWidth = import_xe_utils92.default.toNumber(itemOpts.minWidth);
      const allMinHeight = import_xe_utils92.default.toNumber(itemOpts.minHeight);
      const targetItem = itemList[itemIndex + (isFoldNext ? 1 : -1)];
      const targetItemEl = targetItem ? el.querySelector(`.vxe-split-pane[itemid="${targetItem.id}"]`) : null;
      const currItemEl = item ? el.querySelector(`.vxe-split-pane[itemid="${item.id}"]`) : null;
      const targetWidth = targetItemEl ? targetItemEl.clientWidth : 0;
      const currWidth = currItemEl ? currItemEl.clientWidth : 0;
      const targetHeight = targetItemEl ? targetItemEl.clientHeight : 0;
      const currHeight = currItemEl ? currItemEl.clientHeight : 0;
      const targetMinWidth = import_xe_utils92.default.toNumber(targetItem ? getGlobalDefaultConfig(targetItem.minWidth, allMinWidth) : allMinWidth);
      const currMinWidth = import_xe_utils92.default.toNumber(getGlobalDefaultConfig(item.minWidth, allMinWidth));
      const targetMinHeight = import_xe_utils92.default.toNumber(targetItem ? getGlobalDefaultConfig(targetItem.minHeight, allMinHeight) : allMinHeight);
      const currMinHeight = import_xe_utils92.default.toNumber(getGlobalDefaultConfig(item.minHeight, allMinHeight));
      const disX = evnt.clientX;
      const disY = evnt.clientY;
      addClass(el, "is--drag");
      document.onmousemove = (evnt2) => {
        evnt2.preventDefault();
        if (vertical) {
          const offsetTop = isFoldNext ? disY - evnt2.clientY : evnt2.clientY - disY;
          if (offsetTop > 0) {
            if (targetItem) {
              if (currHeight - offsetTop >= currMinHeight) {
                const reHeight = currHeight - offsetTop;
                targetItem.resizeHeight = targetHeight + offsetTop;
                item.resizeHeight = reHeight;
                dispatchEvent("resize-drag", { item, name: item.name, offsetHeight: offsetTop, resizeHeight: reHeight, offsetWidth: 0, resizeWidth: 0 }, evnt2);
              }
            }
          } else {
            if (targetItem) {
              if (targetHeight + offsetTop >= targetMinHeight) {
                const reHeight = currHeight - offsetTop;
                targetItem.resizeHeight = targetHeight + offsetTop;
                item.resizeHeight = reHeight;
                dispatchEvent("resize-drag", { item, name: item.name, offsetHeight: offsetTop, resizeHeight: reHeight, offsetWidth: 0, resizeWidth: 0 }, evnt2);
              }
            }
          }
        } else {
          const offsetLeft = isFoldNext ? disX - evnt2.clientX : evnt2.clientX - disX;
          if (offsetLeft > 0) {
            if (targetItem) {
              if (currWidth - offsetLeft >= currMinWidth) {
                const reWidth = currWidth - offsetLeft;
                targetItem.resizeWidth = targetWidth + offsetLeft;
                item.resizeWidth = reWidth;
                dispatchEvent("resize-drag", { item, name: item.name, offsetHeight: 0, resizeHeight: 0, offsetWidth: offsetLeft, resizeWidth: reWidth }, evnt2);
              }
            }
          } else {
            if (targetItem) {
              if (targetWidth + offsetLeft >= targetMinWidth) {
                const reWidth = currWidth - offsetLeft;
                targetItem.resizeWidth = targetWidth + offsetLeft;
                item.resizeWidth = reWidth;
                dispatchEvent("resize-drag", { item, name: item.name, offsetHeight: 0, resizeHeight: 0, offsetWidth: offsetLeft, resizeWidth: reWidth }, evnt2);
              }
            }
          }
        }
      };
      document.onmouseup = (evnt2) => {
        document.onmousemove = null;
        document.onmouseup = null;
        removeClass(el, "is--drag");
        dispatchEvent("resize-end", { item, name: item.name, resizeHeight: item.resizeHeight, resizeWidth: item.resizeWidth }, evnt2);
        recalculate();
      };
      dispatchEvent("resize-start", { item, name: item.name }, evnt);
    };
    const handleItemActionEvent = (evnt) => {
      const el = refElem.value;
      if (!el) {
        return;
      }
      const { vertical } = props;
      const { itemList } = reactData;
      const isFoldNext = computeIsFoldNext.value;
      const btnEl = evnt.currentTarget;
      const handleEl = btnEl.parentElement;
      const itemId = handleEl.getAttribute("itemid");
      const itemIndex = import_xe_utils92.default.findIndexOf(itemList, (item2) => item2.id === itemId);
      const item = itemList[itemIndex];
      const targetItem = itemList[itemIndex + (isFoldNext ? 1 : -1)];
      if (item) {
        const { showAction, isExpand } = item;
        if (showAction) {
          if (vertical) {
            if (targetItem) {
              targetItem.isVisible = !isExpand;
              targetItem.foldHeight = 0;
              item.isExpand = !isExpand;
              item.isVisible = true;
              item.foldHeight = isExpand ? (targetItem.resizeHeight || targetItem.renderHeight) + (item.resizeHeight || item.renderHeight) : 0;
            }
          } else {
            if (targetItem) {
              targetItem.isVisible = !isExpand;
              targetItem.foldWidth = 0;
              item.isExpand = !isExpand;
              item.isVisible = true;
              item.foldWidth = isExpand ? (targetItem.resizeWidth || targetItem.renderWidth) + (item.resizeWidth || item.renderWidth) : 0;
            }
          }
          dispatchEvent("toggle-expand", { item, name: item.name, targetItem, targetName: targetItem ? targetItem.name : "", expanded: item.isExpand }, evnt);
          recalculate();
        }
      }
    };
    const handleActionDblclickEvent = (evnt) => {
      const { itemList } = reactData;
      const actionOpts = computeActionOpts.value;
      const btnEl = evnt.currentTarget;
      const handleEl = btnEl.parentElement;
      const itemId = handleEl.getAttribute("itemid");
      const itemIndex = import_xe_utils92.default.findIndexOf(itemList, (item2) => item2.id === itemId);
      const item = itemList[itemIndex];
      if (actionOpts.trigger === "dblclick") {
        handleItemActionEvent(evnt);
      }
      dispatchEvent("action-dblclick", { item, name: item ? item.name : "" }, evnt);
    };
    const handleActionClickEvent = (evnt) => {
      const { itemList } = reactData;
      const actionOpts = computeActionOpts.value;
      const btnEl = evnt.currentTarget;
      const handleEl = btnEl.parentElement;
      const itemId = handleEl.getAttribute("itemid");
      const itemIndex = import_xe_utils92.default.findIndexOf(itemList, (item2) => item2.id === itemId);
      const item = itemList[itemIndex];
      if (actionOpts.trigger !== "dblclick") {
        handleItemActionEvent(evnt);
      }
      dispatchEvent("action-click", { item, name: item ? item.name : "" }, evnt);
    };
    const handleGlobalResizeEvent = () => {
      recalculate();
    };
    const splitMethods = {
      dispatchEvent,
      recalculate,
      reset,
      loadItem,
      reloadItem
    };
    const splitPrivateMethods = {};
    Object.assign($xeSplit, splitMethods, splitPrivateMethods);
    const renderHandleBar = (item) => {
      const barStyle = computeBarStyle.value;
      const actionOpts = computeActionOpts.value;
      const isFoldNext = computeIsFoldNext.value;
      const { id, isExpand, showAction } = item;
      return h("div", {
        itemid: id,
        class: ["vxe-split-pane-handle", isFoldNext ? "to--next" : "to--prev"]
      }, [
        h("div", {
          class: "vxe-split-pane-handle-bar",
          style: barStyle,
          onMousedown: dragEvent
        }),
        showAction ? h("span", {
          class: "vxe-split-pane-action-btn",
          onDblclick: handleActionDblclickEvent,
          onClick: handleActionClickEvent
        }, [
          h("i", {
            class: (isExpand ? actionOpts.openIcon : actionOpts.closeIcon) || getDefaultActionIcon(item)
          })
        ]) : renderEmptyElement($xeSplit)
      ]);
    };
    const renderItems = () => {
      const { border, padding, resize, vertical } = props;
      const { itemList } = reactData;
      const visibleItems = computeVisibleItems.value;
      const autoItems = computeAutoItems.value;
      const isFoldNext = computeIsFoldNext.value;
      const itemVNs = [];
      itemList.forEach((item, index) => {
        const { id, name, slots: slots2, renderHeight, resizeHeight, foldHeight, renderWidth, resizeWidth, foldWidth, isVisible, isExpand } = item;
        const defaultSlot = slots2 ? slots2.default : null;
        const stys = {};
        let itemWidth = isVisible ? foldWidth || resizeWidth || renderWidth : 0;
        let itemHeight = isVisible ? foldHeight || resizeHeight || renderHeight : 0;
        if (autoItems.length === 1) {
          if (vertical) {
            if (!item.height) {
              itemHeight = 0;
            }
          } else {
            if (!item.width) {
              itemWidth = 0;
            }
          }
        }
        if (vertical) {
          if (itemHeight) {
            stys.height = visibleItems.length === 1 ? "100%" : toCssUnit(itemHeight);
          }
        } else {
          if (itemWidth) {
            stys.width = visibleItems.length === 1 ? "100%" : toCssUnit(itemWidth);
          }
        }
        itemVNs.push(h("div", {
          itemid: id,
          class: ["vxe-split-pane", vertical ? "is--vertical" : "is--horizontal", {
            "is--resize": resize,
            "is--padding": padding,
            "is--border": border,
            "is--height": itemHeight,
            "is--width": itemWidth,
            "is--fill": isVisible && !itemHeight && !itemWidth,
            "is--handle": index > 0,
            "is--expand": isExpand,
            "is--hidden": !isVisible
          }],
          style: stys
        }, [
          index && !isFoldNext ? renderHandleBar(item) : renderEmptyElement($xeSplit),
          h("div", {
            itemid: id,
            class: "vxe-split-pane--wrapper"
          }, [
            h("div", {
              class: "vxe-split-pane--inner"
            }, defaultSlot ? callSlot(defaultSlot, { name, isVisible, isExpand }) : [])
          ]),
          isFoldNext && index < itemList.length - 1 ? renderHandleBar(item) : renderEmptyElement($xeSplit)
        ]));
      });
      return h("div", {
        class: "vxe-split-wrapper"
      }, itemVNs);
    };
    const renderVN = () => {
      const { vertical, width, height } = props;
      const defaultSlot = slots.default;
      const stys = {};
      if (height) {
        stys.height = toCssUnit(height);
      }
      if (width) {
        stys.width = toCssUnit(width);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-split", vertical ? "is--vertical" : "is--horizontal"],
        style: stys
      }, [
        h("div", {
          class: "vxe-split-slots"
        }, defaultSlot ? defaultSlot({}) : []),
        renderItems()
      ]);
    };
    const itemFlag = ref(0);
    watch(() => props.items ? props.items.length : -1, () => {
      itemFlag.value++;
    });
    watch(() => props.items, () => {
      itemFlag.value++;
    });
    watch(itemFlag, () => {
      loadItem(props.items || []);
    });
    watch(() => reactData.staticItems, (val) => {
      if (props.items && props.items.length) {
        errLog("vxe.error.errConflicts", ["<vxe-split-pane ...>", "items"]);
      }
      reactData.itemList = val;
      recalculate();
    });
    let resizeObserver;
    onMounted(() => {
      nextTick(() => {
        recalculate();
      });
      const el = refElem.value;
      if (el) {
        resizeObserver = globalResize.create(() => {
          recalculate();
        });
        resizeObserver.observe(el);
      }
      globalEvents.on($xeSplit, "resize", handleGlobalResizeEvent);
    });
    onUnmounted(() => {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      globalEvents.off($xeSplit, "resize");
    });
    onActivated(() => {
      recalculate();
    });
    if (props.items) {
      loadItem(props.items);
    }
    provide("$xeSplit", $xeSplit);
    $xeSplit.renderVN = renderVN;
    return $xeSplit;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/split/index.js
var VxeSplit = Object.assign({}, split_default, {
  install(app) {
    app.component(split_default.name, split_default);
  }
});
dynamicApp.use(VxeSplit);
VxeUI.component(split_default);
var Split = VxeSplit;
var split_default2 = VxeSplit;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/split/src/util.js
var import_xe_utils93 = __toESM(require_xe_utils());
function assembleSplitItem($xeSplit, elem, paneConfig) {
  const staticItems = $xeSplit.reactData.staticItems;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticItems.splice(import_xe_utils93.default.arrayIndexOf(parentElem.children, elem), 0, paneConfig);
    $xeSplit.reactData.staticItems = staticItems.slice(0);
  }
}
function destroySplitItem($xeSplit, paneConfig) {
  const staticItems = $xeSplit.reactData.staticItems;
  const index = import_xe_utils93.default.findIndexOf(staticItems, (item) => item.id === paneConfig.id);
  if (index > -1) {
    staticItems.splice(index, 1);
  }
  $xeSplit.reactData.staticItems = staticItems.slice(0);
}

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/split/src/split-pane.js
var import_xe_utils94 = __toESM(require_xe_utils());
var split_pane_default = defineComponent({
  name: "VxeSplitPane",
  props: {
    name: [Number, String],
    width: [Number, String],
    height: [Number, String],
    showAction: Boolean,
    minWidth: {
      type: [Number, String],
      default: () => null
    },
    minHeight: {
      type: [Number, String],
      default: () => null
    }
  },
  emits: [],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils94.default.uniqueId();
    const $xeSplit = inject("$xeSplit", null);
    const refElem = ref();
    const paneConfig = reactive({
      id: xID,
      name: props.name,
      width: props.width,
      height: props.height,
      minWidth: props.minWidth,
      minHeight: props.minHeight,
      showAction: props.showAction,
      isVisible: true,
      isExpand: true,
      renderWidth: 0,
      resizeWidth: 0,
      foldWidth: 0,
      renderHeight: 0,
      resizeHeight: 0,
      foldHeight: 0,
      slots
    });
    const reactData = reactive({});
    const internalData = {};
    const computeMaps = {};
    const refMaps = {
      refElem
    };
    const $xeSplitItem = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $splitPane: $xeSplitItem }, params));
    };
    const splitPaneMethods = {
      dispatchEvent
    };
    const splitPanePrivateMethods = {};
    Object.assign($xeSplitItem, splitPaneMethods, splitPanePrivateMethods);
    const renderVN = () => {
      return h("div", {
        ref: refElem
      });
    };
    watch(() => props.name, (val) => {
      paneConfig.name = val;
    });
    watch(() => props.width, (val) => {
      paneConfig.width = val;
    });
    watch(() => props.height, (val) => {
      paneConfig.height = val;
    });
    watch(() => props.minWidth, (val) => {
      paneConfig.minWidth = val;
    });
    watch(() => props.minHeight, (val) => {
      paneConfig.minHeight = val;
    });
    watch(() => props.showAction, (val) => {
      paneConfig.showAction = val;
    });
    onMounted(() => {
      const elem = refElem.value;
      if ($xeSplit && elem) {
        assembleSplitItem($xeSplit, elem, paneConfig);
      }
    });
    onUnmounted(() => {
      if ($xeSplit) {
        destroySplitItem($xeSplit, paneConfig);
      }
    });
    provide("$xeSplitItem", $xeSplitItem);
    $xeSplitItem.renderVN = renderVN;
    return $xeSplitItem;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/split-pane/index.js
var VxeSplitPane = Object.assign({}, split_pane_default, {
  install(app) {
    app.component(split_pane_default.name, split_pane_default);
    app.component("VxeSplitItem", split_pane_default);
  }
});
dynamicApp.use(VxeSplitPane);
VxeUI.component(split_pane_default);
var SplitPane = VxeSplitPane;
var split_pane_default2 = VxeSplitPane;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/slider/index.js
var VxeSlider = Object.assign({}, slider_default, {
  install(app) {
    app.component(slider_default.name, slider_default);
  }
});
dynamicApp.use(VxeSlider);
VxeUI.component(slider_default);
var Slider = VxeSlider;
var slider_default2 = VxeSlider;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/steps/src/steps.js
var import_xe_utils95 = __toESM(require_xe_utils());
var steps_default = defineComponent({
  name: "VxeSteps",
  props: {},
  emits: [],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils95.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeSteps = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $steps: $xeSteps }, params));
    };
    const stepsMethods = {
      dispatchEvent
    };
    const stepsPrivateMethods = {};
    Object.assign($xeSteps, stepsMethods, stepsPrivateMethods);
    const renderVN = () => {
      return h("div", {
        ref: refElem,
        class: "vxe-steps"
      }, []);
    };
    $xeSteps.renderVN = renderVN;
    return $xeSteps;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/steps/index.js
var VxeSteps = Object.assign({}, steps_default, {
  install(app) {
    app.component(steps_default.name, steps_default);
  }
});
dynamicApp.use(VxeSteps);
VxeUI.component(steps_default);
var Steps = VxeSteps;
var steps_default2 = VxeSteps;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/switch/index.js
var VxeSwitch = Object.assign(switch_default, {
  install: function(app) {
    app.component(switch_default.name, switch_default);
  }
});
dynamicApp.use(VxeSwitch);
VxeUI.component(switch_default);
var Switch = VxeSwitch;
var switch_default2 = VxeSwitch;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/tab-pane/index.js
var VxeTabPane = Object.assign({}, tab_pane_default, {
  install(app) {
    app.component(tab_pane_default.name, tab_pane_default);
  }
});
dynamicApp.use(VxeTabPane);
VxeUI.component(tab_pane_default);
var TabPane = VxeTabPane;
var tab_pane_default2 = VxeTabPane;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/table-select/src/table-select.js
var import_xe_utils96 = __toESM(require_xe_utils());
function getRowUniqueId() {
  return import_xe_utils96.default.uniqueId("row_");
}
var table_select_default = defineComponent({
  name: "VxeTableSelect",
  props: {
    modelValue: [String, Number, Array],
    clearable: Boolean,
    placeholder: {
      type: String,
      default: () => import_xe_utils96.default.eqNull(getConfig().tableSelect.placeholder) ? getI18n("vxe.base.pleaseSelect") : getConfig().tableSelect.placeholder
    },
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    className: [String, Function],
    prefixIcon: String,
    placement: String,
    columns: Array,
    options: Array,
    optionProps: Object,
    size: {
      type: String,
      default: () => getConfig().select.size || getConfig().size
    },
    popupConfig: Object,
    gridConfig: Object,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "blur",
    "focus",
    "click",
    "form-submit",
    "form-reset",
    "form-collapse",
    "page-change"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const VxeTableGridComponent = VxeUI.getComponent("VxeGrid");
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils96.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refInput = ref();
    const refGridWrapper = ref();
    const refOptionPanel = ref();
    const refGrid = ref();
    const reactData = reactive({
      initialized: false,
      tableColumns: [],
      fullOptionList: [],
      fullRowMaps: {},
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      // hpTimeout: undefined,
      // vpTimeout: undefined
    };
    const refMaps = {
      refElem
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().select.transfer;
        if (import_xe_utils96.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computePropsOpts = computed(() => {
      return props.optionProps || {};
    });
    const computeRowOpts = computed(() => {
      const gridOpts = computeGridOpts.value;
      return Object.assign({}, gridOpts.rowConfig, {
        isCurrent: true
      });
    });
    const computeRowKeyField = computed(() => {
      const rowOpts = computeRowOpts.value;
      return rowOpts.keyField || "_X_ROW_KEY";
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computePopupOpts = computed(() => {
      return Object.assign({}, getConfig().tableSelect.popupConfig, props.popupConfig);
    });
    const computeGridOpts = computed(() => {
      return Object.assign({}, getConfig().tableSelect.gridConfig, props.gridConfig, { data: void 0, columns: void 0 });
    });
    const computeSelectLabel = computed(() => {
      const { modelValue } = props;
      const { fullRowMaps } = reactData;
      const labelField = computeLabelField.value;
      return (import_xe_utils96.default.isArray(modelValue) ? modelValue : [modelValue]).map((val) => {
        const cacheItem = fullRowMaps[val];
        return cacheItem ? cacheItem.item[labelField] : val;
      }).join(", ");
    });
    const computePopupWrapperStyle = computed(() => {
      const popupOpts = computePopupOpts.value;
      const { height, width } = popupOpts;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeMaps = {};
    const $xeTableSelect = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const gridEventKeys = [
      "form-submit",
      "form-reset",
      "form-collapse",
      "page-change"
    ];
    const gridEvents = {};
    gridEventKeys.forEach((name) => {
      gridEvents[getOnName(import_xe_utils96.default.camelCase(name))] = (params) => {
        dispatchEvent(name, params, params.$event);
      };
    });
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tableSelect: $xeTableSelect }, params));
    };
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const tableSelectMethods = {
      dispatchEvent
    };
    const tableSelectPrivateMethods = {};
    const getRowid = (option) => {
      const nodeKeyField = computeRowKeyField.value;
      const rowid = option[nodeKeyField];
      return rowid ? encodeURIComponent(rowid) : "";
    };
    const getRowsByValue = (modelValue) => {
      const { fullRowMaps } = reactData;
      const rows = [];
      const vals = import_xe_utils96.default.eqNull(modelValue) ? [] : import_xe_utils96.default.isArray(modelValue) ? modelValue : [modelValue];
      vals.forEach((val) => {
        const cacheItem = fullRowMaps[val];
        if (cacheItem) {
          rows.push(cacheItem.item);
        }
      });
      return rows;
    };
    const updateModel = (modelValue) => {
      const { multiple } = props;
      nextTick(() => {
        const $grid = refGrid.value;
        if ($grid) {
          const selectList = getRowsByValue(modelValue);
          if (selectList.length) {
            if (multiple) {
              $grid.setCheckboxRow(selectList, true);
            } else {
              $grid.setRadioRow(selectList[0]);
            }
          }
        }
      });
    };
    const loadTableColumn = (columns) => {
      const { multiple } = props;
      const tableCols = [];
      if (multiple) {
        tableCols.push({
          type: "checkbox",
          width: 70
        });
      } else {
        tableCols.push({
          type: "radio",
          width: 70
        });
      }
      reactData.tableColumns = tableCols.concat(columns || []);
    };
    const cacheDataMap = () => {
      const { options } = props;
      const rowKeyField = computeRowKeyField.value;
      const valueField = computeValueField.value;
      const gridOpts = computeGridOpts.value;
      const { treeConfig } = gridOpts;
      const rowMaps = {};
      const keyMaps = {};
      if (treeConfig) {
      } else {
        import_xe_utils96.default.arrayEach(options || [], (item, index, items) => {
          let rowid = getRowid(item);
          if (!rowid) {
            rowid = getRowUniqueId();
          }
          if (keyMaps[rowid]) {
            errLog("vxe.error.repeatKey", [rowKeyField, rowid]);
          }
          keyMaps[rowid] = true;
          const value = item[valueField];
          if (rowMaps[value]) {
            errLog("vxe.error.repeatKey", [valueField, value]);
          }
          rowMaps[value] = { item, index, items, parent: null, nodes: [] };
        });
      }
      reactData.fullOptionList = options || [];
      reactData.fullRowMaps = rowMaps;
      updateModel(props.modelValue);
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (panelElem && el) {
          const targetHeight = el.offsetHeight;
          const targetWidth = el.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(el);
          let panelPlacement = "bottom";
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showOptionPanel = () => {
      const { loading: loading2 } = props;
      const isDisabled = computeIsDisabled.value;
      if (!loading2 && !isDisabled) {
        if (internalData.vpTimeout) {
          clearTimeout(internalData.vpTimeout);
        }
        if (internalData.hpTimeout) {
          clearTimeout(internalData.hpTimeout);
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        internalData.vpTimeout = setTimeout(() => {
          reactData.visiblePanel = true;
          updateModel(props.modelValue);
          internalData.vpTimeout = void 0;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      if (internalData.vpTimeout) {
        clearTimeout(internalData.vpTimeout);
      }
      if (internalData.hpTimeout) {
        clearTimeout(internalData.hpTimeout);
      }
      internalData.hpTimeout = setTimeout(() => {
        reactData.isAniVisible = false;
        internalData.hpTimeout = void 0;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      const { fullRowMaps } = reactData;
      emitModel(selectValue);
      if (selectValue !== props.modelValue) {
        const cacheItem = fullRowMaps[selectValue];
        dispatchEvent("change", { value: selectValue, row: cacheItem ? cacheItem.item : null }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue);
      dispatchEvent("clear", { value: selectValue }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      hideOptionPanel();
    };
    const focusEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          showOptionPanel();
          setTimeout(() => {
            reactData.triggerFocusPanel = false;
          }, 150);
        }
      }
      dispatchEvent("focus", {}, evnt);
    };
    const clickEvent = (evnt) => {
      togglePanelEvent(evnt);
      dispatchEvent("click", {}, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      dispatchEvent("blur", {}, evnt);
    };
    const togglePanelEvent = (params) => {
      const { $event } = params;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
      }
    };
    const radioChangeEvent = (params) => {
      const { $event, row } = params;
      const valueField = computeValueField.value;
      const value = row[valueField];
      changeEvent($event, value);
      hideOptionPanel();
    };
    const checkboxChangeEvent = (params) => {
      const { $grid, $event } = params;
      const valueField = computeValueField.value;
      if ($grid) {
        const checkboxRecords = $grid.getCheckboxRecords();
        const value = checkboxRecords.map((row) => {
          return row[valueField];
        });
        changeEvent($event, value);
      }
    };
    const checkboxAllEvent = (params) => {
      checkboxChangeEvent(params);
    };
    Object.assign($xeTableSelect, tableSelectMethods, tableSelectPrivateMethods);
    const renderVN = () => {
      const { className, options, loading: loading2 } = props;
      const { initialized, isActivated, isAniVisible, visiblePanel, tableColumns } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const selectLabel = computeSelectLabel.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const popupOpts = computePopupOpts.value;
      const { className: popupClassName } = popupOpts;
      const gridOpts = computeGridOpts.value;
      const rowOpts = computeRowOpts.value;
      const popupWrapperStyle = computePopupWrapperStyle.value;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-table-select--readonly", className]
        }, [
          h("span", {
            class: "vxe-table-select-label"
          }, selectLabel)
        ]);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-table-select", className ? import_xe_utils96.default.isFunction(className) ? className({ $tableSelect: $xeTableSelect }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--loading": loading2,
          "is--active": isActivated
        }]
      }, [
        h(input_default, {
          ref: refInput,
          clearable: props.clearable,
          placeholder: loading2 ? getI18n("vxe.select.loadingText") : props.placeholder,
          readonly: true,
          disabled: isDisabled,
          type: "text",
          prefixIcon: props.prefixIcon,
          suffixIcon: loading2 ? getIcon().TABLE_SELECT_LOADED : visiblePanel ? getIcon().TABLE_SELECT_OPEN : getIcon().TABLE_SELECT_CLOSE,
          modelValue: loading2 ? "" : selectLabel,
          onClear: clearEvent,
          onClick: clickEvent,
          onFocus: focusEvent,
          onBlur: blurEvent,
          onSuffixClick: togglePanelEvent
        }, prefixSlot ? {
          prefix: () => prefixSlot({})
        } : {}),
        h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-table-select--panel", popupClassName ? import_xe_utils96.default.isFunction(popupClassName) ? popupClassName({ $tableSelect: $xeTableSelect }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": !loading2 && isAniVisible,
              "ani--enter": !loading2 && visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, initialized ? [
            h("div", {
              class: "vxe-table-select--panel-wrapper"
            }, [
              headerSlot ? h("div", {
                class: "vxe-table-select--panel-header"
              }, headerSlot({})) : renderEmptyElement($xeTableSelect),
              h("div", {
                class: "vxe-table-select--panel-body"
              }, [
                h("div", {
                  ref: refGridWrapper,
                  class: "vxe-table-select-grid--wrapper",
                  style: popupWrapperStyle
                }, [
                  VxeTableGridComponent ? h(VxeTableGridComponent, Object.assign(Object.assign(Object.assign({}, gridOpts), gridEvents), { class: "vxe-table-select--grid", ref: refGrid, rowConfig: rowOpts, data: options, columns: tableColumns, height: "100%", autoResize: true, onRadioChange: radioChangeEvent, onCheckboxChange: checkboxChangeEvent, onCheckboxAll: checkboxAllEvent }), Object.assign({}, slots, {
                    header: void 0,
                    footer: void 0,
                    prefixSlot: void 0
                  })) : renderEmptyElement($xeTableSelect)
                ])
              ]),
              footerSlot ? h("div", {
                class: "vxe-table-select--panel-footer"
              }, footerSlot({})) : renderEmptyElement($xeTableSelect)
            ])
          ] : [])
        ])
      ]);
    };
    watch(() => props.options, () => {
      cacheDataMap();
    });
    watch(() => props.columns, (val) => {
      loadTableColumn(val || []);
    });
    watch(() => props.modelValue, (val) => {
      updateModel(val);
    });
    loadTableColumn(props.columns || []);
    cacheDataMap();
    onMounted(() => {
      globalEvents.on($xeTableSelect, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeTableSelect, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeTableSelect, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeTableSelect, "mousewheel");
      globalEvents.off($xeTableSelect, "mousedown");
      globalEvents.off($xeTableSelect, "blur");
    });
    if (true) {
      nextTick(() => {
        if (!VxeTableGridComponent) {
          errLog("vxe.error.reqComp", ["vxe-grid"]);
        }
      });
    }
    provide("$xeTableSelect", $xeTableSelect);
    $xeTableSelect.renderVN = renderVN;
    return $xeTableSelect;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/table-select/index.js
var VxeTableSelect = Object.assign({}, table_select_default, {
  install(app) {
    app.component(table_select_default.name, table_select_default);
  }
});
dynamicApp.use(VxeTableSelect);
VxeUI.component(table_select_default);
var TableSelect = VxeTableSelect;
var table_select_default2 = VxeTableSelect;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/tabs/index.js
var VxeTabs = Object.assign({}, tabs_default, {
  install(app) {
    app.component(tabs_default.name, tabs_default);
  }
});
dynamicApp.use(VxeTabs);
VxeUI.component(tabs_default);
var Tabs = VxeTabs;
var tabs_default2 = VxeTabs;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/tag/src/tag.js
var import_xe_utils97 = __toESM(require_xe_utils());
var tag_default = defineComponent({
  name: "VxeTag",
  props: {
    status: String,
    title: [String, Number],
    icon: String,
    content: [String, Number],
    size: {
      type: String,
      default: () => getConfig().tag.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils97.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTag = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tag: $xeTag }, params));
    };
    const tagMethods = {
      dispatchEvent
    };
    const tagPrivateMethods = {};
    const clickEvent = (evnt) => {
      dispatchEvent("click", {}, evnt);
    };
    Object.assign($xeTag, tagMethods, tagPrivateMethods);
    const renderContent = () => {
      const { icon, content } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      return [
        iconSlot || icon ? h("span", {
          class: "vxe-tag--icon"
        }, iconSlot ? getSlotVNs(iconSlot({})) : [
          h("i", {
            class: icon
          })
        ]) : createCommentVNode(),
        h("span", {
          class: "vxe-tag--content"
        }, defaultSlot ? defaultSlot({}) : import_xe_utils97.default.toValueString(content))
      ];
    };
    const renderVN = () => {
      const { status, title } = props;
      const vSize = computeSize.value;
      return h("span", {
        ref: refElem,
        class: ["vxe-tag", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status
        }],
        title,
        onClick: clickEvent
      }, renderContent());
    };
    $xeTag.renderVN = renderVN;
    return $xeTag;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/tag/index.js
var VxeTag = Object.assign({}, tag_default, {
  install(app) {
    app.component(tag_default.name, tag_default);
  }
});
dynamicApp.use(VxeTag);
VxeUI.component(tag_default);
var Tag = VxeTag;
var tag_default2 = VxeTag;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/text-ellipsis/src/text-ellipsis.js
var import_xe_utils98 = __toESM(require_xe_utils());
var text_ellipsis_default = defineComponent({
  name: "VxeTextEllipsis",
  props: {
    href: String,
    target: String,
    content: [String, Number],
    lineClamp: [String, Number],
    status: String,
    title: [String, Number],
    loading: Boolean,
    offsetLength: [String, Number],
    routerLink: Object,
    underline: {
      type: Boolean,
      default: () => getConfig().textEllipsis.underline
    },
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    size: {
      type: String,
      default: () => getConfig().textEllipsis.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils98.default.uniqueId();
    const { computeSize } = useSize(props);
    const { computePermissionInfo } = usePermission(props);
    const refElem = ref();
    const realityElem = ref();
    const reactData = reactive({
      resizeObserver: null,
      visibleLen: 0
    });
    const refMaps = {
      refElem
    };
    const computeTextLineClamp = computed(() => {
      return import_xe_utils98.default.toNumber(props.lineClamp);
    });
    const computeTextContent = computed(() => {
      return import_xe_utils98.default.toValueString(props.content);
    });
    const computeTextOffsetLength = computed(() => {
      return props.offsetLength ? import_xe_utils98.default.toNumber(props.offsetLength) : 0;
    });
    const computeVisibleContent = computed(() => {
      const { visibleLen } = reactData;
      const textLineClamp = computeTextLineClamp.value;
      const textContent = computeTextContent.value;
      const textOffsetLength = computeTextOffsetLength.value;
      if (textLineClamp > 1) {
        if (textContent.length > visibleLen) {
          return `${textContent.slice(0, Math.max(1, visibleLen - 3 + textOffsetLength))}...`;
        }
        return textContent;
      }
      return textContent;
    });
    const computeMaps = {};
    const $xeTextEllipsis = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $textEllipsis: $xeTextEllipsis }, params));
    };
    const calculateFont = (targetWidth) => {
      const el = refElem.value;
      const ryEl = realityElem.value;
      if (el && ryEl) {
        let fontSize = 12;
        try {
          fontSize = Math.max(10, import_xe_utils98.default.toNumber(getComputedStyle(ryEl).fontSize));
        } catch (e) {
        }
        const textContent = computeTextContent.value;
        let currIndex = Math.floor(targetWidth / fontSize);
        let currStr = textContent.slice(0, currIndex);
        ryEl.textContent = currStr;
        reactData.visibleLen = currStr.length;
        let maxCount = 0;
        while (targetWidth > ryEl.clientWidth && maxCount < 30) {
          maxCount++;
          const offsetIndex = Math.floor((targetWidth - ryEl.clientWidth) / fontSize);
          if (offsetIndex) {
            currIndex += offsetIndex;
            currStr = textContent.slice(0, currIndex);
            ryEl.textContent = currStr;
            reactData.visibleLen = currStr.length;
          } else {
            break;
          }
        }
        ryEl.textContent = "";
        ryEl.style.display = "";
        ryEl.style.position = "";
        ryEl.style.top = "";
        ryEl.style.left = "";
      }
    };
    const updateStyle = () => {
      const el = refElem.value;
      const ryEl = realityElem.value;
      const textContent = computeTextContent.value;
      const textLineClamp = computeTextLineClamp.value;
      if (el && ryEl) {
        const cWidth = el.clientWidth;
        ryEl.style.display = "block";
        ryEl.style.position = "absolute";
        ryEl.style.top = "-3000px";
        ryEl.style.left = "-3000px";
        ryEl.textContent = textContent;
        const sWidth = ryEl.offsetWidth;
        const targetWidth = Math.floor(cWidth * textLineClamp);
        if (targetWidth > sWidth) {
          reactData.visibleLen = textContent.length;
        } else {
          calculateFont(targetWidth);
        }
      } else {
        reactData.visibleLen = textContent.length;
      }
    };
    const textEllipsisMethods = {
      dispatchEvent
    };
    const clickEvent = () => {
      emit("click", {});
    };
    const initObserver = () => {
      const { resizeObserver } = reactData;
      const textLineClamp = computeTextLineClamp.value;
      if (!resizeObserver) {
        const el = refElem.value;
        if (el && textLineClamp > 1) {
          if (window.ResizeObserver) {
            const observerObj = new window.ResizeObserver(import_xe_utils98.default.throttle(() => {
              updateStyle();
            }, 300, { leading: true, trailing: true }));
            observerObj.observe(el);
            reactData.resizeObserver = observerObj;
          }
        }
      }
    };
    const textEllipsisPrivateMethods = {};
    Object.assign($xeTextEllipsis, textEllipsisMethods, textEllipsisPrivateMethods);
    const renderContent = () => {
      const { routerLink, href, target, title } = props;
      const visibleContent = computeVisibleContent.value;
      if (routerLink) {
        return h(resolveComponent("router-link"), {
          class: "vxe-text-ellipsis--link",
          title,
          target,
          to: routerLink
        }, {
          default() {
            return renderContent();
          }
        });
      }
      if (href) {
        return h("a", {
          class: "vxe-text-ellipsis--link",
          href,
          target,
          title
        }, visibleContent);
      }
      return h("span", {
        class: "vxe-text-ellipsis--content"
      }, visibleContent);
    };
    const renderVN = () => {
      const { loading: loading2, status, title, underline } = props;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      const textLineClamp = computeTextLineClamp.value;
      if (!permissionInfo.visible) {
        return renderEmptyElement($xeTextEllipsis);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-text-ellipsis", textLineClamp > 1 ? "is--multi" : "is--single", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--underline": underline,
          "is--loading": loading2
        }],
        title,
        onClick: clickEvent
      }, [
        h("span", {
          ref: realityElem,
          class: "vxe-text-ellipsis--reality"
        }),
        renderContent()
      ]);
    };
    watch(() => props.content, () => {
      updateStyle();
    });
    watch(() => props.lineClamp, () => {
      initObserver();
      updateStyle();
    });
    onMounted(() => {
      initObserver();
      updateStyle();
    });
    onBeforeUnmount(() => {
      const { resizeObserver } = reactData;
      const el = refElem.value;
      const ryEl = realityElem.value;
      if (ryEl) {
        ryEl.textContent = "";
      }
      if (resizeObserver) {
        if (el) {
          resizeObserver.unobserve(el);
        }
        resizeObserver.disconnect();
        reactData.resizeObserver = null;
      }
    });
    $xeTextEllipsis.renderVN = renderVN;
    return $xeTextEllipsis;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/text-ellipsis/index.js
var VxeTextEllipsis = Object.assign({}, text_ellipsis_default, {
  install(app) {
    app.component(text_ellipsis_default.name, text_ellipsis_default);
  }
});
dynamicApp.use(VxeTextEllipsis);
VxeUI.component(text_ellipsis_default);
var TextEllipsis = VxeTextEllipsis;
var text_ellipsis_default2 = VxeTextEllipsis;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/text/index.js
var VxeText = Object.assign({}, text_default, {
  install(app) {
    app.component(text_default.name, text_default);
  }
});
dynamicApp.use(VxeText);
VxeUI.component(text_default);
var Text = VxeText;
var text_default2 = VxeText;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/textarea/index.js
var VxeTextarea = Object.assign(textarea_default, {
  install: function(app) {
    app.component(textarea_default.name, textarea_default);
  }
});
dynamicApp.use(VxeTextarea);
VxeUI.component(textarea_default);
var Textarea = VxeTextarea;
var textarea_default2 = VxeTextarea;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/tip/index.js
var VxeTip = Object.assign({}, tip_default, {
  install(app) {
    app.component(tip_default.name, tip_default);
    app.component("VxeTipsComponent", tip_default);
  }
});
dynamicApp.use(VxeTip);
VxeUI.component(tip_default);
var Tips = VxeTip;
var Tip = VxeTip;
var tip_default2 = VxeTip;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/tree/index.js
var VxeTree = Object.assign({}, tree_default, {
  install(app) {
    app.component(tree_default.name, tree_default);
  }
});
dynamicApp.use(VxeTree);
VxeUI.component(tree_default);
var Tree = VxeTree;
var tree_default2 = VxeTree;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/tree-select/index.js
var VxeTreeSelect = Object.assign({}, tree_select_default, {
  install(app) {
    app.component(tree_select_default.name, tree_select_default);
  }
});
dynamicApp.use(VxeTreeSelect);
VxeUI.component(tree_select_default);
var TreeSelect = VxeTreeSelect;
var tree_select_default2 = VxeTreeSelect;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/watermark/src/watermark.js
var import_xe_utils100 = __toESM(require_xe_utils());

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/watermark/src/util.js
var import_xe_utils99 = __toESM(require_xe_utils());
var canvasEl = null;
var fontEl = null;
var fontCacheMaps = {};
function getMarkCanvas() {
  if (!canvasEl) {
    canvasEl = document.createElement("canvas");
    canvasEl.style.position = "absolute";
    canvasEl.style.top = "0";
    canvasEl.style.left = "0";
  }
  return canvasEl;
}
function removeMarkElement(elem) {
  if (elem) {
    const parentEl = elem.parentNode;
    if (parentEl) {
      parentEl.removeChild(elem);
    }
  }
}
function calcFontWH(text, fontSize) {
  const fKey = `${fontSize}_${text}`;
  if (!fontCacheMaps[fKey]) {
    if (!fontEl) {
      fontEl = document.createElement("span");
    }
    if (!fontEl.parentNode) {
      document.body.append(fontEl);
    }
    fontEl.textContent = text;
    fontEl.style.fontSize = toCssUnit(fontSize);
    const width = fontEl.offsetWidth;
    const height = fontEl.offsetHeight;
    fontCacheMaps[fKey] = {
      width,
      height
    };
  }
  return fontCacheMaps[fKey];
}
function calcContentWH(contList) {
  let contentWidth = 0;
  let contentHeight = 0;
  contList.forEach((item) => {
    contentWidth = Math.max(item.width, contentWidth);
    contentHeight = Math.max(item.height, contentHeight);
  });
  return {
    contentWidth,
    contentHeight
  };
}
function calcCanvasWH(contentWidth, opts) {
  const { gap } = opts;
  const [gapX = 0, gapY = 0] = gap ? import_xe_utils99.default.isArray(gap) ? gap : [gap, gap] : [];
  const canvasWidth = contentWidth + import_xe_utils99.default.toNumber(gapX);
  const canvasHeight = contentWidth + import_xe_utils99.default.toNumber(gapY);
  return {
    canvasWidth,
    canvasHeight
  };
}
function getFontConf(item, key, opts) {
  return (item.font ? item.font[key] : "") || (opts.font ? opts.font[key] : "");
}
function createMarkFont(contConf, defaultFontSize, opts) {
  const { offset } = opts;
  const text = import_xe_utils99.default.toValueString(contConf.textContent);
  const fontSize = import_xe_utils99.default.toNumber(getFontConf(contConf, "fontSize", opts) || defaultFontSize) || 14;
  const [offsetX = 0, offsetY = 0] = offset ? import_xe_utils99.default.isArray(offset) ? offset : [offset, offset] : [];
  const { width, height } = calcFontWH(text, fontSize);
  return {
    text,
    fontSize,
    font: contConf.font,
    width: width + import_xe_utils99.default.toNumber(offsetX),
    height: height + import_xe_utils99.default.toNumber(offsetY)
  };
}
function drayFont(ctx, item, opts) {
  const fontWeight = getFontConf(item, "fontWeight", opts);
  ctx.fillStyle = `${getFontConf(item, "color", opts) || "rgba(0, 0, 0, 0.15)"}`;
  ctx.font = [
    getFontConf(item, "fontStyle", opts) || "normal",
    fontWeight === "bold" || fontWeight === "bolder" ? "bold" : "",
    toCssUnit(item.fontSize),
    getFontConf(item, "fontFamily", opts) || "sans-serif"
  ].join(" ");
}
function getContentUrl(content, defaultFontSize, options) {
  const opts = Object.assign({}, options);
  const { rotate } = opts;
  const deg = import_xe_utils99.default.toNumber(rotate);
  const contList = (import_xe_utils99.default.isArray(content) ? content : [content]).map((item) => {
    if (item) {
      if (item.textContent) {
        return createMarkFont(item, defaultFontSize, opts);
      }
      return createMarkFont({
        textContent: `${item}`
      }, defaultFontSize, opts);
    }
    return createMarkFont({
      textContent: ""
    }, defaultFontSize, opts);
  });
  removeMarkElement(fontEl);
  return new Promise((resolve) => {
    const canvasEl2 = getMarkCanvas();
    if (!canvasEl2.parentNode) {
      document.body.append(canvasEl2);
    }
    const ctx = canvasEl2.getContext("2d");
    if (ctx && contList.length) {
      const { contentWidth, contentHeight } = calcContentWH(contList);
      const { canvasWidth, canvasHeight } = calcCanvasWH(contentWidth, opts);
      canvasEl2.width = canvasWidth;
      canvasEl2.height = canvasHeight;
      const x = (canvasWidth - contentWidth) / 2;
      const y = (canvasHeight - contentHeight) / 2;
      const drayX = x + contentWidth / 2;
      const drayY = y + contentHeight / 2;
      ctx.save();
      ctx.translate(drayX, drayY);
      ctx.rotate(deg * Math.PI / 180);
      ctx.translate(-drayX, -drayY);
      let offsetHeight = 0;
      contList.forEach((item) => {
        const align = getFontConf(item, "align", opts);
        drayFont(ctx, item, opts);
        ctx.fillText(item.text, x + (align === "center" ? (contentWidth - item.width) / 2 : 0), y + (contentHeight + contentHeight) / 2 + offsetHeight, contentWidth);
        offsetHeight += item.height;
      });
      ctx.restore();
      resolve(canvasEl2.toDataURL());
      removeMarkElement(canvasEl2);
    } else {
      resolve("");
      removeMarkElement(canvasEl2);
    }
  });
}

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/watermark/src/watermark.js
var watermark_default = defineComponent({
  name: "VxeWatermark",
  props: {
    width: String,
    height: String,
    imageUrl: String,
    rotate: {
      type: [Number, String],
      default: () => getConfig().watermark.rotate
    },
    gap: {
      type: [Array, Number, String],
      default: () => import_xe_utils100.default.clone(getConfig().watermark.gap, true)
    },
    content: [String, Array],
    font: Object,
    offset: Object,
    zIndex: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils100.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({
      markUrl: ""
    });
    const refMaps = {
      refElem
    };
    const computeFontOpts = computed(() => {
      return import_xe_utils100.default.assign({}, import_xe_utils100.default.clone(getConfig().watermark.font, true), props.font);
    });
    const computeWrapperStyle = computed(() => {
      const { width, height, zIndex } = props;
      const { markUrl } = reactData;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      if (markUrl) {
        stys.backgroundImage = `url(${markUrl})`;
      }
      if (zIndex) {
        stys.zIndex = zIndex;
      }
      return stys;
    });
    const computeMaps = {};
    const $xeWatermark = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $watermark: $xeWatermark }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const updateMarkStyle = () => {
      const { content, gap, rotate, offset } = props;
      const el = refElem.value;
      const fontOpts = computeFontOpts.value;
      if (el) {
        if (content) {
          getContentUrl(content, getComputedStyle(el).fontSize, {
            font: fontOpts,
            rotate,
            gap,
            offset
          }).then((url) => {
            reactData.markUrl = url;
          });
        }
      }
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeWatermark, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const wrapperStyle = computeWrapperStyle.value;
      return h("div", {
        ref: refElem,
        class: "vxe-watermark",
        style: wrapperStyle
      });
    };
    watch(() => props.imageUrl, () => {
      updateMarkStyle();
    });
    watch(() => props.content, () => {
      updateMarkStyle();
    });
    watch(() => props.gap, () => {
      updateMarkStyle();
    });
    watch(() => props.rotate, () => {
      updateMarkStyle();
    });
    watch(() => props.width, () => {
      updateMarkStyle();
    });
    watch(() => props.height, () => {
      updateMarkStyle();
    });
    watch(() => props.font, () => {
      updateMarkStyle();
    });
    onMounted(() => {
      updateMarkStyle();
      globalEvents.on($xeWatermark, "resize", import_xe_utils100.default.throttle(() => {
        updateMarkStyle();
      }, 300, { trailing: true, leading: true }));
    });
    onUnmounted(() => {
      globalEvents.off($xeWatermark, "resize");
    });
    $xeWatermark.renderVN = renderVN;
    return $xeWatermark;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/watermark/index.js
var VxeWatermark = Object.assign({}, watermark_default, {
  install(app) {
    app.component(watermark_default.name, watermark_default);
  }
});
dynamicApp.use(VxeWatermark);
VxeUI.component(watermark_default);
var WatermarkController = {
  load(options) {
    checkDynamic();
    dynamicStore.globalWatermark = Object.assign({}, options);
    return Promise.resolve();
  },
  clear() {
    dynamicStore.globalWatermark = null;
    return Promise.resolve();
  }
};
VxeUI.watermark = WatermarkController;
var Watermark = VxeWatermark;
var watermark_default2 = VxeWatermark;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/components.js
var components = [
  alert_default2,
  anchor_default2,
  anchor_link_default2,
  avatar_default2,
  badge_default2,
  breadcrumb_default2,
  breadcrumb_item_default2,
  button_default2,
  button_group_default2,
  calendar_default2,
  card_default2,
  carousel_default2,
  carousel_item_default2,
  checkbox_default2,
  checkbox_group_default,
  col_default2,
  collapse_default2,
  collapse_pane_default2,
  color_picker_default2,
  countdown_default2,
  date_picker_default2,
  drawer_default2,
  empty_default2,
  form_default2,
  form_design_default2,
  form_gather_default,
  form_group_default2,
  form_item_default2,
  form_view_default2,
  icon_default2,
  icon_picker_default2,
  image_default2,
  image_group_default,
  image_preview_default,
  input_default2,
  layout_aside_default2,
  layout_body_default2,
  layout_container_default2,
  layout_footer_default2,
  layout_header_default2,
  link_default2,
  list_design_default2,
  list_view_default2,
  list_default2,
  loading_default2,
  menu_default2,
  modal_default2,
  notice_bar_default2,
  number_input_default2,
  optgroup_default2,
  option_default2,
  pager_default,
  password_input_default2,
  print_page_break_default,
  print_default2,
  pulldown_default2,
  radio_default2,
  radio_button_default,
  radio_group_default,
  rate_default2,
  result_default2,
  row_default2,
  select_default2,
  split_default2,
  split_pane_default2,
  slider_default2,
  steps_default2,
  switch_default2,
  tab_pane_default2,
  table_select_default2,
  tabs_default2,
  tag_default2,
  text_ellipsis_default2,
  text_default2,
  textarea_default2,
  tip_default2,
  tooltip_default2,
  tree_default2,
  tree_select_default2,
  upload_default2,
  watermark_default2
];
function install(app, options) {
  setConfig(options);
  components.forEach((component2) => app.use(component2));
}
var defaultLanguage = "zh-CN";
setI18n(defaultLanguage, zh_CN_default);
setLanguage(defaultLanguage);
setTheme("light");
var loading = LoadingController;
var modal = ModalController;
var drawer = DrawerController;
var watermark = WatermarkController;
var print = printHtml;
var saveFile = saveLocalFile;
var readFile = readLocalFile;

// ../../node_modules/.pnpm/vxe-pc-ui@4.5.35_vue@3.5.13_typescript@5.8.3_/node_modules/vxe-pc-ui/es/index.esm.js
var index_esm_default = components_exports;
export {
  Alert,
  Anchor,
  AnchorLink,
  Avatar,
  Badge,
  Breadcrumb,
  BreadcrumbItem,
  Button,
  ButtonGroup,
  Calendar,
  Card,
  Carousel,
  CarouselItem,
  Checkbox,
  CheckboxGroup,
  Col,
  Collapse,
  CollapsePane,
  ColorPicker,
  Countdown,
  DatePicker,
  Drawer,
  DrawerController,
  Empty,
  Form,
  FormDesign,
  FormGather,
  FormGroup,
  FormItem,
  FormView,
  GLOBAL_EVENT_KEYS,
  Icon,
  IconPicker,
  Image,
  ImageGroup,
  ImagePreview,
  Input,
  LayoutAside,
  LayoutBody,
  LayoutContainer,
  LayoutFooter,
  LayoutHeader,
  Link,
  List,
  ListDesign,
  ListView,
  Loading,
  LoadingController,
  Menu,
  Modal,
  ModalController,
  NoticeBar,
  NumberInput,
  Optgroup,
  Option,
  Pager,
  PasswordInput,
  Print,
  PrintPageBreak,
  Pulldown,
  Radio,
  RadioButton,
  RadioGroup,
  Rate,
  Result,
  Row,
  Select,
  Slider,
  Split,
  SplitPane,
  Steps,
  Switch,
  TabPane,
  TableSelect,
  Tabs,
  Tag,
  Text,
  TextEllipsis,
  Textarea,
  Tip,
  Tips,
  Tooltip,
  Tree,
  TreeSelect,
  Upload,
  VxeAlert,
  VxeAnchor,
  VxeAnchorLink,
  VxeAvatar,
  VxeBadge,
  VxeBreadcrumb,
  VxeBreadcrumbItem,
  VxeButton,
  VxeButtonGroup,
  VxeCalendar,
  VxeCard,
  VxeCarousel,
  VxeCarouselItem,
  VxeCheckbox,
  VxeCheckboxGroup,
  VxeCol,
  VxeCollapse,
  VxeCollapsePane,
  VxeColorPicker,
  VxeCore,
  VxeCountdown,
  VxeDatePicker,
  VxeDrawer,
  VxeEmpty,
  VxeForm,
  VxeFormDesign,
  VxeFormGather,
  VxeFormGroup,
  VxeFormItem,
  VxeFormView,
  VxeIcon,
  VxeIconPicker,
  VxeImage,
  VxeImageGroup,
  VxeImagePreview,
  VxeInput,
  VxeLayoutAside,
  VxeLayoutBody,
  VxeLayoutContainer,
  VxeLayoutFooter,
  VxeLayoutHeader,
  VxeLink,
  VxeList,
  VxeListDesign,
  VxeListView,
  VxeLoading,
  VxeMenu,
  VxeModal,
  VxeNoticeBar,
  VxeNumberInput,
  VxeOptgroup,
  VxeOption,
  VxePager,
  VxePasswordInput,
  VxePrint,
  VxePrintPageBreak,
  VxePulldown,
  VxeRadio,
  VxeRadioButton,
  VxeRadioGroup,
  VxeRate,
  VxeResult,
  VxeRow,
  VxeSelect,
  VxeSlider,
  VxeSplit,
  VxeSplitPane,
  VxeSteps,
  VxeSwitch,
  VxeTabPane,
  VxeTableSelect,
  VxeTabs,
  VxeTag,
  VxeText,
  VxeTextEllipsis,
  VxeTextarea,
  VxeTip,
  VxeTooltip,
  VxeTree,
  VxeTreeSelect,
  VxeUI,
  VxeUpload,
  VxeWatermark,
  Watermark,
  WatermarkController,
  clipboard,
  commands,
  component,
  config,
  coreVersion,
  createEvent,
  index_esm_default as default,
  drawer,
  formats,
  getComponent,
  getConfig,
  getI18n,
  getIcon,
  getLanguage,
  getTheme,
  globalEvents,
  globalResize,
  globalStore,
  handleCheckInfo,
  hasLanguage,
  hooks,
  install,
  interceptor,
  loading,
  log,
  menus,
  modal,
  permission,
  print,
  readFile,
  renderEmptyElement,
  renderer,
  saveFile,
  setConfig,
  setI18n,
  setIcon,
  setLanguage,
  setTheme,
  setup,
  use,
  useFns,
  usePermission,
  useSize,
  validators,
  version,
  watermark
};
//# sourceMappingURL=vxe-pc-ui.js.map
